var cv = Object.defineProperty;
var dv = (i, e, t) => e in i ? cv(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var Rt = (i, e, t) => (dv(i, typeof e != "symbol" ? e + "" : e, t), t);
function wt(i, e) {
  const t = /* @__PURE__ */ Object.create(null), r = i.split(",");
  for (let o = 0; o < r.length; o++)
    t[r[o]] = !0;
  return e ? (o) => !!t[o.toLowerCase()] : (o) => !!t[o];
}
const Ae = {}.NODE_ENV !== "production" ? Object.freeze({}) : {}, Qs = {}.NODE_ENV !== "production" ? Object.freeze([]) : [], Ze = () => {
}, Zn = () => !1, fv = /^on[^a-z]/, Ar = (i) => fv.test(i), nu = (i) => i.startsWith("onUpdate:"), pe = Object.assign, zf = (i, e) => {
  const t = i.indexOf(e);
  t > -1 && i.splice(t, 1);
}, pv = Object.prototype.hasOwnProperty, be = (i, e) => pv.call(i, e), W = Array.isArray, Vo = (i) => pn(i) === "[object Map]", as = (i) => pn(i) === "[object Set]", iE = (i) => pn(i) === "[object Date]", Ov = (i) => pn(i) === "[object RegExp]", ae = (i) => typeof i == "function", he = (i) => typeof i == "string", uo = (i) => typeof i == "symbol", Se = (i) => i !== null && typeof i == "object", hh = (i) => Se(i) && ae(i.then) && ae(i.catch), gT = Object.prototype.toString, pn = (i) => gT.call(i), Zf = (i) => pn(i).slice(8, -1), bT = (i) => pn(i) === "[object Object]", qf = (i) => he(i) && i !== "NaN" && i[0] !== "-" && "" + parseInt(i, 10) === i, Ho = /* @__PURE__ */ wt(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), TT = /* @__PURE__ */ wt(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), ch = (i) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = i(t));
}, Ev = /-(\w)/g, ot = ch((i) => i.replace(Ev, (e, t) => t ? t.toUpperCase() : "")), mv = /\B([A-Z])/g, kt = ch(
  (i) => i.replace(mv, "-$1").toLowerCase()
), ur = ch(
  (i) => i.charAt(0).toUpperCase() + i.slice(1)
), zi = ch(
  (i) => i ? `on${ur(i)}` : ""
), zs = (i, e) => !Object.is(i, e), Wr = (i, e) => {
  for (let t = 0; t < i.length; t++)
    i[t](e);
}, au = (i, e, t) => {
  Object.defineProperty(i, e, {
    configurable: !0,
    enumerable: !1,
    value: t
  });
}, lu = (i) => {
  const e = parseFloat(i);
  return isNaN(e) ? i : e;
}, uu = (i) => {
  const e = he(i) ? Number(i) : NaN;
  return isNaN(e) ? i : e;
};
let rE;
const hu = () => rE || (rE = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), rr = {
  [1]: "TEXT",
  [2]: "CLASS",
  [4]: "STYLE",
  [8]: "PROPS",
  [16]: "FULL_PROPS",
  [32]: "HYDRATE_EVENTS",
  [64]: "STABLE_FRAGMENT",
  [128]: "KEYED_FRAGMENT",
  [256]: "UNKEYED_FRAGMENT",
  [512]: "NEED_PATCH",
  [1024]: "DYNAMIC_SLOTS",
  [2048]: "DEV_ROOT_FRAGMENT",
  [-1]: "HOISTED",
  [-2]: "BAIL"
}, gv = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
}, bv = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console", Tv = /* @__PURE__ */ wt(bv), oE = 2;
function Sv(i, e = 0, t = i.length) {
  let r = i.split(/(\r?\n)/);
  const o = r.filter((a, l) => l % 2 === 1);
  r = r.filter((a, l) => l % 2 === 0);
  let s = 0;
  const n = [];
  for (let a = 0; a < r.length; a++)
    if (s += r[a].length + (o[a] && o[a].length || 0), s >= e) {
      for (let l = a - oE; l <= a + oE || t > s; l++) {
        if (l < 0 || l >= r.length)
          continue;
        const u = l + 1;
        n.push(
          `${u}${" ".repeat(Math.max(3 - String(u).length, 0))}|  ${r[l]}`
        );
        const h = r[l].length, c = o[l] && o[l].length || 0;
        if (l === a) {
          const d = e - (s - (h + c)), f = Math.max(
            1,
            t > s ? h - d : t - e
          );
          n.push("   |  " + " ".repeat(d) + "^".repeat(f));
        } else if (l > a) {
          if (t > s) {
            const d = Math.max(Math.min(t - s, h), 1);
            n.push("   |  " + "^".repeat(d));
          }
          s += h + c;
        }
      }
      break;
    }
  return n.join(`
`);
}
function ki(i) {
  if (W(i)) {
    const e = {};
    for (let t = 0; t < i.length; t++) {
      const r = i[t], o = he(r) ? ST(r) : ki(r);
      if (o)
        for (const s in o)
          e[s] = o[s];
    }
    return e;
  } else {
    if (he(i))
      return i;
    if (Se(i))
      return i;
  }
}
const Rv = /;(?![^(]*\))/g, Av = /:([^]+)/, Cv = /\/\*[^]*?\*\//g;
function ST(i) {
  const e = {};
  return i.replace(Cv, "").split(Rv).forEach((t) => {
    if (t) {
      const r = t.split(Av);
      r.length > 1 && (e[r[0].trim()] = r[1].trim());
    }
  }), e;
}
function On(i) {
  let e = "";
  if (he(i))
    e = i;
  else if (W(i))
    for (let t = 0; t < i.length; t++) {
      const r = On(i[t]);
      r && (e += r + " ");
    }
  else if (Se(i))
    for (const t in i)
      i[t] && (e += t + " ");
  return e.trim();
}
function Nv(i) {
  if (!i)
    return null;
  let { class: e, style: t } = i;
  return e && !he(e) && (i.class = On(e)), t && (i.style = ki(t)), i;
}
const Iv = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", vv = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", _v = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", RT = /* @__PURE__ */ wt(Iv), AT = /* @__PURE__ */ wt(vv), Pv = /* @__PURE__ */ wt(_v), Lv = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", wv = /* @__PURE__ */ wt(Lv);
function CT(i) {
  return !!i || i === "";
}
function yv(i, e) {
  if (i.length !== e.length)
    return !1;
  let t = !0;
  for (let r = 0; t && r < i.length; r++)
    t = ho(i[r], e[r]);
  return t;
}
function ho(i, e) {
  if (i === e)
    return !0;
  let t = iE(i), r = iE(e);
  if (t || r)
    return t && r ? i.getTime() === e.getTime() : !1;
  if (t = uo(i), r = uo(e), t || r)
    return i === e;
  if (t = W(i), r = W(e), t || r)
    return t && r ? yv(i, e) : !1;
  if (t = Se(i), r = Se(e), t || r) {
    if (!t || !r)
      return !1;
    const o = Object.keys(i).length, s = Object.keys(e).length;
    if (o !== s)
      return !1;
    for (const n in i) {
      const a = i.hasOwnProperty(n), l = e.hasOwnProperty(n);
      if (a && !l || !a && l || !ho(i[n], e[n]))
        return !1;
    }
  }
  return String(i) === String(e);
}
function dh(i, e) {
  return i.findIndex((t) => ho(t, e));
}
const NT = (i) => he(i) ? i : i == null ? "" : W(i) || Se(i) && (i.toString === gT || !ae(i.toString)) ? JSON.stringify(i, IT, 2) : String(i), IT = (i, e) => e && e.__v_isRef ? IT(i, e.value) : Vo(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce((t, [r, o]) => (t[`${r} =>`] = o, t), {})
} : as(e) ? {
  [`Set(${e.size})`]: [...e.values()]
} : Se(e) && !W(e) && !bT(e) ? String(e) : e;
function cu(i, ...e) {
  console.warn(`[Vue warn] ${i}`, ...e);
}
let ti;
class jf {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = ti, !e && ti && (this.index = (ti.scopes || (ti.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const t = ti;
      try {
        return ti = this, e();
      } finally {
        ti = t;
      }
    } else
      ({}).NODE_ENV !== "production" && cu("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ti = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    ti = this.parent;
  }
  stop(e) {
    if (this._active) {
      let t, r;
      for (t = 0, r = this.effects.length; t < r; t++)
        this.effects[t].stop();
      for (t = 0, r = this.cleanups.length; t < r; t++)
        this.cleanups[t]();
      if (this.scopes)
        for (t = 0, r = this.scopes.length; t < r; t++)
          this.scopes[t].stop(!0);
      if (!this.detached && this.parent && !e) {
        const o = this.parent.scopes.pop();
        o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function Dv(i) {
  return new jf(i);
}
function vT(i, e = ti) {
  e && e.active && e.effects.push(i);
}
function _T() {
  return ti;
}
function xv(i) {
  ti ? ti.cleanups.push(i) : {}.NODE_ENV !== "production" && cu(
    "onScopeDispose() is called when there is no active effect scope to be associated with."
  );
}
const ca = (i) => {
  const e = new Set(i);
  return e.w = 0, e.n = 0, e;
}, PT = (i) => (i.w & co) > 0, LT = (i) => (i.n & co) > 0, Mv = ({ deps: i }) => {
  if (i.length)
    for (let e = 0; e < i.length; e++)
      i[e].w |= co;
}, Uv = (i) => {
  const { deps: e } = i;
  if (e.length) {
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      const o = e[r];
      PT(o) && !LT(o) ? o.delete(i) : e[t++] = o, o.w &= ~co, o.n &= ~co;
    }
    e.length = t;
  }
}, du = /* @__PURE__ */ new WeakMap();
let Gn = 0, co = 1;
const ud = 30;
let Ut;
const Xo = Symbol({}.NODE_ENV !== "production" ? "iterate" : ""), hd = Symbol({}.NODE_ENV !== "production" ? "Map key iterate" : "");
class Ha {
  constructor(e, t = null, r) {
    this.fn = e, this.scheduler = t, this.active = !0, this.deps = [], this.parent = void 0, vT(this, r);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = Ut, t = Jr;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = Ut, Ut = this, Jr = !0, co = 1 << ++Gn, Gn <= ud ? Mv(this) : sE(this), this.fn();
    } finally {
      Gn <= ud && Uv(this), co = 1 << --Gn, Ut = this.parent, Jr = t, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    Ut === this ? this.deferStop = !0 : this.active && (sE(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function sE(i) {
  const { deps: e } = i;
  if (e.length) {
    for (let t = 0; t < e.length; t++)
      e[t].delete(i);
    e.length = 0;
  }
}
function Qv(i, e) {
  i.effect && (i = i.effect.fn);
  const t = new Ha(i);
  e && (pe(t, e), e.scope && vT(t, e.scope)), (!e || !e.lazy) && t.run();
  const r = t.run.bind(t);
  return r.effect = t, r;
}
function kv(i) {
  i.effect.stop();
}
let Jr = !0;
const wT = [];
function ls() {
  wT.push(Jr), Jr = !1;
}
function us() {
  const i = wT.pop();
  Jr = i === void 0 ? !0 : i;
}
function St(i, e, t) {
  if (Jr && Ut) {
    let r = du.get(i);
    r || du.set(i, r = /* @__PURE__ */ new Map());
    let o = r.get(t);
    o || r.set(t, o = ca());
    const s = {}.NODE_ENV !== "production" ? { effect: Ut, target: i, type: e, key: t } : void 0;
    cd(o, s);
  }
}
function cd(i, e) {
  let t = !1;
  Gn <= ud ? LT(i) || (i.n |= co, t = !PT(i)) : t = !i.has(Ut), t && (i.add(Ut), Ut.deps.push(i), {}.NODE_ENV !== "production" && Ut.onTrack && Ut.onTrack(
    pe(
      {
        effect: Ut
      },
      e
    )
  ));
}
function hr(i, e, t, r, o, s) {
  const n = du.get(i);
  if (!n)
    return;
  let a = [];
  if (e === "clear")
    a = [...n.values()];
  else if (t === "length" && W(i)) {
    const u = Number(r);
    n.forEach((h, c) => {
      (c === "length" || c >= u) && a.push(h);
    });
  } else
    switch (t !== void 0 && a.push(n.get(t)), e) {
      case "add":
        W(i) ? qf(t) && a.push(n.get("length")) : (a.push(n.get(Xo)), Vo(i) && a.push(n.get(hd)));
        break;
      case "delete":
        W(i) || (a.push(n.get(Xo)), Vo(i) && a.push(n.get(hd)));
        break;
      case "set":
        Vo(i) && a.push(n.get(Xo));
        break;
    }
  const l = {}.NODE_ENV !== "production" ? { target: i, type: e, key: t, newValue: r, oldValue: o, oldTarget: s } : void 0;
  if (a.length === 1)
    a[0] && ({}.NODE_ENV !== "production" ? Ls(a[0], l) : Ls(a[0]));
  else {
    const u = [];
    for (const h of a)
      h && u.push(...h);
    ({}).NODE_ENV !== "production" ? Ls(ca(u), l) : Ls(ca(u));
  }
}
function Ls(i, e) {
  const t = W(i) ? i : [...i];
  for (const r of t)
    r.computed && nE(r, e);
  for (const r of t)
    r.computed || nE(r, e);
}
function nE(i, e) {
  (i !== Ut || i.allowRecurse) && ({}.NODE_ENV !== "production" && i.onTrigger && i.onTrigger(pe({ effect: i }, e)), i.scheduler ? i.scheduler() : i.run());
}
function $v(i, e) {
  var t;
  return (t = du.get(i)) == null ? void 0 : t.get(e);
}
const Gv = /* @__PURE__ */ wt("__proto__,__v_isRef,__isVue"), yT = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((i) => i !== "arguments" && i !== "caller").map((i) => Symbol[i]).filter(uo)
), Vv = /* @__PURE__ */ fh(), Hv = /* @__PURE__ */ fh(!1, !0), Xv = /* @__PURE__ */ fh(!0), Yv = /* @__PURE__ */ fh(!0, !0), aE = /* @__PURE__ */ Bv();
function Bv() {
  const i = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    i[e] = function(...t) {
      const r = ce(this);
      for (let s = 0, n = this.length; s < n; s++)
        St(r, "get", s + "");
      const o = r[e](...t);
      return o === -1 || o === !1 ? r[e](...t.map(ce)) : o;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    i[e] = function(...t) {
      ls();
      const r = ce(this)[e].apply(this, t);
      return us(), r;
    };
  }), i;
}
function Fv(i) {
  const e = ce(this);
  return St(e, "has", i), e.hasOwnProperty(i);
}
function fh(i = !1, e = !1) {
  return function(r, o, s) {
    if (o === "__v_isReactive")
      return !i;
    if (o === "__v_isReadonly")
      return i;
    if (o === "__v_isShallow")
      return e;
    if (o === "__v_raw" && s === (i ? e ? GT : $T : e ? kT : QT).get(r))
      return r;
    const n = W(r);
    if (!i) {
      if (n && be(aE, o))
        return Reflect.get(aE, o, s);
      if (o === "hasOwnProperty")
        return Fv;
    }
    const a = Reflect.get(r, o, s);
    return (uo(o) ? yT.has(o) : Gv(o)) || (i || St(r, "get", o), e) ? a : Fe(a) ? n && qf(o) ? a : a.value : Se(a) ? i ? Jf(a) : Eh(a) : a;
  };
}
const Wv = /* @__PURE__ */ DT(), zv = /* @__PURE__ */ DT(!0);
function DT(i = !1) {
  return function(t, r, o, s) {
    let n = t[r];
    if (Cr(n) && Fe(n) && !Fe(o))
      return !1;
    if (!i && (!da(o) && !Cr(o) && (n = ce(n), o = ce(o)), !W(t) && Fe(n) && !Fe(o)))
      return n.value = o, !0;
    const a = W(t) && qf(r) ? Number(r) < t.length : be(t, r), l = Reflect.set(t, r, o, s);
    return t === ce(s) && (a ? zs(o, n) && hr(t, "set", r, o, n) : hr(t, "add", r, o)), l;
  };
}
function Zv(i, e) {
  const t = be(i, e), r = i[e], o = Reflect.deleteProperty(i, e);
  return o && t && hr(i, "delete", e, void 0, r), o;
}
function qv(i, e) {
  const t = Reflect.has(i, e);
  return (!uo(e) || !yT.has(e)) && St(i, "has", e), t;
}
function jv(i) {
  return St(i, "iterate", W(i) ? "length" : Xo), Reflect.ownKeys(i);
}
const xT = {
  get: Vv,
  set: Wv,
  deleteProperty: Zv,
  has: qv,
  ownKeys: jv
}, MT = {
  get: Xv,
  set(i, e) {
    return {}.NODE_ENV !== "production" && cu(
      `Set operation on key "${String(e)}" failed: target is readonly.`,
      i
    ), !0;
  },
  deleteProperty(i, e) {
    return {}.NODE_ENV !== "production" && cu(
      `Delete operation on key "${String(e)}" failed: target is readonly.`,
      i
    ), !0;
  }
}, Kv = /* @__PURE__ */ pe(
  {},
  xT,
  {
    get: Hv,
    set: zv
  }
), Jv = /* @__PURE__ */ pe(
  {},
  MT,
  {
    get: Yv
  }
), Kf = (i) => i, ph = (i) => Reflect.getPrototypeOf(i);
function ll(i, e, t = !1, r = !1) {
  i = i.__v_raw;
  const o = ce(i), s = ce(e);
  t || (e !== s && St(o, "get", e), St(o, "get", s));
  const { has: n } = ph(o), a = r ? Kf : t ? tp : pa;
  if (n.call(o, e))
    return a(i.get(e));
  if (n.call(o, s))
    return a(i.get(s));
  i !== o && i.get(e);
}
function ul(i, e = !1) {
  const t = this.__v_raw, r = ce(t), o = ce(i);
  return e || (i !== o && St(r, "has", i), St(r, "has", o)), i === o ? t.has(i) : t.has(i) || t.has(o);
}
function hl(i, e = !1) {
  return i = i.__v_raw, !e && St(ce(i), "iterate", Xo), Reflect.get(i, "size", i);
}
function lE(i) {
  i = ce(i);
  const e = ce(this);
  return ph(e).has.call(e, i) || (e.add(i), hr(e, "add", i, i)), this;
}
function uE(i, e) {
  e = ce(e);
  const t = ce(this), { has: r, get: o } = ph(t);
  let s = r.call(t, i);
  s ? {}.NODE_ENV !== "production" && UT(t, r, i) : (i = ce(i), s = r.call(t, i));
  const n = o.call(t, i);
  return t.set(i, e), s ? zs(e, n) && hr(t, "set", i, e, n) : hr(t, "add", i, e), this;
}
function hE(i) {
  const e = ce(this), { has: t, get: r } = ph(e);
  let o = t.call(e, i);
  o ? {}.NODE_ENV !== "production" && UT(e, t, i) : (i = ce(i), o = t.call(e, i));
  const s = r ? r.call(e, i) : void 0, n = e.delete(i);
  return o && hr(e, "delete", i, void 0, s), n;
}
function cE() {
  const i = ce(this), e = i.size !== 0, t = {}.NODE_ENV !== "production" ? Vo(i) ? new Map(i) : new Set(i) : void 0, r = i.clear();
  return e && hr(i, "clear", void 0, void 0, t), r;
}
function cl(i, e) {
  return function(r, o) {
    const s = this, n = s.__v_raw, a = ce(n), l = e ? Kf : i ? tp : pa;
    return !i && St(a, "iterate", Xo), n.forEach((u, h) => r.call(o, l(u), l(h), s));
  };
}
function dl(i, e, t) {
  return function(...r) {
    const o = this.__v_raw, s = ce(o), n = Vo(s), a = i === "entries" || i === Symbol.iterator && n, l = i === "keys" && n, u = o[i](...r), h = t ? Kf : e ? tp : pa;
    return !e && St(
      s,
      "iterate",
      l ? hd : Xo
    ), {
      // iterator protocol
      next() {
        const { value: c, done: d } = u.next();
        return d ? { value: c, done: d } : {
          value: a ? [h(c[0]), h(c[1])] : h(c),
          done: d
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Qr(i) {
  return function(...e) {
    if ({}.NODE_ENV !== "production") {
      const t = e[0] ? `on key "${e[0]}" ` : "";
      console.warn(
        `${ur(i)} operation ${t}failed: target is readonly.`,
        ce(this)
      );
    }
    return i === "delete" ? !1 : this;
  };
}
function e_() {
  const i = {
    get(s) {
      return ll(this, s);
    },
    get size() {
      return hl(this);
    },
    has: ul,
    add: lE,
    set: uE,
    delete: hE,
    clear: cE,
    forEach: cl(!1, !1)
  }, e = {
    get(s) {
      return ll(this, s, !1, !0);
    },
    get size() {
      return hl(this);
    },
    has: ul,
    add: lE,
    set: uE,
    delete: hE,
    clear: cE,
    forEach: cl(!1, !0)
  }, t = {
    get(s) {
      return ll(this, s, !0);
    },
    get size() {
      return hl(this, !0);
    },
    has(s) {
      return ul.call(this, s, !0);
    },
    add: Qr("add"),
    set: Qr("set"),
    delete: Qr("delete"),
    clear: Qr("clear"),
    forEach: cl(!0, !1)
  }, r = {
    get(s) {
      return ll(this, s, !0, !0);
    },
    get size() {
      return hl(this, !0);
    },
    has(s) {
      return ul.call(this, s, !0);
    },
    add: Qr("add"),
    set: Qr("set"),
    delete: Qr("delete"),
    clear: Qr("clear"),
    forEach: cl(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
    i[s] = dl(
      s,
      !1,
      !1
    ), t[s] = dl(
      s,
      !0,
      !1
    ), e[s] = dl(
      s,
      !1,
      !0
    ), r[s] = dl(
      s,
      !0,
      !0
    );
  }), [
    i,
    t,
    e,
    r
  ];
}
const [
  t_,
  i_,
  r_,
  o_
] = /* @__PURE__ */ e_();
function Oh(i, e) {
  const t = e ? i ? o_ : r_ : i ? i_ : t_;
  return (r, o, s) => o === "__v_isReactive" ? !i : o === "__v_isReadonly" ? i : o === "__v_raw" ? r : Reflect.get(
    be(t, o) && o in r ? t : r,
    o,
    s
  );
}
const s_ = {
  get: /* @__PURE__ */ Oh(!1, !1)
}, n_ = {
  get: /* @__PURE__ */ Oh(!1, !0)
}, a_ = {
  get: /* @__PURE__ */ Oh(!0, !1)
}, l_ = {
  get: /* @__PURE__ */ Oh(!0, !0)
};
function UT(i, e, t) {
  const r = ce(t);
  if (r !== t && e.call(i, r)) {
    const o = Zf(i);
    console.warn(
      `Reactive ${o} contains both the raw and reactive versions of the same object${o === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const QT = /* @__PURE__ */ new WeakMap(), kT = /* @__PURE__ */ new WeakMap(), $T = /* @__PURE__ */ new WeakMap(), GT = /* @__PURE__ */ new WeakMap();
function u_(i) {
  switch (i) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function h_(i) {
  return i.__v_skip || !Object.isExtensible(i) ? 0 : u_(Zf(i));
}
function Eh(i) {
  return Cr(i) ? i : mh(
    i,
    !1,
    xT,
    s_,
    QT
  );
}
function VT(i) {
  return mh(
    i,
    !1,
    Kv,
    n_,
    kT
  );
}
function Jf(i) {
  return mh(
    i,
    !0,
    MT,
    a_,
    $T
  );
}
function ws(i) {
  return mh(
    i,
    !0,
    Jv,
    l_,
    GT
  );
}
function mh(i, e, t, r, o) {
  if (!Se(i))
    return {}.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(i)}`), i;
  if (i.__v_raw && !(e && i.__v_isReactive))
    return i;
  const s = o.get(i);
  if (s)
    return s;
  const n = h_(i);
  if (n === 0)
    return i;
  const a = new Proxy(
    i,
    n === 2 ? r : t
  );
  return o.set(i, a), a;
}
function eo(i) {
  return Cr(i) ? eo(i.__v_raw) : !!(i && i.__v_isReactive);
}
function Cr(i) {
  return !!(i && i.__v_isReadonly);
}
function da(i) {
  return !!(i && i.__v_isShallow);
}
function fa(i) {
  return eo(i) || Cr(i);
}
function ce(i) {
  const e = i && i.__v_raw;
  return e ? ce(e) : i;
}
function ep(i) {
  return au(i, "__v_skip", !0), i;
}
const pa = (i) => Se(i) ? Eh(i) : i, tp = (i) => Se(i) ? Jf(i) : i;
function ip(i) {
  Jr && Ut && (i = ce(i), {}.NODE_ENV !== "production" ? cd(i.dep || (i.dep = ca()), {
    target: i,
    type: "get",
    key: "value"
  }) : cd(i.dep || (i.dep = ca())));
}
function gh(i, e) {
  i = ce(i);
  const t = i.dep;
  t && ({}.NODE_ENV !== "production" ? Ls(t, {
    target: i,
    type: "set",
    key: "value",
    newValue: e
  }) : Ls(t));
}
function Fe(i) {
  return !!(i && i.__v_isRef === !0);
}
function it(i) {
  return HT(i, !1);
}
function c_(i) {
  return HT(i, !0);
}
function HT(i, e) {
  return Fe(i) ? i : new d_(i, e);
}
class d_ {
  constructor(e, t) {
    this.__v_isShallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : ce(e), this._value = t ? e : pa(e);
  }
  get value() {
    return ip(this), this._value;
  }
  set value(e) {
    const t = this.__v_isShallow || da(e) || Cr(e);
    e = t ? e : ce(e), zs(e, this._rawValue) && (this._rawValue = e, this._value = t ? e : pa(e), gh(this, e));
  }
}
function f_(i) {
  gh(i, {}.NODE_ENV !== "production" ? i.value : void 0);
}
function Zs(i) {
  return Fe(i) ? i.value : i;
}
function p_(i) {
  return ae(i) ? i() : Zs(i);
}
const O_ = {
  get: (i, e, t) => Zs(Reflect.get(i, e, t)),
  set: (i, e, t, r) => {
    const o = i[e];
    return Fe(o) && !Fe(t) ? (o.value = t, !0) : Reflect.set(i, e, t, r);
  }
};
function rp(i) {
  return eo(i) ? i : new Proxy(i, O_);
}
class E_ {
  constructor(e) {
    this.dep = void 0, this.__v_isRef = !0;
    const { get: t, set: r } = e(
      () => ip(this),
      () => gh(this)
    );
    this._get = t, this._set = r;
  }
  get value() {
    return this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function m_(i) {
  return new E_(i);
}
function g_(i) {
  ({}).NODE_ENV !== "production" && !fa(i) && console.warn("toRefs() expects a reactive object but received a plain one.");
  const e = W(i) ? new Array(i.length) : {};
  for (const t in i)
    e[t] = XT(i, t);
  return e;
}
class b_ {
  constructor(e, t, r) {
    this._object = e, this._key = t, this._defaultValue = r, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return $v(ce(this._object), this._key);
  }
}
class T_ {
  constructor(e) {
    this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0;
  }
  get value() {
    return this._getter();
  }
}
function S_(i, e, t) {
  return Fe(i) ? i : ae(i) ? new T_(i) : Se(i) && arguments.length > 1 ? XT(i, e, t) : it(i);
}
function XT(i, e, t) {
  const r = i[e];
  return Fe(r) ? r : new b_(
    i,
    e,
    t
  );
}
class R_ {
  constructor(e, t, r, o) {
    this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new Ha(e, () => {
      this._dirty || (this._dirty = !0, gh(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !o, this.__v_isReadonly = r;
  }
  get value() {
    const e = ce(this);
    return ip(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
function A_(i, e, t = !1) {
  let r, o;
  const s = ae(i);
  s ? (r = i, o = {}.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : Ze) : (r = i.get, o = i.set);
  const n = new R_(r, o, s || !o, t);
  return {}.NODE_ENV !== "production" && e && !t && (n.effect.onTrack = e.onTrack, n.effect.onTrigger = e.onTrigger), n;
}
const Yo = [];
function qn(i) {
  Yo.push(i);
}
function jn() {
  Yo.pop();
}
function L(i, ...e) {
  if ({}.NODE_ENV === "production")
    return;
  ls();
  const t = Yo.length ? Yo[Yo.length - 1].component : null, r = t && t.appContext.config.warnHandler, o = C_();
  if (r)
    or(
      r,
      t,
      11,
      [
        i + e.join(""),
        t && t.proxy,
        o.map(
          ({ vnode: s }) => `at <${Ph(t, s.type)}>`
        ).join(`
`),
        o
      ]
    );
  else {
    const s = [`[Vue warn]: ${i}`, ...e];
    o.length && s.push(`
`, ...N_(o)), console.warn(...s);
  }
  us();
}
function C_() {
  let i = Yo[Yo.length - 1];
  if (!i)
    return [];
  const e = [];
  for (; i; ) {
    const t = e[0];
    t && t.vnode === i ? t.recurseCount++ : e.push({
      vnode: i,
      recurseCount: 0
    });
    const r = i.component && i.component.parent;
    i = r && r.vnode;
  }
  return e;
}
function N_(i) {
  const e = [];
  return i.forEach((t, r) => {
    e.push(...r === 0 ? [] : [`
`], ...I_(t));
  }), e;
}
function I_({ vnode: i, recurseCount: e }) {
  const t = e > 0 ? `... (${e} recursive calls)` : "", r = i.component ? i.component.parent == null : !1, o = ` at <${Ph(
    i.component,
    i.type,
    r
  )}`, s = ">" + t;
  return i.props ? [o, ...v_(i.props), s] : [o + s];
}
function v_(i) {
  const e = [], t = Object.keys(i);
  return t.slice(0, 3).forEach((r) => {
    e.push(...YT(r, i[r]));
  }), t.length > 3 && e.push(" ..."), e;
}
function YT(i, e, t) {
  return he(e) ? (e = JSON.stringify(e), t ? e : [`${i}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? t ? e : [`${i}=${e}`] : Fe(e) ? (e = YT(i, ce(e.value), !0), t ? e : [`${i}=Ref<`, e, ">"]) : ae(e) ? [`${i}=fn${e.name ? `<${e.name}>` : ""}`] : (e = ce(e), t ? e : [`${i}=`, e]);
}
function op(i, e) {
  ({}).NODE_ENV !== "production" && i !== void 0 && (typeof i != "number" ? L(`${e} is not a valid number - got ${JSON.stringify(i)}.`) : isNaN(i) && L(`${e} is NaN - the duration expression might be incorrect.`));
}
const sp = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function or(i, e, t, r) {
  let o;
  try {
    o = r ? i(...r) : i();
  } catch (s) {
    hs(s, e, t);
  }
  return o;
}
function li(i, e, t, r) {
  if (ae(i)) {
    const s = or(i, e, t, r);
    return s && hh(s) && s.catch((n) => {
      hs(n, e, t);
    }), s;
  }
  const o = [];
  for (let s = 0; s < i.length; s++)
    o.push(li(i[s], e, t, r));
  return o;
}
function hs(i, e, t, r = !0) {
  const o = e ? e.vnode : null;
  if (e) {
    let s = e.parent;
    const n = e.proxy, a = {}.NODE_ENV !== "production" ? sp[t] : t;
    for (; s; ) {
      const u = s.ec;
      if (u) {
        for (let h = 0; h < u.length; h++)
          if (u[h](i, n, a) === !1)
            return;
      }
      s = s.parent;
    }
    const l = e.appContext.config.errorHandler;
    if (l) {
      or(
        l,
        null,
        10,
        [i, n, a]
      );
      return;
    }
  }
  __(i, t, o, r);
}
function __(i, e, t, r = !0) {
  if ({}.NODE_ENV !== "production") {
    const o = sp[e];
    if (t && qn(t), L(`Unhandled error${o ? ` during execution of ${o}` : ""}`), t && jn(), r)
      throw i;
    console.error(i);
  } else
    console.error(i);
}
let Oa = !1, dd = !1;
const _t = [];
let qi = 0;
const ks = [];
let Fi = null, Xr = 0;
const BT = /* @__PURE__ */ Promise.resolve();
let np = null;
const P_ = 100;
function zo(i) {
  const e = np || BT;
  return i ? e.then(this ? i.bind(this) : i) : e;
}
function L_(i) {
  let e = qi + 1, t = _t.length;
  for (; e < t; ) {
    const r = e + t >>> 1;
    Ea(_t[r]) < i ? e = r + 1 : t = r;
  }
  return e;
}
function Xa(i) {
  (!_t.length || !_t.includes(
    i,
    Oa && i.allowRecurse ? qi + 1 : qi
  )) && (i.id == null ? _t.push(i) : _t.splice(L_(i.id), 0, i), FT());
}
function FT() {
  !Oa && !dd && (dd = !0, np = BT.then(WT));
}
function w_(i) {
  const e = _t.indexOf(i);
  e > qi && _t.splice(e, 1);
}
function bh(i) {
  W(i) ? ks.push(...i) : (!Fi || !Fi.includes(
    i,
    i.allowRecurse ? Xr + 1 : Xr
  )) && ks.push(i), FT();
}
function dE(i, e = Oa ? qi + 1 : 0) {
  for ({}.NODE_ENV !== "production" && (i = i || /* @__PURE__ */ new Map()); e < _t.length; e++) {
    const t = _t[e];
    if (t && t.pre) {
      if ({}.NODE_ENV !== "production" && ap(i, t))
        continue;
      _t.splice(e, 1), e--, t();
    }
  }
}
function fu(i) {
  if (ks.length) {
    const e = [...new Set(ks)];
    if (ks.length = 0, Fi) {
      Fi.push(...e);
      return;
    }
    for (Fi = e, {}.NODE_ENV !== "production" && (i = i || /* @__PURE__ */ new Map()), Fi.sort((t, r) => Ea(t) - Ea(r)), Xr = 0; Xr < Fi.length; Xr++)
      ({}).NODE_ENV !== "production" && ap(i, Fi[Xr]) || Fi[Xr]();
    Fi = null, Xr = 0;
  }
}
const Ea = (i) => i.id == null ? 1 / 0 : i.id, y_ = (i, e) => {
  const t = Ea(i) - Ea(e);
  if (t === 0) {
    if (i.pre && !e.pre)
      return -1;
    if (e.pre && !i.pre)
      return 1;
  }
  return t;
};
function WT(i) {
  dd = !1, Oa = !0, {}.NODE_ENV !== "production" && (i = i || /* @__PURE__ */ new Map()), _t.sort(y_);
  const e = {}.NODE_ENV !== "production" ? (t) => ap(i, t) : Ze;
  try {
    for (qi = 0; qi < _t.length; qi++) {
      const t = _t[qi];
      if (t && t.active !== !1) {
        if ({}.NODE_ENV !== "production" && e(t))
          continue;
        or(t, null, 14);
      }
    }
  } finally {
    qi = 0, _t.length = 0, fu(i), Oa = !1, np = null, (_t.length || ks.length) && WT(i);
  }
}
function ap(i, e) {
  if (!i.has(e))
    i.set(e, 1);
  else {
    const t = i.get(e);
    if (t > P_) {
      const r = e.ownerInstance, o = r && Ra(r.type);
      return L(
        `Maximum recursive updates exceeded${o ? ` in component <${o}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`
      ), !0;
    } else
      i.set(e, t + 1);
  }
}
let to = !1;
const Is = /* @__PURE__ */ new Set();
({}).NODE_ENV !== "production" && (hu().__VUE_HMR_RUNTIME__ = {
  createRecord: nc(zT),
  rerender: nc(M_),
  reload: nc(U_)
});
const Zo = /* @__PURE__ */ new Map();
function D_(i) {
  const e = i.type.__hmrId;
  let t = Zo.get(e);
  t || (zT(e, i.type), t = Zo.get(e)), t.instances.add(i);
}
function x_(i) {
  Zo.get(i.type.__hmrId).instances.delete(i);
}
function zT(i, e) {
  return Zo.has(i) ? !1 : (Zo.set(i, {
    initialDef: Kn(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function Kn(i) {
  return FS(i) ? i.__vccOpts : i;
}
function M_(i, e) {
  const t = Zo.get(i);
  t && (t.initialDef.render = e, [...t.instances].forEach((r) => {
    e && (r.render = e, Kn(r.type).render = e), r.renderCache = [], to = !0, r.update(), to = !1;
  }));
}
function U_(i, e) {
  const t = Zo.get(i);
  if (!t)
    return;
  e = Kn(e), fE(t.initialDef, e);
  const r = [...t.instances];
  for (const o of r) {
    const s = Kn(o.type);
    Is.has(s) || (s !== t.initialDef && fE(s, e), Is.add(s)), o.appContext.propsCache.delete(o.type), o.appContext.emitsCache.delete(o.type), o.appContext.optionsCache.delete(o.type), o.ceReload ? (Is.add(s), o.ceReload(e.styles), Is.delete(s)) : o.parent ? Xa(o.parent.update) : o.appContext.reload ? o.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    );
  }
  bh(() => {
    for (const o of r)
      Is.delete(
        Kn(o.type)
      );
  });
}
function fE(i, e) {
  pe(i, e);
  for (const t in i)
    t !== "__file" && !(t in e) && delete i[t];
}
function nc(i) {
  return (e, t) => {
    try {
      return i(e, t);
    } catch (r) {
      console.error(r), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let Pi, Vn = [], fd = !1;
function Ya(i, ...e) {
  Pi ? Pi.emit(i, ...e) : fd || Vn.push({ event: i, args: e });
}
function lp(i, e) {
  var t, r;
  Pi = i, Pi ? (Pi.enabled = !0, Vn.forEach(({ event: o, args: s }) => Pi.emit(o, ...s)), Vn = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  !((r = (t = window.navigator) == null ? void 0 : t.userAgent) != null && r.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((s) => {
    lp(s, e);
  }), setTimeout(() => {
    Pi || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, fd = !0, Vn = []);
  }, 3e3)) : (fd = !0, Vn = []);
}
function Q_(i, e) {
  Ya("app:init", i, e, {
    Fragment: et,
    Text: fo,
    Comment: Ke,
    Static: io
  });
}
function k_(i) {
  Ya("app:unmount", i);
}
const pd = /* @__PURE__ */ up(
  "component:added"
  /* COMPONENT_ADDED */
), ZT = /* @__PURE__ */ up(
  "component:updated"
  /* COMPONENT_UPDATED */
), $_ = /* @__PURE__ */ up(
  "component:removed"
  /* COMPONENT_REMOVED */
), G_ = (i) => {
  Pi && typeof Pi.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !Pi.cleanupBuffer(i) && $_(i);
};
function up(i) {
  return (e) => {
    Ya(
      i,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
const V_ = /* @__PURE__ */ qT(
  "perf:start"
  /* PERFORMANCE_START */
), H_ = /* @__PURE__ */ qT(
  "perf:end"
  /* PERFORMANCE_END */
);
function qT(i) {
  return (e, t, r) => {
    Ya(i, e.appContext.app, e.uid, e, t, r);
  };
}
function X_(i, e, t) {
  Ya(
    "component:emit",
    i.appContext.app,
    i,
    e,
    t
  );
}
function Y_(i, e, ...t) {
  if (i.isUnmounted)
    return;
  const r = i.vnode.props || Ae;
  if ({}.NODE_ENV !== "production") {
    const {
      emitsOptions: h,
      propsOptions: [c]
    } = i;
    if (h)
      if (!(e in h))
        (!c || !(zi(e) in c)) && L(
          `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${zi(e)}" prop.`
        );
      else {
        const d = h[e];
        ae(d) && (d(...t) || L(
          `Invalid event arguments: event validation failed for event "${e}".`
        ));
      }
  }
  let o = t;
  const s = e.startsWith("update:"), n = s && e.slice(7);
  if (n && n in r) {
    const h = `${n === "modelValue" ? "model" : n}Modifiers`, { number: c, trim: d } = r[h] || Ae;
    d && (o = t.map((f) => he(f) ? f.trim() : f)), c && (o = t.map(lu));
  }
  if ({}.NODE_ENV !== "production" && X_(i, e, o), {}.NODE_ENV !== "production") {
    const h = e.toLowerCase();
    h !== e && r[zi(h)] && L(
      `Event "${h}" is emitted in component ${Ph(
        i,
        i.type
      )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${kt(e)}" instead of "${e}".`
    );
  }
  let a, l = r[a = zi(e)] || // also try camelCase event handler (#2249)
  r[a = zi(ot(e))];
  !l && s && (l = r[a = zi(kt(e))]), l && li(
    l,
    i,
    6,
    o
  );
  const u = r[a + "Once"];
  if (u) {
    if (!i.emitted)
      i.emitted = {};
    else if (i.emitted[a])
      return;
    i.emitted[a] = !0, li(
      u,
      i,
      6,
      o
    );
  }
}
function jT(i, e, t = !1) {
  const r = e.emitsCache, o = r.get(i);
  if (o !== void 0)
    return o;
  const s = i.emits;
  let n = {}, a = !1;
  if (!ae(i)) {
    const l = (u) => {
      const h = jT(u, e, !0);
      h && (a = !0, pe(n, h));
    };
    !t && e.mixins.length && e.mixins.forEach(l), i.extends && l(i.extends), i.mixins && i.mixins.forEach(l);
  }
  return !s && !a ? (Se(i) && r.set(i, null), null) : (W(s) ? s.forEach((l) => n[l] = null) : pe(n, s), Se(i) && r.set(i, n), n);
}
function Th(i, e) {
  return !i || !Ar(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), be(i, e[0].toLowerCase() + e.slice(1)) || be(i, kt(e)) || be(i, e));
}
let je = null, Sh = null;
function ma(i) {
  const e = je;
  return je = i, Sh = i && i.type.__scopeId || null, e;
}
function KT(i) {
  Sh = i;
}
function JT() {
  Sh = null;
}
const B_ = (i) => ga;
function ga(i, e = je, t) {
  if (!e || i._n)
    return i;
  const r = (...o) => {
    r._d && Rd(-1);
    const s = ma(e);
    let n;
    try {
      n = i(...o);
    } finally {
      ma(s), r._d && Rd(1);
    }
    return {}.NODE_ENV !== "production" && ZT(e), n;
  };
  return r._n = !0, r._c = !0, r._d = !0, r;
}
let Od = !1;
function pu() {
  Od = !0;
}
function Hl(i) {
  const {
    type: e,
    vnode: t,
    proxy: r,
    withProxy: o,
    props: s,
    propsOptions: [n],
    slots: a,
    attrs: l,
    emit: u,
    render: h,
    renderCache: c,
    data: d,
    setupState: f,
    ctx: p,
    inheritAttrs: O
  } = i;
  let m, E;
  const g = ma(i);
  ({}).NODE_ENV !== "production" && (Od = !1);
  try {
    if (t.shapeFlag & 4) {
      const R = o || r;
      m = Ht(
        h.call(
          R,
          R,
          c,
          s,
          f,
          d,
          p
        )
      ), E = l;
    } else {
      const R = e;
      ({}).NODE_ENV !== "production" && l === s && pu(), m = Ht(
        R.length > 1 ? R(
          s,
          {}.NODE_ENV !== "production" ? {
            get attrs() {
              return pu(), l;
            },
            slots: a,
            emit: u
          } : { attrs: l, slots: a, emit: u }
        ) : R(
          s,
          null
          /* we know it doesn't need it */
        )
      ), E = e.props ? l : W_(l);
    }
  } catch (R) {
    ia.length = 0, hs(R, i, 1), m = xe(Ke);
  }
  let A = m, S;
  if ({}.NODE_ENV !== "production" && m.patchFlag > 0 && m.patchFlag & 2048 && ([A, S] = F_(m)), E && O !== !1) {
    const R = Object.keys(E), { shapeFlag: v } = A;
    if (R.length) {
      if (v & 7)
        n && R.some(nu) && (E = z_(
          E,
          n
        )), A = Ci(A, E);
      else if ({}.NODE_ENV !== "production" && !Od && A.type !== Ke) {
        const I = Object.keys(l), C = [], P = [];
        for (let w = 0, x = I.length; w < x; w++) {
          const _ = I[w];
          Ar(_) ? nu(_) || C.push(_[2].toLowerCase() + _.slice(3)) : P.push(_);
        }
        P.length && L(
          `Extraneous non-props attributes (${P.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
        ), C.length && L(
          `Extraneous non-emits event listeners (${C.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return t.dirs && ({}.NODE_ENV !== "production" && !pE(A) && L(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), A = Ci(A), A.dirs = A.dirs ? A.dirs.concat(t.dirs) : t.dirs), t.transition && ({}.NODE_ENV !== "production" && !pE(A) && L(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), A.transition = t.transition), {}.NODE_ENV !== "production" && S ? S(A) : m = A, ma(g), m;
}
const F_ = (i) => {
  const e = i.children, t = i.dynamicChildren, r = hp(e);
  if (!r)
    return [i, void 0];
  const o = e.indexOf(r), s = t ? t.indexOf(r) : -1, n = (a) => {
    e[o] = a, t && (s > -1 ? t[s] = a : a.patchFlag > 0 && (i.dynamicChildren = [...t, a]));
  };
  return [Ht(r), n];
};
function hp(i) {
  let e;
  for (let t = 0; t < i.length; t++) {
    const r = i[t];
    if (Nr(r)) {
      if (r.type !== Ke || r.children === "v-if") {
        if (e)
          return;
        e = r;
      }
    } else
      return;
  }
  return e;
}
const W_ = (i) => {
  let e;
  for (const t in i)
    (t === "class" || t === "style" || Ar(t)) && ((e || (e = {}))[t] = i[t]);
  return e;
}, z_ = (i, e) => {
  const t = {};
  for (const r in i)
    (!nu(r) || !(r.slice(9) in e)) && (t[r] = i[r]);
  return t;
}, pE = (i) => i.shapeFlag & 7 || i.type === Ke;
function Z_(i, e, t) {
  const { props: r, children: o, component: s } = i, { props: n, children: a, patchFlag: l } = e, u = s.emitsOptions;
  if ({}.NODE_ENV !== "production" && (o || a) && to || e.dirs || e.transition)
    return !0;
  if (t && l >= 0) {
    if (l & 1024)
      return !0;
    if (l & 16)
      return r ? OE(r, n, u) : !!n;
    if (l & 8) {
      const h = e.dynamicProps;
      for (let c = 0; c < h.length; c++) {
        const d = h[c];
        if (n[d] !== r[d] && !Th(u, d))
          return !0;
      }
    }
  } else
    return (o || a) && (!a || !a.$stable) ? !0 : r === n ? !1 : r ? n ? OE(r, n, u) : !0 : !!n;
  return !1;
}
function OE(i, e, t) {
  const r = Object.keys(e);
  if (r.length !== Object.keys(i).length)
    return !0;
  for (let o = 0; o < r.length; o++) {
    const s = r[o];
    if (e[s] !== i[s] && !Th(t, s))
      return !0;
  }
  return !1;
}
function cp({ vnode: i, parent: e }, t) {
  for (; e && e.subTree === i; )
    (i = e.vnode).el = t, e = e.parent;
}
const eS = (i) => i.__isSuspense, q_ = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: !0,
  process(i, e, t, r, o, s, n, a, l, u) {
    i == null ? K_(
      e,
      t,
      r,
      o,
      s,
      n,
      a,
      l,
      u
    ) : J_(
      i,
      e,
      t,
      r,
      o,
      n,
      a,
      l,
      u
    );
  },
  hydrate: eP,
  create: dp,
  normalize: tP
}, j_ = q_;
function ba(i, e) {
  const t = i.props && i.props[e];
  ae(t) && t();
}
function K_(i, e, t, r, o, s, n, a, l) {
  const {
    p: u,
    o: { createElement: h }
  } = l, c = h("div"), d = i.suspense = dp(
    i,
    o,
    r,
    e,
    c,
    t,
    s,
    n,
    a,
    l
  );
  u(
    null,
    d.pendingBranch = i.ssContent,
    c,
    null,
    r,
    d,
    s,
    n
  ), d.deps > 0 ? (ba(i, "onPending"), ba(i, "onFallback"), u(
    null,
    i.ssFallback,
    e,
    t,
    r,
    null,
    // fallback tree will not have suspense context
    s,
    n
  ), $s(d, i.ssFallback)) : d.resolve(!1, !0);
}
function J_(i, e, t, r, o, s, n, a, { p: l, um: u, o: { createElement: h } }) {
  const c = e.suspense = i.suspense;
  c.vnode = e, e.el = i.el;
  const d = e.ssContent, f = e.ssFallback, { activeBranch: p, pendingBranch: O, isInFallback: m, isHydrating: E } = c;
  if (O)
    c.pendingBranch = d, wi(d, O) ? (l(
      O,
      d,
      c.hiddenContainer,
      null,
      o,
      c,
      s,
      n,
      a
    ), c.deps <= 0 ? c.resolve() : m && (l(
      p,
      f,
      t,
      r,
      o,
      null,
      // fallback tree will not have suspense context
      s,
      n,
      a
    ), $s(c, f))) : (c.pendingId++, E ? (c.isHydrating = !1, c.activeBranch = O) : u(O, o, c), c.deps = 0, c.effects.length = 0, c.hiddenContainer = h("div"), m ? (l(
      null,
      d,
      c.hiddenContainer,
      null,
      o,
      c,
      s,
      n,
      a
    ), c.deps <= 0 ? c.resolve() : (l(
      p,
      f,
      t,
      r,
      o,
      null,
      // fallback tree will not have suspense context
      s,
      n,
      a
    ), $s(c, f))) : p && wi(d, p) ? (l(
      p,
      d,
      t,
      r,
      o,
      c,
      s,
      n,
      a
    ), c.resolve(!0)) : (l(
      null,
      d,
      c.hiddenContainer,
      null,
      o,
      c,
      s,
      n,
      a
    ), c.deps <= 0 && c.resolve()));
  else if (p && wi(d, p))
    l(
      p,
      d,
      t,
      r,
      o,
      c,
      s,
      n,
      a
    ), $s(c, d);
  else if (ba(e, "onPending"), c.pendingBranch = d, c.pendingId++, l(
    null,
    d,
    c.hiddenContainer,
    null,
    o,
    c,
    s,
    n,
    a
  ), c.deps <= 0)
    c.resolve();
  else {
    const { timeout: g, pendingId: A } = c;
    g > 0 ? setTimeout(() => {
      c.pendingId === A && c.fallback(f);
    }, g) : g === 0 && c.fallback(f);
  }
}
let EE = !1;
function dp(i, e, t, r, o, s, n, a, l, u, h = !1) {
  ({}).NODE_ENV !== "production" && !EE && (EE = !0, console[console.info ? "info" : "log"](
    "<Suspense> is an experimental feature and its API will likely change."
  ));
  const {
    p: c,
    m: d,
    um: f,
    n: p,
    o: { parentNode: O, remove: m }
  } = u;
  let E;
  const g = iP(i);
  g && e != null && e.pendingBranch && (E = e.pendingId, e.deps++);
  const A = i.props ? uu(i.props.timeout) : void 0;
  ({}).NODE_ENV !== "production" && op(A, "Suspense timeout");
  const S = {
    vnode: i,
    parent: e,
    parentComponent: t,
    isSVG: n,
    container: r,
    hiddenContainer: o,
    anchor: s,
    deps: 0,
    pendingId: 0,
    timeout: typeof A == "number" ? A : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !0,
    isHydrating: h,
    isUnmounted: !1,
    effects: [],
    resolve(R = !1, v = !1) {
      if ({}.NODE_ENV !== "production") {
        if (!R && !S.pendingBranch)
          throw new Error(
            "suspense.resolve() is called without a pending branch."
          );
        if (S.isUnmounted)
          throw new Error(
            "suspense.resolve() is called on an already unmounted suspense boundary."
          );
      }
      const {
        vnode: I,
        activeBranch: C,
        pendingBranch: P,
        pendingId: w,
        effects: x,
        parentComponent: _,
        container: X
      } = S;
      if (S.isHydrating)
        S.isHydrating = !1;
      else if (!R) {
        const re = C && P.transition && P.transition.mode === "out-in";
        re && (C.transition.afterLeave = () => {
          w === S.pendingId && d(P, X, le, 0);
        });
        let { anchor: le } = S;
        C && (le = p(C), f(C, _, S, !0)), re || d(P, X, le, 0);
      }
      $s(S, P), S.pendingBranch = null, S.isInFallback = !1;
      let G = S.parent, ee = !1;
      for (; G; ) {
        if (G.pendingBranch) {
          G.effects.push(...x), ee = !0;
          break;
        }
        G = G.parent;
      }
      ee || bh(x), S.effects = [], g && e && e.pendingBranch && E === e.pendingId && (e.deps--, e.deps === 0 && !v && e.resolve()), ba(I, "onResolve");
    },
    fallback(R) {
      if (!S.pendingBranch)
        return;
      const { vnode: v, activeBranch: I, parentComponent: C, container: P, isSVG: w } = S;
      ba(v, "onFallback");
      const x = p(I), _ = () => {
        S.isInFallback && (c(
          null,
          R,
          P,
          x,
          C,
          null,
          // fallback tree will not have suspense context
          w,
          a,
          l
        ), $s(S, R));
      }, X = R.transition && R.transition.mode === "out-in";
      X && (I.transition.afterLeave = _), S.isInFallback = !0, f(
        I,
        C,
        null,
        // no suspense so unmount hooks fire now
        !0
        // shouldRemove
      ), X || _();
    },
    move(R, v, I) {
      S.activeBranch && d(S.activeBranch, R, v, I), S.container = R;
    },
    next() {
      return S.activeBranch && p(S.activeBranch);
    },
    registerDep(R, v) {
      const I = !!S.pendingBranch;
      I && S.deps++;
      const C = R.vnode.el;
      R.asyncDep.catch((P) => {
        hs(P, R, 0);
      }).then((P) => {
        if (R.isUnmounted || S.isUnmounted || S.pendingId !== R.suspenseId)
          return;
        R.asyncResolved = !0;
        const { vnode: w } = R;
        ({}).NODE_ENV !== "production" && qn(w), Nd(R, P, !1), C && (w.el = C);
        const x = !C && R.subTree.el;
        v(
          R,
          w,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          O(C || R.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          C ? null : p(R.subTree),
          S,
          n,
          l
        ), x && m(x), cp(R, w.el), {}.NODE_ENV !== "production" && jn(), I && --S.deps === 0 && S.resolve();
      });
    },
    unmount(R, v) {
      S.isUnmounted = !0, S.activeBranch && f(
        S.activeBranch,
        t,
        R,
        v
      ), S.pendingBranch && f(
        S.pendingBranch,
        t,
        R,
        v
      );
    }
  };
  return S;
}
function eP(i, e, t, r, o, s, n, a, l) {
  const u = e.suspense = dp(
    e,
    r,
    t,
    i.parentNode,
    document.createElement("div"),
    null,
    o,
    s,
    n,
    a,
    !0
    /* hydrating */
  ), h = l(
    i,
    u.pendingBranch = e.ssContent,
    t,
    u,
    s,
    n
  );
  return u.deps === 0 && u.resolve(!1, !0), h;
}
function tP(i) {
  const { shapeFlag: e, children: t } = i, r = e & 32;
  i.ssContent = mE(
    r ? t.default : t
  ), i.ssFallback = r ? mE(t.fallback) : xe(Ke);
}
function mE(i) {
  let e;
  if (ae(i)) {
    const t = jo && i._c;
    t && (i._d = !1, Pe()), i = i(), t && (i._d = !0, e = Yt, DS());
  }
  if (W(i)) {
    const t = hp(i);
    ({}).NODE_ENV !== "production" && !t && L("<Suspense> slots expect a single root node."), i = t;
  }
  return i = Ht(i), e && !i.dynamicChildren && (i.dynamicChildren = e.filter((t) => t !== i)), i;
}
function tS(i, e) {
  e && e.pendingBranch ? W(i) ? e.effects.push(...i) : e.effects.push(i) : bh(i);
}
function $s(i, e) {
  i.activeBranch = e;
  const { vnode: t, parentComponent: r } = i, o = t.el = e.el;
  r && r.subTree === t && (r.vnode.el = o, cp(r, o));
}
function iP(i) {
  var e;
  return ((e = i.props) == null ? void 0 : e.suspensible) != null && i.props.suspensible !== !1;
}
function rP(i, e) {
  return Ba(i, null, e);
}
function iS(i, e) {
  return Ba(
    i,
    null,
    {}.NODE_ENV !== "production" ? pe({}, e, { flush: "post" }) : { flush: "post" }
  );
}
function oP(i, e) {
  return Ba(
    i,
    null,
    {}.NODE_ENV !== "production" ? pe({}, e, { flush: "sync" }) : { flush: "sync" }
  );
}
const fl = {};
function Mi(i, e, t) {
  return {}.NODE_ENV !== "production" && !ae(e) && L(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), Ba(i, e, t);
}
function Ba(i, e, { immediate: t, deep: r, flush: o, onTrack: s, onTrigger: n } = Ae) {
  var a;
  ({}).NODE_ENV !== "production" && !e && (t !== void 0 && L(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), r !== void 0 && L(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const l = (R) => {
    L(
      "Invalid watch source: ",
      R,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, u = _T() === ((a = qe) == null ? void 0 : a.scope) ? qe : null;
  let h, c = !1, d = !1;
  if (Fe(i) ? (h = () => i.value, c = da(i)) : eo(i) ? (h = () => i, r = !0) : W(i) ? (d = !0, c = i.some((R) => eo(R) || da(R)), h = () => i.map((R) => {
    if (Fe(R))
      return R.value;
    if (eo(R))
      return Mo(R);
    if (ae(R))
      return or(R, u, 2);
    ({}).NODE_ENV !== "production" && l(R);
  })) : ae(i) ? e ? h = () => or(i, u, 2) : h = () => {
    if (!(u && u.isUnmounted))
      return f && f(), li(
        i,
        u,
        3,
        [p]
      );
  } : (h = Ze, {}.NODE_ENV !== "production" && l(i)), e && r) {
    const R = h;
    h = () => Mo(R());
  }
  let f, p = (R) => {
    f = A.onStop = () => {
      or(R, u, 4);
    };
  }, O;
  if (js)
    if (p = Ze, e ? t && li(e, u, 3, [
      h(),
      d ? [] : void 0,
      p
    ]) : h(), o === "sync") {
      const R = ZS();
      O = R.__watcherHandles || (R.__watcherHandles = []);
    } else
      return Ze;
  let m = d ? new Array(i.length).fill(fl) : fl;
  const E = () => {
    if (A.active)
      if (e) {
        const R = A.run();
        (r || c || (d ? R.some(
          (v, I) => zs(v, m[I])
        ) : zs(R, m))) && (f && f(), li(e, u, 3, [
          R,
          // pass undefined as the old value when it's changed for the first time
          m === fl ? void 0 : d && m[0] === fl ? [] : m,
          p
        ]), m = R);
      } else
        A.run();
  };
  E.allowRecurse = !!e;
  let g;
  o === "sync" ? g = E : o === "post" ? g = () => Ot(E, u && u.suspense) : (E.pre = !0, u && (E.id = u.uid), g = () => Xa(E));
  const A = new Ha(h, g);
  ({}).NODE_ENV !== "production" && (A.onTrack = s, A.onTrigger = n), e ? t ? E() : m = A.run() : o === "post" ? Ot(
    A.run.bind(A),
    u && u.suspense
  ) : A.run();
  const S = () => {
    A.stop(), u && u.scope && zf(u.scope.effects, A);
  };
  return O && O.push(S), S;
}
function sP(i, e, t) {
  const r = this.proxy, o = he(i) ? i.includes(".") ? rS(r, i) : () => r[i] : i.bind(r, r);
  let s;
  ae(e) ? s = e : (s = e.handler, t = e);
  const n = qe;
  po(this);
  const a = Ba(o, s.bind(r), t);
  return n ? po(n) : ro(), a;
}
function rS(i, e) {
  const t = e.split(".");
  return () => {
    let r = i;
    for (let o = 0; o < t.length && r; o++)
      r = r[t[o]];
    return r;
  };
}
function Mo(i, e) {
  if (!Se(i) || i.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(i)))
    return i;
  if (e.add(i), Fe(i))
    Mo(i.value, e);
  else if (W(i))
    for (let t = 0; t < i.length; t++)
      Mo(i[t], e);
  else if (as(i) || Vo(i))
    i.forEach((t) => {
      Mo(t, e);
    });
  else if (bT(i))
    for (const t in i)
      Mo(i[t], e);
  return i;
}
function oS(i) {
  TT(i) && L("Do not use built-in directive ids as custom directive id: " + i);
}
function nP(i, e) {
  const t = je;
  if (t === null)
    return {}.NODE_ENV !== "production" && L("withDirectives can only be used inside render functions."), i;
  const r = _h(t) || t.proxy, o = i.dirs || (i.dirs = []);
  for (let s = 0; s < e.length; s++) {
    let [n, a, l, u = Ae] = e[s];
    n && (ae(n) && (n = {
      mounted: n,
      updated: n
    }), n.deep && Mo(a), o.push({
      dir: n,
      instance: r,
      value: a,
      oldValue: void 0,
      arg: l,
      modifiers: u
    }));
  }
  return i;
}
function Wi(i, e, t, r) {
  const o = i.dirs, s = e && e.dirs;
  for (let n = 0; n < o.length; n++) {
    const a = o[n];
    s && (a.oldValue = s[n].value);
    let l = a.dir[r];
    l && (ls(), li(l, t, 8, [
      i.el,
      a,
      i,
      e
    ]), us());
  }
}
function fp() {
  const i = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return yr(() => {
    i.isMounted = !0;
  }), Nh(() => {
    i.isUnmounting = !0;
  }), i;
}
const Oi = [Function, Array], pp = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: Oi,
  onEnter: Oi,
  onAfterEnter: Oi,
  onEnterCancelled: Oi,
  // leave
  onBeforeLeave: Oi,
  onLeave: Oi,
  onAfterLeave: Oi,
  onLeaveCancelled: Oi,
  // appear
  onBeforeAppear: Oi,
  onAppear: Oi,
  onAfterAppear: Oi,
  onAppearCancelled: Oi
}, aP = {
  name: "BaseTransition",
  props: pp,
  setup(i, { slots: e }) {
    const t = Dr(), r = fp();
    let o;
    return () => {
      const s = e.default && Rh(e.default(), !0);
      if (!s || !s.length)
        return;
      let n = s[0];
      if (s.length > 1) {
        let O = !1;
        for (const m of s)
          if (m.type !== Ke) {
            if ({}.NODE_ENV !== "production" && O) {
              L(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            if (n = m, O = !0, {}.NODE_ENV === "production")
              break;
          }
      }
      const a = ce(i), { mode: l } = a;
      if ({}.NODE_ENV !== "production" && l && l !== "in-out" && l !== "out-in" && l !== "default" && L(`invalid <transition> mode: ${l}`), r.isLeaving)
        return ac(n);
      const u = gE(n);
      if (!u)
        return ac(n);
      const h = qs(
        u,
        a,
        r,
        t
      );
      qo(u, h);
      const c = t.subTree, d = c && gE(c);
      let f = !1;
      const { getTransitionKey: p } = u.type;
      if (p) {
        const O = p();
        o === void 0 ? o = O : O !== o && (o = O, f = !0);
      }
      if (d && d.type !== Ke && (!wi(u, d) || f)) {
        const O = qs(
          d,
          a,
          r,
          t
        );
        if (qo(d, O), l === "out-in")
          return r.isLeaving = !0, O.afterLeave = () => {
            r.isLeaving = !1, t.update.active !== !1 && t.update();
          }, ac(n);
        l === "in-out" && u.type !== Ke && (O.delayLeave = (m, E, g) => {
          const A = nS(
            r,
            d
          );
          A[String(d.key)] = d, m._leaveCb = () => {
            E(), m._leaveCb = void 0, delete h.delayedLeave;
          }, h.delayedLeave = g;
        });
      }
      return n;
    };
  }
}, sS = aP;
function nS(i, e) {
  const { leavingVNodes: t } = i;
  let r = t.get(e.type);
  return r || (r = /* @__PURE__ */ Object.create(null), t.set(e.type, r)), r;
}
function qs(i, e, t, r) {
  const {
    appear: o,
    mode: s,
    persisted: n = !1,
    onBeforeEnter: a,
    onEnter: l,
    onAfterEnter: u,
    onEnterCancelled: h,
    onBeforeLeave: c,
    onLeave: d,
    onAfterLeave: f,
    onLeaveCancelled: p,
    onBeforeAppear: O,
    onAppear: m,
    onAfterAppear: E,
    onAppearCancelled: g
  } = e, A = String(i.key), S = nS(t, i), R = (C, P) => {
    C && li(
      C,
      r,
      9,
      P
    );
  }, v = (C, P) => {
    const w = P[1];
    R(C, P), W(C) ? C.every((x) => x.length <= 1) && w() : C.length <= 1 && w();
  }, I = {
    mode: s,
    persisted: n,
    beforeEnter(C) {
      let P = a;
      if (!t.isMounted)
        if (o)
          P = O || a;
        else
          return;
      C._leaveCb && C._leaveCb(
        !0
        /* cancelled */
      );
      const w = S[A];
      w && wi(i, w) && w.el._leaveCb && w.el._leaveCb(), R(P, [C]);
    },
    enter(C) {
      let P = l, w = u, x = h;
      if (!t.isMounted)
        if (o)
          P = m || l, w = E || u, x = g || h;
        else
          return;
      let _ = !1;
      const X = C._enterCb = (G) => {
        _ || (_ = !0, G ? R(x, [C]) : R(w, [C]), I.delayedLeave && I.delayedLeave(), C._enterCb = void 0);
      };
      P ? v(P, [C, X]) : X();
    },
    leave(C, P) {
      const w = String(i.key);
      if (C._enterCb && C._enterCb(
        !0
        /* cancelled */
      ), t.isUnmounting)
        return P();
      R(c, [C]);
      let x = !1;
      const _ = C._leaveCb = (X) => {
        x || (x = !0, P(), X ? R(p, [C]) : R(f, [C]), C._leaveCb = void 0, S[w] === i && delete S[w]);
      };
      S[w] = i, d ? v(d, [C, _]) : _();
    },
    clone(C) {
      return qs(C, e, t, r);
    }
  };
  return I;
}
function ac(i) {
  if (En(i))
    return i = Ci(i), i.children = null, i;
}
function gE(i) {
  return En(i) ? i.children ? i.children[0] : void 0 : i;
}
function qo(i, e) {
  i.shapeFlag & 6 && i.component ? qo(i.component.subTree, e) : i.shapeFlag & 128 ? (i.ssContent.transition = e.clone(i.ssContent), i.ssFallback.transition = e.clone(i.ssFallback)) : i.transition = e;
}
function Rh(i, e = !1, t) {
  let r = [], o = 0;
  for (let s = 0; s < i.length; s++) {
    let n = i[s];
    const a = t == null ? n.key : String(t) + String(n.key != null ? n.key : s);
    n.type === et ? (n.patchFlag & 128 && o++, r = r.concat(
      Rh(n.children, e, a)
    )) : (e || n.type !== Ke) && r.push(a != null ? Ci(n, { key: a }) : n);
  }
  if (o > 1)
    for (let s = 0; s < r.length; s++)
      r[s].patchFlag = -2;
  return r;
}
function fi(i, e) {
  return ae(i) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => pe({ name: i.name }, e, { setup: i }))()
  ) : i;
}
const Bo = (i) => !!i.type.__asyncLoader;
function lP(i) {
  ae(i) && (i = { loader: i });
  const {
    loader: e,
    loadingComponent: t,
    errorComponent: r,
    delay: o = 200,
    timeout: s,
    // undefined = never times out
    suspensible: n = !0,
    onError: a
  } = i;
  let l = null, u, h = 0;
  const c = () => (h++, l = null, d()), d = () => {
    let f;
    return l || (f = l = e().catch((p) => {
      if (p = p instanceof Error ? p : new Error(String(p)), a)
        return new Promise((O, m) => {
          a(p, () => O(c()), () => m(p), h + 1);
        });
      throw p;
    }).then((p) => {
      if (f !== l && l)
        return l;
      if ({}.NODE_ENV !== "production" && !p && L(
        "Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."
      ), p && (p.__esModule || p[Symbol.toStringTag] === "Module") && (p = p.default), {}.NODE_ENV !== "production" && p && !Se(p) && !ae(p))
        throw new Error(`Invalid async component load result: ${p}`);
      return u = p, p;
    }));
  };
  return fi({
    name: "AsyncComponentWrapper",
    __asyncLoader: d,
    get __asyncResolved() {
      return u;
    },
    setup() {
      const f = qe;
      if (u)
        return () => lc(u, f);
      const p = (g) => {
        l = null, hs(
          g,
          f,
          13,
          !r
          /* do not throw in dev if user provided error component */
        );
      };
      if (n && f.suspense || js)
        return d().then((g) => () => lc(g, f)).catch((g) => (p(g), () => r ? xe(r, {
          error: g
        }) : null));
      const O = it(!1), m = it(), E = it(!!o);
      return o && setTimeout(() => {
        E.value = !1;
      }, o), s != null && setTimeout(() => {
        if (!O.value && !m.value) {
          const g = new Error(
            `Async component timed out after ${s}ms.`
          );
          p(g), m.value = g;
        }
      }, s), d().then(() => {
        O.value = !0, f.parent && En(f.parent.vnode) && Xa(f.parent.update);
      }).catch((g) => {
        p(g), m.value = g;
      }), () => {
        if (O.value && u)
          return lc(u, f);
        if (m.value && r)
          return xe(r, {
            error: m.value
          });
        if (t && !E.value)
          return xe(t);
      };
    }
  });
}
function lc(i, e) {
  const { ref: t, props: r, children: o, ce: s } = e.vnode, n = xe(i, r, o);
  return n.ref = t, n.ce = s, delete e.vnode.ce, n;
}
const En = (i) => i.type.__isKeepAlive, uP = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: !0,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(i, { slots: e }) {
    const t = Dr(), r = t.ctx;
    if (!r.renderer)
      return () => {
        const g = e.default && e.default();
        return g && g.length === 1 ? g[0] : g;
      };
    const o = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set();
    let n = null;
    ({}).NODE_ENV !== "production" && (t.__v_cache = o);
    const a = t.suspense, {
      renderer: {
        p: l,
        m: u,
        um: h,
        o: { createElement: c }
      }
    } = r, d = c("div");
    r.activate = (g, A, S, R, v) => {
      const I = g.component;
      u(g, A, S, 0, a), l(
        I.vnode,
        g,
        A,
        S,
        I,
        a,
        R,
        g.slotScopeIds,
        v
      ), Ot(() => {
        I.isDeactivated = !1, I.a && Wr(I.a);
        const C = g.props && g.props.onVnodeMounted;
        C && Vt(C, I.parent, g);
      }, a), {}.NODE_ENV !== "production" && pd(I);
    }, r.deactivate = (g) => {
      const A = g.component;
      u(g, d, null, 1, a), Ot(() => {
        A.da && Wr(A.da);
        const S = g.props && g.props.onVnodeUnmounted;
        S && Vt(S, A.parent, g), A.isDeactivated = !0;
      }, a), {}.NODE_ENV !== "production" && pd(A);
    };
    function f(g) {
      uc(g), h(g, t, a, !0);
    }
    function p(g) {
      o.forEach((A, S) => {
        const R = Ra(A.type);
        R && (!g || !g(R)) && O(S);
      });
    }
    function O(g) {
      const A = o.get(g);
      !n || !wi(A, n) ? f(A) : n && uc(n), o.delete(g), s.delete(g);
    }
    Mi(
      () => [i.include, i.exclude],
      ([g, A]) => {
        g && p((S) => Hn(g, S)), A && p((S) => !Hn(A, S));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: !0 }
    );
    let m = null;
    const E = () => {
      m != null && o.set(m, hc(t.subTree));
    };
    return yr(E), Ch(E), Nh(() => {
      o.forEach((g) => {
        const { subTree: A, suspense: S } = t, R = hc(A);
        if (g.type === R.type && g.key === R.key) {
          uc(R);
          const v = R.component.da;
          v && Ot(v, S);
          return;
        }
        f(g);
      });
    }), () => {
      if (m = null, !e.default)
        return null;
      const g = e.default(), A = g[0];
      if (g.length > 1)
        return {}.NODE_ENV !== "production" && L("KeepAlive should contain exactly one component child."), n = null, g;
      if (!Nr(A) || !(A.shapeFlag & 4) && !(A.shapeFlag & 128))
        return n = null, A;
      let S = hc(A);
      const R = S.type, v = Ra(
        Bo(S) ? S.type.__asyncResolved || {} : R
      ), { include: I, exclude: C, max: P } = i;
      if (I && (!v || !Hn(I, v)) || C && v && Hn(C, v))
        return n = S, A;
      const w = S.key == null ? R : S.key, x = o.get(w);
      return S.el && (S = Ci(S), A.shapeFlag & 128 && (A.ssContent = S)), m = w, x ? (S.el = x.el, S.component = x.component, S.transition && qo(S, S.transition), S.shapeFlag |= 512, s.delete(w), s.add(w)) : (s.add(w), P && s.size > parseInt(P, 10) && O(s.values().next().value)), S.shapeFlag |= 256, n = S, eS(A.type) ? A : S;
    };
  }
}, hP = uP;
function Hn(i, e) {
  return W(i) ? i.some((t) => Hn(t, e)) : he(i) ? i.split(",").includes(e) : Ov(i) ? i.test(e) : !1;
}
function aS(i, e) {
  uS(i, "a", e);
}
function lS(i, e) {
  uS(i, "da", e);
}
function uS(i, e, t = qe) {
  const r = i.__wdc || (i.__wdc = () => {
    let o = t;
    for (; o; ) {
      if (o.isDeactivated)
        return;
      o = o.parent;
    }
    return i();
  });
  if (Ah(e, r, t), t) {
    let o = t.parent;
    for (; o && o.parent; )
      En(o.parent.vnode) && cP(r, e, t, o), o = o.parent;
  }
}
function cP(i, e, t, r) {
  const o = Ah(
    e,
    i,
    r,
    !0
    /* prepend */
  );
  Ih(() => {
    zf(r[e], o);
  }, t);
}
function uc(i) {
  i.shapeFlag &= -257, i.shapeFlag &= -513;
}
function hc(i) {
  return i.shapeFlag & 128 ? i.ssContent : i;
}
function Ah(i, e, t = qe, r = !1) {
  if (t) {
    const o = t[i] || (t[i] = []), s = e.__weh || (e.__weh = (...n) => {
      if (t.isUnmounted)
        return;
      ls(), po(t);
      const a = li(e, t, i, n);
      return ro(), us(), a;
    });
    return r ? o.unshift(s) : o.push(s), s;
  } else if ({}.NODE_ENV !== "production") {
    const o = zi(sp[i].replace(/ hook$/, ""));
    L(
      `${o} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const wr = (i) => (e, t = qe) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!js || i === "sp") && Ah(i, (...r) => e(...r), t)
), hS = wr("bm"), yr = wr("m"), cS = wr("bu"), Ch = wr("u"), Nh = wr("bum"), Ih = wr("um"), dS = wr("sp"), fS = wr(
  "rtg"
), pS = wr(
  "rtc"
);
function OS(i, e = qe) {
  Ah("ec", i, e);
}
const Ou = "components", dP = "directives";
function ES(i, e) {
  return Op(Ou, i, !0, e) || i;
}
const mS = Symbol.for("v-ndc");
function fP(i) {
  return he(i) ? Op(Ou, i, !1) || i : i || mS;
}
function pP(i) {
  return Op(dP, i);
}
function Op(i, e, t = !0, r = !1) {
  const o = je || qe;
  if (o) {
    const s = o.type;
    if (i === Ou) {
      const a = Ra(
        s,
        !1
        /* do not include inferred name to avoid breaking existing code */
      );
      if (a && (a === e || a === ot(e) || a === ur(ot(e))))
        return s;
    }
    const n = (
      // local registration
      // check instance[type] first which is resolved for options API
      bE(o[i] || s[i], e) || // global registration
      bE(o.appContext[i], e)
    );
    if (!n && r)
      return s;
    if ({}.NODE_ENV !== "production" && t && !n) {
      const a = i === Ou ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      L(`Failed to resolve ${i.slice(0, -1)}: ${e}${a}`);
    }
    return n;
  } else
    ({}).NODE_ENV !== "production" && L(
      `resolve${ur(i.slice(0, -1))} can only be used in render() or setup().`
    );
}
function bE(i, e) {
  return i && (i[e] || i[ot(e)] || i[ur(ot(e))]);
}
function Ep(i, e, t, r) {
  let o;
  const s = t && t[r];
  if (W(i) || he(i)) {
    o = new Array(i.length);
    for (let n = 0, a = i.length; n < a; n++)
      o[n] = e(i[n], n, void 0, s && s[n]);
  } else if (typeof i == "number") {
    ({}).NODE_ENV !== "production" && !Number.isInteger(i) && L(`The v-for range expect an integer value but got ${i}.`), o = new Array(i);
    for (let n = 0; n < i; n++)
      o[n] = e(n + 1, n, void 0, s && s[n]);
  } else if (Se(i))
    if (i[Symbol.iterator])
      o = Array.from(
        i,
        (n, a) => e(n, a, void 0, s && s[a])
      );
    else {
      const n = Object.keys(i);
      o = new Array(n.length);
      for (let a = 0, l = n.length; a < l; a++) {
        const u = n[a];
        o[a] = e(i[u], u, a, s && s[a]);
      }
    }
  else
    o = [];
  return t && (t[r] = o), o;
}
function OP(i, e) {
  for (let t = 0; t < e.length; t++) {
    const r = e[t];
    if (W(r))
      for (let o = 0; o < r.length; o++)
        i[r[o].name] = r[o].fn;
    else
      r && (i[r.name] = r.key ? (...o) => {
        const s = r.fn(...o);
        return s && (s.key = r.key), s;
      } : r.fn);
  }
  return i;
}
function ui(i, e, t = {}, r, o) {
  if (je.isCE || je.parent && Bo(je.parent) && je.parent.isCE)
    return e !== "default" && (t.name = e), xe("slot", t, r && r());
  let s = i[e];
  ({}).NODE_ENV !== "production" && s && s.length > 1 && (L(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), s = () => []), s && s._c && (s._d = !1), Pe();
  const n = s && gS(s(t)), a = Li(
    et,
    {
      key: t.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      n && n.key || `_${e}`
    },
    n || (r ? r() : []),
    n && i._ === 1 ? 64 : -2
  );
  return !o && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a;
}
function gS(i) {
  return i.some((e) => Nr(e) ? !(e.type === Ke || e.type === et && !gS(e.children)) : !0) ? i : null;
}
function EP(i, e) {
  const t = {};
  if ({}.NODE_ENV !== "production" && !Se(i))
    return L("v-on with no argument expects an object value."), t;
  for (const r in i)
    t[e && /[A-Z]/.test(r) ? `on:${r}` : zi(r)] = i[r];
  return t;
}
const Ed = (i) => i ? VS(i) ? _h(i) || i.proxy : Ed(i.parent) : null, Fo = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ pe(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => ({}).NODE_ENV !== "production" ? ws(i.props) : i.props,
    $attrs: (i) => ({}).NODE_ENV !== "production" ? ws(i.attrs) : i.attrs,
    $slots: (i) => ({}).NODE_ENV !== "production" ? ws(i.slots) : i.slots,
    $refs: (i) => ({}).NODE_ENV !== "production" ? ws(i.refs) : i.refs,
    $parent: (i) => Ed(i.parent),
    $root: (i) => Ed(i.root),
    $emit: (i) => i.emit,
    $options: (i) => gp(i),
    $forceUpdate: (i) => i.f || (i.f = () => Xa(i.update)),
    $nextTick: (i) => i.n || (i.n = zo.bind(i.proxy)),
    $watch: (i) => sP.bind(i)
  })
), mp = (i) => i === "_" || i === "$", cc = (i, e) => i !== Ae && !i.__isScriptSetup && be(i, e), Jn = {
  get({ _: i }, e) {
    const { ctx: t, setupState: r, data: o, props: s, accessCache: n, type: a, appContext: l } = i;
    if ({}.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let u;
    if (e[0] !== "$") {
      const f = n[e];
      if (f !== void 0)
        switch (f) {
          case 1:
            return r[e];
          case 2:
            return o[e];
          case 4:
            return t[e];
          case 3:
            return s[e];
        }
      else {
        if (cc(r, e))
          return n[e] = 1, r[e];
        if (o !== Ae && be(o, e))
          return n[e] = 2, o[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (u = i.propsOptions[0]) && be(u, e)
        )
          return n[e] = 3, s[e];
        if (t !== Ae && be(t, e))
          return n[e] = 4, t[e];
        md && (n[e] = 0);
      }
    }
    const h = Fo[e];
    let c, d;
    if (h)
      return e === "$attrs" ? (St(i, "get", e), {}.NODE_ENV !== "production" && pu()) : {}.NODE_ENV !== "production" && e === "$slots" && St(i, "get", e), h(i);
    if (
      // css module (injected by vue-loader)
      (c = a.__cssModules) && (c = c[e])
    )
      return c;
    if (t !== Ae && be(t, e))
      return n[e] = 4, t[e];
    if (
      // global properties
      d = l.config.globalProperties, be(d, e)
    )
      return d[e];
    ({}).NODE_ENV !== "production" && je && (!he(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (o !== Ae && mp(e[0]) && be(o, e) ? L(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : i === je && L(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: i }, e, t) {
    const { data: r, setupState: o, ctx: s } = i;
    return cc(o, e) ? (o[e] = t, !0) : {}.NODE_ENV !== "production" && o.__isScriptSetup && be(o, e) ? (L(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : r !== Ae && be(r, e) ? (r[e] = t, !0) : be(i.props, e) ? ({}.NODE_ENV !== "production" && L(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in i ? ({}.NODE_ENV !== "production" && L(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : ({}.NODE_ENV !== "production" && e in i.appContext.config.globalProperties ? Object.defineProperty(s, e, {
      enumerable: !0,
      configurable: !0,
      value: t
    }) : s[e] = t, !0);
  },
  has({
    _: { data: i, setupState: e, accessCache: t, ctx: r, appContext: o, propsOptions: s }
  }, n) {
    let a;
    return !!t[n] || i !== Ae && be(i, n) || cc(e, n) || (a = s[0]) && be(a, n) || be(r, n) || be(Fo, n) || be(o.config.globalProperties, n);
  },
  defineProperty(i, e, t) {
    return t.get != null ? i._.accessCache[e] = 0 : be(t, "value") && this.set(i, e, t.value, null), Reflect.defineProperty(i, e, t);
  }
};
({}).NODE_ENV !== "production" && (Jn.ownKeys = (i) => (L(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(i)));
const mP = /* @__PURE__ */ pe(
  {},
  Jn,
  {
    get(i, e) {
      if (e !== Symbol.unscopables)
        return Jn.get(i, e, i);
    },
    has(i, e) {
      const t = e[0] !== "_" && !Tv(e);
      return {}.NODE_ENV !== "production" && !t && Jn.has(i, e) && L(
        `Property ${JSON.stringify(
          e
        )} should not start with _ which is a reserved prefix for Vue internals.`
      ), t;
    }
  }
);
function gP(i) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => i
  }), Object.keys(Fo).forEach((t) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      get: () => Fo[t](i),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: Ze
    });
  }), e;
}
function bP(i) {
  const {
    ctx: e,
    propsOptions: [t]
  } = i;
  t && Object.keys(t).forEach((r) => {
    Object.defineProperty(e, r, {
      enumerable: !0,
      configurable: !0,
      get: () => i.props[r],
      set: Ze
    });
  });
}
function TP(i) {
  const { ctx: e, setupState: t } = i;
  Object.keys(ce(t)).forEach((r) => {
    if (!t.__isScriptSetup) {
      if (mp(r[0])) {
        L(
          `setup() return property ${JSON.stringify(
            r
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(e, r, {
        enumerable: !0,
        configurable: !0,
        get: () => t[r],
        set: Ze
      });
    }
  });
}
const cs = (i) => L(
  `${i}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function SP() {
  return {}.NODE_ENV !== "production" && cs("defineProps"), null;
}
function RP() {
  return {}.NODE_ENV !== "production" && cs("defineEmits"), null;
}
function AP(i) {
  ({}).NODE_ENV !== "production" && cs("defineExpose");
}
function CP(i) {
  ({}).NODE_ENV !== "production" && cs("defineOptions");
}
function NP() {
  return {}.NODE_ENV !== "production" && cs("defineSlots"), null;
}
function IP() {
  ({}).NODE_ENV !== "production" && cs("defineModel");
}
function vP(i, e) {
  return {}.NODE_ENV !== "production" && cs("withDefaults"), null;
}
function _P() {
  return bS().slots;
}
function PP() {
  return bS().attrs;
}
function LP(i, e, t) {
  const r = Dr();
  if ({}.NODE_ENV !== "production" && !r)
    return L("useModel() called without active instance."), it();
  if ({}.NODE_ENV !== "production" && !r.propsOptions[0][e])
    return L(`useModel() called with prop "${e}" which is not declared.`), it();
  if (t && t.local) {
    const o = it(i[e]);
    return Mi(
      () => i[e],
      (s) => o.value = s
    ), Mi(o, (s) => {
      s !== i[e] && r.emit(`update:${e}`, s);
    }), o;
  } else
    return {
      __v_isRef: !0,
      get value() {
        return i[e];
      },
      set value(o) {
        r.emit(`update:${e}`, o);
      }
    };
}
function bS() {
  const i = Dr();
  return {}.NODE_ENV !== "production" && !i && L("useContext() called without active instance."), i.setupContext || (i.setupContext = BS(i));
}
function Ta(i) {
  return W(i) ? i.reduce(
    (e, t) => (e[t] = null, e),
    {}
  ) : i;
}
function wP(i, e) {
  const t = Ta(i);
  for (const r in e) {
    if (r.startsWith("__skip"))
      continue;
    let o = t[r];
    o ? W(o) || ae(o) ? o = t[r] = { type: o, default: e[r] } : o.default = e[r] : o === null ? o = t[r] = { default: e[r] } : {}.NODE_ENV !== "production" && L(`props default key "${r}" has no corresponding declaration.`), o && e[`__skip_${r}`] && (o.skipFactory = !0);
  }
  return t;
}
function yP(i, e) {
  return !i || !e ? i || e : W(i) && W(e) ? i.concat(e) : pe({}, Ta(i), Ta(e));
}
function DP(i, e) {
  const t = {};
  for (const r in i)
    e.includes(r) || Object.defineProperty(t, r, {
      enumerable: !0,
      get: () => i[r]
    });
  return t;
}
function xP(i) {
  const e = Dr();
  ({}).NODE_ENV !== "production" && !e && L(
    "withAsyncContext called without active current instance. This is likely a bug."
  );
  let t = i();
  return ro(), hh(t) && (t = t.catch((r) => {
    throw po(e), r;
  })), [t, () => po(e)];
}
function MP() {
  const i = /* @__PURE__ */ Object.create(null);
  return (e, t) => {
    i[t] ? L(`${e} property "${t}" is already defined in ${i[t]}.`) : i[t] = e;
  };
}
let md = !0;
function UP(i) {
  const e = gp(i), t = i.proxy, r = i.ctx;
  md = !1, e.beforeCreate && TE(e.beforeCreate, i, "bc");
  const {
    // state
    data: o,
    computed: s,
    methods: n,
    watch: a,
    provide: l,
    inject: u,
    // lifecycle
    created: h,
    beforeMount: c,
    mounted: d,
    beforeUpdate: f,
    updated: p,
    activated: O,
    deactivated: m,
    beforeDestroy: E,
    beforeUnmount: g,
    destroyed: A,
    unmounted: S,
    render: R,
    renderTracked: v,
    renderTriggered: I,
    errorCaptured: C,
    serverPrefetch: P,
    // public API
    expose: w,
    inheritAttrs: x,
    // assets
    components: _,
    directives: X,
    filters: G
  } = e, ee = {}.NODE_ENV !== "production" ? MP() : null;
  if ({}.NODE_ENV !== "production") {
    const [le] = i.propsOptions;
    if (le)
      for (const oe in le)
        ee("Props", oe);
  }
  if (u && QP(u, r, ee), n)
    for (const le in n) {
      const oe = n[le];
      ae(oe) ? ({}.NODE_ENV !== "production" ? Object.defineProperty(r, le, {
        value: oe.bind(t),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : r[le] = oe.bind(t), {}.NODE_ENV !== "production" && ee("Methods", le)) : {}.NODE_ENV !== "production" && L(
        `Method "${le}" has type "${typeof oe}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (o) {
    ({}).NODE_ENV !== "production" && !ae(o) && L(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const le = o.call(t, t);
    if ({}.NODE_ENV !== "production" && hh(le) && L(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !Se(le))
      ({}).NODE_ENV !== "production" && L("data() should return an object.");
    else if (i.data = Eh(le), {}.NODE_ENV !== "production")
      for (const oe in le)
        ee("Data", oe), mp(oe[0]) || Object.defineProperty(r, oe, {
          configurable: !0,
          enumerable: !0,
          get: () => le[oe],
          set: Ze
        });
  }
  if (md = !0, s)
    for (const le in s) {
      const oe = s[le], Ee = ae(oe) ? oe.bind(t, t) : ae(oe.get) ? oe.get.bind(t, t) : Ze;
      ({}).NODE_ENV !== "production" && Ee === Ze && L(`Computed property "${le}" has no getter.`);
      const ve = !ae(oe) && ae(oe.set) ? oe.set.bind(t) : {}.NODE_ENV !== "production" ? () => {
        L(
          `Write operation failed: computed property "${le}" is readonly.`
        );
      } : Ze, qt = WS({
        get: Ee,
        set: ve
      });
      Object.defineProperty(r, le, {
        enumerable: !0,
        configurable: !0,
        get: () => qt.value,
        set: (jt) => qt.value = jt
      }), {}.NODE_ENV !== "production" && ee("Computed", le);
    }
  if (a)
    for (const le in a)
      TS(a[le], r, t, le);
  if (l) {
    const le = ae(l) ? l.call(t) : l;
    Reflect.ownKeys(le).forEach((oe) => {
      RS(oe, le[oe]);
    });
  }
  h && TE(h, i, "c");
  function re(le, oe) {
    W(oe) ? oe.forEach((Ee) => le(Ee.bind(t))) : oe && le(oe.bind(t));
  }
  if (re(hS, c), re(yr, d), re(cS, f), re(Ch, p), re(aS, O), re(lS, m), re(OS, C), re(pS, v), re(fS, I), re(Nh, g), re(Ih, S), re(dS, P), W(w))
    if (w.length) {
      const le = i.exposed || (i.exposed = {});
      w.forEach((oe) => {
        Object.defineProperty(le, oe, {
          get: () => t[oe],
          set: (Ee) => t[oe] = Ee
        });
      });
    } else
      i.exposed || (i.exposed = {});
  R && i.render === Ze && (i.render = R), x != null && (i.inheritAttrs = x), _ && (i.components = _), X && (i.directives = X);
}
function QP(i, e, t = Ze) {
  W(i) && (i = gd(i));
  for (const r in i) {
    const o = i[r];
    let s;
    Se(o) ? "default" in o ? s = ea(
      o.from || r,
      o.default,
      !0
      /* treat default function as factory */
    ) : s = ea(o.from || r) : s = ea(o), Fe(s) ? Object.defineProperty(e, r, {
      enumerable: !0,
      configurable: !0,
      get: () => s.value,
      set: (n) => s.value = n
    }) : e[r] = s, {}.NODE_ENV !== "production" && t("Inject", r);
  }
}
function TE(i, e, t) {
  li(
    W(i) ? i.map((r) => r.bind(e.proxy)) : i.bind(e.proxy),
    e,
    t
  );
}
function TS(i, e, t, r) {
  const o = r.includes(".") ? rS(t, r) : () => t[r];
  if (he(i)) {
    const s = e[i];
    ae(s) ? Mi(o, s) : {}.NODE_ENV !== "production" && L(`Invalid watch handler specified by key "${i}"`, s);
  } else if (ae(i))
    Mi(o, i.bind(t));
  else if (Se(i))
    if (W(i))
      i.forEach((s) => TS(s, e, t, r));
    else {
      const s = ae(i.handler) ? i.handler.bind(t) : e[i.handler];
      ae(s) ? Mi(o, s, i) : {}.NODE_ENV !== "production" && L(`Invalid watch handler specified by key "${i.handler}"`, s);
    }
  else
    ({}).NODE_ENV !== "production" && L(`Invalid watch option: "${r}"`, i);
}
function gp(i) {
  const e = i.type, { mixins: t, extends: r } = e, {
    mixins: o,
    optionsCache: s,
    config: { optionMergeStrategies: n }
  } = i.appContext, a = s.get(e);
  let l;
  return a ? l = a : !o.length && !t && !r ? l = e : (l = {}, o.length && o.forEach(
    (u) => Eu(l, u, n, !0)
  ), Eu(l, e, n)), Se(e) && s.set(e, l), l;
}
function Eu(i, e, t, r = !1) {
  const { mixins: o, extends: s } = e;
  s && Eu(i, s, t, !0), o && o.forEach(
    (n) => Eu(i, n, t, !0)
  );
  for (const n in e)
    if (r && n === "expose")
      ({}).NODE_ENV !== "production" && L(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const a = kP[n] || t && t[n];
      i[n] = a ? a(i[n], e[n]) : e[n];
    }
  return i;
}
const kP = {
  data: SE,
  props: RE,
  emits: RE,
  // objects
  methods: Xn,
  computed: Xn,
  // lifecycle
  beforeCreate: xt,
  created: xt,
  beforeMount: xt,
  mounted: xt,
  beforeUpdate: xt,
  updated: xt,
  beforeDestroy: xt,
  beforeUnmount: xt,
  destroyed: xt,
  unmounted: xt,
  activated: xt,
  deactivated: xt,
  errorCaptured: xt,
  serverPrefetch: xt,
  // assets
  components: Xn,
  directives: Xn,
  // watch
  watch: GP,
  // provide / inject
  provide: SE,
  inject: $P
};
function SE(i, e) {
  return e ? i ? function() {
    return pe(
      ae(i) ? i.call(this, this) : i,
      ae(e) ? e.call(this, this) : e
    );
  } : e : i;
}
function $P(i, e) {
  return Xn(gd(i), gd(e));
}
function gd(i) {
  if (W(i)) {
    const e = {};
    for (let t = 0; t < i.length; t++)
      e[i[t]] = i[t];
    return e;
  }
  return i;
}
function xt(i, e) {
  return i ? [...new Set([].concat(i, e))] : e;
}
function Xn(i, e) {
  return i ? pe(/* @__PURE__ */ Object.create(null), i, e) : e;
}
function RE(i, e) {
  return i ? W(i) && W(e) ? [.../* @__PURE__ */ new Set([...i, ...e])] : pe(
    /* @__PURE__ */ Object.create(null),
    Ta(i),
    Ta(e ?? {})
  ) : e;
}
function GP(i, e) {
  if (!i)
    return e;
  if (!e)
    return i;
  const t = pe(/* @__PURE__ */ Object.create(null), i);
  for (const r in e)
    t[r] = xt(i[r], e[r]);
  return t;
}
function SS() {
  return {
    app: null,
    config: {
      isNativeTag: Zn,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let VP = 0;
function HP(i, e) {
  return function(r, o = null) {
    ae(r) || (r = pe({}, r)), o != null && !Se(o) && ({}.NODE_ENV !== "production" && L("root props passed to app.mount() must be an object."), o = null);
    const s = SS();
    ({}).NODE_ENV !== "production" && Object.defineProperty(s.config, "unwrapInjectedRef", {
      get() {
        return !0;
      },
      set() {
        L(
          "app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API."
        );
      }
    });
    const n = /* @__PURE__ */ new Set();
    let a = !1;
    const l = s.app = {
      _uid: VP++,
      _component: r,
      _props: o,
      _container: null,
      _context: s,
      _instance: null,
      version: vd,
      get config() {
        return s.config;
      },
      set config(u) {
        ({}).NODE_ENV !== "production" && L(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(u, ...h) {
        return n.has(u) ? {}.NODE_ENV !== "production" && L("Plugin has already been applied to target app.") : u && ae(u.install) ? (n.add(u), u.install(l, ...h)) : ae(u) ? (n.add(u), u(l, ...h)) : {}.NODE_ENV !== "production" && L(
          'A plugin must either be a function or an object with an "install" function.'
        ), l;
      },
      mixin(u) {
        return s.mixins.includes(u) ? {}.NODE_ENV !== "production" && L(
          "Mixin has already been applied to target app" + (u.name ? `: ${u.name}` : "")
        ) : s.mixins.push(u), l;
      },
      component(u, h) {
        return {}.NODE_ENV !== "production" && Cd(u, s.config), h ? ({}.NODE_ENV !== "production" && s.components[u] && L(`Component "${u}" has already been registered in target app.`), s.components[u] = h, l) : s.components[u];
      },
      directive(u, h) {
        return {}.NODE_ENV !== "production" && oS(u), h ? ({}.NODE_ENV !== "production" && s.directives[u] && L(`Directive "${u}" has already been registered in target app.`), s.directives[u] = h, l) : s.directives[u];
      },
      mount(u, h, c) {
        if (a)
          ({}).NODE_ENV !== "production" && L(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          ({}).NODE_ENV !== "production" && u.__vue_app__ && L(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const d = xe(
            r,
            o
          );
          return d.appContext = s, {}.NODE_ENV !== "production" && (s.reload = () => {
            i(Ci(d), u, c);
          }), h && e ? e(d, u) : i(d, u, c), a = !0, l._container = u, u.__vue_app__ = l, {}.NODE_ENV !== "production" && (l._instance = d.component, Q_(l, vd)), _h(d.component) || d.component.proxy;
        }
      },
      unmount() {
        a ? (i(null, l._container), {}.NODE_ENV !== "production" && (l._instance = null, k_(l)), delete l._container.__vue_app__) : {}.NODE_ENV !== "production" && L("Cannot unmount an app that is not mounted.");
      },
      provide(u, h) {
        return {}.NODE_ENV !== "production" && u in s.provides && L(
          `App already provides property with key "${String(u)}". It will be overwritten with the new value.`
        ), s.provides[u] = h, l;
      },
      runWithContext(u) {
        Sa = l;
        try {
          return u();
        } finally {
          Sa = null;
        }
      }
    };
    return l;
  };
}
let Sa = null;
function RS(i, e) {
  if (!qe)
    ({}).NODE_ENV !== "production" && L("provide() can only be used inside setup().");
  else {
    let t = qe.provides;
    const r = qe.parent && qe.parent.provides;
    r === t && (t = qe.provides = Object.create(r)), t[i] = e;
  }
}
function ea(i, e, t = !1) {
  const r = qe || je;
  if (r || Sa) {
    const o = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : Sa._context.provides;
    if (o && i in o)
      return o[i];
    if (arguments.length > 1)
      return t && ae(e) ? e.call(r && r.proxy) : e;
    ({}).NODE_ENV !== "production" && L(`injection "${String(i)}" not found.`);
  } else
    ({}).NODE_ENV !== "production" && L("inject() can only be used inside setup() or functional components.");
}
function XP() {
  return !!(qe || je || Sa);
}
function YP(i, e, t, r = !1) {
  const o = {}, s = {};
  au(s, vh, 1), i.propsDefaults = /* @__PURE__ */ Object.create(null), AS(i, e, o, s);
  for (const n in i.propsOptions[0])
    n in o || (o[n] = void 0);
  ({}).NODE_ENV !== "production" && NS(e || {}, o, i), t ? i.props = r ? o : VT(o) : i.type.props ? i.props = o : i.props = s, i.attrs = s;
}
function BP(i) {
  for (; i; ) {
    if (i.type.__hmrId)
      return !0;
    i = i.parent;
  }
}
function FP(i, e, t, r) {
  const {
    props: o,
    attrs: s,
    vnode: { patchFlag: n }
  } = i, a = ce(o), [l] = i.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !({}.NODE_ENV !== "production" && BP(i)) && (r || n > 0) && !(n & 16)
  ) {
    if (n & 8) {
      const h = i.vnode.dynamicProps;
      for (let c = 0; c < h.length; c++) {
        let d = h[c];
        if (Th(i.emitsOptions, d))
          continue;
        const f = e[d];
        if (l)
          if (be(s, d))
            f !== s[d] && (s[d] = f, u = !0);
          else {
            const p = ot(d);
            o[p] = bd(
              l,
              a,
              p,
              f,
              i,
              !1
              /* isAbsent */
            );
          }
        else
          f !== s[d] && (s[d] = f, u = !0);
      }
    }
  } else {
    AS(i, e, o, s) && (u = !0);
    let h;
    for (const c in a)
      (!e || // for camelCase
      !be(e, c) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((h = kt(c)) === c || !be(e, h))) && (l ? t && // for camelCase
      (t[c] !== void 0 || // for kebab-case
      t[h] !== void 0) && (o[c] = bd(
        l,
        a,
        c,
        void 0,
        i,
        !0
        /* isAbsent */
      )) : delete o[c]);
    if (s !== a)
      for (const c in s)
        (!e || !be(e, c)) && (delete s[c], u = !0);
  }
  u && hr(i, "set", "$attrs"), {}.NODE_ENV !== "production" && NS(e || {}, o, i);
}
function AS(i, e, t, r) {
  const [o, s] = i.propsOptions;
  let n = !1, a;
  if (e)
    for (let l in e) {
      if (Ho(l))
        continue;
      const u = e[l];
      let h;
      o && be(o, h = ot(l)) ? !s || !s.includes(h) ? t[h] = u : (a || (a = {}))[h] = u : Th(i.emitsOptions, l) || (!(l in r) || u !== r[l]) && (r[l] = u, n = !0);
    }
  if (s) {
    const l = ce(t), u = a || Ae;
    for (let h = 0; h < s.length; h++) {
      const c = s[h];
      t[c] = bd(
        o,
        l,
        c,
        u[c],
        i,
        !be(u, c)
      );
    }
  }
  return n;
}
function bd(i, e, t, r, o, s) {
  const n = i[t];
  if (n != null) {
    const a = be(n, "default");
    if (a && r === void 0) {
      const l = n.default;
      if (n.type !== Function && !n.skipFactory && ae(l)) {
        const { propsDefaults: u } = o;
        t in u ? r = u[t] : (po(o), r = u[t] = l.call(
          null,
          e
        ), ro());
      } else
        r = l;
    }
    n[
      0
      /* shouldCast */
    ] && (s && !a ? r = !1 : n[
      1
      /* shouldCastTrue */
    ] && (r === "" || r === kt(t)) && (r = !0));
  }
  return r;
}
function CS(i, e, t = !1) {
  const r = e.propsCache, o = r.get(i);
  if (o)
    return o;
  const s = i.props, n = {}, a = [];
  let l = !1;
  if (!ae(i)) {
    const h = (c) => {
      l = !0;
      const [d, f] = CS(c, e, !0);
      pe(n, d), f && a.push(...f);
    };
    !t && e.mixins.length && e.mixins.forEach(h), i.extends && h(i.extends), i.mixins && i.mixins.forEach(h);
  }
  if (!s && !l)
    return Se(i) && r.set(i, Qs), Qs;
  if (W(s))
    for (let h = 0; h < s.length; h++) {
      ({}).NODE_ENV !== "production" && !he(s[h]) && L("props must be strings when using array syntax.", s[h]);
      const c = ot(s[h]);
      AE(c) && (n[c] = Ae);
    }
  else if (s) {
    ({}).NODE_ENV !== "production" && !Se(s) && L("invalid props options", s);
    for (const h in s) {
      const c = ot(h);
      if (AE(c)) {
        const d = s[h], f = n[c] = W(d) || ae(d) ? { type: d } : pe({}, d);
        if (f) {
          const p = NE(Boolean, f.type), O = NE(String, f.type);
          f[
            0
            /* shouldCast */
          ] = p > -1, f[
            1
            /* shouldCastTrue */
          ] = O < 0 || p < O, (p > -1 || be(f, "default")) && a.push(c);
        }
      }
    }
  }
  const u = [n, a];
  return Se(i) && r.set(i, u), u;
}
function AE(i) {
  return i[0] !== "$" ? !0 : ({}.NODE_ENV !== "production" && L(`Invalid prop name: "${i}" is a reserved property.`), !1);
}
function Td(i) {
  const e = i && i.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : i === null ? "null" : "";
}
function CE(i, e) {
  return Td(i) === Td(e);
}
function NE(i, e) {
  return W(e) ? e.findIndex((t) => CE(t, i)) : ae(e) && CE(e, i) ? 0 : -1;
}
function NS(i, e, t) {
  const r = ce(e), o = t.propsOptions[0];
  for (const s in o) {
    let n = o[s];
    n != null && WP(
      s,
      r[s],
      n,
      !be(i, s) && !be(i, kt(s))
    );
  }
}
function WP(i, e, t, r) {
  const { type: o, required: s, validator: n, skipCheck: a } = t;
  if (s && r) {
    L('Missing required prop: "' + i + '"');
    return;
  }
  if (!(e == null && !s)) {
    if (o != null && o !== !0 && !a) {
      let l = !1;
      const u = W(o) ? o : [o], h = [];
      for (let c = 0; c < u.length && !l; c++) {
        const { valid: d, expectedType: f } = ZP(e, u[c]);
        h.push(f || ""), l = d;
      }
      if (!l) {
        L(qP(i, e, h));
        return;
      }
    }
    n && !n(e) && L('Invalid prop: custom validator check failed for prop "' + i + '".');
  }
}
const zP = /* @__PURE__ */ wt(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function ZP(i, e) {
  let t;
  const r = Td(e);
  if (zP(r)) {
    const o = typeof i;
    t = o === r.toLowerCase(), !t && o === "object" && (t = i instanceof e);
  } else
    r === "Object" ? t = Se(i) : r === "Array" ? t = W(i) : r === "null" ? t = i === null : t = i instanceof e;
  return {
    valid: t,
    expectedType: r
  };
}
function qP(i, e, t) {
  let r = `Invalid prop: type check failed for prop "${i}". Expected ${t.map(ur).join(" | ")}`;
  const o = t[0], s = Zf(e), n = IE(e, o), a = IE(e, s);
  return t.length === 1 && vE(o) && !jP(o, s) && (r += ` with value ${n}`), r += `, got ${s} `, vE(s) && (r += `with value ${a}.`), r;
}
function IE(i, e) {
  return e === "String" ? `"${i}"` : e === "Number" ? `${Number(i)}` : `${i}`;
}
function vE(i) {
  return ["string", "number", "boolean"].some((t) => i.toLowerCase() === t);
}
function jP(...i) {
  return i.some((e) => e.toLowerCase() === "boolean");
}
const IS = (i) => i[0] === "_" || i === "$stable", bp = (i) => W(i) ? i.map(Ht) : [Ht(i)], KP = (i, e, t) => {
  if (e._n)
    return e;
  const r = ga((...o) => ({}.NODE_ENV !== "production" && qe && L(
    `Slot "${i}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), bp(e(...o))), t);
  return r._c = !1, r;
}, vS = (i, e, t) => {
  const r = i._ctx;
  for (const o in i) {
    if (IS(o))
      continue;
    const s = i[o];
    if (ae(s))
      e[o] = KP(o, s, r);
    else if (s != null) {
      ({}).NODE_ENV !== "production" && L(
        `Non-function value encountered for slot "${o}". Prefer function slots for better performance.`
      );
      const n = bp(s);
      e[o] = () => n;
    }
  }
}, _S = (i, e) => {
  ({}).NODE_ENV !== "production" && !En(i.vnode) && L(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const t = bp(e);
  i.slots.default = () => t;
}, JP = (i, e) => {
  if (i.vnode.shapeFlag & 32) {
    const t = e._;
    t ? (i.slots = ce(e), au(e, "_", t)) : vS(
      e,
      i.slots = {}
    );
  } else
    i.slots = {}, e && _S(i, e);
  au(i.slots, vh, 1);
}, e0 = (i, e, t) => {
  const { vnode: r, slots: o } = i;
  let s = !0, n = Ae;
  if (r.shapeFlag & 32) {
    const a = e._;
    a ? {}.NODE_ENV !== "production" && to ? (pe(o, e), hr(i, "set", "$slots")) : t && a === 1 ? s = !1 : (pe(o, e), !t && a === 1 && delete o._) : (s = !e.$stable, vS(e, o)), n = e;
  } else
    e && (_S(i, e), n = { default: 1 });
  if (s)
    for (const a in o)
      !IS(a) && !(a in n) && delete o[a];
};
function mu(i, e, t, r, o = !1) {
  if (W(i)) {
    i.forEach(
      (d, f) => mu(
        d,
        e && (W(e) ? e[f] : e),
        t,
        r,
        o
      )
    );
    return;
  }
  if (Bo(r) && !o)
    return;
  const s = r.shapeFlag & 4 ? _h(r.component) || r.component.proxy : r.el, n = o ? null : s, { i: a, r: l } = i;
  if ({}.NODE_ENV !== "production" && !a) {
    L(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const u = e && e.r, h = a.refs === Ae ? a.refs = {} : a.refs, c = a.setupState;
  if (u != null && u !== l && (he(u) ? (h[u] = null, be(c, u) && (c[u] = null)) : Fe(u) && (u.value = null)), ae(l))
    or(l, a, 12, [n, h]);
  else {
    const d = he(l), f = Fe(l);
    if (d || f) {
      const p = () => {
        if (i.f) {
          const O = d ? be(c, l) ? c[l] : h[l] : l.value;
          o ? W(O) && zf(O, s) : W(O) ? O.includes(s) || O.push(s) : d ? (h[l] = [s], be(c, l) && (c[l] = h[l])) : (l.value = [s], i.k && (h[i.k] = l.value));
        } else
          d ? (h[l] = n, be(c, l) && (c[l] = n)) : f ? (l.value = n, i.k && (h[i.k] = n)) : {}.NODE_ENV !== "production" && L("Invalid template ref type:", l, `(${typeof l})`);
      };
      n ? (p.id = -1, Ot(p, t)) : p();
    } else
      ({}).NODE_ENV !== "production" && L("Invalid template ref type:", l, `(${typeof l})`);
  }
}
let kr = !1;
const pl = (i) => /svg/.test(i.namespaceURI) && i.tagName !== "foreignObject", In = (i) => i.nodeType === 8;
function t0(i) {
  const {
    mt: e,
    p: t,
    o: {
      patchProp: r,
      createText: o,
      nextSibling: s,
      parentNode: n,
      remove: a,
      insert: l,
      createComment: u
    }
  } = i, h = (E, g) => {
    if (!g.hasChildNodes()) {
      ({}).NODE_ENV !== "production" && L(
        "Attempting to hydrate existing markup but container is empty. Performing full mount instead."
      ), t(null, E, g), fu(), g._vnode = E;
      return;
    }
    kr = !1, c(g.firstChild, E, null, null, null), fu(), g._vnode = E, kr && console.error("Hydration completed but contains mismatches.");
  }, c = (E, g, A, S, R, v = !1) => {
    const I = In(E) && E.data === "[", C = () => O(
      E,
      g,
      A,
      S,
      R,
      I
    ), { type: P, ref: w, shapeFlag: x, patchFlag: _ } = g;
    let X = E.nodeType;
    g.el = E, _ === -2 && (v = !1, g.dynamicChildren = null);
    let G = null;
    switch (P) {
      case fo:
        X !== 3 ? g.children === "" ? (l(g.el = o(""), n(E), E), G = E) : G = C() : (E.data !== g.children && (kr = !0, {}.NODE_ENV !== "production" && L(
          `Hydration text mismatch:
- Client: ${JSON.stringify(E.data)}
- Server: ${JSON.stringify(g.children)}`
        ), E.data = g.children), G = s(E));
        break;
      case Ke:
        X !== 8 || I ? G = C() : G = s(E);
        break;
      case io:
        if (I && (E = s(E), X = E.nodeType), X === 1 || X === 3) {
          G = E;
          const ee = !g.children.length;
          for (let re = 0; re < g.staticCount; re++)
            ee && (g.children += G.nodeType === 1 ? G.outerHTML : G.data), re === g.staticCount - 1 && (g.anchor = G), G = s(G);
          return I ? s(G) : G;
        } else
          C();
        break;
      case et:
        I ? G = p(
          E,
          g,
          A,
          S,
          R,
          v
        ) : G = C();
        break;
      default:
        if (x & 1)
          X !== 1 || g.type.toLowerCase() !== E.tagName.toLowerCase() ? G = C() : G = d(
            E,
            g,
            A,
            S,
            R,
            v
          );
        else if (x & 6) {
          g.slotScopeIds = R;
          const ee = n(E);
          if (e(
            g,
            ee,
            null,
            A,
            S,
            pl(ee),
            v
          ), G = I ? m(E) : s(E), G && In(G) && G.data === "teleport end" && (G = s(G)), Bo(g)) {
            let re;
            I ? (re = xe(et), re.anchor = G ? G.previousSibling : ee.lastChild) : re = E.nodeType === 3 ? Tp("") : xe("div"), re.el = E, g.component.subTree = re;
          }
        } else
          x & 64 ? X !== 8 ? G = C() : G = g.type.hydrate(
            E,
            g,
            A,
            S,
            R,
            v,
            i,
            f
          ) : x & 128 ? G = g.type.hydrate(
            E,
            g,
            A,
            S,
            pl(n(E)),
            R,
            v,
            i,
            c
          ) : {}.NODE_ENV !== "production" && L("Invalid HostVNode type:", P, `(${typeof P})`);
    }
    return w != null && mu(w, null, S, g), G;
  }, d = (E, g, A, S, R, v) => {
    v = v || !!g.dynamicChildren;
    const { type: I, props: C, patchFlag: P, shapeFlag: w, dirs: x } = g, _ = I === "input" && x || I === "option";
    if ({}.NODE_ENV !== "production" || _ || P !== -1) {
      if (x && Wi(g, null, A, "created"), C)
        if (_ || !v || P & 48)
          for (const G in C)
            (_ && G.endsWith("value") || Ar(G) && !Ho(G)) && r(
              E,
              G,
              null,
              C[G],
              !1,
              void 0,
              A
            );
        else
          C.onClick && r(
            E,
            "onClick",
            null,
            C.onClick,
            !1,
            void 0,
            A
          );
      let X;
      if ((X = C && C.onVnodeBeforeMount) && Vt(X, A, g), x && Wi(g, null, A, "beforeMount"), ((X = C && C.onVnodeMounted) || x) && tS(() => {
        X && Vt(X, A, g), x && Wi(g, null, A, "mounted");
      }, S), w & 16 && // skip if element has innerHTML / textContent
      !(C && (C.innerHTML || C.textContent))) {
        let G = f(
          E.firstChild,
          g,
          E,
          A,
          S,
          R,
          v
        ), ee = !1;
        for (; G; ) {
          kr = !0, {}.NODE_ENV !== "production" && !ee && (L(
            `Hydration children mismatch in <${g.type}>: server rendered element contains more child nodes than client vdom.`
          ), ee = !0);
          const re = G;
          G = G.nextSibling, a(re);
        }
      } else
        w & 8 && E.textContent !== g.children && (kr = !0, {}.NODE_ENV !== "production" && L(
          `Hydration text content mismatch in <${g.type}>:
- Client: ${E.textContent}
- Server: ${g.children}`
        ), E.textContent = g.children);
    }
    return E.nextSibling;
  }, f = (E, g, A, S, R, v, I) => {
    I = I || !!g.dynamicChildren;
    const C = g.children, P = C.length;
    let w = !1;
    for (let x = 0; x < P; x++) {
      const _ = I ? C[x] : C[x] = Ht(C[x]);
      if (E)
        E = c(
          E,
          _,
          S,
          R,
          v,
          I
        );
      else {
        if (_.type === fo && !_.children)
          continue;
        kr = !0, {}.NODE_ENV !== "production" && !w && (L(
          `Hydration children mismatch in <${A.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`
        ), w = !0), t(
          null,
          _,
          A,
          null,
          S,
          R,
          pl(A),
          v
        );
      }
    }
    return E;
  }, p = (E, g, A, S, R, v) => {
    const { slotScopeIds: I } = g;
    I && (R = R ? R.concat(I) : I);
    const C = n(E), P = f(
      s(E),
      g,
      C,
      A,
      S,
      R,
      v
    );
    return P && In(P) && P.data === "]" ? s(g.anchor = P) : (kr = !0, l(g.anchor = u("]"), C, P), P);
  }, O = (E, g, A, S, R, v) => {
    if (kr = !0, {}.NODE_ENV !== "production" && L(
      `Hydration node mismatch:
- Client vnode:`,
      g.type,
      `
- Server rendered DOM:`,
      E,
      E.nodeType === 3 ? "(text)" : In(E) && E.data === "[" ? "(start of fragment)" : ""
    ), g.el = null, v) {
      const P = m(E);
      for (; ; ) {
        const w = s(E);
        if (w && w !== P)
          a(w);
        else
          break;
      }
    }
    const I = s(E), C = n(E);
    return a(E), t(
      null,
      g,
      C,
      I,
      A,
      S,
      pl(C),
      R
    ), I;
  }, m = (E) => {
    let g = 0;
    for (; E; )
      if (E = s(E), E && In(E) && (E.data === "[" && g++, E.data === "]")) {
        if (g === 0)
          return s(E);
        g--;
      }
    return E;
  };
  return [h, c];
}
let vn, zr;
function pr(i, e) {
  i.appContext.config.performance && gu() && zr.mark(`vue-${e}-${i.uid}`), {}.NODE_ENV !== "production" && V_(i, e, gu() ? zr.now() : Date.now());
}
function Or(i, e) {
  if (i.appContext.config.performance && gu()) {
    const t = `vue-${e}-${i.uid}`, r = t + ":end";
    zr.mark(r), zr.measure(
      `<${Ph(i, i.type)}> ${e}`,
      t,
      r
    ), zr.clearMarks(t), zr.clearMarks(r);
  }
  ({}).NODE_ENV !== "production" && H_(i, e, gu() ? zr.now() : Date.now());
}
function gu() {
  return vn !== void 0 || (typeof window < "u" && window.performance ? (vn = !0, zr = window.performance) : vn = !1), vn;
}
function i0() {
  const i = [];
  if ({}.NODE_ENV !== "production" && i.length) {
    const e = i.length > 1;
    console.warn(
      `Feature flag${e ? "s" : ""} ${i.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const Ot = tS;
function PS(i) {
  return wS(i);
}
function LS(i) {
  return wS(i, t0);
}
function wS(i, e) {
  i0();
  const t = hu();
  t.__VUE__ = !0, {}.NODE_ENV !== "production" && lp(t.__VUE_DEVTOOLS_GLOBAL_HOOK__, t);
  const {
    insert: r,
    remove: o,
    patchProp: s,
    createElement: n,
    createText: a,
    createComment: l,
    setText: u,
    setElementText: h,
    parentNode: c,
    nextSibling: d,
    setScopeId: f = Ze,
    insertStaticContent: p
  } = i, O = (T, N, y, Q = null, U = null, Y = null, z = !1, H = null, B = {}.NODE_ENV !== "production" && to ? !1 : !!N.dynamicChildren) => {
    if (T === N)
      return;
    T && !wi(T, N) && (Q = al(T), Kt(T, U, Y, !0), T = null), N.patchFlag === -2 && (B = !1, N.dynamicChildren = null);
    const { type: $, ref: te, shapeFlag: j } = N;
    switch ($) {
      case fo:
        m(T, N, y, Q);
        break;
      case Ke:
        E(T, N, y, Q);
        break;
      case io:
        T == null ? g(N, y, Q, z) : {}.NODE_ENV !== "production" && A(T, N, y, z);
        break;
      case et:
        X(
          T,
          N,
          y,
          Q,
          U,
          Y,
          z,
          H,
          B
        );
        break;
      default:
        j & 1 ? v(
          T,
          N,
          y,
          Q,
          U,
          Y,
          z,
          H,
          B
        ) : j & 6 ? G(
          T,
          N,
          y,
          Q,
          U,
          Y,
          z,
          H,
          B
        ) : j & 64 || j & 128 ? $.process(
          T,
          N,
          y,
          Q,
          U,
          Y,
          z,
          H,
          B,
          bs
        ) : {}.NODE_ENV !== "production" && L("Invalid VNode type:", $, `(${typeof $})`);
    }
    te != null && U && mu(te, T && T.ref, Y, N || T, !N);
  }, m = (T, N, y, Q) => {
    if (T == null)
      r(
        N.el = a(N.children),
        y,
        Q
      );
    else {
      const U = N.el = T.el;
      N.children !== T.children && u(U, N.children);
    }
  }, E = (T, N, y, Q) => {
    T == null ? r(
      N.el = l(N.children || ""),
      y,
      Q
    ) : N.el = T.el;
  }, g = (T, N, y, Q) => {
    [T.el, T.anchor] = p(
      T.children,
      N,
      y,
      Q,
      T.el,
      T.anchor
    );
  }, A = (T, N, y, Q) => {
    if (N.children !== T.children) {
      const U = d(T.anchor);
      R(T), [N.el, N.anchor] = p(
        N.children,
        y,
        U,
        Q
      );
    } else
      N.el = T.el, N.anchor = T.anchor;
  }, S = ({ el: T, anchor: N }, y, Q) => {
    let U;
    for (; T && T !== N; )
      U = d(T), r(T, y, Q), T = U;
    r(N, y, Q);
  }, R = ({ el: T, anchor: N }) => {
    let y;
    for (; T && T !== N; )
      y = d(T), o(T), T = y;
    o(N);
  }, v = (T, N, y, Q, U, Y, z, H, B) => {
    z = z || N.type === "svg", T == null ? I(
      N,
      y,
      Q,
      U,
      Y,
      z,
      H,
      B
    ) : w(
      T,
      N,
      U,
      Y,
      z,
      H,
      B
    );
  }, I = (T, N, y, Q, U, Y, z, H) => {
    let B, $;
    const { type: te, props: j, shapeFlag: se, transition: de, dirs: Te } = T;
    if (B = T.el = n(
      T.type,
      Y,
      j && j.is,
      j
    ), se & 8 ? h(B, T.children) : se & 16 && P(
      T.children,
      B,
      null,
      Q,
      U,
      Y && te !== "foreignObject",
      z,
      H
    ), Te && Wi(T, null, Q, "created"), C(B, T, T.scopeId, z, Q), j) {
      for (const we in j)
        we !== "value" && !Ho(we) && s(
          B,
          we,
          null,
          j[we],
          Y,
          T.children,
          Q,
          U,
          fr
        );
      "value" in j && s(B, "value", null, j.value), ($ = j.onVnodeBeforeMount) && Vt($, Q, T);
    }
    ({}).NODE_ENV !== "production" && (Object.defineProperty(B, "__vnode", {
      value: T,
      enumerable: !1
    }), Object.defineProperty(B, "__vueParentComponent", {
      value: Q,
      enumerable: !1
    })), Te && Wi(T, null, Q, "beforeMount");
    const ye = (!U || U && !U.pendingBranch) && de && !de.persisted;
    ye && de.beforeEnter(B), r(B, N, y), (($ = j && j.onVnodeMounted) || ye || Te) && Ot(() => {
      $ && Vt($, Q, T), ye && de.enter(B), Te && Wi(T, null, Q, "mounted");
    }, U);
  }, C = (T, N, y, Q, U) => {
    if (y && f(T, y), Q)
      for (let Y = 0; Y < Q.length; Y++)
        f(T, Q[Y]);
    if (U) {
      let Y = U.subTree;
      if ({}.NODE_ENV !== "production" && Y.patchFlag > 0 && Y.patchFlag & 2048 && (Y = hp(Y.children) || Y), N === Y) {
        const z = U.vnode;
        C(
          T,
          z,
          z.scopeId,
          z.slotScopeIds,
          U.parent
        );
      }
    }
  }, P = (T, N, y, Q, U, Y, z, H, B = 0) => {
    for (let $ = B; $ < T.length; $++) {
      const te = T[$] = H ? Yr(T[$]) : Ht(T[$]);
      O(
        null,
        te,
        N,
        y,
        Q,
        U,
        Y,
        z,
        H
      );
    }
  }, w = (T, N, y, Q, U, Y, z) => {
    const H = N.el = T.el;
    let { patchFlag: B, dynamicChildren: $, dirs: te } = N;
    B |= T.patchFlag & 16;
    const j = T.props || Ae, se = N.props || Ae;
    let de;
    y && vo(y, !1), (de = se.onVnodeBeforeUpdate) && Vt(de, y, N, T), te && Wi(N, T, y, "beforeUpdate"), y && vo(y, !0), {}.NODE_ENV !== "production" && to && (B = 0, z = !1, $ = null);
    const Te = U && N.type !== "foreignObject";
    if ($ ? (x(
      T.dynamicChildren,
      $,
      H,
      y,
      Q,
      Te,
      Y
    ), {}.NODE_ENV !== "production" && ta(T, N)) : z || Ee(
      T,
      N,
      H,
      null,
      y,
      Q,
      Te,
      Y,
      !1
    ), B > 0) {
      if (B & 16)
        _(
          H,
          N,
          j,
          se,
          y,
          Q,
          U
        );
      else if (B & 2 && j.class !== se.class && s(H, "class", null, se.class, U), B & 4 && s(H, "style", j.style, se.style, U), B & 8) {
        const ye = N.dynamicProps;
        for (let we = 0; we < ye.length; we++) {
          const Je = ye[we], Ii = j[Je], Ts = se[Je];
          (Ts !== Ii || Je === "value") && s(
            H,
            Je,
            Ii,
            Ts,
            U,
            T.children,
            y,
            Q,
            fr
          );
        }
      }
      B & 1 && T.children !== N.children && h(H, N.children);
    } else
      !z && $ == null && _(
        H,
        N,
        j,
        se,
        y,
        Q,
        U
      );
    ((de = se.onVnodeUpdated) || te) && Ot(() => {
      de && Vt(de, y, N, T), te && Wi(N, T, y, "updated");
    }, Q);
  }, x = (T, N, y, Q, U, Y, z) => {
    for (let H = 0; H < N.length; H++) {
      const B = T[H], $ = N[H], te = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        B.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (B.type === et || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !wi(B, $) || // - In the case of a component, it could contain anything.
        B.shapeFlag & 70) ? c(B.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          y
        )
      );
      O(
        B,
        $,
        te,
        null,
        Q,
        U,
        Y,
        z,
        !0
      );
    }
  }, _ = (T, N, y, Q, U, Y, z) => {
    if (y !== Q) {
      if (y !== Ae)
        for (const H in y)
          !Ho(H) && !(H in Q) && s(
            T,
            H,
            y[H],
            null,
            z,
            N.children,
            U,
            Y,
            fr
          );
      for (const H in Q) {
        if (Ho(H))
          continue;
        const B = Q[H], $ = y[H];
        B !== $ && H !== "value" && s(
          T,
          H,
          $,
          B,
          z,
          N.children,
          U,
          Y,
          fr
        );
      }
      "value" in Q && s(T, "value", y.value, Q.value);
    }
  }, X = (T, N, y, Q, U, Y, z, H, B) => {
    const $ = N.el = T ? T.el : a(""), te = N.anchor = T ? T.anchor : a("");
    let { patchFlag: j, dynamicChildren: se, slotScopeIds: de } = N;
    ({}).NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (to || j & 2048) && (j = 0, B = !1, se = null), de && (H = H ? H.concat(de) : de), T == null ? (r($, y, Q), r(te, y, Q), P(
      N.children,
      y,
      te,
      U,
      Y,
      z,
      H,
      B
    )) : j > 0 && j & 64 && se && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    T.dynamicChildren ? (x(
      T.dynamicChildren,
      se,
      y,
      U,
      Y,
      z,
      H
    ), {}.NODE_ENV !== "production" ? ta(T, N) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (N.key != null || U && N === U.subTree) && ta(
        T,
        N,
        !0
        /* shallow */
      )
    )) : Ee(
      T,
      N,
      y,
      te,
      U,
      Y,
      z,
      H,
      B
    );
  }, G = (T, N, y, Q, U, Y, z, H, B) => {
    N.slotScopeIds = H, T == null ? N.shapeFlag & 512 ? U.ctx.activate(
      N,
      y,
      Q,
      z,
      B
    ) : ee(
      N,
      y,
      Q,
      U,
      Y,
      z,
      B
    ) : re(T, N, B);
  }, ee = (T, N, y, Q, U, Y, z) => {
    const H = T.component = GS(
      T,
      Q,
      U
    );
    if ({}.NODE_ENV !== "production" && H.type.__hmrId && D_(H), {}.NODE_ENV !== "production" && (qn(T), pr(H, "mount")), En(T) && (H.ctx.renderer = bs), {}.NODE_ENV !== "production" && pr(H, "init"), HS(H), {}.NODE_ENV !== "production" && Or(H, "init"), H.asyncDep) {
      if (U && U.registerDep(H, le), !T.el) {
        const B = H.subTree = xe(Ke);
        E(null, B, N, y);
      }
      return;
    }
    le(
      H,
      T,
      N,
      y,
      U,
      Y,
      z
    ), {}.NODE_ENV !== "production" && (jn(), Or(H, "mount"));
  }, re = (T, N, y) => {
    const Q = N.component = T.component;
    if (Z_(T, N, y))
      if (Q.asyncDep && !Q.asyncResolved) {
        ({}).NODE_ENV !== "production" && qn(N), oe(Q, N, y), {}.NODE_ENV !== "production" && jn();
        return;
      } else
        Q.next = N, w_(Q.update), Q.update();
    else
      N.el = T.el, Q.vnode = N;
  }, le = (T, N, y, Q, U, Y, z) => {
    const H = () => {
      if (T.isMounted) {
        let { next: te, bu: j, u: se, parent: de, vnode: Te } = T, ye = te, we;
        ({}).NODE_ENV !== "production" && qn(te || T.vnode), vo(T, !1), te ? (te.el = Te.el, oe(T, te, z)) : te = Te, j && Wr(j), (we = te.props && te.props.onVnodeBeforeUpdate) && Vt(we, de, te, Te), vo(T, !0), {}.NODE_ENV !== "production" && pr(T, "render");
        const Je = Hl(T);
        ({}).NODE_ENV !== "production" && Or(T, "render");
        const Ii = T.subTree;
        T.subTree = Je, {}.NODE_ENV !== "production" && pr(T, "patch"), O(
          Ii,
          Je,
          // parent may have changed if it's in a teleport
          c(Ii.el),
          // anchor may have changed if it's in a fragment
          al(Ii),
          T,
          U,
          Y
        ), {}.NODE_ENV !== "production" && Or(T, "patch"), te.el = Je.el, ye === null && cp(T, Je.el), se && Ot(se, U), (we = te.props && te.props.onVnodeUpdated) && Ot(
          () => Vt(we, de, te, Te),
          U
        ), {}.NODE_ENV !== "production" && ZT(T), {}.NODE_ENV !== "production" && jn();
      } else {
        let te;
        const { el: j, props: se } = N, { bm: de, m: Te, parent: ye } = T, we = Bo(N);
        if (vo(T, !1), de && Wr(de), !we && (te = se && se.onVnodeBeforeMount) && Vt(te, ye, N), vo(T, !0), j && sc) {
          const Je = () => {
            ({}).NODE_ENV !== "production" && pr(T, "render"), T.subTree = Hl(T), {}.NODE_ENV !== "production" && Or(T, "render"), {}.NODE_ENV !== "production" && pr(T, "hydrate"), sc(
              j,
              T.subTree,
              T,
              U,
              null
            ), {}.NODE_ENV !== "production" && Or(T, "hydrate");
          };
          we ? N.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !T.isUnmounted && Je()
          ) : Je();
        } else {
          ({}).NODE_ENV !== "production" && pr(T, "render");
          const Je = T.subTree = Hl(T);
          ({}).NODE_ENV !== "production" && Or(T, "render"), {}.NODE_ENV !== "production" && pr(T, "patch"), O(
            null,
            Je,
            y,
            Q,
            T,
            U,
            Y
          ), {}.NODE_ENV !== "production" && Or(T, "patch"), N.el = Je.el;
        }
        if (Te && Ot(Te, U), !we && (te = se && se.onVnodeMounted)) {
          const Je = N;
          Ot(
            () => Vt(te, ye, Je),
            U
          );
        }
        (N.shapeFlag & 256 || ye && Bo(ye.vnode) && ye.vnode.shapeFlag & 256) && T.a && Ot(T.a, U), T.isMounted = !0, {}.NODE_ENV !== "production" && pd(T), N = y = Q = null;
      }
    }, B = T.effect = new Ha(
      H,
      () => Xa($),
      T.scope
      // track it in component's effect scope
    ), $ = T.update = () => B.run();
    $.id = T.uid, vo(T, !0), {}.NODE_ENV !== "production" && (B.onTrack = T.rtc ? (te) => Wr(T.rtc, te) : void 0, B.onTrigger = T.rtg ? (te) => Wr(T.rtg, te) : void 0, $.ownerInstance = T), $();
  }, oe = (T, N, y) => {
    N.component = T;
    const Q = T.vnode.props;
    T.vnode = N, T.next = null, FP(T, N.props, Q, y), e0(T, N.children, y), ls(), dE(), us();
  }, Ee = (T, N, y, Q, U, Y, z, H, B = !1) => {
    const $ = T && T.children, te = T ? T.shapeFlag : 0, j = N.children, { patchFlag: se, shapeFlag: de } = N;
    if (se > 0) {
      if (se & 128) {
        qt(
          $,
          j,
          y,
          Q,
          U,
          Y,
          z,
          H,
          B
        );
        return;
      } else if (se & 256) {
        ve(
          $,
          j,
          y,
          Q,
          U,
          Y,
          z,
          H,
          B
        );
        return;
      }
    }
    de & 8 ? (te & 16 && fr($, U, Y), j !== $ && h(y, j)) : te & 16 ? de & 16 ? qt(
      $,
      j,
      y,
      Q,
      U,
      Y,
      z,
      H,
      B
    ) : fr($, U, Y, !0) : (te & 8 && h(y, ""), de & 16 && P(
      j,
      y,
      Q,
      U,
      Y,
      z,
      H,
      B
    ));
  }, ve = (T, N, y, Q, U, Y, z, H, B) => {
    T = T || Qs, N = N || Qs;
    const $ = T.length, te = N.length, j = Math.min($, te);
    let se;
    for (se = 0; se < j; se++) {
      const de = N[se] = B ? Yr(N[se]) : Ht(N[se]);
      O(
        T[se],
        de,
        y,
        null,
        U,
        Y,
        z,
        H,
        B
      );
    }
    $ > te ? fr(
      T,
      U,
      Y,
      !0,
      !1,
      j
    ) : P(
      N,
      y,
      Q,
      U,
      Y,
      z,
      H,
      B,
      j
    );
  }, qt = (T, N, y, Q, U, Y, z, H, B) => {
    let $ = 0;
    const te = N.length;
    let j = T.length - 1, se = te - 1;
    for (; $ <= j && $ <= se; ) {
      const de = T[$], Te = N[$] = B ? Yr(N[$]) : Ht(N[$]);
      if (wi(de, Te))
        O(
          de,
          Te,
          y,
          null,
          U,
          Y,
          z,
          H,
          B
        );
      else
        break;
      $++;
    }
    for (; $ <= j && $ <= se; ) {
      const de = T[j], Te = N[se] = B ? Yr(N[se]) : Ht(N[se]);
      if (wi(de, Te))
        O(
          de,
          Te,
          y,
          null,
          U,
          Y,
          z,
          H,
          B
        );
      else
        break;
      j--, se--;
    }
    if ($ > j) {
      if ($ <= se) {
        const de = se + 1, Te = de < te ? N[de].el : Q;
        for (; $ <= se; )
          O(
            null,
            N[$] = B ? Yr(N[$]) : Ht(N[$]),
            y,
            Te,
            U,
            Y,
            z,
            H,
            B
          ), $++;
      }
    } else if ($ > se)
      for (; $ <= j; )
        Kt(T[$], U, Y, !0), $++;
    else {
      const de = $, Te = $, ye = /* @__PURE__ */ new Map();
      for ($ = Te; $ <= se; $++) {
        const Dt = N[$] = B ? Yr(N[$]) : Ht(N[$]);
        Dt.key != null && ({}.NODE_ENV !== "production" && ye.has(Dt.key) && L(
          "Duplicate keys found during update:",
          JSON.stringify(Dt.key),
          "Make sure keys are unique."
        ), ye.set(Dt.key, $));
      }
      let we, Je = 0;
      const Ii = se - Te + 1;
      let Ts = !1, JO = 0;
      const Nn = new Array(Ii);
      for ($ = 0; $ < Ii; $++)
        Nn[$] = 0;
      for ($ = de; $ <= j; $++) {
        const Dt = T[$];
        if (Je >= Ii) {
          Kt(Dt, U, Y, !0);
          continue;
        }
        let Vi;
        if (Dt.key != null)
          Vi = ye.get(Dt.key);
        else
          for (we = Te; we <= se; we++)
            if (Nn[we - Te] === 0 && wi(Dt, N[we])) {
              Vi = we;
              break;
            }
        Vi === void 0 ? Kt(Dt, U, Y, !0) : (Nn[Vi - Te] = $ + 1, Vi >= JO ? JO = Vi : Ts = !0, O(
          Dt,
          N[Vi],
          y,
          null,
          U,
          Y,
          z,
          H,
          B
        ), Je++);
      }
      const eE = Ts ? r0(Nn) : Qs;
      for (we = eE.length - 1, $ = Ii - 1; $ >= 0; $--) {
        const Dt = Te + $, Vi = N[Dt], tE = Dt + 1 < te ? N[Dt + 1].el : Q;
        Nn[$] === 0 ? O(
          null,
          Vi,
          y,
          tE,
          U,
          Y,
          z,
          H,
          B
        ) : Ts && (we < 0 || $ !== eE[we] ? jt(Vi, y, tE, 2) : we--);
      }
    }
  }, jt = (T, N, y, Q, U = null) => {
    const { el: Y, type: z, transition: H, children: B, shapeFlag: $ } = T;
    if ($ & 6) {
      jt(T.component.subTree, N, y, Q);
      return;
    }
    if ($ & 128) {
      T.suspense.move(N, y, Q);
      return;
    }
    if ($ & 64) {
      z.move(T, N, y, bs);
      return;
    }
    if (z === et) {
      r(Y, N, y);
      for (let j = 0; j < B.length; j++)
        jt(B[j], N, y, Q);
      r(T.anchor, N, y);
      return;
    }
    if (z === io) {
      S(T, N, y);
      return;
    }
    if (Q !== 2 && $ & 1 && H)
      if (Q === 0)
        H.beforeEnter(Y), r(Y, N, y), Ot(() => H.enter(Y), U);
      else {
        const { leave: j, delayLeave: se, afterLeave: de } = H, Te = () => r(Y, N, y), ye = () => {
          j(Y, () => {
            Te(), de && de();
          });
        };
        se ? se(Y, Te, ye) : ye();
      }
    else
      r(Y, N, y);
  }, Kt = (T, N, y, Q = !1, U = !1) => {
    const {
      type: Y,
      props: z,
      ref: H,
      children: B,
      dynamicChildren: $,
      shapeFlag: te,
      patchFlag: j,
      dirs: se
    } = T;
    if (H != null && mu(H, null, y, T, !0), te & 256) {
      N.ctx.deactivate(T);
      return;
    }
    const de = te & 1 && se, Te = !Bo(T);
    let ye;
    if (Te && (ye = z && z.onVnodeBeforeUnmount) && Vt(ye, N, T), te & 6)
      hv(T.component, y, Q);
    else {
      if (te & 128) {
        T.suspense.unmount(y, Q);
        return;
      }
      de && Wi(T, null, N, "beforeUnmount"), te & 64 ? T.type.remove(
        T,
        N,
        y,
        U,
        bs,
        Q
      ) : $ && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (Y !== et || j > 0 && j & 64) ? fr(
        $,
        N,
        y,
        !1,
        !0
      ) : (Y === et && j & 384 || !U && te & 16) && fr(B, N, y), Q && gs(T);
    }
    (Te && (ye = z && z.onVnodeUnmounted) || de) && Ot(() => {
      ye && Vt(ye, N, T), de && Wi(T, null, N, "unmounted");
    }, y);
  }, gs = (T) => {
    const { type: N, el: y, anchor: Q, transition: U } = T;
    if (N === et) {
      ({}).NODE_ENV !== "production" && T.patchFlag > 0 && T.patchFlag & 2048 && U && !U.persisted ? T.children.forEach((z) => {
        z.type === Ke ? o(z.el) : gs(z);
      }) : uv(y, Q);
      return;
    }
    if (N === io) {
      R(T);
      return;
    }
    const Y = () => {
      o(y), U && !U.persisted && U.afterLeave && U.afterLeave();
    };
    if (T.shapeFlag & 1 && U && !U.persisted) {
      const { leave: z, delayLeave: H } = U, B = () => z(y, Y);
      H ? H(T.el, Y, B) : B();
    } else
      Y();
  }, uv = (T, N) => {
    let y;
    for (; T !== N; )
      y = d(T), o(T), T = y;
    o(N);
  }, hv = (T, N, y) => {
    ({}).NODE_ENV !== "production" && T.type.__hmrId && x_(T);
    const { bum: Q, scope: U, update: Y, subTree: z, um: H } = T;
    Q && Wr(Q), U.stop(), Y && (Y.active = !1, Kt(z, T, N, y)), H && Ot(H, N), Ot(() => {
      T.isUnmounted = !0;
    }, N), N && N.pendingBranch && !N.isUnmounted && T.asyncDep && !T.asyncResolved && T.suspenseId === N.pendingId && (N.deps--, N.deps === 0 && N.resolve()), {}.NODE_ENV !== "production" && G_(T);
  }, fr = (T, N, y, Q = !1, U = !1, Y = 0) => {
    for (let z = Y; z < T.length; z++)
      Kt(T[z], N, y, Q, U);
  }, al = (T) => T.shapeFlag & 6 ? al(T.component.subTree) : T.shapeFlag & 128 ? T.suspense.next() : d(T.anchor || T.el), KO = (T, N, y) => {
    T == null ? N._vnode && Kt(N._vnode, null, null, !0) : O(N._vnode || null, T, N, null, null, null, y), dE(), fu(), N._vnode = T;
  }, bs = {
    p: O,
    um: Kt,
    m: jt,
    r: gs,
    mt: ee,
    mc: P,
    pc: Ee,
    pbc: x,
    n: al,
    o: i
  };
  let oc, sc;
  return e && ([oc, sc] = e(
    bs
  )), {
    render: KO,
    hydrate: oc,
    createApp: HP(KO, oc)
  };
}
function vo({ effect: i, update: e }, t) {
  i.allowRecurse = e.allowRecurse = t;
}
function ta(i, e, t = !1) {
  const r = i.children, o = e.children;
  if (W(r) && W(o))
    for (let s = 0; s < r.length; s++) {
      const n = r[s];
      let a = o[s];
      a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = o[s] = Yr(o[s]), a.el = n.el), t || ta(n, a)), a.type === fo && (a.el = n.el), {}.NODE_ENV !== "production" && a.type === Ke && !a.el && (a.el = n.el);
    }
}
function r0(i) {
  const e = i.slice(), t = [0];
  let r, o, s, n, a;
  const l = i.length;
  for (r = 0; r < l; r++) {
    const u = i[r];
    if (u !== 0) {
      if (o = t[t.length - 1], i[o] < u) {
        e[r] = o, t.push(r);
        continue;
      }
      for (s = 0, n = t.length - 1; s < n; )
        a = s + n >> 1, i[t[a]] < u ? s = a + 1 : n = a;
      u < i[t[s]] && (s > 0 && (e[r] = t[s - 1]), t[s] = r);
    }
  }
  for (s = t.length, n = t[s - 1]; s-- > 0; )
    t[s] = n, n = e[n];
  return t;
}
const o0 = (i) => i.__isTeleport, Gs = (i) => i && (i.disabled || i.disabled === ""), _E = (i) => typeof SVGElement < "u" && i instanceof SVGElement, Sd = (i, e) => {
  const t = i && i.to;
  if (he(t))
    if (e) {
      const r = e(t);
      return r || {}.NODE_ENV !== "production" && L(
        `Failed to locate Teleport target with selector "${t}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), r;
    } else
      return {}.NODE_ENV !== "production" && L(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return {}.NODE_ENV !== "production" && !t && !Gs(i) && L(`Invalid Teleport target: ${t}`), t;
}, s0 = {
  __isTeleport: !0,
  process(i, e, t, r, o, s, n, a, l, u) {
    const {
      mc: h,
      pc: c,
      pbc: d,
      o: { insert: f, querySelector: p, createText: O, createComment: m }
    } = u, E = Gs(e.props);
    let { shapeFlag: g, children: A, dynamicChildren: S } = e;
    if ({}.NODE_ENV !== "production" && to && (l = !1, S = null), i == null) {
      const R = e.el = {}.NODE_ENV !== "production" ? m("teleport start") : O(""), v = e.anchor = {}.NODE_ENV !== "production" ? m("teleport end") : O("");
      f(R, t, r), f(v, t, r);
      const I = e.target = Sd(e.props, p), C = e.targetAnchor = O("");
      I ? (f(C, I), n = n || _E(I)) : {}.NODE_ENV !== "production" && !E && L("Invalid Teleport target on mount:", I, `(${typeof I})`);
      const P = (w, x) => {
        g & 16 && h(
          A,
          w,
          x,
          o,
          s,
          n,
          a,
          l
        );
      };
      E ? P(t, v) : I && P(I, C);
    } else {
      e.el = i.el;
      const R = e.anchor = i.anchor, v = e.target = i.target, I = e.targetAnchor = i.targetAnchor, C = Gs(i.props), P = C ? t : v, w = C ? R : I;
      if (n = n || _E(v), S ? (d(
        i.dynamicChildren,
        S,
        P,
        o,
        s,
        n,
        a
      ), ta(i, e, !0)) : l || c(
        i,
        e,
        P,
        w,
        o,
        s,
        n,
        a,
        !1
      ), E)
        C || Ol(
          e,
          t,
          R,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (i.props && i.props.to)) {
        const x = e.target = Sd(
          e.props,
          p
        );
        x ? Ol(
          e,
          x,
          null,
          u,
          0
        ) : {}.NODE_ENV !== "production" && L(
          "Invalid Teleport target on update:",
          v,
          `(${typeof v})`
        );
      } else
        C && Ol(
          e,
          v,
          I,
          u,
          1
        );
    }
    yS(e);
  },
  remove(i, e, t, r, { um: o, o: { remove: s } }, n) {
    const { shapeFlag: a, children: l, anchor: u, targetAnchor: h, target: c, props: d } = i;
    if (c && s(h), (n || !Gs(d)) && (s(u), a & 16))
      for (let f = 0; f < l.length; f++) {
        const p = l[f];
        o(
          p,
          e,
          t,
          !0,
          !!p.dynamicChildren
        );
      }
  },
  move: Ol,
  hydrate: n0
};
function Ol(i, e, t, { o: { insert: r }, m: o }, s = 2) {
  s === 0 && r(i.targetAnchor, e, t);
  const { el: n, anchor: a, shapeFlag: l, children: u, props: h } = i, c = s === 2;
  if (c && r(n, e, t), (!c || Gs(h)) && l & 16)
    for (let d = 0; d < u.length; d++)
      o(
        u[d],
        e,
        t,
        2
      );
  c && r(a, e, t);
}
function n0(i, e, t, r, o, s, {
  o: { nextSibling: n, parentNode: a, querySelector: l }
}, u) {
  const h = e.target = Sd(
    e.props,
    l
  );
  if (h) {
    const c = h._lpa || h.firstChild;
    if (e.shapeFlag & 16)
      if (Gs(e.props))
        e.anchor = u(
          n(i),
          e,
          a(i),
          t,
          r,
          o,
          s
        ), e.targetAnchor = c;
      else {
        e.anchor = n(i);
        let d = c;
        for (; d; )
          if (d = n(d), d && d.nodeType === 8 && d.data === "teleport anchor") {
            e.targetAnchor = d, h._lpa = e.targetAnchor && n(e.targetAnchor);
            break;
          }
        u(
          c,
          e,
          h,
          t,
          r,
          o,
          s
        );
      }
    yS(e);
  }
  return e.anchor && n(e.anchor);
}
const a0 = s0;
function yS(i) {
  const e = i.ctx;
  if (e && e.ut) {
    let t = i.children[0].el;
    for (; t !== i.targetAnchor; )
      t.nodeType === 1 && t.setAttribute("data-v-owner", e.uid), t = t.nextSibling;
    e.ut();
  }
}
const et = Symbol.for("v-fgt"), fo = Symbol.for("v-txt"), Ke = Symbol.for("v-cmt"), io = Symbol.for("v-stc"), ia = [];
let Yt = null;
function Pe(i = !1) {
  ia.push(Yt = i ? null : []);
}
function DS() {
  ia.pop(), Yt = ia[ia.length - 1] || null;
}
let jo = 1;
function Rd(i) {
  jo += i;
}
function xS(i) {
  return i.dynamicChildren = jo > 0 ? Yt || Qs : null, DS(), jo > 0 && Yt && Yt.push(i), i;
}
function ht(i, e, t, r, o, s) {
  return xS(
    ke(
      i,
      e,
      t,
      r,
      o,
      s,
      !0
      /* isBlock */
    )
  );
}
function Li(i, e, t, r, o) {
  return xS(
    xe(
      i,
      e,
      t,
      r,
      o,
      !0
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function Nr(i) {
  return i ? i.__v_isVNode === !0 : !1;
}
function wi(i, e) {
  return {}.NODE_ENV !== "production" && e.shapeFlag & 6 && Is.has(e.type) ? (i.shapeFlag &= -257, e.shapeFlag &= -513, !1) : i.type === e.type && i.key === e.key;
}
let Ad;
function l0(i) {
  Ad = i;
}
const u0 = (...i) => US(
  ...Ad ? Ad(i, je) : i
), vh = "__vInternal", MS = ({ key: i }) => i ?? null, Xl = ({
  ref: i,
  ref_key: e,
  ref_for: t
}) => (typeof i == "number" && (i = "" + i), i != null ? he(i) || Fe(i) || ae(i) ? { i: je, r: i, k: e, f: !!t } : i : null);
function ke(i, e = null, t = null, r = 0, o = null, s = i === et ? 0 : 1, n = !1, a = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: i,
    props: e,
    key: e && MS(e),
    ref: e && Xl(e),
    scopeId: Sh,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: r,
    dynamicProps: o,
    dynamicChildren: null,
    appContext: null,
    ctx: je
  };
  return a ? (Sp(l, t), s & 128 && i.normalize(l)) : t && (l.shapeFlag |= he(t) ? 8 : 16), {}.NODE_ENV !== "production" && l.key !== l.key && L("VNode created with invalid key (NaN). VNode type:", l.type), jo > 0 && // avoid a block node from tracking itself
  !n && // has current parent block
  Yt && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || s & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && Yt.push(l), l;
}
const xe = {}.NODE_ENV !== "production" ? u0 : US;
function US(i, e = null, t = null, r = 0, o = null, s = !1) {
  if ((!i || i === mS) && ({}.NODE_ENV !== "production" && !i && L(`Invalid vnode type when creating vnode: ${i}.`), i = Ke), Nr(i)) {
    const a = Ci(
      i,
      e,
      !0
      /* mergeRef: true */
    );
    return t && Sp(a, t), jo > 0 && !s && Yt && (a.shapeFlag & 6 ? Yt[Yt.indexOf(i)] = a : Yt.push(a)), a.patchFlag |= -2, a;
  }
  if (FS(i) && (i = i.__vccOpts), e) {
    e = QS(e);
    let { class: a, style: l } = e;
    a && !he(a) && (e.class = On(a)), Se(l) && (fa(l) && !W(l) && (l = pe({}, l)), e.style = ki(l));
  }
  const n = he(i) ? 1 : eS(i) ? 128 : o0(i) ? 64 : Se(i) ? 4 : ae(i) ? 2 : 0;
  return {}.NODE_ENV !== "production" && n & 4 && fa(i) && (i = ce(i), L(
    "Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    i
  )), ke(
    i,
    e,
    t,
    r,
    o,
    n,
    s,
    !0
  );
}
function QS(i) {
  return i ? fa(i) || vh in i ? pe({}, i) : i : null;
}
function Ci(i, e, t = !1) {
  const { props: r, ref: o, patchFlag: s, children: n } = i, a = e ? $S(r || {}, e) : r;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: i.type,
    props: a,
    key: a && MS(a),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && o ? W(o) ? o.concat(Xl(e)) : [o, Xl(e)] : Xl(e)
    ) : o,
    scopeId: i.scopeId,
    slotScopeIds: i.slotScopeIds,
    children: {}.NODE_ENV !== "production" && s === -1 && W(n) ? n.map(kS) : n,
    target: i.target,
    targetAnchor: i.targetAnchor,
    staticCount: i.staticCount,
    shapeFlag: i.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && i.type !== et ? s === -1 ? 16 : s | 16 : s,
    dynamicProps: i.dynamicProps,
    dynamicChildren: i.dynamicChildren,
    appContext: i.appContext,
    dirs: i.dirs,
    transition: i.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: i.component,
    suspense: i.suspense,
    ssContent: i.ssContent && Ci(i.ssContent),
    ssFallback: i.ssFallback && Ci(i.ssFallback),
    el: i.el,
    anchor: i.anchor,
    ctx: i.ctx,
    ce: i.ce
  };
}
function kS(i) {
  const e = Ci(i);
  return W(i.children) && (e.children = i.children.map(kS)), e;
}
function Tp(i = " ", e = 0) {
  return xe(fo, null, i, e);
}
function h0(i, e) {
  const t = xe(io, null, i);
  return t.staticCount = e, t;
}
function gr(i = "", e = !1) {
  return e ? (Pe(), Li(Ke, null, i)) : xe(Ke, null, i);
}
function Ht(i) {
  return i == null || typeof i == "boolean" ? xe(Ke) : W(i) ? xe(
    et,
    null,
    // #3666, avoid reference pollution when reusing vnode
    i.slice()
  ) : typeof i == "object" ? Yr(i) : xe(fo, null, String(i));
}
function Yr(i) {
  return i.el === null && i.patchFlag !== -1 || i.memo ? i : Ci(i);
}
function Sp(i, e) {
  let t = 0;
  const { shapeFlag: r } = i;
  if (e == null)
    e = null;
  else if (W(e))
    t = 16;
  else if (typeof e == "object")
    if (r & 65) {
      const o = e.default;
      o && (o._c && (o._d = !1), Sp(i, o()), o._c && (o._d = !0));
      return;
    } else {
      t = 32;
      const o = e._;
      !o && !(vh in e) ? e._ctx = je : o === 3 && je && (je.slots._ === 1 ? e._ = 1 : (e._ = 2, i.patchFlag |= 1024));
    }
  else
    ae(e) ? (e = { default: e, _ctx: je }, t = 32) : (e = String(e), r & 64 ? (t = 16, e = [Tp(e)]) : t = 8);
  i.children = e, i.shapeFlag |= t;
}
function $S(...i) {
  const e = {};
  for (let t = 0; t < i.length; t++) {
    const r = i[t];
    for (const o in r)
      if (o === "class")
        e.class !== r.class && (e.class = On([e.class, r.class]));
      else if (o === "style")
        e.style = ki([e.style, r.style]);
      else if (Ar(o)) {
        const s = e[o], n = r[o];
        n && s !== n && !(W(s) && s.includes(n)) && (e[o] = s ? [].concat(s, n) : n);
      } else
        o !== "" && (e[o] = r[o]);
  }
  return e;
}
function Vt(i, e, t, r = null) {
  li(i, e, 7, [
    t,
    r
  ]);
}
const c0 = SS();
let d0 = 0;
function GS(i, e, t) {
  const r = i.type, o = (e ? e.appContext : i.appContext) || c0, s = {
    uid: d0++,
    vnode: i,
    type: r,
    parent: e,
    appContext: o,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new jf(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(o.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: CS(r, o),
    emitsOptions: jT(r, o),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Ae,
    // inheritAttrs
    inheritAttrs: r.inheritAttrs,
    // state
    ctx: Ae,
    data: Ae,
    props: Ae,
    attrs: Ae,
    slots: Ae,
    refs: Ae,
    setupState: Ae,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense: t,
    suspenseId: t ? t.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return {}.NODE_ENV !== "production" ? s.ctx = gP(s) : s.ctx = { _: s }, s.root = e ? e.root : s, s.emit = Y_.bind(null, s), i.ce && i.ce(s), s;
}
let qe = null;
const Dr = () => qe || je;
let Rp, Ss, PE = "__VUE_INSTANCE_SETTERS__";
(Ss = hu()[PE]) || (Ss = hu()[PE] = []), Ss.push((i) => qe = i), Rp = (i) => {
  Ss.length > 1 ? Ss.forEach((e) => e(i)) : Ss[0](i);
};
const po = (i) => {
  Rp(i), i.scope.on();
}, ro = () => {
  qe && qe.scope.off(), Rp(null);
}, f0 = /* @__PURE__ */ wt("slot,component");
function Cd(i, e) {
  const t = e.isNativeTag || Zn;
  (f0(i) || t(i)) && L(
    "Do not use built-in or reserved HTML elements as component id: " + i
  );
}
function VS(i) {
  return i.vnode.shapeFlag & 4;
}
let js = !1;
function HS(i, e = !1) {
  js = e;
  const { props: t, children: r } = i.vnode, o = VS(i);
  YP(i, t, o, e), JP(i, r);
  const s = o ? p0(i, e) : void 0;
  return js = !1, s;
}
function p0(i, e) {
  var t;
  const r = i.type;
  if ({}.NODE_ENV !== "production") {
    if (r.name && Cd(r.name, i.appContext.config), r.components) {
      const s = Object.keys(r.components);
      for (let n = 0; n < s.length; n++)
        Cd(s[n], i.appContext.config);
    }
    if (r.directives) {
      const s = Object.keys(r.directives);
      for (let n = 0; n < s.length; n++)
        oS(s[n]);
    }
    r.compilerOptions && Ap() && L(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  i.accessCache = /* @__PURE__ */ Object.create(null), i.proxy = ep(new Proxy(i.ctx, Jn)), {}.NODE_ENV !== "production" && bP(i);
  const { setup: o } = r;
  if (o) {
    const s = i.setupContext = o.length > 1 ? BS(i) : null;
    po(i), ls();
    const n = or(
      o,
      i,
      0,
      [{}.NODE_ENV !== "production" ? ws(i.props) : i.props, s]
    );
    if (us(), ro(), hh(n)) {
      if (n.then(ro, ro), e)
        return n.then((a) => {
          Nd(i, a, e);
        }).catch((a) => {
          hs(a, i, 0);
        });
      if (i.asyncDep = n, {}.NODE_ENV !== "production" && !i.suspense) {
        const a = (t = r.name) != null ? t : "Anonymous";
        L(
          `Component <${a}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      Nd(i, n, e);
  } else
    YS(i, e);
}
function Nd(i, e, t) {
  ae(e) ? i.type.__ssrInlineRender ? i.ssrRender = e : i.render = e : Se(e) ? ({}.NODE_ENV !== "production" && Nr(e) && L(
    "setup() should not return VNodes directly - return a render function instead."
  ), {}.NODE_ENV !== "production" && (i.devtoolsRawSetupState = e), i.setupState = rp(e), {}.NODE_ENV !== "production" && TP(i)) : {}.NODE_ENV !== "production" && e !== void 0 && L(
    `setup() should return an object. Received: ${e === null ? "null" : typeof e}`
  ), YS(i, t);
}
let ra, Id;
function XS(i) {
  ra = i, Id = (e) => {
    e.render._rc && (e.withProxy = new Proxy(e.ctx, mP));
  };
}
const Ap = () => !ra;
function YS(i, e, t) {
  const r = i.type;
  if (!i.render) {
    if (!e && ra && !r.render) {
      const o = r.template || gp(i).template;
      if (o) {
        ({}).NODE_ENV !== "production" && pr(i, "compile");
        const { isCustomElement: s, compilerOptions: n } = i.appContext.config, { delimiters: a, compilerOptions: l } = r, u = pe(
          pe(
            {
              isCustomElement: s,
              delimiters: a
            },
            n
          ),
          l
        );
        r.render = ra(o, u), {}.NODE_ENV !== "production" && Or(i, "compile");
      }
    }
    i.render = r.render || Ze, Id && Id(i);
  }
  po(i), ls(), UP(i), us(), ro(), {}.NODE_ENV !== "production" && !r.render && i.render === Ze && !e && (!ra && r.template ? L(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
    /* should not happen */
  ) : L("Component is missing template or render function."));
}
function LE(i) {
  return i.attrsProxy || (i.attrsProxy = new Proxy(
    i.attrs,
    {}.NODE_ENV !== "production" ? {
      get(e, t) {
        return pu(), St(i, "get", "$attrs"), e[t];
      },
      set() {
        return L("setupContext.attrs is readonly."), !1;
      },
      deleteProperty() {
        return L("setupContext.attrs is readonly."), !1;
      }
    } : {
      get(e, t) {
        return St(i, "get", "$attrs"), e[t];
      }
    }
  ));
}
function O0(i) {
  return i.slotsProxy || (i.slotsProxy = new Proxy(i.slots, {
    get(e, t) {
      return St(i, "get", "$slots"), e[t];
    }
  }));
}
function BS(i) {
  const e = (t) => {
    if ({}.NODE_ENV !== "production" && (i.exposed && L("expose() should be called only once per setup()."), t != null)) {
      let r = typeof t;
      r === "object" && (W(t) ? r = "array" : Fe(t) && (r = "ref")), r !== "object" && L(
        `expose() should be passed a plain object, received ${r}.`
      );
    }
    i.exposed = t || {};
  };
  return {}.NODE_ENV !== "production" ? Object.freeze({
    get attrs() {
      return LE(i);
    },
    get slots() {
      return O0(i);
    },
    get emit() {
      return (t, ...r) => i.emit(t, ...r);
    },
    expose: e
  }) : {
    get attrs() {
      return LE(i);
    },
    slots: i.slots,
    emit: i.emit,
    expose: e
  };
}
function _h(i) {
  if (i.exposed)
    return i.exposeProxy || (i.exposeProxy = new Proxy(rp(ep(i.exposed)), {
      get(e, t) {
        if (t in e)
          return e[t];
        if (t in Fo)
          return Fo[t](i);
      },
      has(e, t) {
        return t in e || t in Fo;
      }
    }));
}
const E0 = /(?:^|[-_])(\w)/g, m0 = (i) => i.replace(E0, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function Ra(i, e = !0) {
  return ae(i) ? i.displayName || i.name : i.name || e && i.__name;
}
function Ph(i, e, t = !1) {
  let r = Ra(e);
  if (!r && e.__file) {
    const o = e.__file.match(/([^/\\]+)\.\w+$/);
    o && (r = o[1]);
  }
  if (!r && i && i.parent) {
    const o = (s) => {
      for (const n in s)
        if (s[n] === e)
          return n;
    };
    r = o(
      i.components || i.parent.type.components
    ) || o(i.appContext.components);
  }
  return r ? m0(r) : t ? "App" : "Anonymous";
}
function FS(i) {
  return ae(i) && "__vccOpts" in i;
}
const WS = (i, e) => A_(i, e, js);
function No(i, e, t) {
  const r = arguments.length;
  return r === 2 ? Se(e) && !W(e) ? Nr(e) ? xe(i, null, [e]) : xe(i, e) : xe(i, null, e) : (r > 3 ? t = Array.prototype.slice.call(arguments, 2) : r === 3 && Nr(t) && (t = [t]), xe(i, e, t));
}
const zS = Symbol.for("v-scx"), ZS = () => {
  {
    const i = ea(zS);
    return i || {}.NODE_ENV !== "production" && L(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), i;
  }
};
function dc(i) {
  return !!(i && i.__v_isShallow);
}
function qS() {
  if ({}.NODE_ENV === "production" || typeof window > "u")
    return;
  const i = { style: "color:#3ba776" }, e = { style: "color:#0b1bc9" }, t = { style: "color:#b62e24" }, r = { style: "color:#9d288c" }, o = {
    header(c) {
      return Se(c) ? c.__isVue ? ["div", i, "VueInstance"] : Fe(c) ? [
        "div",
        {},
        ["span", i, h(c)],
        "<",
        a(c.value),
        ">"
      ] : eo(c) ? [
        "div",
        {},
        ["span", i, dc(c) ? "ShallowReactive" : "Reactive"],
        "<",
        a(c),
        `>${Cr(c) ? " (readonly)" : ""}`
      ] : Cr(c) ? [
        "div",
        {},
        ["span", i, dc(c) ? "ShallowReadonly" : "Readonly"],
        "<",
        a(c),
        ">"
      ] : null : null;
    },
    hasBody(c) {
      return c && c.__isVue;
    },
    body(c) {
      if (c && c.__isVue)
        return [
          "div",
          {},
          ...s(c.$)
        ];
    }
  };
  function s(c) {
    const d = [];
    c.type.props && c.props && d.push(n("props", ce(c.props))), c.setupState !== Ae && d.push(n("setup", c.setupState)), c.data !== Ae && d.push(n("data", ce(c.data)));
    const f = l(c, "computed");
    f && d.push(n("computed", f));
    const p = l(c, "inject");
    return p && d.push(n("injected", p)), d.push([
      "div",
      {},
      [
        "span",
        {
          style: r.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: c }]
    ]), d;
  }
  function n(c, d) {
    return d = pe({}, d), Object.keys(d).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        c
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(d).map((f) => [
          "div",
          {},
          ["span", r, f + ": "],
          a(d[f], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function a(c, d = !0) {
    return typeof c == "number" ? ["span", e, c] : typeof c == "string" ? ["span", t, JSON.stringify(c)] : typeof c == "boolean" ? ["span", r, c] : Se(c) ? ["object", { object: d ? ce(c) : c }] : ["span", t, String(c)];
  }
  function l(c, d) {
    const f = c.type;
    if (ae(f))
      return;
    const p = {};
    for (const O in c.ctx)
      u(f, O, d) && (p[O] = c.ctx[O]);
    return p;
  }
  function u(c, d, f) {
    const p = c[f];
    if (W(p) && p.includes(d) || Se(p) && d in p || c.extends && u(c.extends, d, f) || c.mixins && c.mixins.some((O) => u(O, d, f)))
      return !0;
  }
  function h(c) {
    return dc(c) ? "ShallowRef" : c.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(o) : window.devtoolsFormatters = [o];
}
function g0(i, e, t, r) {
  const o = t[r];
  if (o && jS(o, i))
    return o;
  const s = e();
  return s.memo = i.slice(), t[r] = s;
}
function jS(i, e) {
  const t = i.memo;
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (zs(t[r], e[r]))
      return !1;
  return jo > 0 && Yt && Yt.push(i), !0;
}
const vd = "3.3.4", b0 = {
  createComponentInstance: GS,
  setupComponent: HS,
  renderComponentRoot: Hl,
  setCurrentRenderingInstance: ma,
  isVNode: Nr,
  normalizeVNode: Ht
}, T0 = b0, S0 = null, R0 = null, A0 = "http://www.w3.org/2000/svg", yo = typeof document < "u" ? document : null, wE = yo && /* @__PURE__ */ yo.createElement("template"), C0 = {
  insert: (i, e, t) => {
    e.insertBefore(i, t || null);
  },
  remove: (i) => {
    const e = i.parentNode;
    e && e.removeChild(i);
  },
  createElement: (i, e, t, r) => {
    const o = e ? yo.createElementNS(A0, i) : yo.createElement(i, t ? { is: t } : void 0);
    return i === "select" && r && r.multiple != null && o.setAttribute("multiple", r.multiple), o;
  },
  createText: (i) => yo.createTextNode(i),
  createComment: (i) => yo.createComment(i),
  setText: (i, e) => {
    i.nodeValue = e;
  },
  setElementText: (i, e) => {
    i.textContent = e;
  },
  parentNode: (i) => i.parentNode,
  nextSibling: (i) => i.nextSibling,
  querySelector: (i) => yo.querySelector(i),
  setScopeId(i, e) {
    i.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(i, e, t, r, o, s) {
    const n = t ? t.previousSibling : e.lastChild;
    if (o && (o === s || o.nextSibling))
      for (; e.insertBefore(o.cloneNode(!0), t), !(o === s || !(o = o.nextSibling)); )
        ;
    else {
      wE.innerHTML = r ? `<svg>${i}</svg>` : i;
      const a = wE.content;
      if (r) {
        const l = a.firstChild;
        for (; l.firstChild; )
          a.appendChild(l.firstChild);
        a.removeChild(l);
      }
      e.insertBefore(a, t);
    }
    return [
      // first
      n ? n.nextSibling : e.firstChild,
      // last
      t ? t.previousSibling : e.lastChild
    ];
  }
};
function N0(i, e, t) {
  const r = i._vtc;
  r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? i.removeAttribute("class") : t ? i.setAttribute("class", e) : i.className = e;
}
function I0(i, e, t) {
  const r = i.style, o = he(t);
  if (t && !o) {
    if (e && !he(e))
      for (const s in e)
        t[s] == null && _d(r, s, "");
    for (const s in t)
      _d(r, s, t[s]);
  } else {
    const s = r.display;
    o ? e !== t && (r.cssText = t) : e && i.removeAttribute("style"), "_vod" in i && (r.display = s);
  }
}
const v0 = /[^\\];\s*$/, yE = /\s*!important$/;
function _d(i, e, t) {
  if (W(t))
    t.forEach((r) => _d(i, e, r));
  else if (t == null && (t = ""), {}.NODE_ENV !== "production" && v0.test(t) && L(
    `Unexpected semicolon at the end of '${e}' style value: '${t}'`
  ), e.startsWith("--"))
    i.setProperty(e, t);
  else {
    const r = _0(i, e);
    yE.test(t) ? i.setProperty(
      kt(r),
      t.replace(yE, ""),
      "important"
    ) : i[r] = t;
  }
}
const DE = ["Webkit", "Moz", "ms"], fc = {};
function _0(i, e) {
  const t = fc[e];
  if (t)
    return t;
  let r = ot(e);
  if (r !== "filter" && r in i)
    return fc[e] = r;
  r = ur(r);
  for (let o = 0; o < DE.length; o++) {
    const s = DE[o] + r;
    if (s in i)
      return fc[e] = s;
  }
  return e;
}
const xE = "http://www.w3.org/1999/xlink";
function P0(i, e, t, r, o) {
  if (r && e.startsWith("xlink:"))
    t == null ? i.removeAttributeNS(xE, e.slice(6, e.length)) : i.setAttributeNS(xE, e, t);
  else {
    const s = wv(e);
    t == null || s && !CT(t) ? i.removeAttribute(e) : i.setAttribute(e, s ? "" : t);
  }
}
function L0(i, e, t, r, o, s, n) {
  if (e === "innerHTML" || e === "textContent") {
    r && n(r, o, s), i[e] = t ?? "";
    return;
  }
  const a = i.tagName;
  if (e === "value" && a !== "PROGRESS" && // custom elements may use _value internally
  !a.includes("-")) {
    i._value = t;
    const u = a === "OPTION" ? i.getAttribute("value") : i.value, h = t ?? "";
    u !== h && (i.value = h), t == null && i.removeAttribute(e);
    return;
  }
  let l = !1;
  if (t === "" || t == null) {
    const u = typeof i[e];
    u === "boolean" ? t = CT(t) : t == null && u === "string" ? (t = "", l = !0) : u === "number" && (t = 0, l = !0);
  }
  try {
    i[e] = t;
  } catch (u) {
    ({}).NODE_ENV !== "production" && !l && L(
      `Failed setting prop "${e}" on <${a.toLowerCase()}>: value ${t} is invalid.`,
      u
    );
  }
  l && i.removeAttribute(e);
}
function br(i, e, t, r) {
  i.addEventListener(e, t, r);
}
function w0(i, e, t, r) {
  i.removeEventListener(e, t, r);
}
function y0(i, e, t, r, o = null) {
  const s = i._vei || (i._vei = {}), n = s[e];
  if (r && n)
    n.value = r;
  else {
    const [a, l] = D0(e);
    if (r) {
      const u = s[e] = U0(r, o);
      br(i, a, u, l);
    } else
      n && (w0(i, a, n, l), s[e] = void 0);
  }
}
const ME = /(?:Once|Passive|Capture)$/;
function D0(i) {
  let e;
  if (ME.test(i)) {
    e = {};
    let r;
    for (; r = i.match(ME); )
      i = i.slice(0, i.length - r[0].length), e[r[0].toLowerCase()] = !0;
  }
  return [i[2] === ":" ? i.slice(3) : kt(i.slice(2)), e];
}
let pc = 0;
const x0 = /* @__PURE__ */ Promise.resolve(), M0 = () => pc || (x0.then(() => pc = 0), pc = Date.now());
function U0(i, e) {
  const t = (r) => {
    if (!r._vts)
      r._vts = Date.now();
    else if (r._vts <= t.attached)
      return;
    li(
      Q0(r, t.value),
      e,
      5,
      [r]
    );
  };
  return t.value = i, t.attached = M0(), t;
}
function Q0(i, e) {
  if (W(e)) {
    const t = i.stopImmediatePropagation;
    return i.stopImmediatePropagation = () => {
      t.call(i), i._stopped = !0;
    }, e.map((r) => (o) => !o._stopped && r && r(o));
  } else
    return e;
}
const UE = /^on[a-z]/, k0 = (i, e, t, r, o = !1, s, n, a, l) => {
  e === "class" ? N0(i, r, o) : e === "style" ? I0(i, t, r) : Ar(e) ? nu(e) || y0(i, e, t, r, n) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : $0(i, e, r, o)) ? L0(
    i,
    e,
    r,
    s,
    n,
    a,
    l
  ) : (e === "true-value" ? i._trueValue = r : e === "false-value" && (i._falseValue = r), P0(i, e, r, o));
};
function $0(i, e, t, r) {
  return r ? !!(e === "innerHTML" || e === "textContent" || e in i && UE.test(e) && ae(t)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && i.tagName === "INPUT" || e === "type" && i.tagName === "TEXTAREA" || UE.test(e) && he(t) ? !1 : e in i;
}
function Cp(i, e) {
  const t = fi(i);
  class r extends Lh {
    constructor(s) {
      super(t, s, e);
    }
  }
  return r.def = t, r;
}
const G0 = (i) => Cp(i, fR), V0 = typeof HTMLElement < "u" ? HTMLElement : class {
};
class Lh extends V0 {
  constructor(e, t = {}, r) {
    super(), this._def = e, this._props = t, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this.shadowRoot && r ? r(this._createVNode(), this.shadowRoot) : ({}.NODE_ENV !== "production" && this.shadowRoot && L(
      "Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."
    ), this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def));
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, zo(() => {
      this._connected || (wd(null, this.shadowRoot), this._instance = null);
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = !0;
    for (let r = 0; r < this.attributes.length; r++)
      this._setAttr(this.attributes[r].name);
    new MutationObserver((r) => {
      for (const o of r)
        this._setAttr(o.attributeName);
    }).observe(this, { attributes: !0 });
    const e = (r, o = !1) => {
      const { props: s, styles: n } = r;
      let a;
      if (s && !W(s))
        for (const l in s) {
          const u = s[l];
          (u === Number || u && u.type === Number) && (l in this._props && (this._props[l] = uu(this._props[l])), (a || (a = /* @__PURE__ */ Object.create(null)))[ot(l)] = !0);
        }
      this._numberProps = a, o && this._resolveProps(r), this._applyStyles(n), this._update();
    }, t = this._def.__asyncLoader;
    t ? t().then((r) => e(r, !0)) : e(this._def);
  }
  _resolveProps(e) {
    const { props: t } = e, r = W(t) ? t : Object.keys(t || {});
    for (const o of Object.keys(this))
      o[0] !== "_" && r.includes(o) && this._setProp(o, this[o], !0, !1);
    for (const o of r.map(ot))
      Object.defineProperty(this, o, {
        get() {
          return this._getProp(o);
        },
        set(s) {
          this._setProp(o, s);
        }
      });
  }
  _setAttr(e) {
    let t = this.getAttribute(e);
    const r = ot(e);
    this._numberProps && this._numberProps[r] && (t = uu(t)), this._setProp(r, t, !1);
  }
  /**
   * @internal
   */
  _getProp(e) {
    return this._props[e];
  }
  /**
   * @internal
   */
  _setProp(e, t, r = !0, o = !0) {
    t !== this._props[e] && (this._props[e] = t, o && this._instance && this._update(), r && (t === !0 ? this.setAttribute(kt(e), "") : typeof t == "string" || typeof t == "number" ? this.setAttribute(kt(e), t + "") : t || this.removeAttribute(kt(e))));
  }
  _update() {
    wd(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const e = xe(this._def, pe({}, this._props));
    return this._instance || (e.ce = (t) => {
      this._instance = t, t.isCE = !0, {}.NODE_ENV !== "production" && (t.ceReload = (s) => {
        this._styles && (this._styles.forEach((n) => this.shadowRoot.removeChild(n)), this._styles.length = 0), this._applyStyles(s), this._instance = null, this._update();
      });
      const r = (s, n) => {
        this.dispatchEvent(
          new CustomEvent(s, {
            detail: n
          })
        );
      };
      t.emit = (s, ...n) => {
        r(s, n), kt(s) !== s && r(kt(s), n);
      };
      let o = this;
      for (; o = o && (o.parentNode || o.host); )
        if (o instanceof Lh) {
          t.parent = o._instance, t.provides = o._instance.provides;
          break;
        }
    }), e;
  }
  _applyStyles(e) {
    e && e.forEach((t) => {
      const r = document.createElement("style");
      r.textContent = t, this.shadowRoot.appendChild(r), {}.NODE_ENV !== "production" && (this._styles || (this._styles = [])).push(r);
    });
  }
}
function H0(i = "$style") {
  {
    const e = Dr();
    if (!e)
      return {}.NODE_ENV !== "production" && L("useCssModule must be called inside setup()"), Ae;
    const t = e.type.__cssModules;
    if (!t)
      return {}.NODE_ENV !== "production" && L("Current instance does not have CSS modules injected."), Ae;
    const r = t[i];
    return r || ({}.NODE_ENV !== "production" && L(`Current instance does not have CSS module named "${i}".`), Ae);
  }
}
function X0(i) {
  const e = Dr();
  if (!e) {
    ({}).NODE_ENV !== "production" && L("useCssVars is called without current active component instance.");
    return;
  }
  const t = e.ut = (o = i(e.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${e.uid}"]`)
    ).forEach((s) => Ld(s, o));
  }, r = () => {
    const o = i(e.proxy);
    Pd(e.subTree, o), t(o);
  };
  iS(r), yr(() => {
    const o = new MutationObserver(r);
    o.observe(e.subTree.el.parentNode, { childList: !0 }), Ih(() => o.disconnect());
  });
}
function Pd(i, e) {
  if (i.shapeFlag & 128) {
    const t = i.suspense;
    i = t.activeBranch, t.pendingBranch && !t.isHydrating && t.effects.push(() => {
      Pd(t.activeBranch, e);
    });
  }
  for (; i.component; )
    i = i.component.subTree;
  if (i.shapeFlag & 1 && i.el)
    Ld(i.el, e);
  else if (i.type === et)
    i.children.forEach((t) => Pd(t, e));
  else if (i.type === io) {
    let { el: t, anchor: r } = i;
    for (; t && (Ld(t, e), t !== r); )
      t = t.nextSibling;
  }
}
function Ld(i, e) {
  if (i.nodeType === 1) {
    const t = i.style;
    for (const r in e)
      t.setProperty(`--${r}`, e[r]);
  }
}
const $r = "transition", _n = "animation", Np = (i, { slots: e }) => No(sS, JS(i), e);
Np.displayName = "Transition";
const KS = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, Y0 = Np.props = /* @__PURE__ */ pe(
  {},
  pp,
  KS
), _o = (i, e = []) => {
  W(i) ? i.forEach((t) => t(...e)) : i && i(...e);
}, QE = (i) => i ? W(i) ? i.some((e) => e.length > 1) : i.length > 1 : !1;
function JS(i) {
  const e = {};
  for (const _ in i)
    _ in KS || (e[_] = i[_]);
  if (i.css === !1)
    return e;
  const {
    name: t = "v",
    type: r,
    duration: o,
    enterFromClass: s = `${t}-enter-from`,
    enterActiveClass: n = `${t}-enter-active`,
    enterToClass: a = `${t}-enter-to`,
    appearFromClass: l = s,
    appearActiveClass: u = n,
    appearToClass: h = a,
    leaveFromClass: c = `${t}-leave-from`,
    leaveActiveClass: d = `${t}-leave-active`,
    leaveToClass: f = `${t}-leave-to`
  } = i, p = B0(o), O = p && p[0], m = p && p[1], {
    onBeforeEnter: E,
    onEnter: g,
    onEnterCancelled: A,
    onLeave: S,
    onLeaveCancelled: R,
    onBeforeAppear: v = E,
    onAppear: I = g,
    onAppearCancelled: C = A
  } = e, P = (_, X, G) => {
    Hr(_, X ? h : a), Hr(_, X ? u : n), G && G();
  }, w = (_, X) => {
    _._isLeaving = !1, Hr(_, c), Hr(_, f), Hr(_, d), X && X();
  }, x = (_) => (X, G) => {
    const ee = _ ? I : g, re = () => P(X, _, G);
    _o(ee, [X, re]), kE(() => {
      Hr(X, _ ? l : s), Er(X, _ ? h : a), QE(ee) || $E(X, r, O, re);
    });
  };
  return pe(e, {
    onBeforeEnter(_) {
      _o(E, [_]), Er(_, s), Er(_, n);
    },
    onBeforeAppear(_) {
      _o(v, [_]), Er(_, l), Er(_, u);
    },
    onEnter: x(!1),
    onAppear: x(!0),
    onLeave(_, X) {
      _._isLeaving = !0;
      const G = () => w(_, X);
      Er(_, c), tR(), Er(_, d), kE(() => {
        _._isLeaving && (Hr(_, c), Er(_, f), QE(S) || $E(_, r, m, G));
      }), _o(S, [_, G]);
    },
    onEnterCancelled(_) {
      P(_, !1), _o(A, [_]);
    },
    onAppearCancelled(_) {
      P(_, !0), _o(C, [_]);
    },
    onLeaveCancelled(_) {
      w(_), _o(R, [_]);
    }
  });
}
function B0(i) {
  if (i == null)
    return null;
  if (Se(i))
    return [Oc(i.enter), Oc(i.leave)];
  {
    const e = Oc(i);
    return [e, e];
  }
}
function Oc(i) {
  const e = uu(i);
  return {}.NODE_ENV !== "production" && op(e, "<transition> explicit duration"), e;
}
function Er(i, e) {
  e.split(/\s+/).forEach((t) => t && i.classList.add(t)), (i._vtc || (i._vtc = /* @__PURE__ */ new Set())).add(e);
}
function Hr(i, e) {
  e.split(/\s+/).forEach((r) => r && i.classList.remove(r));
  const { _vtc: t } = i;
  t && (t.delete(e), t.size || (i._vtc = void 0));
}
function kE(i) {
  requestAnimationFrame(() => {
    requestAnimationFrame(i);
  });
}
let F0 = 0;
function $E(i, e, t, r) {
  const o = i._endId = ++F0, s = () => {
    o === i._endId && r();
  };
  if (t)
    return setTimeout(s, t);
  const { type: n, timeout: a, propCount: l } = eR(i, e);
  if (!n)
    return r();
  const u = n + "end";
  let h = 0;
  const c = () => {
    i.removeEventListener(u, d), s();
  }, d = (f) => {
    f.target === i && ++h >= l && c();
  };
  setTimeout(() => {
    h < l && c();
  }, a + 1), i.addEventListener(u, d);
}
function eR(i, e) {
  const t = window.getComputedStyle(i), r = (p) => (t[p] || "").split(", "), o = r(`${$r}Delay`), s = r(`${$r}Duration`), n = GE(o, s), a = r(`${_n}Delay`), l = r(`${_n}Duration`), u = GE(a, l);
  let h = null, c = 0, d = 0;
  e === $r ? n > 0 && (h = $r, c = n, d = s.length) : e === _n ? u > 0 && (h = _n, c = u, d = l.length) : (c = Math.max(n, u), h = c > 0 ? n > u ? $r : _n : null, d = h ? h === $r ? s.length : l.length : 0);
  const f = h === $r && /\b(transform|all)(,|$)/.test(
    r(`${$r}Property`).toString()
  );
  return {
    type: h,
    timeout: c,
    propCount: d,
    hasTransform: f
  };
}
function GE(i, e) {
  for (; i.length < e.length; )
    i = i.concat(i);
  return Math.max(...e.map((t, r) => VE(t) + VE(i[r])));
}
function VE(i) {
  return Number(i.slice(0, -1).replace(",", ".")) * 1e3;
}
function tR() {
  return document.body.offsetHeight;
}
const iR = /* @__PURE__ */ new WeakMap(), rR = /* @__PURE__ */ new WeakMap(), oR = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ pe({}, Y0, {
    tag: String,
    moveClass: String
  }),
  setup(i, { slots: e }) {
    const t = Dr(), r = fp();
    let o, s;
    return Ch(() => {
      if (!o.length)
        return;
      const n = i.moveClass || `${i.name || "v"}-move`;
      if (!K0(
        o[0].el,
        t.vnode.el,
        n
      ))
        return;
      o.forEach(Z0), o.forEach(q0);
      const a = o.filter(j0);
      tR(), a.forEach((l) => {
        const u = l.el, h = u.style;
        Er(u, n), h.transform = h.webkitTransform = h.transitionDuration = "";
        const c = u._moveCb = (d) => {
          d && d.target !== u || (!d || /transform$/.test(d.propertyName)) && (u.removeEventListener("transitionend", c), u._moveCb = null, Hr(u, n));
        };
        u.addEventListener("transitionend", c);
      });
    }), () => {
      const n = ce(i), a = JS(n);
      let l = n.tag || et;
      o = s, s = e.default ? Rh(e.default()) : [];
      for (let u = 0; u < s.length; u++) {
        const h = s[u];
        h.key != null ? qo(
          h,
          qs(h, a, r, t)
        ) : {}.NODE_ENV !== "production" && L("<TransitionGroup> children must be keyed.");
      }
      if (o)
        for (let u = 0; u < o.length; u++) {
          const h = o[u];
          qo(
            h,
            qs(h, a, r, t)
          ), iR.set(h, h.el.getBoundingClientRect());
        }
      return xe(l, null, s);
    };
  }
}, W0 = (i) => delete i.mode;
oR.props;
const z0 = oR;
function Z0(i) {
  const e = i.el;
  e._moveCb && e._moveCb(), e._enterCb && e._enterCb();
}
function q0(i) {
  rR.set(i, i.el.getBoundingClientRect());
}
function j0(i) {
  const e = iR.get(i), t = rR.get(i), r = e.left - t.left, o = e.top - t.top;
  if (r || o) {
    const s = i.el.style;
    return s.transform = s.webkitTransform = `translate(${r}px,${o}px)`, s.transitionDuration = "0s", i;
  }
}
function K0(i, e, t) {
  const r = i.cloneNode();
  i._vtc && i._vtc.forEach((n) => {
    n.split(/\s+/).forEach((a) => a && r.classList.remove(a));
  }), t.split(/\s+/).forEach((n) => n && r.classList.add(n)), r.style.display = "none";
  const o = e.nodeType === 1 ? e : e.parentNode;
  o.appendChild(r);
  const { hasTransform: s } = eR(r);
  return o.removeChild(r), s;
}
const Oo = (i) => {
  const e = i.props["onUpdate:modelValue"] || !1;
  return W(e) ? (t) => Wr(e, t) : e;
};
function J0(i) {
  i.target.composing = !0;
}
function HE(i) {
  const e = i.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const bu = {
  created(i, { modifiers: { lazy: e, trim: t, number: r } }, o) {
    i._assign = Oo(o);
    const s = r || o.props && o.props.type === "number";
    br(i, e ? "change" : "input", (n) => {
      if (n.target.composing)
        return;
      let a = i.value;
      t && (a = a.trim()), s && (a = lu(a)), i._assign(a);
    }), t && br(i, "change", () => {
      i.value = i.value.trim();
    }), e || (br(i, "compositionstart", J0), br(i, "compositionend", HE), br(i, "change", HE));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(i, { value: e }) {
    i.value = e ?? "";
  },
  beforeUpdate(i, { value: e, modifiers: { lazy: t, trim: r, number: o } }, s) {
    if (i._assign = Oo(s), i.composing || document.activeElement === i && i.type !== "range" && (t || r && i.value.trim() === e || (o || i.type === "number") && lu(i.value) === e))
      return;
    const n = e ?? "";
    i.value !== n && (i.value = n);
  }
}, Ip = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(i, e, t) {
    i._assign = Oo(t), br(i, "change", () => {
      const r = i._modelValue, o = Ks(i), s = i.checked, n = i._assign;
      if (W(r)) {
        const a = dh(r, o), l = a !== -1;
        if (s && !l)
          n(r.concat(o));
        else if (!s && l) {
          const u = [...r];
          u.splice(a, 1), n(u);
        }
      } else if (as(r)) {
        const a = new Set(r);
        s ? a.add(o) : a.delete(o), n(a);
      } else
        n(nR(i, s));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: XE,
  beforeUpdate(i, e, t) {
    i._assign = Oo(t), XE(i, e, t);
  }
};
function XE(i, { value: e, oldValue: t }, r) {
  i._modelValue = e, W(e) ? i.checked = dh(e, r.props.value) > -1 : as(e) ? i.checked = e.has(r.props.value) : e !== t && (i.checked = ho(e, nR(i, !0)));
}
const vp = {
  created(i, { value: e }, t) {
    i.checked = ho(e, t.props.value), i._assign = Oo(t), br(i, "change", () => {
      i._assign(Ks(i));
    });
  },
  beforeUpdate(i, { value: e, oldValue: t }, r) {
    i._assign = Oo(r), e !== t && (i.checked = ho(e, r.props.value));
  }
}, sR = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(i, { value: e, modifiers: { number: t } }, r) {
    const o = as(e);
    br(i, "change", () => {
      const s = Array.prototype.filter.call(i.options, (n) => n.selected).map(
        (n) => t ? lu(Ks(n)) : Ks(n)
      );
      i._assign(
        i.multiple ? o ? new Set(s) : s : s[0]
      );
    }), i._assign = Oo(r);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(i, { value: e }) {
    YE(i, e);
  },
  beforeUpdate(i, e, t) {
    i._assign = Oo(t);
  },
  updated(i, { value: e }) {
    YE(i, e);
  }
};
function YE(i, e) {
  const t = i.multiple;
  if (t && !W(e) && !as(e)) {
    ({}).NODE_ENV !== "production" && L(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`
    );
    return;
  }
  for (let r = 0, o = i.options.length; r < o; r++) {
    const s = i.options[r], n = Ks(s);
    if (t)
      W(e) ? s.selected = dh(e, n) > -1 : s.selected = e.has(n);
    else if (ho(Ks(s), e)) {
      i.selectedIndex !== r && (i.selectedIndex = r);
      return;
    }
  }
  !t && i.selectedIndex !== -1 && (i.selectedIndex = -1);
}
function Ks(i) {
  return "_value" in i ? i._value : i.value;
}
function nR(i, e) {
  const t = e ? "_trueValue" : "_falseValue";
  return t in i ? i[t] : e;
}
const aR = {
  created(i, e, t) {
    El(i, e, t, null, "created");
  },
  mounted(i, e, t) {
    El(i, e, t, null, "mounted");
  },
  beforeUpdate(i, e, t, r) {
    El(i, e, t, r, "beforeUpdate");
  },
  updated(i, e, t, r) {
    El(i, e, t, r, "updated");
  }
};
function lR(i, e) {
  switch (i) {
    case "SELECT":
      return sR;
    case "TEXTAREA":
      return bu;
    default:
      switch (e) {
        case "checkbox":
          return Ip;
        case "radio":
          return vp;
        default:
          return bu;
      }
  }
}
function El(i, e, t, r, o) {
  const n = lR(
    i.tagName,
    t.props && t.props.type
  )[o];
  n && n(i, e, t, r);
}
function eL() {
  bu.getSSRProps = ({ value: i }) => ({ value: i }), vp.getSSRProps = ({ value: i }, e) => {
    if (e.props && ho(e.props.value, i))
      return { checked: !0 };
  }, Ip.getSSRProps = ({ value: i }, e) => {
    if (W(i)) {
      if (e.props && dh(i, e.props.value) > -1)
        return { checked: !0 };
    } else if (as(i)) {
      if (e.props && i.has(e.props.value))
        return { checked: !0 };
    } else if (i)
      return { checked: !0 };
  }, aR.getSSRProps = (i, e) => {
    if (typeof e.type != "string")
      return;
    const t = lR(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      e.type.toUpperCase(),
      e.props && e.props.type
    );
    if (t.getSSRProps)
      return t.getSSRProps(i, e);
  };
}
const tL = ["ctrl", "shift", "alt", "meta"], iL = {
  stop: (i) => i.stopPropagation(),
  prevent: (i) => i.preventDefault(),
  self: (i) => i.target !== i.currentTarget,
  ctrl: (i) => !i.ctrlKey,
  shift: (i) => !i.shiftKey,
  alt: (i) => !i.altKey,
  meta: (i) => !i.metaKey,
  left: (i) => "button" in i && i.button !== 0,
  middle: (i) => "button" in i && i.button !== 1,
  right: (i) => "button" in i && i.button !== 2,
  exact: (i, e) => tL.some((t) => i[`${t}Key`] && !e.includes(t))
}, rL = (i, e) => (t, ...r) => {
  for (let o = 0; o < e.length; o++) {
    const s = iL[e[o]];
    if (s && s(t, e))
      return;
  }
  return i(t, ...r);
}, oL = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, sL = (i, e) => (t) => {
  if (!("key" in t))
    return;
  const r = kt(t.key);
  if (e.some((o) => o === r || oL[o] === r))
    return i(t);
}, uR = {
  beforeMount(i, { value: e }, { transition: t }) {
    i._vod = i.style.display === "none" ? "" : i.style.display, t && e ? t.beforeEnter(i) : Pn(i, e);
  },
  mounted(i, { value: e }, { transition: t }) {
    t && e && t.enter(i);
  },
  updated(i, { value: e, oldValue: t }, { transition: r }) {
    !e != !t && (r ? e ? (r.beforeEnter(i), Pn(i, !0), r.enter(i)) : r.leave(i, () => {
      Pn(i, !1);
    }) : Pn(i, e));
  },
  beforeUnmount(i, { value: e }) {
    Pn(i, e);
  }
};
function Pn(i, e) {
  i.style.display = e ? i._vod : "none";
}
function nL() {
  uR.getSSRProps = ({ value: i }) => {
    if (!i)
      return { style: { display: "none" } };
  };
}
const hR = /* @__PURE__ */ pe({ patchProp: k0 }, C0);
let oa, BE = !1;
function cR() {
  return oa || (oa = PS(hR));
}
function dR() {
  return oa = BE ? oa : LS(hR), BE = !0, oa;
}
const wd = (...i) => {
  cR().render(...i);
}, fR = (...i) => {
  dR().hydrate(...i);
}, aL = (...i) => {
  const e = cR().createApp(...i);
  ({}).NODE_ENV !== "production" && (pR(e), ER(e));
  const { mount: t } = e;
  return e.mount = (r) => {
    const o = mR(r);
    if (!o)
      return;
    const s = e._component;
    !ae(s) && !s.render && !s.template && (s.template = o.innerHTML), o.innerHTML = "";
    const n = t(o, !1, o instanceof SVGElement);
    return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), n;
  }, e;
}, lL = (...i) => {
  const e = dR().createApp(...i);
  ({}).NODE_ENV !== "production" && (pR(e), ER(e));
  const { mount: t } = e;
  return e.mount = (r) => {
    const o = mR(r);
    if (o)
      return t(o, !0, o instanceof SVGElement);
  }, e;
};
function pR(i) {
  Object.defineProperty(i.config, "isNativeTag", {
    value: (e) => RT(e) || AT(e),
    writable: !1
  });
}
function ER(i) {
  if (Ap()) {
    const e = i.config.isCustomElement;
    Object.defineProperty(i.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        L(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const t = i.config.compilerOptions, r = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(i.config, "compilerOptions", {
      get() {
        return L(r), t;
      },
      set() {
        L(r);
      }
    });
  }
}
function mR(i) {
  if (he(i)) {
    const e = document.querySelector(i);
    return {}.NODE_ENV !== "production" && !e && L(
      `Failed to mount app: mount target selector "${i}" returned null.`
    ), e;
  }
  return {}.NODE_ENV !== "production" && window.ShadowRoot && i instanceof window.ShadowRoot && i.mode === "closed" && L(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), i;
}
let FE = !1;
const uL = () => {
  FE || (FE = !0, eL(), nL());
}, hL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition: sS,
  BaseTransitionPropsValidators: pp,
  Comment: Ke,
  EffectScope: jf,
  Fragment: et,
  KeepAlive: hP,
  ReactiveEffect: Ha,
  Static: io,
  Suspense: j_,
  Teleport: a0,
  Text: fo,
  Transition: Np,
  TransitionGroup: z0,
  VueElement: Lh,
  assertNumber: op,
  callWithAsyncErrorHandling: li,
  callWithErrorHandling: or,
  camelize: ot,
  capitalize: ur,
  cloneVNode: Ci,
  compatUtils: R0,
  computed: WS,
  createApp: aL,
  createBlock: Li,
  createCommentVNode: gr,
  createElementBlock: ht,
  createElementVNode: ke,
  createHydrationRenderer: LS,
  createPropsRestProxy: DP,
  createRenderer: PS,
  createSSRApp: lL,
  createSlots: OP,
  createStaticVNode: h0,
  createTextVNode: Tp,
  createVNode: xe,
  customRef: m_,
  defineAsyncComponent: lP,
  defineComponent: fi,
  defineCustomElement: Cp,
  defineEmits: RP,
  defineExpose: AP,
  defineModel: IP,
  defineOptions: CP,
  defineProps: SP,
  defineSSRCustomElement: G0,
  defineSlots: NP,
  get devtools() {
    return Pi;
  },
  effect: Qv,
  effectScope: Dv,
  getCurrentInstance: Dr,
  getCurrentScope: _T,
  getTransitionRawChildren: Rh,
  guardReactiveProps: QS,
  h: No,
  handleError: hs,
  hasInjectionContext: XP,
  hydrate: fR,
  initCustomFormatter: qS,
  initDirectivesForSSR: uL,
  inject: ea,
  isMemoSame: jS,
  isProxy: fa,
  isReactive: eo,
  isReadonly: Cr,
  isRef: Fe,
  isRuntimeOnly: Ap,
  isShallow: da,
  isVNode: Nr,
  markRaw: ep,
  mergeDefaults: wP,
  mergeModels: yP,
  mergeProps: $S,
  nextTick: zo,
  normalizeClass: On,
  normalizeProps: Nv,
  normalizeStyle: ki,
  onActivated: aS,
  onBeforeMount: hS,
  onBeforeUnmount: Nh,
  onBeforeUpdate: cS,
  onDeactivated: lS,
  onErrorCaptured: OS,
  onMounted: yr,
  onRenderTracked: pS,
  onRenderTriggered: fS,
  onScopeDispose: xv,
  onServerPrefetch: dS,
  onUnmounted: Ih,
  onUpdated: Ch,
  openBlock: Pe,
  popScopeId: JT,
  provide: RS,
  proxyRefs: rp,
  pushScopeId: KT,
  queuePostFlushCb: bh,
  reactive: Eh,
  readonly: Jf,
  ref: it,
  registerRuntimeCompiler: XS,
  render: wd,
  renderList: Ep,
  renderSlot: ui,
  resolveComponent: ES,
  resolveDirective: pP,
  resolveDynamicComponent: fP,
  resolveFilter: S0,
  resolveTransitionHooks: qs,
  setBlockTracking: Rd,
  setDevtoolsHook: lp,
  setTransitionHooks: qo,
  shallowReactive: VT,
  shallowReadonly: ws,
  shallowRef: c_,
  ssrContextKey: zS,
  ssrUtils: T0,
  stop: kv,
  toDisplayString: NT,
  toHandlerKey: zi,
  toHandlers: EP,
  toRaw: ce,
  toRef: S_,
  toRefs: g_,
  toValue: p_,
  transformVNodeArgs: l0,
  triggerRef: f_,
  unref: Zs,
  useAttrs: PP,
  useCssModule: H0,
  useCssVars: X0,
  useModel: LP,
  useSSRContext: ZS,
  useSlots: _P,
  useTransitionState: fp,
  vModelCheckbox: Ip,
  vModelDynamic: aR,
  vModelRadio: vp,
  vModelSelect: sR,
  vModelText: bu,
  vShow: uR,
  version: vd,
  warn: L,
  watch: Mi,
  watchEffect: rP,
  watchPostEffect: iS,
  watchSyncEffect: oP,
  withAsyncContext: xP,
  withCtx: ga,
  withDefaults: vP,
  withDirectives: nP,
  withKeys: sL,
  withMemo: g0,
  withModifiers: rL,
  withScopeId: B_
}, Symbol.toStringTag, { value: "Module" }));
function _p(i) {
  throw i;
}
function gR(i) {
  ({}).NODE_ENV !== "production" && console.warn(`[Vue warn] ${i.message}`);
}
function Ie(i, e, t, r) {
  const o = {}.NODE_ENV !== "production" ? (t || cL)[i] + (r || "") : i, s = new SyntaxError(String(o));
  return s.code = i, s.loc = e, s;
}
const cL = {
  // parse errors
  [0]: "Illegal comment.",
  [1]: "CDATA section is allowed only in XML context.",
  [2]: "Duplicate attribute.",
  [3]: "End tag cannot have attributes.",
  [4]: "Illegal '/' in tags.",
  [5]: "Unexpected EOF in tag.",
  [6]: "Unexpected EOF in CDATA section.",
  [7]: "Unexpected EOF in comment.",
  [8]: "Unexpected EOF in script.",
  [9]: "Unexpected EOF in tag.",
  [10]: "Incorrectly closed comment.",
  [11]: "Incorrectly opened comment.",
  [12]: "Illegal tag name. Use '&lt;' to print '<'.",
  [13]: "Attribute value was expected.",
  [14]: "End tag name was expected.",
  [15]: "Whitespace was expected.",
  [16]: "Unexpected '<!--' in comment.",
  [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  [19]: "Attribute name cannot start with '='.",
  [21]: "'<?' is allowed only in XML context.",
  [20]: "Unexpected null character.",
  [22]: "Illegal '/' in tags.",
  // Vue-specific parse errors
  [23]: "Invalid end tag.",
  [24]: "Element is missing end tag.",
  [25]: "Interpolation end sign was not found.",
  [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  [26]: "Legal directive name was expected.",
  // transform errors
  [28]: "v-if/v-else-if is missing expression.",
  [29]: "v-if/else branches must use unique keys.",
  [30]: "v-else/v-else-if has no adjacent v-if or v-else-if.",
  [31]: "v-for is missing expression.",
  [32]: "v-for has invalid expression.",
  [33]: "<template v-for> key should be placed on the <template> tag.",
  [34]: "v-bind is missing expression.",
  [35]: "v-on is missing expression.",
  [36]: "Unexpected custom directive on <slot> outlet.",
  [37]: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",
  [38]: "Duplicate slot names found. ",
  [39]: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.",
  [40]: "v-slot can only be used on components or <template> tags.",
  [41]: "v-model is missing expression.",
  [42]: "v-model value must be a valid JavaScript member expression.",
  [43]: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.",
  [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  [45]: "Error parsing JavaScript expression: ",
  [46]: "<KeepAlive> expects exactly one child component.",
  // generic errors
  [47]: '"prefixIdentifiers" option is not supported in this build of compiler.',
  [48]: "ES module mode is not supported in this build of compiler.",
  [49]: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
  [50]: '"scopeId" option is only supported in module mode.',
  // deprecations
  [51]: "@vnode-* hooks in templates are deprecated. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support will be removed in 3.4.",
  [52]: 'v-is="component-name" has been deprecated. Use is="vue:component-name" instead. v-is support will be removed in 3.4.',
  // just to fulfill types
  [53]: ""
}, Aa = Symbol({}.NODE_ENV !== "production" ? "Fragment" : ""), sa = Symbol({}.NODE_ENV !== "production" ? "Teleport" : ""), Pp = Symbol({}.NODE_ENV !== "production" ? "Suspense" : ""), Tu = Symbol({}.NODE_ENV !== "production" ? "KeepAlive" : ""), bR = Symbol({}.NODE_ENV !== "production" ? "BaseTransition" : ""), Ko = Symbol({}.NODE_ENV !== "production" ? "openBlock" : ""), TR = Symbol({}.NODE_ENV !== "production" ? "createBlock" : ""), SR = Symbol({}.NODE_ENV !== "production" ? "createElementBlock" : ""), Lp = Symbol({}.NODE_ENV !== "production" ? "createVNode" : ""), wp = Symbol({}.NODE_ENV !== "production" ? "createElementVNode" : ""), Fa = Symbol({}.NODE_ENV !== "production" ? "createCommentVNode" : ""), yp = Symbol({}.NODE_ENV !== "production" ? "createTextVNode" : ""), RR = Symbol({}.NODE_ENV !== "production" ? "createStaticVNode" : ""), Dp = Symbol({}.NODE_ENV !== "production" ? "resolveComponent" : ""), Su = Symbol(
  {}.NODE_ENV !== "production" ? "resolveDynamicComponent" : ""
), xp = Symbol({}.NODE_ENV !== "production" ? "resolveDirective" : ""), Mp = Symbol({}.NODE_ENV !== "production" ? "resolveFilter" : ""), Up = Symbol({}.NODE_ENV !== "production" ? "withDirectives" : ""), Qp = Symbol({}.NODE_ENV !== "production" ? "renderList" : ""), AR = Symbol({}.NODE_ENV !== "production" ? "renderSlot" : ""), CR = Symbol({}.NODE_ENV !== "production" ? "createSlots" : ""), wh = Symbol({}.NODE_ENV !== "production" ? "toDisplayString" : ""), Ru = Symbol({}.NODE_ENV !== "production" ? "mergeProps" : ""), kp = Symbol({}.NODE_ENV !== "production" ? "normalizeClass" : ""), $p = Symbol({}.NODE_ENV !== "production" ? "normalizeStyle" : ""), Ca = Symbol({}.NODE_ENV !== "production" ? "normalizeProps" : ""), Wa = Symbol({}.NODE_ENV !== "production" ? "guardReactiveProps" : ""), Gp = Symbol({}.NODE_ENV !== "production" ? "toHandlers" : ""), yd = Symbol({}.NODE_ENV !== "production" ? "camelize" : ""), dL = Symbol({}.NODE_ENV !== "production" ? "capitalize" : ""), Dd = Symbol({}.NODE_ENV !== "production" ? "toHandlerKey" : ""), Au = Symbol({}.NODE_ENV !== "production" ? "setBlockTracking" : ""), fL = Symbol({}.NODE_ENV !== "production" ? "pushScopeId" : ""), pL = Symbol({}.NODE_ENV !== "production" ? "popScopeId" : ""), Vp = Symbol({}.NODE_ENV !== "production" ? "withCtx" : ""), OL = Symbol({}.NODE_ENV !== "production" ? "unref" : ""), EL = Symbol({}.NODE_ENV !== "production" ? "isRef" : ""), Hp = Symbol({}.NODE_ENV !== "production" ? "withMemo" : ""), NR = Symbol({}.NODE_ENV !== "production" ? "isMemoSame" : ""), Js = {
  [Aa]: "Fragment",
  [sa]: "Teleport",
  [Pp]: "Suspense",
  [Tu]: "KeepAlive",
  [bR]: "BaseTransition",
  [Ko]: "openBlock",
  [TR]: "createBlock",
  [SR]: "createElementBlock",
  [Lp]: "createVNode",
  [wp]: "createElementVNode",
  [Fa]: "createCommentVNode",
  [yp]: "createTextVNode",
  [RR]: "createStaticVNode",
  [Dp]: "resolveComponent",
  [Su]: "resolveDynamicComponent",
  [xp]: "resolveDirective",
  [Mp]: "resolveFilter",
  [Up]: "withDirectives",
  [Qp]: "renderList",
  [AR]: "renderSlot",
  [CR]: "createSlots",
  [wh]: "toDisplayString",
  [Ru]: "mergeProps",
  [kp]: "normalizeClass",
  [$p]: "normalizeStyle",
  [Ca]: "normalizeProps",
  [Wa]: "guardReactiveProps",
  [Gp]: "toHandlers",
  [yd]: "camelize",
  [dL]: "capitalize",
  [Dd]: "toHandlerKey",
  [Au]: "setBlockTracking",
  [fL]: "pushScopeId",
  [pL]: "popScopeId",
  [Vp]: "withCtx",
  [OL]: "unref",
  [EL]: "isRef",
  [Hp]: "withMemo",
  [NR]: "isMemoSame"
};
function mL(i) {
  Object.getOwnPropertySymbols(i).forEach((e) => {
    Js[e] = i[e];
  });
}
const pi = {
  source: "",
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function gL(i, e = pi) {
  return {
    type: 0,
    children: i,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc: e
  };
}
function Na(i, e, t, r, o, s, n, a = !1, l = !1, u = !1, h = pi) {
  return i && (a ? (i.helper(Ko), i.helper(rn(i.inSSR, u))) : i.helper(tn(i.inSSR, u)), n && i.helper(Up)), {
    type: 13,
    tag: e,
    props: t,
    children: r,
    patchFlag: o,
    dynamicProps: s,
    directives: n,
    isBlock: a,
    disableTracking: l,
    isComponent: u,
    loc: h
  };
}
function za(i, e = pi) {
  return {
    type: 17,
    loc: e,
    elements: i
  };
}
function gi(i, e = pi) {
  return {
    type: 15,
    loc: e,
    properties: i
  };
}
function We(i, e) {
  return {
    type: 16,
    loc: pi,
    key: he(i) ? me(i, !0) : i,
    value: e
  };
}
function me(i, e = !1, t = pi, r = 0) {
  return {
    type: 4,
    loc: t,
    content: i,
    isStatic: e,
    constType: e ? 3 : r
  };
}
function Ui(i, e = pi) {
  return {
    type: 8,
    loc: e,
    children: i
  };
}
function tt(i, e = [], t = pi) {
  return {
    type: 14,
    loc: t,
    callee: i,
    arguments: e
  };
}
function en(i, e = void 0, t = !1, r = !1, o = pi) {
  return {
    type: 18,
    params: i,
    returns: e,
    newline: t,
    isSlot: r,
    loc: o
  };
}
function xd(i, e, t, r = !0) {
  return {
    type: 19,
    test: i,
    consequent: e,
    alternate: t,
    newline: r,
    loc: pi
  };
}
function bL(i, e, t = !1) {
  return {
    type: 20,
    index: i,
    value: e,
    isVNode: t,
    loc: pi
  };
}
function TL(i) {
  return {
    type: 21,
    body: i,
    loc: pi
  };
}
function tn(i, e) {
  return i || e ? Lp : wp;
}
function rn(i, e) {
  return i || e ? TR : SR;
}
function Xp(i, { helper: e, removeHelper: t, inSSR: r }) {
  i.isBlock || (i.isBlock = !0, t(tn(r, i.isComponent)), e(Ko), e(rn(r, i.isComponent)));
}
const Bt = (i) => i.type === 4 && i.isStatic, Uo = (i, e) => i === e || i === kt(e);
function IR(i) {
  if (Uo(i, "Teleport"))
    return sa;
  if (Uo(i, "Suspense"))
    return Pp;
  if (Uo(i, "KeepAlive"))
    return Tu;
  if (Uo(i, "BaseTransition"))
    return bR;
}
const SL = /^\d|[^\$\w]/, Yp = (i) => !SL.test(i), RL = /[A-Za-z_$\xA0-\uFFFF]/, AL = /[\.\?\w$\xA0-\uFFFF]/, CL = /\s+[.[]\s*|\s*[.[]\s+/g, NL = (i) => {
  i = i.trim().replace(CL, (n) => n.trim());
  let e = 0, t = [], r = 0, o = 0, s = null;
  for (let n = 0; n < i.length; n++) {
    const a = i.charAt(n);
    switch (e) {
      case 0:
        if (a === "[")
          t.push(e), e = 1, r++;
        else if (a === "(")
          t.push(e), e = 2, o++;
        else if (!(n === 0 ? RL : AL).test(a))
          return !1;
        break;
      case 1:
        a === "'" || a === '"' || a === "`" ? (t.push(e), e = 3, s = a) : a === "[" ? r++ : a === "]" && (--r || (e = t.pop()));
        break;
      case 2:
        if (a === "'" || a === '"' || a === "`")
          t.push(e), e = 3, s = a;
        else if (a === "(")
          o++;
        else if (a === ")") {
          if (n === i.length - 1)
            return !1;
          --o || (e = t.pop());
        }
        break;
      case 3:
        a === s && (e = t.pop(), s = null);
        break;
    }
  }
  return !r && !o;
}, vR = NL;
function _R(i, e, t) {
  const o = {
    source: i.source.slice(e, e + t),
    start: Cu(i.start, i.source, e),
    end: i.end
  };
  return t != null && (o.end = Cu(
    i.start,
    i.source,
    e + t
  )), o;
}
function Cu(i, e, t = e.length) {
  return Nu(
    pe({}, i),
    e,
    t
  );
}
function Nu(i, e, t = e.length) {
  let r = 0, o = -1;
  for (let s = 0; s < t; s++)
    e.charCodeAt(s) === 10 && (r++, o = s);
  return i.offset += t, i.line += r, i.column = o === -1 ? i.column + t : t - o, i;
}
function WE(i, e) {
  if (!i)
    throw new Error(e || "unexpected compiler condition");
}
function Ei(i, e, t = !1) {
  for (let r = 0; r < i.props.length; r++) {
    const o = i.props[r];
    if (o.type === 7 && (t || o.exp) && (he(e) ? o.name === e : e.test(o.name)))
      return o;
  }
}
function on(i, e, t = !1, r = !1) {
  for (let o = 0; o < i.props.length; o++) {
    const s = i.props[o];
    if (s.type === 6) {
      if (t)
        continue;
      if (s.name === e && (s.value || r))
        return s;
    } else if (s.name === "bind" && (s.exp || r) && Qo(s.arg, e))
      return s;
  }
}
function Qo(i, e) {
  return !!(i && Bt(i) && i.content === e);
}
function IL(i) {
  return i.props.some(
    (e) => e.type === 7 && e.name === "bind" && (!e.arg || // v-bind="obj"
    e.arg.type !== 4 || // v-bind:[_ctx.foo]
    !e.arg.isStatic)
    // v-bind:[foo]
  );
}
function Ec(i) {
  return i.type === 5 || i.type === 2;
}
function vL(i) {
  return i.type === 7 && i.name === "slot";
}
function Iu(i) {
  return i.type === 1 && i.tagType === 3;
}
function vu(i) {
  return i.type === 1 && i.tagType === 2;
}
const _L = /* @__PURE__ */ new Set([Ca, Wa]);
function PR(i, e = []) {
  if (i && !he(i) && i.type === 14) {
    const t = i.callee;
    if (!he(t) && _L.has(t))
      return PR(
        i.arguments[0],
        e.concat(i)
      );
  }
  return [i, e];
}
function _u(i, e, t) {
  let r, o = i.type === 13 ? i.props : i.arguments[2], s = [], n;
  if (o && !he(o) && o.type === 14) {
    const a = PR(o);
    o = a[0], s = a[1], n = s[s.length - 1];
  }
  if (o == null || he(o))
    r = gi([e]);
  else if (o.type === 14) {
    const a = o.arguments[0];
    !he(a) && a.type === 15 ? zE(e, a) || a.properties.unshift(e) : o.callee === Gp ? r = tt(t.helper(Ru), [
      gi([e]),
      o
    ]) : o.arguments.unshift(gi([e])), !r && (r = o);
  } else
    o.type === 15 ? (zE(e, o) || o.properties.unshift(e), r = o) : (r = tt(t.helper(Ru), [
      gi([e]),
      o
    ]), n && n.callee === Wa && (n = s[s.length - 2]));
  i.type === 13 ? n ? n.arguments[0] = r : i.props = r : n ? n.arguments[0] = r : i.arguments[2] = r;
}
function zE(i, e) {
  let t = !1;
  if (i.key.type === 4) {
    const r = i.key.content;
    t = e.properties.some(
      (o) => o.key.type === 4 && o.key.content === r
    );
  }
  return t;
}
function Ia(i, e) {
  return `_${e}_${i.replace(/[^\w]/g, (t, r) => t === "-" ? "_" : i.charCodeAt(r).toString())}`;
}
function PL(i) {
  return i.type === 14 && i.callee === Hp ? i.arguments[1].returns : i;
}
const LL = {
  COMPILER_IS_ON_ELEMENT: {
    message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
    link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"
  },
  COMPILER_V_BIND_SYNC: {
    message: (i) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${i}.sync\` should be changed to \`v-model:${i}\`.`,
    link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html"
  },
  COMPILER_V_BIND_PROP: {
    message: ".prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate."
  },
  COMPILER_V_BIND_OBJECT_ORDER: {
    message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
    link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html"
  },
  COMPILER_V_ON_NATIVE: {
    message: ".native modifier for v-on has been removed as is no longer necessary.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"
  },
  COMPILER_V_IF_V_FOR_PRECEDENCE: {
    message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"
  },
  COMPILER_NATIVE_TEMPLATE: {
    message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3."
  },
  COMPILER_INLINE_TEMPLATE: {
    message: '"inline-template" has been removed in Vue 3.',
    link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"
  },
  COMPILER_FILTER: {
    message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
    link: "https://v3-migration.vuejs.org/breaking-changes/filters.html"
  }
};
function Md(i, e) {
  const t = e.options ? e.options.compatConfig : e.compatConfig, r = t && t[i];
  return i === "MODE" ? r || 3 : r;
}
function oo(i, e) {
  const t = Md("MODE", e), r = Md(i, e);
  return t === 3 ? r === !0 : r !== !1;
}
function Jo(i, e, t, ...r) {
  const o = oo(i, e);
  return {}.NODE_ENV !== "production" && o && yh(i, e, t, ...r), o;
}
function yh(i, e, t, ...r) {
  if (Md(i, e) === "suppress-warning")
    return;
  const { message: s, link: n } = LL[i], a = `(deprecation ${i}) ${typeof s == "function" ? s(...r) : s}${n ? `
  Details: ${n}` : ""}`, l = new SyntaxError(a);
  l.code = i, t && (l.loc = t), e.onWarn(l);
}
const wL = /&(gt|lt|amp|apos|quot);/g, yL = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
}, ZE = {
  delimiters: ["{{", "}}"],
  getNamespace: () => 0,
  getTextMode: () => 0,
  isVoidTag: Zn,
  isPreTag: Zn,
  isCustomElement: Zn,
  decodeEntities: (i) => i.replace(wL, (e, t) => yL[t]),
  onError: _p,
  onWarn: gR,
  comments: {}.NODE_ENV !== "production"
};
function DL(i, e = {}) {
  const t = xL(i, e), r = hi(t);
  return gL(
    Bp(t, 0, []),
    ci(t, r)
  );
}
function xL(i, e) {
  const t = pe({}, ZE);
  let r;
  for (r in e)
    t[r] = e[r] === void 0 ? ZE[r] : e[r];
  return {
    options: t,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: i,
    source: i,
    inPre: !1,
    inVPre: !1,
    onWarn: t.onWarn
  };
}
function Bp(i, e, t) {
  const r = Dh(t), o = r ? r.ns : 0, s = [];
  for (; !XL(i, e, t); ) {
    const a = i.source;
    let l;
    if (e === 0 || e === 1) {
      if (!i.inVPre && Pt(a, i.options.delimiters[0]))
        l = VL(i, e);
      else if (e === 0 && a[0] === "<")
        if (a.length === 1)
          _e(i, 5, 1);
        else if (a[1] === "!")
          Pt(a, "<!--") ? l = UL(i) : Pt(a, "<!DOCTYPE") ? l = Ln(i) : Pt(a, "<![CDATA[") ? o !== 0 ? l = ML(i, t) : (_e(i, 1), l = Ln(i)) : (_e(i, 11), l = Ln(i));
        else if (a[1] === "/")
          if (a.length === 2)
            _e(i, 5, 2);
          else if (a[2] === ">") {
            _e(i, 14, 2), at(i, 3);
            continue;
          } else if (/[a-z]/i.test(a[2])) {
            _e(i, 23), Ud(i, Pu.End, r);
            continue;
          } else
            _e(
              i,
              12,
              2
            ), l = Ln(i);
        else
          /[a-z]/i.test(a[1]) ? (l = QL(i, t), oo(
            "COMPILER_NATIVE_TEMPLATE",
            i
          ) && l && l.tag === "template" && !l.props.some(
            (u) => u.type === 7 && LR(u.name)
          ) && ({}.NODE_ENV !== "production" && yh(
            "COMPILER_NATIVE_TEMPLATE",
            i,
            l.loc
          ), l = l.children)) : a[1] === "?" ? (_e(
            i,
            21,
            1
          ), l = Ln(i)) : _e(i, 12, 1);
    }
    if (l || (l = HL(i, e)), W(l))
      for (let u = 0; u < l.length; u++)
        qE(s, l[u]);
    else
      qE(s, l);
  }
  let n = !1;
  if (e !== 2 && e !== 1) {
    const a = i.options.whitespace !== "preserve";
    for (let l = 0; l < s.length; l++) {
      const u = s[l];
      if (u.type === 2)
        if (i.inPre)
          u.content = u.content.replace(/\r\n/g, `
`);
        else if (/[^\t\r\n\f ]/.test(u.content))
          a && (u.content = u.content.replace(/[\t\r\n\f ]+/g, " "));
        else {
          const h = s[l - 1], c = s[l + 1];
          !h || !c || a && (h.type === 3 && c.type === 3 || h.type === 3 && c.type === 1 || h.type === 1 && c.type === 3 || h.type === 1 && c.type === 1 && /[\r\n]/.test(u.content)) ? (n = !0, s[l] = null) : u.content = " ";
        }
      else
        u.type === 3 && !i.options.comments && (n = !0, s[l] = null);
    }
    if (i.inPre && r && i.options.isPreTag(r.tag)) {
      const l = s[0];
      l && l.type === 2 && (l.content = l.content.replace(/^\r?\n/, ""));
    }
  }
  return n ? s.filter(Boolean) : s;
}
function qE(i, e) {
  if (e.type === 2) {
    const t = Dh(i);
    if (t && t.type === 2 && t.loc.end.offset === e.loc.start.offset) {
      t.content += e.content, t.loc.end = e.loc.end, t.loc.source += e.loc.source;
      return;
    }
  }
  i.push(e);
}
function ML(i, e) {
  at(i, 9);
  const t = Bp(i, 3, e);
  return i.source.length === 0 ? _e(i, 6) : at(i, 3), t;
}
function UL(i) {
  const e = hi(i);
  let t;
  const r = /--(\!)?>/.exec(i.source);
  if (!r)
    t = i.source.slice(4), at(i, i.source.length), _e(i, 7);
  else {
    r.index <= 3 && _e(i, 0), r[1] && _e(i, 10), t = i.source.slice(4, r.index);
    const o = i.source.slice(0, r.index);
    let s = 1, n = 0;
    for (; (n = o.indexOf("<!--", s)) !== -1; )
      at(i, n - s + 1), n + 4 < o.length && _e(i, 16), s = n + 1;
    at(i, r.index + r[0].length - s + 1);
  }
  return {
    type: 3,
    content: t,
    loc: ci(i, e)
  };
}
function Ln(i) {
  const e = hi(i), t = i.source[1] === "?" ? 1 : 2;
  let r;
  const o = i.source.indexOf(">");
  return o === -1 ? (r = i.source.slice(t), at(i, i.source.length)) : (r = i.source.slice(t, o), at(i, o + 1)), {
    type: 3,
    content: r,
    loc: ci(i, e)
  };
}
function QL(i, e) {
  const t = i.inPre, r = i.inVPre, o = Dh(e), s = Ud(i, Pu.Start, o), n = i.inPre && !t, a = i.inVPre && !r;
  if (s.isSelfClosing || i.options.isVoidTag(s.tag))
    return n && (i.inPre = !1), a && (i.inVPre = !1), s;
  e.push(s);
  const l = i.options.getTextMode(s, o), u = Bp(i, l, e);
  e.pop();
  {
    const h = s.props.find(
      (c) => c.type === 6 && c.name === "inline-template"
    );
    if (h && Jo(
      "COMPILER_INLINE_TEMPLATE",
      i,
      h.loc
    )) {
      const c = ci(i, s.loc.end);
      h.value = {
        type: 2,
        content: c.source,
        loc: c
      };
    }
  }
  if (s.children = u, Qd(i.source, s.tag))
    Ud(i, Pu.End, o);
  else if (_e(i, 24, 0, s.loc.start), i.source.length === 0 && s.tag.toLowerCase() === "script") {
    const h = u[0];
    h && Pt(h.loc.source, "<!--") && _e(i, 8);
  }
  return s.loc = ci(i, s.loc.start), n && (i.inPre = !1), a && (i.inVPre = !1), s;
}
var Pu = /* @__PURE__ */ ((i) => (i[i.Start = 0] = "Start", i[i.End = 1] = "End", i))(Pu || {});
const LR = /* @__PURE__ */ wt(
  "if,else,else-if,for,slot"
);
function Ud(i, e, t) {
  const r = hi(i), o = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(i.source), s = o[1], n = i.options.getNamespace(s, t);
  at(i, o[0].length), va(i);
  const a = hi(i), l = i.source;
  i.options.isPreTag(s) && (i.inPre = !0);
  let u = jE(i, e);
  e === 0 && !i.inVPre && u.some((d) => d.type === 7 && d.name === "pre") && (i.inVPre = !0, pe(i, a), i.source = l, u = jE(i, e).filter((d) => d.name !== "v-pre"));
  let h = !1;
  if (i.source.length === 0 ? _e(i, 9) : (h = Pt(i.source, "/>"), e === 1 && h && _e(i, 4), at(i, h ? 2 : 1)), e === 1)
    return;
  if ({}.NODE_ENV !== "production" && oo(
    "COMPILER_V_IF_V_FOR_PRECEDENCE",
    i
  )) {
    let d = !1, f = !1;
    for (let p = 0; p < u.length; p++) {
      const O = u[p];
      if (O.type === 7 && (O.name === "if" ? d = !0 : O.name === "for" && (f = !0)), d && f) {
        yh(
          "COMPILER_V_IF_V_FOR_PRECEDENCE",
          i,
          ci(i, r)
        );
        break;
      }
    }
  }
  let c = 0;
  return i.inVPre || (s === "slot" ? c = 2 : s === "template" ? u.some(
    (d) => d.type === 7 && LR(d.name)
  ) && (c = 3) : kL(s, u, i) && (c = 1)), {
    type: 1,
    ns: n,
    tag: s,
    tagType: c,
    props: u,
    isSelfClosing: h,
    children: [],
    loc: ci(i, r),
    codegenNode: void 0
    // to be created during transform phase
  };
}
function kL(i, e, t) {
  const r = t.options;
  if (r.isCustomElement(i))
    return !1;
  if (i === "component" || /^[A-Z]/.test(i) || IR(i) || r.isBuiltInComponent && r.isBuiltInComponent(i) || r.isNativeTag && !r.isNativeTag(i))
    return !0;
  for (let o = 0; o < e.length; o++) {
    const s = e[o];
    if (s.type === 6) {
      if (s.name === "is" && s.value) {
        if (s.value.content.startsWith("vue:"))
          return !0;
        if (Jo(
          "COMPILER_IS_ON_ELEMENT",
          t,
          s.loc
        ))
          return !0;
      }
    } else {
      if (s.name === "is")
        return !0;
      if (
        // :is on plain element - only treat as component in compat mode
        s.name === "bind" && Qo(s.arg, "is") && Jo(
          "COMPILER_IS_ON_ELEMENT",
          t,
          s.loc
        )
      )
        return !0;
    }
  }
}
function jE(i, e) {
  const t = [], r = /* @__PURE__ */ new Set();
  for (; i.source.length > 0 && !Pt(i.source, ">") && !Pt(i.source, "/>"); ) {
    if (Pt(i.source, "/")) {
      _e(i, 22), at(i, 1), va(i);
      continue;
    }
    e === 1 && _e(i, 3);
    const o = $L(i, r);
    o.type === 6 && o.value && o.name === "class" && (o.value.content = o.value.content.replace(/\s+/g, " ").trim()), e === 0 && t.push(o), /^[^\t\r\n\f />]/.test(i.source) && _e(i, 15), va(i);
  }
  return t;
}
function $L(i, e) {
  var t;
  const r = hi(i), s = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(i.source)[0];
  e.has(s) && _e(i, 2), e.add(s), s[0] === "=" && _e(i, 19);
  {
    const l = /["'<]/g;
    let u;
    for (; u = l.exec(s); )
      _e(
        i,
        17,
        u.index
      );
  }
  at(i, s.length);
  let n;
  /^[\t\r\n\f ]*=/.test(i.source) && (va(i), at(i, 1), va(i), n = GL(i), n || _e(i, 13));
  const a = ci(i, r);
  if (!i.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(s)) {
    const l = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
      s
    );
    let u = Pt(s, "."), h = l[1] || (u || Pt(s, ":") ? "bind" : Pt(s, "@") ? "on" : "slot"), c;
    if (l[2]) {
      const f = h === "slot", p = s.lastIndexOf(
        l[2],
        s.length - (((t = l[3]) == null ? void 0 : t.length) || 0)
      ), O = ci(
        i,
        KE(i, r, p),
        KE(
          i,
          r,
          p + l[2].length + (f && l[3] || "").length
        )
      );
      let m = l[2], E = !0;
      m.startsWith("[") ? (E = !1, m.endsWith("]") ? m = m.slice(1, m.length - 1) : (_e(
        i,
        27
      ), m = m.slice(1))) : f && (m += l[3] || ""), c = {
        type: 4,
        content: m,
        isStatic: E,
        constType: E ? 3 : 0,
        loc: O
      };
    }
    if (n && n.isQuoted) {
      const f = n.loc;
      f.start.offset++, f.start.column++, f.end = Cu(f.start, n.content), f.source = f.source.slice(1, -1);
    }
    const d = l[3] ? l[3].slice(1).split(".") : [];
    return u && d.push("prop"), h === "bind" && c && (d.includes("sync") && Jo(
      "COMPILER_V_BIND_SYNC",
      i,
      a,
      c.loc.source
    ) && (h = "model", d.splice(d.indexOf("sync"), 1)), {}.NODE_ENV !== "production" && d.includes("prop") && Jo(
      "COMPILER_V_BIND_PROP",
      i,
      a
    )), {
      type: 7,
      name: h,
      exp: n && {
        type: 4,
        content: n.content,
        isStatic: !1,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0,
        loc: n.loc
      },
      arg: c,
      modifiers: d,
      loc: a
    };
  }
  return !i.inVPre && Pt(s, "v-") && _e(i, 26), {
    type: 6,
    name: s,
    value: n && {
      type: 2,
      content: n.content,
      loc: n.loc
    },
    loc: a
  };
}
function GL(i) {
  const e = hi(i);
  let t;
  const r = i.source[0], o = r === '"' || r === "'";
  if (o) {
    at(i, 1);
    const s = i.source.indexOf(r);
    s === -1 ? t = na(
      i,
      i.source.length,
      4
    ) : (t = na(i, s, 4), at(i, 1));
  } else {
    const s = /^[^\t\r\n\f >]+/.exec(i.source);
    if (!s)
      return;
    const n = /["'<=`]/g;
    let a;
    for (; a = n.exec(s[0]); )
      _e(
        i,
        18,
        a.index
      );
    t = na(i, s[0].length, 4);
  }
  return { content: t, isQuoted: o, loc: ci(i, e) };
}
function VL(i, e) {
  const [t, r] = i.options.delimiters, o = i.source.indexOf(r, t.length);
  if (o === -1) {
    _e(i, 25);
    return;
  }
  const s = hi(i);
  at(i, t.length);
  const n = hi(i), a = hi(i), l = o - t.length, u = i.source.slice(0, l), h = na(i, l, e), c = h.trim(), d = h.indexOf(c);
  d > 0 && Nu(n, u, d);
  const f = l - (h.length - c.length - d);
  return Nu(a, u, f), at(i, r.length), {
    type: 5,
    content: {
      type: 4,
      isStatic: !1,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0,
      content: c,
      loc: ci(i, n, a)
    },
    loc: ci(i, s)
  };
}
function HL(i, e) {
  const t = e === 3 ? ["]]>"] : ["<", i.options.delimiters[0]];
  let r = i.source.length;
  for (let n = 0; n < t.length; n++) {
    const a = i.source.indexOf(t[n], 1);
    a !== -1 && r > a && (r = a);
  }
  const o = hi(i);
  return {
    type: 2,
    content: na(i, r, e),
    loc: ci(i, o)
  };
}
function na(i, e, t) {
  const r = i.source.slice(0, e);
  return at(i, e), t === 2 || t === 3 || !r.includes("&") ? r : i.options.decodeEntities(
    r,
    t === 4
  );
}
function hi(i) {
  const { column: e, line: t, offset: r } = i;
  return { column: e, line: t, offset: r };
}
function ci(i, e, t) {
  return t = t || hi(i), {
    start: e,
    end: t,
    source: i.originalSource.slice(e.offset, t.offset)
  };
}
function Dh(i) {
  return i[i.length - 1];
}
function Pt(i, e) {
  return i.startsWith(e);
}
function at(i, e) {
  const { source: t } = i;
  Nu(i, t, e), i.source = t.slice(e);
}
function va(i) {
  const e = /^[\t\r\n\f ]+/.exec(i.source);
  e && at(i, e[0].length);
}
function KE(i, e, t) {
  return Cu(
    e,
    i.originalSource.slice(e.offset, t),
    t
  );
}
function _e(i, e, t, r = hi(i)) {
  t && (r.offset += t, r.column += t), i.options.onError(
    Ie(e, {
      start: r,
      end: r,
      source: ""
    })
  );
}
function XL(i, e, t) {
  const r = i.source;
  switch (e) {
    case 0:
      if (Pt(r, "</")) {
        for (let o = t.length - 1; o >= 0; --o)
          if (Qd(r, t[o].tag))
            return !0;
      }
      break;
    case 1:
    case 2: {
      const o = Dh(t);
      if (o && Qd(r, o.tag))
        return !0;
      break;
    }
    case 3:
      if (Pt(r, "]]>"))
        return !0;
      break;
  }
  return !r;
}
function Qd(i, e) {
  return Pt(i, "</") && i.slice(2, 2 + e.length).toLowerCase() === e.toLowerCase() && /[\t\r\n\f />]/.test(i[2 + e.length] || ">");
}
function YL(i, e) {
  Yl(
    i,
    e,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    wR(i, i.children[0])
  );
}
function wR(i, e) {
  const { children: t } = i;
  return t.length === 1 && e.type === 1 && !vu(e);
}
function Yl(i, e, t = !1) {
  const { children: r } = i, o = r.length;
  let s = 0;
  for (let n = 0; n < r.length; n++) {
    const a = r[n];
    if (a.type === 1 && a.tagType === 0) {
      const l = t ? 0 : bi(a, e);
      if (l > 0) {
        if (l >= 2) {
          a.codegenNode.patchFlag = -1 + ({}.NODE_ENV !== "production" ? " /* HOISTED */" : ""), a.codegenNode = e.hoist(a.codegenNode), s++;
          continue;
        }
      } else {
        const u = a.codegenNode;
        if (u.type === 13) {
          const h = MR(u);
          if ((!h || h === 512 || h === 1) && DR(a, e) >= 2) {
            const c = xR(a);
            c && (u.props = e.hoist(c));
          }
          u.dynamicProps && (u.dynamicProps = e.hoist(u.dynamicProps));
        }
      }
    }
    if (a.type === 1) {
      const l = a.tagType === 1;
      l && e.scopes.vSlot++, Yl(a, e), l && e.scopes.vSlot--;
    } else if (a.type === 11)
      Yl(a, e, a.children.length === 1);
    else if (a.type === 9)
      for (let l = 0; l < a.branches.length; l++)
        Yl(
          a.branches[l],
          e,
          a.branches[l].children.length === 1
        );
  }
  s && e.transformHoist && e.transformHoist(r, e, i), s && s === o && i.type === 1 && i.tagType === 0 && i.codegenNode && i.codegenNode.type === 13 && W(i.codegenNode.children) && (i.codegenNode.children = e.hoist(
    za(i.codegenNode.children)
  ));
}
function bi(i, e) {
  const { constantCache: t } = e;
  switch (i.type) {
    case 1:
      if (i.tagType !== 0)
        return 0;
      const r = t.get(i);
      if (r !== void 0)
        return r;
      const o = i.codegenNode;
      if (o.type !== 13 || o.isBlock && i.tag !== "svg" && i.tag !== "foreignObject")
        return 0;
      if (MR(o))
        return t.set(i, 0), 0;
      {
        let a = 3;
        const l = DR(i, e);
        if (l === 0)
          return t.set(i, 0), 0;
        l < a && (a = l);
        for (let u = 0; u < i.children.length; u++) {
          const h = bi(i.children[u], e);
          if (h === 0)
            return t.set(i, 0), 0;
          h < a && (a = h);
        }
        if (a > 1)
          for (let u = 0; u < i.props.length; u++) {
            const h = i.props[u];
            if (h.type === 7 && h.name === "bind" && h.exp) {
              const c = bi(h.exp, e);
              if (c === 0)
                return t.set(i, 0), 0;
              c < a && (a = c);
            }
          }
        if (o.isBlock) {
          for (let u = 0; u < i.props.length; u++)
            if (i.props[u].type === 7)
              return t.set(i, 0), 0;
          e.removeHelper(Ko), e.removeHelper(
            rn(e.inSSR, o.isComponent)
          ), o.isBlock = !1, e.helper(tn(e.inSSR, o.isComponent));
        }
        return t.set(i, a), a;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return bi(i.content, e);
    case 4:
      return i.constType;
    case 8:
      let n = 3;
      for (let a = 0; a < i.children.length; a++) {
        const l = i.children[a];
        if (he(l) || uo(l))
          continue;
        const u = bi(l, e);
        if (u === 0)
          return 0;
        u < n && (n = u);
      }
      return n;
    default:
      return 0;
  }
}
const BL = /* @__PURE__ */ new Set([
  kp,
  $p,
  Ca,
  Wa
]);
function yR(i, e) {
  if (i.type === 14 && !he(i.callee) && BL.has(i.callee)) {
    const t = i.arguments[0];
    if (t.type === 4)
      return bi(t, e);
    if (t.type === 14)
      return yR(t, e);
  }
  return 0;
}
function DR(i, e) {
  let t = 3;
  const r = xR(i);
  if (r && r.type === 15) {
    const { properties: o } = r;
    for (let s = 0; s < o.length; s++) {
      const { key: n, value: a } = o[s], l = bi(n, e);
      if (l === 0)
        return l;
      l < t && (t = l);
      let u;
      if (a.type === 4 ? u = bi(a, e) : a.type === 14 ? u = yR(a, e) : u = 0, u === 0)
        return u;
      u < t && (t = u);
    }
  }
  return t;
}
function xR(i) {
  const e = i.codegenNode;
  if (e.type === 13)
    return e.props;
}
function MR(i) {
  const e = i.patchFlag;
  return e ? parseInt(e, 10) : void 0;
}
function FL(i, {
  filename: e = "",
  prefixIdentifiers: t = !1,
  hoistStatic: r = !1,
  cacheHandlers: o = !1,
  nodeTransforms: s = [],
  directiveTransforms: n = {},
  transformHoist: a = null,
  isBuiltInComponent: l = Ze,
  isCustomElement: u = Ze,
  expressionPlugins: h = [],
  scopeId: c = null,
  slotted: d = !0,
  ssr: f = !1,
  inSSR: p = !1,
  ssrCssVars: O = "",
  bindingMetadata: m = Ae,
  inline: E = !1,
  isTS: g = !1,
  onError: A = _p,
  onWarn: S = gR,
  compatConfig: R
}) {
  const v = e.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), I = {
    // options
    selfName: v && ur(ot(v[1])),
    prefixIdentifiers: t,
    hoistStatic: r,
    cacheHandlers: o,
    nodeTransforms: s,
    directiveTransforms: n,
    transformHoist: a,
    isBuiltInComponent: l,
    isCustomElement: u,
    expressionPlugins: h,
    scopeId: c,
    slotted: d,
    ssr: f,
    inSSR: p,
    ssrCssVars: O,
    bindingMetadata: m,
    inline: E,
    isTS: g,
    onError: A,
    onWarn: S,
    compatConfig: R,
    // state
    root: i,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: i,
    childIndex: 0,
    inVOnce: !1,
    // methods
    helper(C) {
      const P = I.helpers.get(C) || 0;
      return I.helpers.set(C, P + 1), C;
    },
    removeHelper(C) {
      const P = I.helpers.get(C);
      if (P) {
        const w = P - 1;
        w ? I.helpers.set(C, w) : I.helpers.delete(C);
      }
    },
    helperString(C) {
      return `_${Js[I.helper(C)]}`;
    },
    replaceNode(C) {
      if ({}.NODE_ENV !== "production") {
        if (!I.currentNode)
          throw new Error("Node being replaced is already removed.");
        if (!I.parent)
          throw new Error("Cannot replace root node.");
      }
      I.parent.children[I.childIndex] = I.currentNode = C;
    },
    removeNode(C) {
      if ({}.NODE_ENV !== "production" && !I.parent)
        throw new Error("Cannot remove root node.");
      const P = I.parent.children, w = C ? P.indexOf(C) : I.currentNode ? I.childIndex : -1;
      if ({}.NODE_ENV !== "production" && w < 0)
        throw new Error("node being removed is not a child of current parent");
      !C || C === I.currentNode ? (I.currentNode = null, I.onNodeRemoved()) : I.childIndex > w && (I.childIndex--, I.onNodeRemoved()), I.parent.children.splice(w, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(C) {
    },
    removeIdentifiers(C) {
    },
    hoist(C) {
      he(C) && (C = me(C)), I.hoists.push(C);
      const P = me(
        `_hoisted_${I.hoists.length}`,
        !1,
        C.loc,
        2
      );
      return P.hoisted = C, P;
    },
    cache(C, P = !1) {
      return bL(I.cached++, C, P);
    }
  };
  return I.filters = /* @__PURE__ */ new Set(), I;
}
function WL(i, e) {
  const t = FL(i, e);
  xh(i, t), e.hoistStatic && YL(i, t), e.ssr || zL(i, t), i.helpers = /* @__PURE__ */ new Set([...t.helpers.keys()]), i.components = [...t.components], i.directives = [...t.directives], i.imports = t.imports, i.hoists = t.hoists, i.temps = t.temps, i.cached = t.cached, i.filters = [...t.filters];
}
function zL(i, e) {
  const { helper: t } = e, { children: r } = i;
  if (r.length === 1) {
    const o = r[0];
    if (wR(i, o) && o.codegenNode) {
      const s = o.codegenNode;
      s.type === 13 && Xp(s, e), i.codegenNode = s;
    } else
      i.codegenNode = o;
  } else if (r.length > 1) {
    let o = 64, s = rr[64];
    ({}).NODE_ENV !== "production" && r.filter((n) => n.type !== 3).length === 1 && (o |= 2048, s += `, ${rr[2048]}`), i.codegenNode = Na(
      e,
      t(Aa),
      void 0,
      i.children,
      o + ({}.NODE_ENV !== "production" ? ` /* ${s} */` : ""),
      void 0,
      void 0,
      !0,
      void 0,
      !1
      /* isComponent */
    );
  }
}
function ZL(i, e) {
  let t = 0;
  const r = () => {
    t--;
  };
  for (; t < i.children.length; t++) {
    const o = i.children[t];
    he(o) || (e.parent = i, e.childIndex = t, e.onNodeRemoved = r, xh(o, e));
  }
}
function xh(i, e) {
  e.currentNode = i;
  const { nodeTransforms: t } = e, r = [];
  for (let s = 0; s < t.length; s++) {
    const n = t[s](i, e);
    if (n && (W(n) ? r.push(...n) : r.push(n)), e.currentNode)
      i = e.currentNode;
    else
      return;
  }
  switch (i.type) {
    case 3:
      e.ssr || e.helper(Fa);
      break;
    case 5:
      e.ssr || e.helper(wh);
      break;
    case 9:
      for (let s = 0; s < i.branches.length; s++)
        xh(i.branches[s], e);
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      ZL(i, e);
      break;
  }
  e.currentNode = i;
  let o = r.length;
  for (; o--; )
    r[o]();
}
function UR(i, e) {
  const t = he(i) ? (r) => r === i : (r) => i.test(r);
  return (r, o) => {
    if (r.type === 1) {
      const { props: s } = r;
      if (r.tagType === 3 && s.some(vL))
        return;
      const n = [];
      for (let a = 0; a < s.length; a++) {
        const l = s[a];
        if (l.type === 7 && t(l.name)) {
          s.splice(a, 1), a--;
          const u = e(r, l, o);
          u && n.push(u);
        }
      }
      return n;
    }
  };
}
const Mh = "/*#__PURE__*/", QR = (i) => `${Js[i]}: _${Js[i]}`;
function JE(i, {
  mode: e = "function",
  prefixIdentifiers: t = e === "module",
  sourceMap: r = !1,
  filename: o = "template.vue.html",
  scopeId: s = null,
  optimizeImports: n = !1,
  runtimeGlobalName: a = "Vue",
  runtimeModuleName: l = "vue",
  ssrRuntimeModuleName: u = "vue/server-renderer",
  ssr: h = !1,
  isTS: c = !1,
  inSSR: d = !1
}) {
  const f = {
    mode: e,
    prefixIdentifiers: t,
    sourceMap: r,
    filename: o,
    scopeId: s,
    optimizeImports: n,
    runtimeGlobalName: a,
    runtimeModuleName: l,
    ssrRuntimeModuleName: u,
    ssr: h,
    isTS: c,
    inSSR: d,
    source: i.loc.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: !1,
    map: void 0,
    helper(O) {
      return `_${Js[O]}`;
    },
    push(O, m) {
      f.code += O;
    },
    indent() {
      p(++f.indentLevel);
    },
    deindent(O = !1) {
      O ? --f.indentLevel : p(--f.indentLevel);
    },
    newline() {
      p(f.indentLevel);
    }
  };
  function p(O) {
    f.push(`
` + "  ".repeat(O));
  }
  return f;
}
function qL(i, e = {}) {
  const t = JE(i, e);
  e.onContextCreated && e.onContextCreated(t);
  const {
    mode: r,
    push: o,
    prefixIdentifiers: s,
    indent: n,
    deindent: a,
    newline: l,
    scopeId: u,
    ssr: h
  } = t, c = Array.from(i.helpers), d = c.length > 0, f = !s && r !== "module", p = !1, O = p ? JE(i, e) : t;
  jL(i, O);
  const m = h ? "ssrRender" : "render", g = (h ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"]).join(", ");
  if (o(`function ${m}(${g}) {`), n(), f && (o("with (_ctx) {"), n(), d && (o(`const { ${c.map(QR).join(", ")} } = _Vue`), o(`
`), l())), i.components.length && (mc(i.components, "component", t), (i.directives.length || i.temps > 0) && l()), i.directives.length && (mc(i.directives, "directive", t), i.temps > 0 && l()), i.filters && i.filters.length && (l(), mc(i.filters, "filter", t), l()), i.temps > 0) {
    o("let ");
    for (let A = 0; A < i.temps; A++)
      o(`${A > 0 ? ", " : ""}_temp${A}`);
  }
  return (i.components.length || i.directives.length || i.temps) && (o(`
`), l()), h || o("return "), i.codegenNode ? Lt(i.codegenNode, t) : o("null"), f && (a(), o("}")), a(), o("}"), {
    ast: i,
    code: t.code,
    preamble: p ? O.code : "",
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: t.map ? t.map.toJSON() : void 0
  };
}
function jL(i, e) {
  const {
    ssr: t,
    prefixIdentifiers: r,
    push: o,
    newline: s,
    runtimeModuleName: n,
    runtimeGlobalName: a,
    ssrRuntimeModuleName: l
  } = e, u = a, h = Array.from(i.helpers);
  if (h.length > 0 && (o(`const _Vue = ${u}
`), i.hoists.length)) {
    const c = [
      Lp,
      wp,
      Fa,
      yp,
      RR
    ].filter((d) => h.includes(d)).map(QR).join(", ");
    o(`const { ${c} } = _Vue
`);
  }
  KL(i.hoists, e), s(), o("return ");
}
function mc(i, e, { helper: t, push: r, newline: o, isTS: s }) {
  const n = t(
    e === "filter" ? Mp : e === "component" ? Dp : xp
  );
  for (let a = 0; a < i.length; a++) {
    let l = i[a];
    const u = l.endsWith("__self");
    u && (l = l.slice(0, -6)), r(
      `const ${Ia(l, e)} = ${n}(${JSON.stringify(l)}${u ? ", true" : ""})${s ? "!" : ""}`
    ), a < i.length - 1 && o();
  }
}
function KL(i, e) {
  if (!i.length)
    return;
  e.pure = !0;
  const { push: t, newline: r, helper: o, scopeId: s, mode: n } = e;
  r();
  for (let a = 0; a < i.length; a++) {
    const l = i[a];
    l && (t(
      `const _hoisted_${a + 1} = `
    ), Lt(l, e), r());
  }
  e.pure = !1;
}
function JL(i) {
  return he(i) || i.type === 4 || i.type === 2 || i.type === 5 || i.type === 8;
}
function Fp(i, e) {
  const t = i.length > 3 || {}.NODE_ENV !== "production" && i.some((r) => W(r) || !JL(r));
  e.push("["), t && e.indent(), Za(i, e, t), t && e.deindent(), e.push("]");
}
function Za(i, e, t = !1, r = !0) {
  const { push: o, newline: s } = e;
  for (let n = 0; n < i.length; n++) {
    const a = i[n];
    he(a) ? o(a) : W(a) ? Fp(a, e) : Lt(a, e), n < i.length - 1 && (t ? (r && o(","), s()) : r && o(", "));
  }
}
function Lt(i, e) {
  if (he(i)) {
    e.push(i);
    return;
  }
  if (uo(i)) {
    e.push(e.helper(i));
    return;
  }
  switch (i.type) {
    case 1:
    case 9:
    case 11:
      ({}).NODE_ENV !== "production" && WE(
        i.codegenNode != null,
        "Codegen node is missing for element/if/for node. Apply appropriate transforms first."
      ), Lt(i.codegenNode, e);
      break;
    case 2:
      ew(i, e);
      break;
    case 4:
      kR(i, e);
      break;
    case 5:
      tw(i, e);
      break;
    case 12:
      Lt(i.codegenNode, e);
      break;
    case 8:
      $R(i, e);
      break;
    case 3:
      rw(i, e);
      break;
    case 13:
      ow(i, e);
      break;
    case 14:
      nw(i, e);
      break;
    case 15:
      aw(i, e);
      break;
    case 17:
      lw(i, e);
      break;
    case 18:
      uw(i, e);
      break;
    case 19:
      hw(i, e);
      break;
    case 20:
      cw(i, e);
      break;
    case 21:
      Za(i.body, e, !0, !1);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if ({}.NODE_ENV !== "production")
        return WE(!1, `unhandled codegen node type: ${i.type}`), i;
  }
}
function ew(i, e) {
  e.push(JSON.stringify(i.content), i);
}
function kR(i, e) {
  const { content: t, isStatic: r } = i;
  e.push(r ? JSON.stringify(t) : t, i);
}
function tw(i, e) {
  const { push: t, helper: r, pure: o } = e;
  o && t(Mh), t(`${r(wh)}(`), Lt(i.content, e), t(")");
}
function $R(i, e) {
  for (let t = 0; t < i.children.length; t++) {
    const r = i.children[t];
    he(r) ? e.push(r) : Lt(r, e);
  }
}
function iw(i, e) {
  const { push: t } = e;
  if (i.type === 8)
    t("["), $R(i, e), t("]");
  else if (i.isStatic) {
    const r = Yp(i.content) ? i.content : JSON.stringify(i.content);
    t(r, i);
  } else
    t(`[${i.content}]`, i);
}
function rw(i, e) {
  const { push: t, helper: r, pure: o } = e;
  o && t(Mh), t(`${r(Fa)}(${JSON.stringify(i.content)})`, i);
}
function ow(i, e) {
  const { push: t, helper: r, pure: o } = e, {
    tag: s,
    props: n,
    children: a,
    patchFlag: l,
    dynamicProps: u,
    directives: h,
    isBlock: c,
    disableTracking: d,
    isComponent: f
  } = i;
  h && t(r(Up) + "("), c && t(`(${r(Ko)}(${d ? "true" : ""}), `), o && t(Mh);
  const p = c ? rn(e.inSSR, f) : tn(e.inSSR, f);
  t(r(p) + "(", i), Za(
    sw([s, n, a, l, u]),
    e
  ), t(")"), c && t(")"), h && (t(", "), Lt(h, e), t(")"));
}
function sw(i) {
  let e = i.length;
  for (; e-- && i[e] == null; )
    ;
  return i.slice(0, e + 1).map((t) => t || "null");
}
function nw(i, e) {
  const { push: t, helper: r, pure: o } = e, s = he(i.callee) ? i.callee : r(i.callee);
  o && t(Mh), t(s + "(", i), Za(i.arguments, e), t(")");
}
function aw(i, e) {
  const { push: t, indent: r, deindent: o, newline: s } = e, { properties: n } = i;
  if (!n.length) {
    t("{}", i);
    return;
  }
  const a = n.length > 1 || {}.NODE_ENV !== "production" && n.some((l) => l.value.type !== 4);
  t(a ? "{" : "{ "), a && r();
  for (let l = 0; l < n.length; l++) {
    const { key: u, value: h } = n[l];
    iw(u, e), t(": "), Lt(h, e), l < n.length - 1 && (t(","), s());
  }
  a && o(), t(a ? "}" : " }");
}
function lw(i, e) {
  Fp(i.elements, e);
}
function uw(i, e) {
  const { push: t, indent: r, deindent: o } = e, { params: s, returns: n, body: a, newline: l, isSlot: u } = i;
  u && t(`_${Js[Vp]}(`), t("(", i), W(s) ? Za(s, e) : s && Lt(s, e), t(") => "), (l || a) && (t("{"), r()), n ? (l && t("return "), W(n) ? Fp(n, e) : Lt(n, e)) : a && Lt(a, e), (l || a) && (o(), t("}")), u && (i.isNonScopedSlot && t(", undefined, true"), t(")"));
}
function hw(i, e) {
  const { test: t, consequent: r, alternate: o, newline: s } = i, { push: n, indent: a, deindent: l, newline: u } = e;
  if (t.type === 4) {
    const c = !Yp(t.content);
    c && n("("), kR(t, e), c && n(")");
  } else
    n("("), Lt(t, e), n(")");
  s && a(), e.indentLevel++, s || n(" "), n("? "), Lt(r, e), e.indentLevel--, s && u(), s || n(" "), n(": ");
  const h = o.type === 19;
  h || e.indentLevel++, Lt(o, e), h || e.indentLevel--, s && l(
    !0
    /* without newline */
  );
}
function cw(i, e) {
  const { push: t, helper: r, indent: o, deindent: s, newline: n } = e;
  t(`_cache[${i.index}] || (`), i.isVNode && (o(), t(`${r(Au)}(-1),`), n()), t(`_cache[${i.index}] = `), Lt(i.value, e), i.isVNode && (t(","), n(), t(`${r(Au)}(1),`), n(), t(`_cache[${i.index}]`), s()), t(")");
}
const dw = new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
), fw = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
function ko(i, e, t = !1, r = !1) {
  const o = i.content;
  if (o.trim())
    try {
      new Function(
        r ? ` ${o} ` : `return ${t ? `(${o}) => {}` : `(${o})`}`
      );
    } catch (s) {
      let n = s.message;
      const a = o.replace(fw, "").match(dw);
      a && (n = `avoid using JavaScript keyword as property name: "${a[0]}"`), e.onError(
        Ie(
          45,
          i.loc,
          void 0,
          n
        )
      );
    }
}
const pw = (i, e) => {
  if (i.type === 5)
    i.content = gc(
      i.content,
      e
    );
  else if (i.type === 1)
    for (let t = 0; t < i.props.length; t++) {
      const r = i.props[t];
      if (r.type === 7 && r.name !== "for") {
        const o = r.exp, s = r.arg;
        o && o.type === 4 && !(r.name === "on" && s) && (r.exp = gc(
          o,
          e,
          // slot args must be processed as function params
          r.name === "slot"
        )), s && s.type === 4 && !s.isStatic && (r.arg = gc(s, e));
      }
    }
};
function gc(i, e, t = !1, r = !1, o = Object.create(e.identifiers)) {
  return {}.NODE_ENV !== "production" && ko(i, e, t, r), i;
}
const Ow = UR(
  /^(if|else|else-if)$/,
  (i, e, t) => Ew(i, e, t, (r, o, s) => {
    const n = t.parent.children;
    let a = n.indexOf(r), l = 0;
    for (; a-- >= 0; ) {
      const u = n[a];
      u && u.type === 9 && (l += u.branches.length);
    }
    return () => {
      if (s)
        r.codegenNode = tm(
          o,
          l,
          t
        );
      else {
        const u = gw(r.codegenNode);
        u.alternate = tm(
          o,
          l + r.branches.length - 1,
          t
        );
      }
    };
  })
);
function Ew(i, e, t, r) {
  if (e.name !== "else" && (!e.exp || !e.exp.content.trim())) {
    const o = e.exp ? e.exp.loc : i.loc;
    t.onError(
      Ie(28, e.loc)
    ), e.exp = me("true", !1, o);
  }
  if ({}.NODE_ENV !== "production" && e.exp && ko(e.exp, t), e.name === "if") {
    const o = em(i, e), s = {
      type: 9,
      loc: i.loc,
      branches: [o]
    };
    if (t.replaceNode(s), r)
      return r(s, o, !0);
  } else {
    const o = t.parent.children, s = [];
    let n = o.indexOf(i);
    for (; n-- >= -1; ) {
      const a = o[n];
      if (a && a.type === 3) {
        t.removeNode(a), {}.NODE_ENV !== "production" && s.unshift(a);
        continue;
      }
      if (a && a.type === 2 && !a.content.trim().length) {
        t.removeNode(a);
        continue;
      }
      if (a && a.type === 9) {
        e.name === "else-if" && a.branches[a.branches.length - 1].condition === void 0 && t.onError(
          Ie(30, i.loc)
        ), t.removeNode();
        const l = em(i, e);
        if ({}.NODE_ENV !== "production" && s.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(t.parent && t.parent.type === 1 && Uo(t.parent.tag, "transition")) && (l.children = [...s, ...l.children]), {}.NODE_ENV !== "production") {
          const h = l.userKey;
          h && a.branches.forEach(({ userKey: c }) => {
            mw(c, h) && t.onError(
              Ie(
                29,
                l.userKey.loc
              )
            );
          });
        }
        a.branches.push(l);
        const u = r && r(a, l, !1);
        xh(l, t), u && u(), t.currentNode = null;
      } else
        t.onError(
          Ie(30, i.loc)
        );
      break;
    }
  }
}
function em(i, e) {
  const t = i.tagType === 3;
  return {
    type: 10,
    loc: i.loc,
    condition: e.name === "else" ? void 0 : e.exp,
    children: t && !Ei(i, "for") ? i.children : [i],
    userKey: on(i, "key"),
    isTemplateIf: t
  };
}
function tm(i, e, t) {
  return i.condition ? xd(
    i.condition,
    im(i, e, t),
    // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    tt(t.helper(Fa), [
      {}.NODE_ENV !== "production" ? '"v-if"' : '""',
      "true"
    ])
  ) : im(i, e, t);
}
function im(i, e, t) {
  const { helper: r } = t, o = We(
    "key",
    me(
      `${e}`,
      !1,
      pi,
      2
    )
  ), { children: s } = i, n = s[0];
  if (s.length !== 1 || n.type !== 1)
    if (s.length === 1 && n.type === 11) {
      const l = n.codegenNode;
      return _u(l, o, t), l;
    } else {
      let l = 64, u = rr[64];
      return {}.NODE_ENV !== "production" && !i.isTemplateIf && s.filter((h) => h.type !== 3).length === 1 && (l |= 2048, u += `, ${rr[2048]}`), Na(
        t,
        r(Aa),
        gi([o]),
        s,
        l + ({}.NODE_ENV !== "production" ? ` /* ${u} */` : ""),
        void 0,
        void 0,
        !0,
        !1,
        !1,
        i.loc
      );
    }
  else {
    const l = n.codegenNode, u = PL(l);
    return u.type === 13 && Xp(u, t), _u(u, o, t), l;
  }
}
function mw(i, e) {
  if (!i || i.type !== e.type)
    return !1;
  if (i.type === 6) {
    if (i.value.content !== e.value.content)
      return !1;
  } else {
    const t = i.exp, r = e.exp;
    if (t.type !== r.type || t.type !== 4 || t.isStatic !== r.isStatic || t.content !== r.content)
      return !1;
  }
  return !0;
}
function gw(i) {
  for (; ; )
    if (i.type === 19)
      if (i.alternate.type === 19)
        i = i.alternate;
      else
        return i;
    else
      i.type === 20 && (i = i.value);
}
const bw = UR(
  "for",
  (i, e, t) => {
    const { helper: r, removeHelper: o } = t;
    return Tw(i, e, t, (s) => {
      const n = tt(r(Qp), [
        s.source
      ]), a = Iu(i), l = Ei(i, "memo"), u = on(i, "key"), h = u && (u.type === 6 ? me(u.value.content, !0) : u.exp), c = u ? We("key", h) : null, d = s.source.type === 4 && s.source.constType > 0, f = d ? 64 : u ? 128 : 256;
      return s.codegenNode = Na(
        t,
        r(Aa),
        void 0,
        n,
        f + ({}.NODE_ENV !== "production" ? ` /* ${rr[f]} */` : ""),
        void 0,
        void 0,
        !0,
        !d,
        !1,
        i.loc
      ), () => {
        let p;
        const { children: O } = s;
        ({}).NODE_ENV !== "production" && a && i.children.some((g) => {
          if (g.type === 1) {
            const A = on(g, "key");
            if (A)
              return t.onError(
                Ie(
                  33,
                  A.loc
                )
              ), !0;
          }
        });
        const m = O.length !== 1 || O[0].type !== 1, E = vu(i) ? i : a && i.children.length === 1 && vu(i.children[0]) ? i.children[0] : null;
        if (E ? (p = E.codegenNode, a && c && _u(p, c, t)) : m ? p = Na(
          t,
          r(Aa),
          c ? gi([c]) : void 0,
          i.children,
          64 + ({}.NODE_ENV !== "production" ? ` /* ${rr[64]} */` : ""),
          void 0,
          void 0,
          !0,
          void 0,
          !1
          /* isComponent */
        ) : (p = O[0].codegenNode, a && c && _u(p, c, t), p.isBlock !== !d && (p.isBlock ? (o(Ko), o(
          rn(t.inSSR, p.isComponent)
        )) : o(
          tn(t.inSSR, p.isComponent)
        )), p.isBlock = !d, p.isBlock ? (r(Ko), r(rn(t.inSSR, p.isComponent))) : r(tn(t.inSSR, p.isComponent))), l) {
          const g = en(
            kd(s.parseResult, [
              me("_cached")
            ])
          );
          g.body = TL([
            Ui(["const _memo = (", l.exp, ")"]),
            Ui([
              "if (_cached",
              ...h ? [" && _cached.key === ", h] : [],
              ` && ${t.helperString(
                NR
              )}(_cached, _memo)) return _cached`
            ]),
            Ui(["const _item = ", p]),
            me("_item.memo = _memo"),
            me("return _item")
          ]), n.arguments.push(
            g,
            me("_cache"),
            me(String(t.cached++))
          );
        } else
          n.arguments.push(
            en(
              kd(s.parseResult),
              p,
              !0
              /* force newline */
            )
          );
      };
    });
  }
);
function Tw(i, e, t, r) {
  if (!e.exp) {
    t.onError(
      Ie(31, e.loc)
    );
    return;
  }
  const o = GR(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    e.exp,
    t
  );
  if (!o) {
    t.onError(
      Ie(32, e.loc)
    );
    return;
  }
  const { addIdentifiers: s, removeIdentifiers: n, scopes: a } = t, { source: l, value: u, key: h, index: c } = o, d = {
    type: 11,
    loc: e.loc,
    source: l,
    valueAlias: u,
    keyAlias: h,
    objectIndexAlias: c,
    parseResult: o,
    children: Iu(i) ? i.children : [i]
  };
  t.replaceNode(d), a.vFor++;
  const f = r && r(d);
  return () => {
    a.vFor--, f && f();
  };
}
const Sw = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, rm = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, Rw = /^\(|\)$/g;
function GR(i, e) {
  const t = i.loc, r = i.content, o = r.match(Sw);
  if (!o)
    return;
  const [, s, n] = o, a = {
    source: ml(
      t,
      n.trim(),
      r.indexOf(n, s.length)
    ),
    value: void 0,
    key: void 0,
    index: void 0
  };
  ({}).NODE_ENV !== "production" && ko(a.source, e);
  let l = s.trim().replace(Rw, "").trim();
  const u = s.indexOf(l), h = l.match(rm);
  if (h) {
    l = l.replace(rm, "").trim();
    const c = h[1].trim();
    let d;
    if (c && (d = r.indexOf(c, u + l.length), a.key = ml(t, c, d), {}.NODE_ENV !== "production" && ko(
      a.key,
      e,
      !0
    )), h[2]) {
      const f = h[2].trim();
      f && (a.index = ml(
        t,
        f,
        r.indexOf(
          f,
          a.key ? d + c.length : u + l.length
        )
      ), {}.NODE_ENV !== "production" && ko(
        a.index,
        e,
        !0
      ));
    }
  }
  return l && (a.value = ml(t, l, u), {}.NODE_ENV !== "production" && ko(
    a.value,
    e,
    !0
  )), a;
}
function ml(i, e, t) {
  return me(
    e,
    !1,
    _R(i, t, e.length)
  );
}
function kd({ value: i, key: e, index: t }, r = []) {
  return Aw([i, e, t, ...r]);
}
function Aw(i) {
  let e = i.length;
  for (; e-- && !i[e]; )
    ;
  return i.slice(0, e + 1).map((t, r) => t || me("_".repeat(r + 1), !1));
}
const om = me("undefined", !1), Cw = (i, e) => {
  if (i.type === 1 && (i.tagType === 1 || i.tagType === 3)) {
    const t = Ei(i, "slot");
    if (t)
      return t.exp, e.scopes.vSlot++, () => {
        e.scopes.vSlot--;
      };
  }
}, Nw = (i, e, t) => en(
  i,
  e,
  !1,
  !0,
  e.length ? e[0].loc : t
);
function Iw(i, e, t = Nw) {
  e.helper(Vp);
  const { children: r, loc: o } = i, s = [], n = [];
  let a = e.scopes.vSlot > 0 || e.scopes.vFor > 0;
  const l = Ei(i, "slot", !0);
  if (l) {
    const { arg: m, exp: E } = l;
    m && !Bt(m) && (a = !0), s.push(
      We(
        m || me("default", !0),
        t(E, r, o)
      )
    );
  }
  let u = !1, h = !1;
  const c = [], d = /* @__PURE__ */ new Set();
  let f = 0;
  for (let m = 0; m < r.length; m++) {
    const E = r[m];
    let g;
    if (!Iu(E) || !(g = Ei(E, "slot", !0))) {
      E.type !== 3 && c.push(E);
      continue;
    }
    if (l) {
      e.onError(
        Ie(37, g.loc)
      );
      break;
    }
    u = !0;
    const { children: A, loc: S } = E, {
      arg: R = me("default", !0),
      exp: v,
      loc: I
    } = g;
    let C;
    Bt(R) ? C = R ? R.content : "default" : a = !0;
    const P = t(v, A, S);
    let w, x, _;
    if (w = Ei(E, "if"))
      a = !0, n.push(
        xd(
          w.exp,
          gl(R, P, f++),
          om
        )
      );
    else if (x = Ei(
      E,
      /^else(-if)?$/,
      !0
      /* allowEmpty */
    )) {
      let X = m, G;
      for (; X-- && (G = r[X], G.type === 3); )
        ;
      if (G && Iu(G) && Ei(G, "if")) {
        r.splice(m, 1), m--;
        let ee = n[n.length - 1];
        for (; ee.alternate.type === 19; )
          ee = ee.alternate;
        ee.alternate = x.exp ? xd(
          x.exp,
          gl(
            R,
            P,
            f++
          ),
          om
        ) : gl(R, P, f++);
      } else
        e.onError(
          Ie(30, x.loc)
        );
    } else if (_ = Ei(E, "for")) {
      a = !0;
      const X = _.parseResult || GR(_.exp, e);
      X ? n.push(
        tt(e.helper(Qp), [
          X.source,
          en(
            kd(X),
            gl(R, P),
            !0
            /* force newline */
          )
        ])
      ) : e.onError(
        Ie(32, _.loc)
      );
    } else {
      if (C) {
        if (d.has(C)) {
          e.onError(
            Ie(
              38,
              I
            )
          );
          continue;
        }
        d.add(C), C === "default" && (h = !0);
      }
      s.push(We(R, P));
    }
  }
  if (!l) {
    const m = (E, g) => {
      const A = t(E, g, o);
      return e.compatConfig && (A.isNonScopedSlot = !0), We("default", A);
    };
    u ? c.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    c.some((E) => VR(E)) && (h ? e.onError(
      Ie(
        39,
        c[0].loc
      )
    ) : s.push(
      m(void 0, c)
    )) : s.push(m(void 0, r));
  }
  const p = a ? 2 : Bl(i.children) ? 3 : 1;
  let O = gi(
    s.concat(
      We(
        "_",
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        me(
          p + ({}.NODE_ENV !== "production" ? ` /* ${gv[p]} */` : ""),
          !1
        )
      )
    ),
    o
  );
  return n.length && (O = tt(e.helper(CR), [
    O,
    za(n)
  ])), {
    slots: O,
    hasDynamicSlots: a
  };
}
function gl(i, e, t) {
  const r = [
    We("name", i),
    We("fn", e)
  ];
  return t != null && r.push(
    We("key", me(String(t), !0))
  ), gi(r);
}
function Bl(i) {
  for (let e = 0; e < i.length; e++) {
    const t = i[e];
    switch (t.type) {
      case 1:
        if (t.tagType === 2 || Bl(t.children))
          return !0;
        break;
      case 9:
        if (Bl(t.branches))
          return !0;
        break;
      case 10:
      case 11:
        if (Bl(t.children))
          return !0;
        break;
    }
  }
  return !1;
}
function VR(i) {
  return i.type !== 2 && i.type !== 12 ? !0 : i.type === 2 ? !!i.content.trim() : VR(i.content);
}
const HR = /* @__PURE__ */ new WeakMap(), vw = (i, e) => function() {
  if (i = e.currentNode, !(i.type === 1 && (i.tagType === 0 || i.tagType === 1)))
    return;
  const { tag: r, props: o } = i, s = i.tagType === 1;
  let n = s ? _w(i, e) : `"${r}"`;
  const a = Se(n) && n.callee === Su;
  let l, u, h, c = 0, d, f, p, O = (
    // dynamic component may resolve to plain elements
    a || n === sa || n === Pp || !s && // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    (r === "svg" || r === "foreignObject")
  );
  if (o.length > 0) {
    const m = XR(
      i,
      e,
      void 0,
      s,
      a
    );
    l = m.props, c = m.patchFlag, f = m.dynamicPropNames;
    const E = m.directives;
    p = E && E.length ? za(
      E.map((g) => Lw(g, e))
    ) : void 0, m.shouldUseBlock && (O = !0);
  }
  if (i.children.length > 0)
    if (n === Tu && (O = !0, c |= 1024, {}.NODE_ENV !== "production" && i.children.length > 1 && e.onError(
      Ie(46, {
        start: i.children[0].loc.start,
        end: i.children[i.children.length - 1].loc.end,
        source: ""
      })
    )), s && // Teleport is not a real component and has dedicated runtime handling
    n !== sa && // explained above.
    n !== Tu) {
      const { slots: E, hasDynamicSlots: g } = Iw(i, e);
      u = E, g && (c |= 1024);
    } else if (i.children.length === 1 && n !== sa) {
      const E = i.children[0], g = E.type, A = g === 5 || g === 8;
      A && bi(E, e) === 0 && (c |= 1), A || g === 2 ? u = E : u = i.children;
    } else
      u = i.children;
  if (c !== 0) {
    if ({}.NODE_ENV !== "production")
      if (c < 0)
        h = c + ` /* ${rr[c]} */`;
      else {
        const m = Object.keys(rr).map(Number).filter((E) => E > 0 && c & E).map((E) => rr[E]).join(", ");
        h = c + ` /* ${m} */`;
      }
    else
      h = String(c);
    f && f.length && (d = ww(f));
  }
  i.codegenNode = Na(
    e,
    n,
    l,
    u,
    h,
    d,
    p,
    !!O,
    !1,
    s,
    i.loc
  );
};
function _w(i, e, t = !1) {
  let { tag: r } = i;
  const o = $d(r), s = on(i, "is");
  if (s)
    if (o || oo(
      "COMPILER_IS_ON_ELEMENT",
      e
    )) {
      const l = s.type === 6 ? s.value && me(s.value.content, !0) : s.exp;
      if (l)
        return tt(e.helper(Su), [
          l
        ]);
    } else
      s.type === 6 && s.value.content.startsWith("vue:") && (r = s.value.content.slice(4));
  const n = !o && Ei(i, "is");
  if (n && n.exp)
    return {}.NODE_ENV !== "production" && e.onWarn(
      Ie(52, n.loc)
    ), tt(e.helper(Su), [
      n.exp
    ]);
  const a = IR(r) || e.isBuiltInComponent(r);
  return a ? (t || e.helper(a), a) : (e.helper(Dp), e.components.add(r), Ia(r, "component"));
}
function XR(i, e, t = i.props, r, o, s = !1) {
  const { tag: n, loc: a, children: l } = i;
  let u = [];
  const h = [], c = [], d = l.length > 0;
  let f = !1, p = 0, O = !1, m = !1, E = !1, g = !1, A = !1, S = !1;
  const R = [], v = (P) => {
    u.length && (h.push(
      gi(sm(u), a)
    ), u = []), P && h.push(P);
  }, I = ({ key: P, value: w }) => {
    if (Bt(P)) {
      const x = P.content, _ = Ar(x);
      if (_ && (!r || o) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      x.toLowerCase() !== "onclick" && // omit v-model handlers
      x !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !Ho(x) && (g = !0), _ && Ho(x) && (S = !0), w.type === 20 || (w.type === 4 || w.type === 8) && bi(w, e) > 0)
        return;
      x === "ref" ? O = !0 : x === "class" ? m = !0 : x === "style" ? E = !0 : x !== "key" && !R.includes(x) && R.push(x), r && (x === "class" || x === "style") && !R.includes(x) && R.push(x);
    } else
      A = !0;
  };
  for (let P = 0; P < t.length; P++) {
    const w = t[P];
    if (w.type === 6) {
      const { loc: x, name: _, value: X } = w;
      let G = !0;
      if (_ === "ref" && (O = !0, e.scopes.vFor > 0 && u.push(
        We(
          me("ref_for", !0),
          me("true")
        )
      )), _ === "is" && ($d(n) || X && X.content.startsWith("vue:") || oo(
        "COMPILER_IS_ON_ELEMENT",
        e
      )))
        continue;
      u.push(
        We(
          me(
            _,
            !0,
            _R(x, 0, _.length)
          ),
          me(
            X ? X.content : "",
            G,
            X ? X.loc : x
          )
        )
      );
    } else {
      const { name: x, arg: _, exp: X, loc: G } = w, ee = x === "bind", re = x === "on";
      if (x === "slot") {
        r || e.onError(
          Ie(40, G)
        );
        continue;
      }
      if (x === "once" || x === "memo" || x === "is" || ee && Qo(_, "is") && ($d(n) || oo(
        "COMPILER_IS_ON_ELEMENT",
        e
      )) || re && s)
        continue;
      if (
        // #938: elements with dynamic keys should be forced into blocks
        (ee && Qo(_, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        re && d && Qo(_, "vue:before-update")) && (f = !0), ee && Qo(_, "ref") && e.scopes.vFor > 0 && u.push(
          We(
            me("ref_for", !0),
            me("true")
          )
        ), !_ && (ee || re)
      ) {
        if (A = !0, X)
          if (ee) {
            if (v(), {}.NODE_ENV !== "production" && h.some((Ee) => Ee.type === 15 ? Ee.properties.some(({ key: ve }) => ve.type !== 4 || !ve.isStatic ? !0 : ve.content !== "class" && ve.content !== "style" && !Ar(ve.content)) : !0) && Jo(
              "COMPILER_V_BIND_OBJECT_ORDER",
              e,
              G
            ), oo(
              "COMPILER_V_BIND_OBJECT_ORDER",
              e
            )) {
              h.unshift(X);
              continue;
            }
            h.push(X);
          } else
            v({
              type: 14,
              loc: G,
              callee: e.helper(Gp),
              arguments: r ? [X] : [X, "true"]
            });
        else
          e.onError(
            Ie(
              ee ? 34 : 35,
              G
            )
          );
        continue;
      }
      const le = e.directiveTransforms[x];
      if (le) {
        const { props: oe, needRuntime: Ee } = le(w, i, e);
        !s && oe.forEach(I), re && _ && !Bt(_) ? v(gi(oe, a)) : u.push(...oe), Ee && (c.push(w), uo(Ee) && HR.set(w, Ee));
      } else
        TT(x) || (c.push(w), d && (f = !0));
    }
  }
  let C;
  if (h.length ? (v(), h.length > 1 ? C = tt(
    e.helper(Ru),
    h,
    a
  ) : C = h[0]) : u.length && (C = gi(
    sm(u),
    a
  )), A ? p |= 16 : (m && !r && (p |= 2), E && !r && (p |= 4), R.length && (p |= 8), g && (p |= 32)), !f && (p === 0 || p === 32) && (O || S || c.length > 0) && (p |= 512), !e.inSSR && C)
    switch (C.type) {
      case 15:
        let P = -1, w = -1, x = !1;
        for (let G = 0; G < C.properties.length; G++) {
          const ee = C.properties[G].key;
          Bt(ee) ? ee.content === "class" ? P = G : ee.content === "style" && (w = G) : ee.isHandlerKey || (x = !0);
        }
        const _ = C.properties[P], X = C.properties[w];
        x ? C = tt(
          e.helper(Ca),
          [C]
        ) : (_ && !Bt(_.value) && (_.value = tt(
          e.helper(kp),
          [_.value]
        )), X && // the static style is compiled into an object,
        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
        (E || X.value.type === 4 && X.value.content.trim()[0] === "[" || // v-bind:style and style both exist,
        // v-bind:style with static literal object
        X.value.type === 17) && (X.value = tt(
          e.helper($p),
          [X.value]
        )));
        break;
      case 14:
        break;
      default:
        C = tt(
          e.helper(Ca),
          [
            tt(e.helper(Wa), [
              C
            ])
          ]
        );
        break;
    }
  return {
    props: C,
    directives: c,
    patchFlag: p,
    dynamicPropNames: R,
    shouldUseBlock: f
  };
}
function sm(i) {
  const e = /* @__PURE__ */ new Map(), t = [];
  for (let r = 0; r < i.length; r++) {
    const o = i[r];
    if (o.key.type === 8 || !o.key.isStatic) {
      t.push(o);
      continue;
    }
    const s = o.key.content, n = e.get(s);
    n ? (s === "style" || s === "class" || Ar(s)) && Pw(n, o) : (e.set(s, o), t.push(o));
  }
  return t;
}
function Pw(i, e) {
  i.value.type === 17 ? i.value.elements.push(e.value) : i.value = za(
    [i.value, e.value],
    i.loc
  );
}
function Lw(i, e) {
  const t = [], r = HR.get(i);
  r ? t.push(e.helperString(r)) : (e.helper(xp), e.directives.add(i.name), t.push(Ia(i.name, "directive")));
  const { loc: o } = i;
  if (i.exp && t.push(i.exp), i.arg && (i.exp || t.push("void 0"), t.push(i.arg)), Object.keys(i.modifiers).length) {
    i.arg || (i.exp || t.push("void 0"), t.push("void 0"));
    const s = me("true", !1, o);
    t.push(
      gi(
        i.modifiers.map(
          (n) => We(n, s)
        ),
        o
      )
    );
  }
  return za(t, i.loc);
}
function ww(i) {
  let e = "[";
  for (let t = 0, r = i.length; t < r; t++)
    e += JSON.stringify(i[t]), t < r - 1 && (e += ", ");
  return e + "]";
}
function $d(i) {
  return i === "component" || i === "Component";
}
const yw = (i, e) => {
  if (vu(i)) {
    const { children: t, loc: r } = i, { slotName: o, slotProps: s } = Dw(i, e), n = [
      e.prefixIdentifiers ? "_ctx.$slots" : "$slots",
      o,
      "{}",
      "undefined",
      "true"
    ];
    let a = 2;
    s && (n[2] = s, a = 3), t.length && (n[3] = en([], t, !1, !1, r), a = 4), e.scopeId && !e.slotted && (a = 5), n.splice(a), i.codegenNode = tt(
      e.helper(AR),
      n,
      r
    );
  }
};
function Dw(i, e) {
  let t = '"default"', r;
  const o = [];
  for (let s = 0; s < i.props.length; s++) {
    const n = i.props[s];
    n.type === 6 ? n.value && (n.name === "name" ? t = JSON.stringify(n.value.content) : (n.name = ot(n.name), o.push(n))) : n.name === "bind" && Qo(n.arg, "name") ? n.exp && (t = n.exp) : (n.name === "bind" && n.arg && Bt(n.arg) && (n.arg.content = ot(n.arg.content)), o.push(n));
  }
  if (o.length > 0) {
    const { props: s, directives: n } = XR(
      i,
      e,
      o,
      !1,
      !1
    );
    r = s, n.length && e.onError(
      Ie(
        36,
        n[0].loc
      )
    );
  }
  return {
    slotName: t,
    slotProps: r
  };
}
const xw = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/, YR = (i, e, t, r) => {
  const { loc: o, modifiers: s, arg: n } = i;
  !i.exp && !s.length && t.onError(Ie(35, o));
  let a;
  if (n.type === 4)
    if (n.isStatic) {
      let c = n.content;
      ({}).NODE_ENV !== "production" && c.startsWith("vnode") && t.onWarn(
        Ie(51, n.loc)
      ), c.startsWith("vue:") && (c = `vnode-${c.slice(4)}`);
      const d = e.tagType !== 0 || c.startsWith("vnode") || !/[A-Z]/.test(c) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        zi(ot(c))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${c}`
      );
      a = me(d, !0, n.loc);
    } else
      a = Ui([
        `${t.helperString(Dd)}(`,
        n,
        ")"
      ]);
  else
    a = n, a.children.unshift(`${t.helperString(Dd)}(`), a.children.push(")");
  let l = i.exp;
  l && !l.content.trim() && (l = void 0);
  let u = t.cacheHandlers && !l && !t.inVOnce;
  if (l) {
    const c = vR(l.content), d = !(c || xw.test(l.content)), f = l.content.includes(";");
    ({}).NODE_ENV !== "production" && ko(
      l,
      t,
      !1,
      f
    ), (d || u && c) && (l = Ui([
      `${d ? "$event" : "(...args)"} => ${f ? "{" : "("}`,
      l,
      f ? "}" : ")"
    ]));
  }
  let h = {
    props: [
      We(
        a,
        l || me("() => {}", !1, o)
      )
    ]
  };
  return r && (h = r(h)), u && (h.props[0].value = t.cache(h.props[0].value)), h.props.forEach((c) => c.key.isHandlerKey = !0), h;
}, Mw = (i, e, t) => {
  const { exp: r, modifiers: o, loc: s } = i, n = i.arg;
  return n.type !== 4 ? (n.children.unshift("("), n.children.push(') || ""')) : n.isStatic || (n.content = `${n.content} || ""`), o.includes("camel") && (n.type === 4 ? n.isStatic ? n.content = ot(n.content) : n.content = `${t.helperString(yd)}(${n.content})` : (n.children.unshift(`${t.helperString(yd)}(`), n.children.push(")"))), t.inSSR || (o.includes("prop") && nm(n, "."), o.includes("attr") && nm(n, "^")), !r || r.type === 4 && !r.content.trim() ? (t.onError(Ie(34, s)), {
    props: [We(n, me("", !0, s))]
  }) : {
    props: [We(n, r)]
  };
}, nm = (i, e) => {
  i.type === 4 ? i.isStatic ? i.content = e + i.content : i.content = `\`${e}\${${i.content}}\`` : (i.children.unshift(`'${e}' + (`), i.children.push(")"));
}, Uw = (i, e) => {
  if (i.type === 0 || i.type === 1 || i.type === 11 || i.type === 10)
    return () => {
      const t = i.children;
      let r, o = !1;
      for (let s = 0; s < t.length; s++) {
        const n = t[s];
        if (Ec(n)) {
          o = !0;
          for (let a = s + 1; a < t.length; a++) {
            const l = t[a];
            if (Ec(l))
              r || (r = t[s] = Ui(
                [n],
                n.loc
              )), r.children.push(" + ", l), t.splice(a, 1), a--;
            else {
              r = void 0;
              break;
            }
          }
        }
      }
      if (!(!o || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      t.length === 1 && (i.type === 0 || i.type === 1 && i.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !i.props.find(
        (s) => s.type === 7 && !e.directiveTransforms[s.name]
      ) && i.tag !== "template")))
        for (let s = 0; s < t.length; s++) {
          const n = t[s];
          if (Ec(n) || n.type === 8) {
            const a = [];
            (n.type !== 2 || n.content !== " ") && a.push(n), !e.ssr && bi(n, e) === 0 && a.push(
              1 + ({}.NODE_ENV !== "production" ? ` /* ${rr[1]} */` : "")
            ), t[s] = {
              type: 12,
              content: n,
              loc: n.loc,
              codegenNode: tt(
                e.helper(yp),
                a
              )
            };
          }
        }
    };
}, am = /* @__PURE__ */ new WeakSet(), Qw = (i, e) => {
  if (i.type === 1 && Ei(i, "once", !0))
    return am.has(i) || e.inVOnce || e.inSSR ? void 0 : (am.add(i), e.inVOnce = !0, e.helper(Au), () => {
      e.inVOnce = !1;
      const t = e.currentNode;
      t.codegenNode && (t.codegenNode = e.cache(
        t.codegenNode,
        !0
        /* isVNode */
      ));
    });
}, BR = (i, e, t) => {
  const { exp: r, arg: o } = i;
  if (!r)
    return t.onError(
      Ie(41, i.loc)
    ), bl();
  const s = r.loc.source, n = r.type === 4 ? r.content : s, a = t.bindingMetadata[s];
  if (a === "props" || a === "props-aliased")
    return t.onError(Ie(44, r.loc)), bl();
  const l = !1;
  if (!n.trim() || !vR(n) && !l)
    return t.onError(
      Ie(42, r.loc)
    ), bl();
  const u = o || me("modelValue", !0), h = o ? Bt(o) ? `onUpdate:${ot(o.content)}` : Ui(['"onUpdate:" + ', o]) : "onUpdate:modelValue";
  let c;
  const d = t.isTS ? "($event: any)" : "$event";
  c = Ui([
    `${d} => ((`,
    r,
    ") = $event)"
  ]);
  const f = [
    // modelValue: foo
    We(u, i.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    We(h, c)
  ];
  if (i.modifiers.length && e.tagType === 1) {
    const p = i.modifiers.map((m) => (Yp(m) ? m : JSON.stringify(m)) + ": true").join(", "), O = o ? Bt(o) ? `${o.content}Modifiers` : Ui([o, ' + "Modifiers"']) : "modelModifiers";
    f.push(
      We(
        O,
        me(
          `{ ${p} }`,
          !1,
          i.loc,
          2
        )
      )
    );
  }
  return bl(f);
};
function bl(i = []) {
  return { props: i };
}
const kw = /[\w).+\-_$\]]/, $w = (i, e) => {
  oo("COMPILER_FILTER", e) && (i.type === 5 && Lu(i.content, e), i.type === 1 && i.props.forEach((t) => {
    t.type === 7 && t.name !== "for" && t.exp && Lu(t.exp, e);
  }));
};
function Lu(i, e) {
  if (i.type === 4)
    lm(i, e);
  else
    for (let t = 0; t < i.children.length; t++) {
      const r = i.children[t];
      typeof r == "object" && (r.type === 4 ? lm(r, e) : r.type === 8 ? Lu(i, e) : r.type === 5 && Lu(r.content, e));
    }
}
function lm(i, e) {
  const t = i.content;
  let r = !1, o = !1, s = !1, n = !1, a = 0, l = 0, u = 0, h = 0, c, d, f, p, O = [];
  for (f = 0; f < t.length; f++)
    if (d = c, c = t.charCodeAt(f), r)
      c === 39 && d !== 92 && (r = !1);
    else if (o)
      c === 34 && d !== 92 && (o = !1);
    else if (s)
      c === 96 && d !== 92 && (s = !1);
    else if (n)
      c === 47 && d !== 92 && (n = !1);
    else if (c === 124 && // pipe
    t.charCodeAt(f + 1) !== 124 && t.charCodeAt(f - 1) !== 124 && !a && !l && !u)
      p === void 0 ? (h = f + 1, p = t.slice(0, f).trim()) : m();
    else {
      switch (c) {
        case 34:
          o = !0;
          break;
        case 39:
          r = !0;
          break;
        case 96:
          s = !0;
          break;
        case 40:
          u++;
          break;
        case 41:
          u--;
          break;
        case 91:
          l++;
          break;
        case 93:
          l--;
          break;
        case 123:
          a++;
          break;
        case 125:
          a--;
          break;
      }
      if (c === 47) {
        let E = f - 1, g;
        for (; E >= 0 && (g = t.charAt(E), g === " "); E--)
          ;
        (!g || !kw.test(g)) && (n = !0);
      }
    }
  p === void 0 ? p = t.slice(0, f).trim() : h !== 0 && m();
  function m() {
    O.push(t.slice(h, f).trim()), h = f + 1;
  }
  if (O.length) {
    for ({}.NODE_ENV !== "production" && yh(
      "COMPILER_FILTER",
      e,
      i.loc
    ), f = 0; f < O.length; f++)
      p = Gw(p, O[f], e);
    i.content = p;
  }
}
function Gw(i, e, t) {
  t.helper(Mp);
  const r = e.indexOf("(");
  if (r < 0)
    return t.filters.add(e), `${Ia(e, "filter")}(${i})`;
  {
    const o = e.slice(0, r), s = e.slice(r + 1);
    return t.filters.add(o), `${Ia(o, "filter")}(${i}${s !== ")" ? "," + s : s}`;
  }
}
const um = /* @__PURE__ */ new WeakSet(), Vw = (i, e) => {
  if (i.type === 1) {
    const t = Ei(i, "memo");
    return !t || um.has(i) ? void 0 : (um.add(i), () => {
      const r = i.codegenNode || e.currentNode.codegenNode;
      r && r.type === 13 && (i.tagType !== 1 && Xp(r, e), i.codegenNode = tt(e.helper(Hp), [
        t.exp,
        en(void 0, r),
        "_cache",
        String(e.cached++)
      ]));
    });
  }
};
function Hw(i) {
  return [
    [
      Qw,
      Ow,
      Vw,
      bw,
      $w,
      ...{}.NODE_ENV !== "production" ? [pw] : [],
      yw,
      vw,
      Cw,
      Uw
    ],
    {
      on: YR,
      bind: Mw,
      model: BR
    }
  ];
}
function Xw(i, e = {}) {
  const t = e.onError || _p, r = e.mode === "module";
  e.prefixIdentifiers === !0 ? t(Ie(47)) : r && t(Ie(48));
  const o = !1;
  e.cacheHandlers && t(Ie(49)), e.scopeId && !r && t(Ie(50));
  const s = he(i) ? DL(i, e) : i, [n, a] = Hw();
  return WL(
    s,
    pe({}, e, {
      prefixIdentifiers: o,
      nodeTransforms: [
        ...n,
        ...e.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: pe(
        {},
        a,
        e.directiveTransforms || {}
        // user transforms
      )
    })
  ), qL(
    s,
    pe({}, e, {
      prefixIdentifiers: o
    })
  );
}
const Yw = () => ({ props: [] }), FR = Symbol({}.NODE_ENV !== "production" ? "vModelRadio" : ""), WR = Symbol({}.NODE_ENV !== "production" ? "vModelCheckbox" : ""), zR = Symbol({}.NODE_ENV !== "production" ? "vModelText" : ""), ZR = Symbol({}.NODE_ENV !== "production" ? "vModelSelect" : ""), Gd = Symbol({}.NODE_ENV !== "production" ? "vModelDynamic" : ""), qR = Symbol({}.NODE_ENV !== "production" ? "vOnModifiersGuard" : ""), jR = Symbol({}.NODE_ENV !== "production" ? "vOnKeysGuard" : ""), KR = Symbol({}.NODE_ENV !== "production" ? "vShow" : ""), Wp = Symbol({}.NODE_ENV !== "production" ? "Transition" : ""), JR = Symbol({}.NODE_ENV !== "production" ? "TransitionGroup" : "");
mL({
  [FR]: "vModelRadio",
  [WR]: "vModelCheckbox",
  [zR]: "vModelText",
  [ZR]: "vModelSelect",
  [Gd]: "vModelDynamic",
  [qR]: "withModifiers",
  [jR]: "withKeys",
  [KR]: "vShow",
  [Wp]: "Transition",
  [JR]: "TransitionGroup"
});
let Rs;
function Bw(i, e = !1) {
  return Rs || (Rs = document.createElement("div")), e ? (Rs.innerHTML = `<div foo="${i.replace(/"/g, "&quot;")}">`, Rs.children[0].getAttribute("foo")) : (Rs.innerHTML = i, Rs.textContent);
}
const Fw = /* @__PURE__ */ wt(
  "style,iframe,script,noscript",
  !0
), Ww = {
  isVoidTag: Pv,
  isNativeTag: (i) => RT(i) || AT(i),
  isPreTag: (i) => i === "pre",
  decodeEntities: Bw,
  isBuiltInComponent: (i) => {
    if (Uo(i, "Transition"))
      return Wp;
    if (Uo(i, "TransitionGroup"))
      return JR;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(i, e) {
    let t = e ? e.ns : 0;
    if (e && t === 2)
      if (e.tag === "annotation-xml") {
        if (i === "svg")
          return 1;
        e.props.some(
          (r) => r.type === 6 && r.name === "encoding" && r.value != null && (r.value.content === "text/html" || r.value.content === "application/xhtml+xml")
        ) && (t = 0);
      } else
        /^m(?:[ions]|text)$/.test(e.tag) && i !== "mglyph" && i !== "malignmark" && (t = 0);
    else
      e && t === 1 && (e.tag === "foreignObject" || e.tag === "desc" || e.tag === "title") && (t = 0);
    if (t === 0) {
      if (i === "svg")
        return 1;
      if (i === "math")
        return 2;
    }
    return t;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode({ tag: i, ns: e }) {
    if (e === 0) {
      if (i === "textarea" || i === "title")
        return 1;
      if (Fw(i))
        return 2;
    }
    return 0;
  }
}, zw = (i) => {
  i.type === 1 && i.props.forEach((e, t) => {
    e.type === 6 && e.name === "style" && e.value && (i.props[t] = {
      type: 7,
      name: "bind",
      arg: me("style", !0, e.loc),
      exp: Zw(e.value.content, e.loc),
      modifiers: [],
      loc: e.loc
    });
  });
}, Zw = (i, e) => {
  const t = ST(i);
  return me(
    JSON.stringify(t),
    !1,
    e,
    3
  );
};
function yi(i, e) {
  return Ie(
    i,
    e,
    {}.NODE_ENV !== "production" ? qw : void 0
  );
}
const qw = {
  [53]: "v-html is missing expression.",
  [54]: "v-html will override element children.",
  [55]: "v-text is missing expression.",
  [56]: "v-text will override element children.",
  [57]: "v-model can only be used on <input>, <textarea> and <select> elements.",
  [58]: "v-model argument is not supported on plain elements.",
  [59]: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",
  [60]: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
  [61]: "v-show is missing expression.",
  [62]: "<Transition> expects exactly one child element or component.",
  [63]: "Tags with side effect (<script> and <style>) are ignored in client component templates."
}, jw = (i, e, t) => {
  const { exp: r, loc: o } = i;
  return r || t.onError(
    yi(53, o)
  ), e.children.length && (t.onError(
    yi(54, o)
  ), e.children.length = 0), {
    props: [
      We(
        me("innerHTML", !0, o),
        r || me("", !0)
      )
    ]
  };
}, Kw = (i, e, t) => {
  const { exp: r, loc: o } = i;
  return r || t.onError(
    yi(55, o)
  ), e.children.length && (t.onError(
    yi(56, o)
  ), e.children.length = 0), {
    props: [
      We(
        me("textContent", !0),
        r ? bi(r, t) > 0 ? r : tt(
          t.helperString(wh),
          [r],
          o
        ) : me("", !0)
      )
    ]
  };
}, Jw = (i, e, t) => {
  const r = BR(i, e, t);
  if (!r.props.length || e.tagType === 1)
    return r;
  i.arg && t.onError(
    yi(
      58,
      i.arg.loc
    )
  );
  function o() {
    const a = on(e, "value");
    a && t.onError(
      yi(
        60,
        a.loc
      )
    );
  }
  const { tag: s } = e, n = t.isCustomElement(s);
  if (s === "input" || s === "textarea" || s === "select" || n) {
    let a = zR, l = !1;
    if (s === "input" || n) {
      const u = on(e, "type");
      if (u) {
        if (u.type === 7)
          a = Gd;
        else if (u.value)
          switch (u.value.content) {
            case "radio":
              a = FR;
              break;
            case "checkbox":
              a = WR;
              break;
            case "file":
              l = !0, t.onError(
                yi(
                  59,
                  i.loc
                )
              );
              break;
            default:
              ({}).NODE_ENV !== "production" && o();
              break;
          }
      } else
        IL(e) ? a = Gd : {}.NODE_ENV !== "production" && o();
    } else
      s === "select" ? a = ZR : {}.NODE_ENV !== "production" && o();
    l || (r.needRuntime = t.helper(a));
  } else
    t.onError(
      yi(
        57,
        i.loc
      )
    );
  return r.props = r.props.filter(
    (a) => !(a.key.type === 4 && a.key.content === "modelValue")
  ), r;
}, ey = /* @__PURE__ */ wt("passive,once,capture"), ty = /* @__PURE__ */ wt(
  // event propagation management
  "stop,prevent,self,ctrl,shift,alt,meta,exact,middle"
), iy = /* @__PURE__ */ wt("left,right"), eA = /* @__PURE__ */ wt(
  "onkeyup,onkeydown,onkeypress",
  !0
), ry = (i, e, t, r) => {
  const o = [], s = [], n = [];
  for (let a = 0; a < e.length; a++) {
    const l = e[a];
    l === "native" && Jo(
      "COMPILER_V_ON_NATIVE",
      t,
      r
    ) || ey(l) ? n.push(l) : iy(l) ? Bt(i) ? eA(i.content) ? o.push(l) : s.push(l) : (o.push(l), s.push(l)) : ty(l) ? s.push(l) : o.push(l);
  }
  return {
    keyModifiers: o,
    nonKeyModifiers: s,
    eventOptionModifiers: n
  };
}, hm = (i, e) => Bt(i) && i.content.toLowerCase() === "onclick" ? me(e, !0) : i.type !== 4 ? Ui([
  "(",
  i,
  `) === "onClick" ? "${e}" : (`,
  i,
  ")"
]) : i, oy = (i, e, t) => YR(i, e, t, (r) => {
  const { modifiers: o } = i;
  if (!o.length)
    return r;
  let { key: s, value: n } = r.props[0];
  const { keyModifiers: a, nonKeyModifiers: l, eventOptionModifiers: u } = ry(s, o, t, i.loc);
  if (l.includes("right") && (s = hm(s, "onContextmenu")), l.includes("middle") && (s = hm(s, "onMouseup")), l.length && (n = tt(t.helper(qR), [
    n,
    JSON.stringify(l)
  ])), a.length && // if event name is dynamic, always wrap with keys guard
  (!Bt(s) || eA(s.content)) && (n = tt(t.helper(jR), [
    n,
    JSON.stringify(a)
  ])), u.length) {
    const h = u.map(ur).join("");
    s = Bt(s) ? me(`${s.content}${h}`, !0) : Ui(["(", s, `) + "${h}"`]);
  }
  return {
    props: [We(s, n)]
  };
}), sy = (i, e, t) => {
  const { exp: r, loc: o } = i;
  return r || t.onError(
    yi(61, o)
  ), {
    props: [],
    needRuntime: t.helper(KR)
  };
}, ny = (i, e) => {
  if (i.type === 1 && i.tagType === 1 && e.isBuiltInComponent(i.tag) === Wp)
    return () => {
      if (!i.children.length)
        return;
      tA(i) && e.onError(
        yi(
          62,
          {
            start: i.children[0].loc.start,
            end: i.children[i.children.length - 1].loc.end,
            source: ""
          }
        )
      );
      const r = i.children[0];
      if (r.type === 1)
        for (const o of r.props)
          o.type === 7 && o.name === "show" && i.props.push({
            type: 6,
            name: "persisted",
            value: void 0,
            loc: i.loc
          });
    };
};
function tA(i) {
  const e = i.children = i.children.filter(
    (r) => r.type !== 3 && !(r.type === 2 && !r.content.trim())
  ), t = e[0];
  return e.length !== 1 || t.type === 11 || t.type === 9 && t.branches.some(tA);
}
const ay = (i, e) => {
  i.type === 1 && i.tagType === 0 && (i.tag === "script" || i.tag === "style") && ({}.NODE_ENV !== "production" && e.onError(
    yi(
      63,
      i.loc
    )
  ), e.removeNode());
}, ly = [
  zw,
  ...{}.NODE_ENV !== "production" ? [ny] : []
], uy = {
  cloak: Yw,
  html: jw,
  text: Kw,
  model: Jw,
  // override compiler-core
  on: oy,
  // override compiler-core
  show: sy
};
function hy(i, e = {}) {
  return Xw(
    i,
    pe({}, Ww, e, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ay,
        ...ly,
        ...e.nodeTransforms || []
      ],
      directiveTransforms: pe(
        {},
        uy,
        e.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function cy() {
  qS();
}
({}).NODE_ENV !== "production" && cy();
const cm = /* @__PURE__ */ Object.create(null);
function dy(i, e) {
  if (!he(i))
    if (i.nodeType)
      i = i.innerHTML;
    else
      return {}.NODE_ENV !== "production" && L("invalid template option: ", i), Ze;
  const t = i, r = cm[t];
  if (r)
    return r;
  if (i[0] === "#") {
    const l = document.querySelector(i);
    ({}).NODE_ENV !== "production" && !l && L(`Template element not found or is empty: ${i}`), i = l ? l.innerHTML : "";
  }
  const o = pe(
    {
      hoistStatic: !0,
      onError: {}.NODE_ENV !== "production" ? n : void 0,
      onWarn: {}.NODE_ENV !== "production" ? (l) => n(l, !0) : Ze
    },
    e
  );
  !o.isCustomElement && typeof customElements < "u" && (o.isCustomElement = (l) => !!customElements.get(l));
  const { code: s } = hy(i, o);
  function n(l, u = !1) {
    const h = u ? l.message : `Template compilation error: ${l.message}`, c = l.loc && Sv(
      i,
      l.loc.start.offset,
      l.loc.end.offset
    );
    L(c ? `${h}
${c}` : h);
  }
  const a = new Function("Vue", s)(hL);
  return a._rc = !0, cm[t] = a;
}
XS(dy);
const fy = {
  "Content-Type": "application/json;charset=UTF-8"
}, py = {
  mode: "cors",
  credentials: "include",
  cache: "no-cache"
}, uh = class {
  constructor() {
    Rt(this, "headers", {
      ...fy
    });
  }
  fetchHandler(e, t, r, o, s = "json") {
    let n = { ...py };
    const a = {
      ...this.headers,
      ...o || {}
    };
    let l = `${/^http/gi.test(e) ? "" : uh.BasePath}${e}`;
    switch (n = {
      ...n,
      method: t.toUpperCase(),
      headers: a,
      responseType: s
    }, t.toLocaleLowerCase()) {
      case "get":
        r && (l += "?", Object.keys(r).forEach((u) => {
          l += `${u}=${r[u]}&`;
        }));
        break;
      default:
        n = {
          ...n,
          body: r ? JSON.stringify(r) : "{}"
        };
    }
    return window.fetch(l, n).then((u) => new Promise((h, c) => {
      switch (s) {
        case "arraybuffer":
        case "file":
          h(u.arrayBuffer());
          break;
        case "blob":
          h(u.blob());
          break;
        case "document":
          h(u.formData());
          break;
        case "text":
          h(u.text());
          break;
        default:
          h(u.json());
      }
    }));
  }
  static setBasePath(e) {
    uh.BasePath = e;
  }
  setHeader(e) {
    e && (this.headers = {
      ...this.headers,
      ...e
    });
  }
  post(e, t, r, o = "json") {
    return this.fetchHandler(e, "POST", t, r, o);
  }
  get(e, t, r, o = "json") {
    return this.fetchHandler(e, "GET", t, r, o);
  }
  put(e, t, r, o = "json") {
    return this.fetchHandler(e, "PUT", t, r, o);
  }
  delete(e, t, r, o = "json") {
    return this.fetchHandler(e, "DELETE", t, r, o);
  }
};
let Fl = uh;
Rt(Fl, "BasePath", "");
function dm(i) {
  var c;
  const e = document.getElementById(i);
  if (!e)
    return null;
  const t = (c = e.shadowRoot) == null ? void 0 : c.querySelector(`#${i}`);
  if (!t)
    return null;
  const { width: r, height: o, x: s, y: n } = t.getBoundingClientRect(), { clientHeight: a, clientWidth: l, clientTop: u, clientLeft: h } = window.document.body;
  return {
    ele: {
      width: r,
      height: o,
      x: s,
      y: n,
      element: e
    },
    window: {
      clientHeight: a,
      clientWidth: l,
      clientTop: u,
      clientLeft: h
    }
  };
}
const Gr = 10;
window.NsFloatingbox = {
  open(i, e) {
    var A;
    const t = dm(i);
    if (!t)
      return;
    const { clientX: r, clientY: o } = e, { width: s, height: n, x: a, y: l } = t.ele, { clientHeight: u, clientWidth: h, clientTop: c, clientLeft: d } = t.window;
    let f = r - Gr, p = o - Gr;
    const O = r - Gr + s, m = o - Gr + n;
    f < d && (f = d + Gr), O > h + d && (f = h - s - Gr), p < c && (p = c + Gr), m > u + c && (p = u - n - Gr);
    const { element: E } = t.ele, g = (A = E.shadowRoot) == null ? void 0 : A.querySelector("#" + i);
    g && (g.style.top = `${p}px`, g.style.left = `${f}px`, zo(() => {
      g.style.opacity = "1";
    }));
  },
  close(i) {
    var o;
    const e = dm(i);
    if (!e)
      return;
    const { element: t } = e.ele, r = (o = t.shadowRoot) == null ? void 0 : o.querySelector("#" + i);
    r && (r.style.opacity = "0", setTimeout(() => {
      r.style.top = "-1000px", r.style.left = "-1000px";
    }, 200));
  }
};
var Tl, Oy = new Uint8Array(16);
function iA() {
  if (!Tl && (Tl = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !Tl))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Tl(Oy);
}
const Ey = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function rA(i) {
  return typeof i == "string" && Ey.test(i);
}
var ft = [];
for (var bc = 0; bc < 256; ++bc)
  ft.push((bc + 256).toString(16).substr(1));
function zp(i) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = (ft[i[e + 0]] + ft[i[e + 1]] + ft[i[e + 2]] + ft[i[e + 3]] + "-" + ft[i[e + 4]] + ft[i[e + 5]] + "-" + ft[i[e + 6]] + ft[i[e + 7]] + "-" + ft[i[e + 8]] + ft[i[e + 9]] + "-" + ft[i[e + 10]] + ft[i[e + 11]] + ft[i[e + 12]] + ft[i[e + 13]] + ft[i[e + 14]] + ft[i[e + 15]]).toLowerCase();
  if (!rA(t))
    throw TypeError("Stringified UUID is invalid");
  return t;
}
var fm, Tc, Sc = 0, Rc = 0;
function my(i, e, t) {
  var r = e && t || 0, o = e || new Array(16);
  i = i || {};
  var s = i.node || fm, n = i.clockseq !== void 0 ? i.clockseq : Tc;
  if (s == null || n == null) {
    var a = i.random || (i.rng || iA)();
    s == null && (s = fm = [a[0] | 1, a[1], a[2], a[3], a[4], a[5]]), n == null && (n = Tc = (a[6] << 8 | a[7]) & 16383);
  }
  var l = i.msecs !== void 0 ? i.msecs : Date.now(), u = i.nsecs !== void 0 ? i.nsecs : Rc + 1, h = l - Sc + (u - Rc) / 1e4;
  if (h < 0 && i.clockseq === void 0 && (n = n + 1 & 16383), (h < 0 || l > Sc) && i.nsecs === void 0 && (u = 0), u >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  Sc = l, Rc = u, Tc = n, l += 122192928e5;
  var c = ((l & 268435455) * 1e4 + u) % 4294967296;
  o[r++] = c >>> 24 & 255, o[r++] = c >>> 16 & 255, o[r++] = c >>> 8 & 255, o[r++] = c & 255;
  var d = l / 4294967296 * 1e4 & 268435455;
  o[r++] = d >>> 8 & 255, o[r++] = d & 255, o[r++] = d >>> 24 & 15 | 16, o[r++] = d >>> 16 & 255, o[r++] = n >>> 8 | 128, o[r++] = n & 255;
  for (var f = 0; f < 6; ++f)
    o[r + f] = s[f];
  return e || zp(o);
}
function gy(i) {
  if (!rA(i))
    throw TypeError("Invalid UUID");
  var e, t = new Uint8Array(16);
  return t[0] = (e = parseInt(i.slice(0, 8), 16)) >>> 24, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, t[3] = e & 255, t[4] = (e = parseInt(i.slice(9, 13), 16)) >>> 8, t[5] = e & 255, t[6] = (e = parseInt(i.slice(14, 18), 16)) >>> 8, t[7] = e & 255, t[8] = (e = parseInt(i.slice(19, 23), 16)) >>> 8, t[9] = e & 255, t[10] = (e = parseInt(i.slice(24, 36), 16)) / 1099511627776 & 255, t[11] = e / 4294967296 & 255, t[12] = e >>> 24 & 255, t[13] = e >>> 16 & 255, t[14] = e >>> 8 & 255, t[15] = e & 255, t;
}
function by(i) {
  i = unescape(encodeURIComponent(i));
  for (var e = [], t = 0; t < i.length; ++t)
    e.push(i.charCodeAt(t));
  return e;
}
var Ty = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", Sy = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function oA(i, e, t) {
  function r(o, s, n, a) {
    if (typeof o == "string" && (o = by(o)), typeof s == "string" && (s = gy(s)), s.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var l = new Uint8Array(16 + o.length);
    if (l.set(s), l.set(o, s.length), l = t(l), l[6] = l[6] & 15 | e, l[8] = l[8] & 63 | 128, n) {
      a = a || 0;
      for (var u = 0; u < 16; ++u)
        n[a + u] = l[u];
      return n;
    }
    return zp(l);
  }
  try {
    r.name = i;
  } catch {
  }
  return r.DNS = Ty, r.URL = Sy, r;
}
function Ry(i) {
  if (typeof i == "string") {
    var e = unescape(encodeURIComponent(i));
    i = new Uint8Array(e.length);
    for (var t = 0; t < e.length; ++t)
      i[t] = e.charCodeAt(t);
  }
  return Ay(Cy(Ny(i), i.length * 8));
}
function Ay(i) {
  for (var e = [], t = i.length * 32, r = "0123456789abcdef", o = 0; o < t; o += 8) {
    var s = i[o >> 5] >>> o % 32 & 255, n = parseInt(r.charAt(s >>> 4 & 15) + r.charAt(s & 15), 16);
    e.push(n);
  }
  return e;
}
function sA(i) {
  return (i + 64 >>> 9 << 4) + 14 + 1;
}
function Cy(i, e) {
  i[e >> 5] |= 128 << e % 32, i[sA(e) - 1] = e;
  for (var t = 1732584193, r = -271733879, o = -1732584194, s = 271733878, n = 0; n < i.length; n += 16) {
    var a = t, l = r, u = o, h = s;
    t = At(t, r, o, s, i[n], 7, -680876936), s = At(s, t, r, o, i[n + 1], 12, -389564586), o = At(o, s, t, r, i[n + 2], 17, 606105819), r = At(r, o, s, t, i[n + 3], 22, -1044525330), t = At(t, r, o, s, i[n + 4], 7, -176418897), s = At(s, t, r, o, i[n + 5], 12, 1200080426), o = At(o, s, t, r, i[n + 6], 17, -1473231341), r = At(r, o, s, t, i[n + 7], 22, -45705983), t = At(t, r, o, s, i[n + 8], 7, 1770035416), s = At(s, t, r, o, i[n + 9], 12, -1958414417), o = At(o, s, t, r, i[n + 10], 17, -42063), r = At(r, o, s, t, i[n + 11], 22, -1990404162), t = At(t, r, o, s, i[n + 12], 7, 1804603682), s = At(s, t, r, o, i[n + 13], 12, -40341101), o = At(o, s, t, r, i[n + 14], 17, -1502002290), r = At(r, o, s, t, i[n + 15], 22, 1236535329), t = Ct(t, r, o, s, i[n + 1], 5, -165796510), s = Ct(s, t, r, o, i[n + 6], 9, -1069501632), o = Ct(o, s, t, r, i[n + 11], 14, 643717713), r = Ct(r, o, s, t, i[n], 20, -373897302), t = Ct(t, r, o, s, i[n + 5], 5, -701558691), s = Ct(s, t, r, o, i[n + 10], 9, 38016083), o = Ct(o, s, t, r, i[n + 15], 14, -660478335), r = Ct(r, o, s, t, i[n + 4], 20, -405537848), t = Ct(t, r, o, s, i[n + 9], 5, 568446438), s = Ct(s, t, r, o, i[n + 14], 9, -1019803690), o = Ct(o, s, t, r, i[n + 3], 14, -187363961), r = Ct(r, o, s, t, i[n + 8], 20, 1163531501), t = Ct(t, r, o, s, i[n + 13], 5, -1444681467), s = Ct(s, t, r, o, i[n + 2], 9, -51403784), o = Ct(o, s, t, r, i[n + 7], 14, 1735328473), r = Ct(r, o, s, t, i[n + 12], 20, -1926607734), t = Nt(t, r, o, s, i[n + 5], 4, -378558), s = Nt(s, t, r, o, i[n + 8], 11, -2022574463), o = Nt(o, s, t, r, i[n + 11], 16, 1839030562), r = Nt(r, o, s, t, i[n + 14], 23, -35309556), t = Nt(t, r, o, s, i[n + 1], 4, -1530992060), s = Nt(s, t, r, o, i[n + 4], 11, 1272893353), o = Nt(o, s, t, r, i[n + 7], 16, -155497632), r = Nt(r, o, s, t, i[n + 10], 23, -1094730640), t = Nt(t, r, o, s, i[n + 13], 4, 681279174), s = Nt(s, t, r, o, i[n], 11, -358537222), o = Nt(o, s, t, r, i[n + 3], 16, -722521979), r = Nt(r, o, s, t, i[n + 6], 23, 76029189), t = Nt(t, r, o, s, i[n + 9], 4, -640364487), s = Nt(s, t, r, o, i[n + 12], 11, -421815835), o = Nt(o, s, t, r, i[n + 15], 16, 530742520), r = Nt(r, o, s, t, i[n + 2], 23, -995338651), t = It(t, r, o, s, i[n], 6, -198630844), s = It(s, t, r, o, i[n + 7], 10, 1126891415), o = It(o, s, t, r, i[n + 14], 15, -1416354905), r = It(r, o, s, t, i[n + 5], 21, -57434055), t = It(t, r, o, s, i[n + 12], 6, 1700485571), s = It(s, t, r, o, i[n + 3], 10, -1894986606), o = It(o, s, t, r, i[n + 10], 15, -1051523), r = It(r, o, s, t, i[n + 1], 21, -2054922799), t = It(t, r, o, s, i[n + 8], 6, 1873313359), s = It(s, t, r, o, i[n + 15], 10, -30611744), o = It(o, s, t, r, i[n + 6], 15, -1560198380), r = It(r, o, s, t, i[n + 13], 21, 1309151649), t = It(t, r, o, s, i[n + 4], 6, -145523070), s = It(s, t, r, o, i[n + 11], 10, -1120210379), o = It(o, s, t, r, i[n + 2], 15, 718787259), r = It(r, o, s, t, i[n + 9], 21, -343485551), t = qr(t, a), r = qr(r, l), o = qr(o, u), s = qr(s, h);
  }
  return [t, r, o, s];
}
function Ny(i) {
  if (i.length === 0)
    return [];
  for (var e = i.length * 8, t = new Uint32Array(sA(e)), r = 0; r < e; r += 8)
    t[r >> 5] |= (i[r / 8] & 255) << r % 32;
  return t;
}
function qr(i, e) {
  var t = (i & 65535) + (e & 65535), r = (i >> 16) + (e >> 16) + (t >> 16);
  return r << 16 | t & 65535;
}
function Iy(i, e) {
  return i << e | i >>> 32 - e;
}
function Uh(i, e, t, r, o, s) {
  return qr(Iy(qr(qr(e, i), qr(r, s)), o), t);
}
function At(i, e, t, r, o, s, n) {
  return Uh(e & t | ~e & r, i, e, o, s, n);
}
function Ct(i, e, t, r, o, s, n) {
  return Uh(e & r | t & ~r, i, e, o, s, n);
}
function Nt(i, e, t, r, o, s, n) {
  return Uh(e ^ t ^ r, i, e, o, s, n);
}
function It(i, e, t, r, o, s, n) {
  return Uh(t ^ (e | ~r), i, e, o, s, n);
}
var vy = oA("v3", 48, Ry);
const _y = vy;
function Py(i, e, t) {
  i = i || {};
  var r = i.random || (i.rng || iA)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, e) {
    t = t || 0;
    for (var o = 0; o < 16; ++o)
      e[t + o] = r[o];
    return e;
  }
  return zp(r);
}
function Ly(i, e, t, r) {
  switch (i) {
    case 0:
      return e & t ^ ~e & r;
    case 1:
      return e ^ t ^ r;
    case 2:
      return e & t ^ e & r ^ t & r;
    case 3:
      return e ^ t ^ r;
  }
}
function Ac(i, e) {
  return i << e | i >>> 32 - e;
}
function wy(i) {
  var e = [1518500249, 1859775393, 2400959708, 3395469782], t = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof i == "string") {
    var r = unescape(encodeURIComponent(i));
    i = [];
    for (var o = 0; o < r.length; ++o)
      i.push(r.charCodeAt(o));
  } else
    Array.isArray(i) || (i = Array.prototype.slice.call(i));
  i.push(128);
  for (var s = i.length / 4 + 2, n = Math.ceil(s / 16), a = new Array(n), l = 0; l < n; ++l) {
    for (var u = new Uint32Array(16), h = 0; h < 16; ++h)
      u[h] = i[l * 64 + h * 4] << 24 | i[l * 64 + h * 4 + 1] << 16 | i[l * 64 + h * 4 + 2] << 8 | i[l * 64 + h * 4 + 3];
    a[l] = u;
  }
  a[n - 1][14] = (i.length - 1) * 8 / Math.pow(2, 32), a[n - 1][14] = Math.floor(a[n - 1][14]), a[n - 1][15] = (i.length - 1) * 8 & 4294967295;
  for (var c = 0; c < n; ++c) {
    for (var d = new Uint32Array(80), f = 0; f < 16; ++f)
      d[f] = a[c][f];
    for (var p = 16; p < 80; ++p)
      d[p] = Ac(d[p - 3] ^ d[p - 8] ^ d[p - 14] ^ d[p - 16], 1);
    for (var O = t[0], m = t[1], E = t[2], g = t[3], A = t[4], S = 0; S < 80; ++S) {
      var R = Math.floor(S / 20), v = Ac(O, 5) + Ly(R, m, E, g) + A + e[R] + d[S] >>> 0;
      A = g, g = E, E = Ac(m, 30) >>> 0, m = O, O = v;
    }
    t[0] = t[0] + O >>> 0, t[1] = t[1] + m >>> 0, t[2] = t[2] + E >>> 0, t[3] = t[3] + g >>> 0, t[4] = t[4] + A >>> 0;
  }
  return [t[0] >> 24 & 255, t[0] >> 16 & 255, t[0] >> 8 & 255, t[0] & 255, t[1] >> 24 & 255, t[1] >> 16 & 255, t[1] >> 8 & 255, t[1] & 255, t[2] >> 24 & 255, t[2] >> 16 & 255, t[2] >> 8 & 255, t[2] & 255, t[3] >> 24 & 255, t[3] >> 16 & 255, t[3] >> 8 & 255, t[3] & 255, t[4] >> 24 & 255, t[4] >> 16 & 255, t[4] >> 8 & 255, t[4] & 255];
}
var yy = oA("v5", 80, wy);
const Dy = yy;
var wu = {
  v1: my,
  v3: _y,
  v4: Py,
  v5: Dy
};
const xy = { class: "ns-sandbox-box" }, My = ["src", "id", "name", "sandbox"], Uy = /* @__PURE__ */ fi({
  __name: "sandbox",
  props: {
    url: {
      type: String,
      default: ""
    },
    limit: {
      // 限制条件, 默认只限制顶级内容控制
      type: String,
      default: "allow-same-origin allow-scripts allow-forms"
    }
  },
  emits: ["name", "loaded", "change"],
  setup(i, { expose: e, emit: t }) {
    const r = i, o = it(), s = it(wu.v4()), n = it(!1), a = it(), l = it(!0);
    function u() {
      if (!o.value) {
        setTimeout(() => {
          u();
        }, 100);
        return;
      }
      o.value.onload = function(d) {
        zo(() => {
          t("loaded", r.url);
        });
      };
    }
    function h(d, f) {
      !n.value || !a.value || a.value.on(d, f);
    }
    function c(d, f) {
      return !n.value || !a.value ? Promise.reject() : a.value.send(d, f);
    }
    return Mi(() => r.url, (d, f) => {
      d && (f || (l.value = !1, zo(() => {
        l.value = !0;
      })));
    }, {
      immediate: !0
    }), yr(() => {
      u(), t("name", s.value);
    }), e({
      on: h,
      send: c
    }), (d, f) => (Pe(), ht("div", xy, [
      i.url && l.value ? (Pe(), ht("iframe", {
        key: 0,
        src: i.url,
        id: s.value,
        name: s.value,
        ref_key: "RefIframeBox",
        ref: o,
        sandbox: i.limit.toLocaleLowerCase() === "all" ? "" : i.limit
      }, null, 8, My)) : gr("", !0)
    ]));
  }
}), Qy = `:host{width:100%;height:100%;overflow:hidden;box-sizing:border-box;padding:0}.ns-sandbox-box{width:100%;height:100%;overflow:hidden;box-sizing:border-box;padding:0}.ns-sandbox-box iframe{width:100%;height:100%;overflow:hidden;border:0;padding:0}
`, xr = (i, e) => {
  const t = i.__vccOpts || i;
  for (const [r, o] of e)
    t[r] = o;
  return t;
}, ky = /* @__PURE__ */ xr(Uy, [["styles", [Qy]]]), $y = {
  // eslint-disable-next-line vue/multi-word-component-names
  name: "splitpanes",
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  props: {
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: !0 },
    dblClickSplitter: { type: Boolean, default: !0 },
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean }
  },
  provide() {
    return {
      requestUpdate: this.requestUpdate,
      onPaneAdd: this.onPaneAdd,
      onPaneRemove: this.onPaneRemove,
      onPaneClick: this.onPaneClick
    };
  },
  data: () => ({
    container: null,
    ready: !1,
    panes: [],
    touch: {
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null
    },
    splitterTaps: {
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }
  }),
  computed: {
    panesCount() {
      return this.panes.length;
    },
    // Indexed panes by `uid` of Pane components for fast lookup.
    // Every time a pane is destroyed this index is recomputed.
    indexedPanes() {
      return this.panes.reduce((i, e) => (i[e.id] = e) && i, {});
    }
  },
  methods: {
    updatePaneComponents() {
      this.panes.forEach((i) => {
        i.update && i.update({
          // Panes are indexed by Pane component uid, as they might be inserted at different index.
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[i.id].size}%`
        });
      });
    },
    bindEvents() {
      document.addEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.addEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.addEventListener("touchend", this.onMouseUp));
    },
    unbindEvents() {
      document.removeEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.removeEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.removeEventListener("touchend", this.onMouseUp));
    },
    onMouseDown(i, e) {
      this.bindEvents(), this.touch.mouseDown = !0, this.touch.activeSplitter = e;
    },
    onMouseMove(i) {
      this.touch.mouseDown && (i.preventDefault(), this.touch.dragging = !0, this.calculatePanesSize(this.getCurrentMouseDrag(i)), this.$emit("resize", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size }))));
    },
    onMouseUp() {
      this.touch.dragging && this.$emit("resized", this.panes.map((i) => ({ min: i.min, max: i.max, size: i.size }))), this.touch.mouseDown = !1, setTimeout(() => {
        this.touch.dragging = !1, this.unbindEvents();
      }, 100);
    },
    // If touch device, detect double tap manually (2 taps separated by less than 500ms).
    onSplitterClick(i, e) {
      "ontouchstart" in window && (i.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === e ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(i, e), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = e, this.splitterTaps.timeoutId = setTimeout(() => {
        this.splitterTaps.splitter = null;
      }, 500)))), this.touch.dragging || this.$emit("splitter-click", this.panes[e]);
    },
    // On splitter dbl click or dbl tap maximize this pane.
    onSplitterDblClick(i, e) {
      let t = 0;
      this.panes = this.panes.map((r, o) => (r.size = o === e ? r.max : r.min, o !== e && (t += r.min), r)), this.panes[e].size -= t, this.$emit("pane-maximize", this.panes[e]), this.$emit("resized", this.panes.map((r) => ({ min: r.min, max: r.max, size: r.size })));
    },
    onPaneClick(i, e) {
      this.$emit("pane-click", this.indexedPanes[e]);
    },
    // Get the cursor position relative to the splitpane container.
    getCurrentMouseDrag(i) {
      const e = this.container.getBoundingClientRect(), { clientX: t, clientY: r } = "ontouchstart" in window && i.touches ? i.touches[0] : i;
      return {
        x: t - e.left,
        y: r - e.top
      };
    },
    // Returns the drag percentage of the splitter relative to the 2 panes it's inbetween.
    // if the sum of size of the 2 cells is 60%, the dragPercentage range will be 0 to 100% of this 60%.
    getCurrentDragPercentage(i) {
      i = i[this.horizontal ? "y" : "x"];
      const e = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
      return this.rtl && !this.horizontal && (i = e - i), i * 100 / e;
    },
    calculatePanesSize(i) {
      const e = this.touch.activeSplitter;
      let t = {
        prevPanesSize: this.sumPrevPanesSize(e),
        nextPanesSize: this.sumNextPanesSize(e),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const r = 0 + (this.pushOtherPanes ? 0 : t.prevPanesSize), o = 100 - (this.pushOtherPanes ? 0 : t.nextPanesSize), s = Math.max(Math.min(this.getCurrentDragPercentage(i), o), r);
      let n = [e, e + 1], a = this.panes[n[0]] || null, l = this.panes[n[1]] || null;
      const u = a.max < 100 && s >= a.max + t.prevPanesSize, h = l.max < 100 && s <= 100 - (l.max + this.sumNextPanesSize(e + 1));
      if (u || h) {
        u ? (a.size = a.max, l.size = Math.max(100 - a.max - t.prevPanesSize - t.nextPanesSize, 0)) : (a.size = Math.max(100 - l.max - t.prevPanesSize - this.sumNextPanesSize(e + 1), 0), l.size = l.max);
        return;
      }
      if (this.pushOtherPanes) {
        const c = this.doPushOtherPanes(t, s);
        if (!c)
          return;
        ({ sums: t, panesToResize: n } = c), a = this.panes[n[0]] || null, l = this.panes[n[1]] || null;
      }
      a !== null && (a.size = Math.min(Math.max(s - t.prevPanesSize - t.prevReachedMinPanes, a.min), a.max)), l !== null && (l.size = Math.min(Math.max(100 - s - t.nextPanesSize - t.nextReachedMinPanes, l.min), l.max));
    },
    doPushOtherPanes(i, e) {
      const t = this.touch.activeSplitter, r = [t, t + 1];
      return e < i.prevPanesSize + this.panes[r[0]].min && (r[0] = this.findPrevExpandedPane(t).index, i.prevReachedMinPanes = 0, r[0] < t && this.panes.forEach((o, s) => {
        s > r[0] && s <= t && (o.size = o.min, i.prevReachedMinPanes += o.min);
      }), i.prevPanesSize = this.sumPrevPanesSize(r[0]), r[0] === void 0) ? (i.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((o, s) => {
        s > 0 && s <= t && (o.size = o.min, i.prevReachedMinPanes += o.min);
      }), this.panes[r[1]].size = 100 - i.prevReachedMinPanes - this.panes[0].min - i.prevPanesSize - i.nextPanesSize, null) : e > 100 - i.nextPanesSize - this.panes[r[1]].min && (r[1] = this.findNextExpandedPane(t).index, i.nextReachedMinPanes = 0, r[1] > t + 1 && this.panes.forEach((o, s) => {
        s > t && s < r[1] && (o.size = o.min, i.nextReachedMinPanes += o.min);
      }), i.nextPanesSize = this.sumNextPanesSize(r[1] - 1), r[1] === void 0) ? (i.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((o, s) => {
        s < this.panesCount - 1 && s >= t + 1 && (o.size = o.min, i.nextReachedMinPanes += o.min);
      }), this.panes[r[0]].size = 100 - i.prevPanesSize - i.nextReachedMinPanes - this.panes[this.panesCount - 1].min - i.nextPanesSize, null) : { sums: i, panesToResize: r };
    },
    sumPrevPanesSize(i) {
      return this.panes.reduce((e, t, r) => e + (r < i ? t.size : 0), 0);
    },
    sumNextPanesSize(i) {
      return this.panes.reduce((e, t, r) => e + (r > i + 1 ? t.size : 0), 0);
    },
    // Return the previous pane from siblings which has a size (width for vert or height for horz) of more than 0.
    findPrevExpandedPane(i) {
      return [...this.panes].reverse().find((t) => t.index < i && t.size > t.min) || {};
    },
    // Return the next pane from siblings which has a size (width for vert or height for horz) of more than 0.
    findNextExpandedPane(i) {
      return this.panes.find((t) => t.index > i + 1 && t.size > t.min) || {};
    },
    checkSplitpanesNodes() {
      Array.from(this.container.children).forEach((e) => {
        const t = e.classList.contains("splitpanes__pane"), r = e.classList.contains("splitpanes__splitter");
        !t && !r && console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed.");
      });
    },
    addSplitter(i, e, t = !1) {
      const r = i - 1, o = document.createElement("div");
      o.classList.add("splitpanes__splitter"), t || (o.onmousedown = (s) => this.onMouseDown(s, r), typeof window < "u" && "ontouchstart" in window && (o.ontouchstart = (s) => this.onMouseDown(s, r)), o.onclick = (s) => this.onSplitterClick(s, r + 1)), this.dblClickSplitter && (o.ondblclick = (s) => this.onSplitterDblClick(s, r + 1)), e.parentNode.insertBefore(o, e);
    },
    removeSplitter(i) {
      i.onmousedown = void 0, i.onclick = void 0, i.ondblclick = void 0, i.parentNode.removeChild(i);
    },
    redoSplitters() {
      const i = Array.from(this.container.children);
      i.forEach((t) => {
        t.className.includes("splitpanes__splitter") && this.removeSplitter(t);
      });
      let e = 0;
      i.forEach((t) => {
        t.className.includes("splitpanes__pane") && (!e && this.firstSplitter ? this.addSplitter(e, t, !0) : e && this.addSplitter(e, t), e++);
      });
    },
    // Called by Pane component on programmatic resize.
    requestUpdate({ target: i, ...e }) {
      const t = this.indexedPanes[i._.uid];
      Object.entries(e).forEach(([r, o]) => t[r] = o);
    },
    onPaneAdd(i) {
      let e = -1;
      Array.from(i.$el.parentNode.children).some((o) => (o.className.includes("splitpanes__pane") && e++, o === i.$el));
      const t = parseFloat(i.minSize), r = parseFloat(i.maxSize);
      this.panes.splice(e, 0, {
        id: i._.uid,
        index: e,
        min: isNaN(t) ? 0 : t,
        max: isNaN(r) ? 100 : r,
        size: i.size === null ? null : parseFloat(i.size),
        givenSize: i.size,
        update: i.update
      }), this.panes.forEach((o, s) => o.index = s), this.ready && this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[e] }), this.$emit("pane-add", { index: e, panes: this.panes.map((o) => ({ min: o.min, max: o.max, size: o.size })) });
      });
    },
    onPaneRemove(i) {
      const e = this.panes.findIndex((r) => r.id === i._.uid), t = this.panes.splice(e, 1)[0];
      this.panes.forEach((r, o) => r.index = o), this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...t, index: e } }), this.$emit("pane-remove", { removed: t, panes: this.panes.map((r) => ({ min: r.min, max: r.max, size: r.size })) });
      });
    },
    resetPaneSizes(i = {}) {
      !i.addedPane && !i.removedPane ? this.initialPanesSizing() : this.panes.some((e) => e.givenSize !== null || e.min || e.max < 100) ? this.equalizeAfterAddOrRemove(i) : this.equalize(), this.ready && this.$emit("resized", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size })));
    },
    equalize() {
      const i = 100 / this.panesCount;
      let e = 0;
      const t = [], r = [];
      this.panes.forEach((o) => {
        o.size = Math.max(Math.min(i, o.max), o.min), e -= o.size, o.size >= o.max && t.push(o.id), o.size <= o.min && r.push(o.id);
      }), e > 0.1 && this.readjustSizes(e, t, r);
    },
    initialPanesSizing() {
      let i = 100;
      const e = [], t = [];
      let r = 0;
      this.panes.forEach((s) => {
        i -= s.size, s.size !== null && r++, s.size >= s.max && e.push(s.id), s.size <= s.min && t.push(s.id);
      });
      let o = 100;
      i > 0.1 && (this.panes.forEach((s) => {
        s.size === null && (s.size = Math.max(Math.min(i / (this.panesCount - r), s.max), s.min)), o -= s.size;
      }), o > 0.1 && this.readjustSizes(i, e, t));
    },
    equalizeAfterAddOrRemove({ addedPane: i, removedPane: e } = {}) {
      let t = 100 / this.panesCount, r = 0;
      const o = [], s = [];
      i && i.givenSize !== null && (t = (100 - i.givenSize) / (this.panesCount - 1)), this.panes.forEach((n) => {
        r -= n.size, n.size >= n.max && o.push(n.id), n.size <= n.min && s.push(n.id);
      }), !(Math.abs(r) < 0.1) && (this.panes.forEach((n) => {
        i && i.givenSize !== null && i.id === n.id || (n.size = Math.max(Math.min(t, n.max), n.min)), r -= n.size, n.size >= n.max && o.push(n.id), n.size <= n.min && s.push(n.id);
      }), r > 0.1 && this.readjustSizes(r, o, s));
    },
    /* recalculatePaneSizes ({ addedPane, removedPane } = {}) {
          let leftToAllocate = 100
          let equalSpaceToAllocate = leftToAllocate / this.panesCount
          let ungrowable = []
          let unshrinkable = []
    
          // When adding a pane with no size, apply min-size if defined otherwise divide another pane
          // (next or prev) in 2.
          // if (addedPane && addedPane.size === null) {
          //   if (addedPane.min) addedPane.size = addedPane.min
          //   else {
          //     const paneToDivide = this.panes[addedPane.index + 1] || this.panes[addedPane.index - 1]
          //     if (paneToDivide) {
          //       // @todo: Dividing that pane in 2 could be incorrect if becoming lower than its min size.
          //       addedPane.size = paneToDivide.size / 2
          //       paneToDivide.size /= 2
          //     }
          //   }
          // }
    
          this.panes.forEach((pane, i) => {
            // Added pane - reduce the size of the next pane.
            if (addedPane && addedPane.index + 1 === i) {
              pane.size = Math.max(Math.min(100 - this.sumPrevPanesSize(i) - this.sumNextPanesSize(i + 1), pane.max), pane.min)
              // @todo: if could not allocate correctly, try to allocate in the next pane straight away,
              // then still do the second loop if not correct.
            }
    
            // Removed pane - increase the size of the next pane.
            else if (removedPane && removedPane.index === i) {
              pane.size = Math.max(Math.min(100 - this.sumPrevPanesSize(i) - this.sumNextPanesSize(i + 1), pane.max), pane.min)
              // @todo: if could not allocate correctly, try to allocate in the next pane straight away,
              // then still do the second loop if not correct.
            }
    
            // Initial load and on demand recalculation.
            else if (!addedPane && !removedPane && pane.size === null) {
              pane.size = Math.max(Math.min(equalSpaceToAllocate, pane.max), pane.min)
            }
    
            leftToAllocate -= pane.size
    
            if (pane.size >= pane.max) ungrowable.push(pane.id)
            if (pane.size <= pane.min) unshrinkable.push(pane.id)
          })
    
          // Do one more loop to adjust sizes if still wrong.
          // > 0.1: Prevent maths rounding issues due to bytes.
          if (Math.abs(leftToAllocate) > 0.1) this.readjustSizes(leftToAllocate, ungrowable, unshrinkable)
        }, */
    // Second loop to adjust sizes now that we know more about the panes constraints.
    readjustSizes(i, e, t) {
      let r;
      i > 0 ? r = i / (this.panesCount - e.length) : r = i / (this.panesCount - t.length), this.panes.forEach((o, s) => {
        if (i > 0 && !e.includes(o.id)) {
          const n = Math.max(Math.min(o.size + r, o.max), o.min), a = n - o.size;
          i -= a, o.size = n;
        } else if (!t.includes(o.id)) {
          const n = Math.max(Math.min(o.size + r, o.max), o.min), a = n - o.size;
          i -= a, o.size = n;
        }
        o.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[o.id].size}%`
        });
      }), Math.abs(i) > 0.1 && this.$nextTick(() => {
        this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }
    /* distributeEmptySpace () {
          let growablePanes = []
          let collapsedPanesCount = 0
          let growableAmount = 0 // Total of how much the current panes can grow to fill blank space.
          let spaceToDistribute = 100 - this.panes.reduce((sum, pane) => (sum += pane.size) && sum, 0)
          // Do a first loop to determine if we can distribute the new blank space between all the
          // expandedPanes, without expanding the collapsed ones.
          this.panes.forEach(pane => {
            if (pane.size < pane.max) growablePanes.push(pane)
    
            if (!pane.size) collapsedPanesCount++
            else growableAmount += pane.max - pane.size
          })
    
          // If the blank space to distribute is too great for the expanded panes, also expand collapsed ones.
          let expandCollapsedPanes = growableAmount < spaceToDistribute
    
          // New space to distribute equally.
          let growablePanesCount = (growablePanes.length - (expandCollapsedPanes ? 0 : collapsedPanesCount))
          let equalSpaceToDistribute = spaceToDistribute / growablePanesCount
          // if (growablePanesCount === 1) equalSpace = 100 / this.panesCount
          let spaceLeftToDistribute = spaceToDistribute
    
          // Now add the equalSpaceToDistribute to each pane size accordingly.
          growablePanes.forEach(pane => {
            if (pane.size < pane.max && (pane.size || (!pane.size && expandCollapsedPanes))) {
              const newSize = Math.min(pane.size + equalSpaceToDistribute, pane.max)
              let allocatedSpace = (newSize - pane.size)
              spaceLeftToDistribute -= allocatedSpace
              pane.size = newSize
              // If the equalSpaceToDistribute is not fully added to the current pane, distribute the remainder
              // to the next panes.
              // Also fix decimal issue due to bites - E.g. calculating 8.33 and getting 8.3299999999999
              if (equalSpaceToDistribute - allocatedSpace > 0.1) equalSpaceToDistribute = spaceLeftToDistribute / (--growablePanesCount)
            }
          })
    
          /* Disabled otherwise will show up on hot reload.
          // if there is still space to allocate show warning message.
          if (this.panesCount && ~~spaceLeftToDistribute) {
            // eslint-disable-next-line no-console
            console.warn('Splitpanes: Could not distribute all the empty space between panes due to their constraints.')
          } *\/
    
          this.$emit('resized', this.panes.map(pane => ({ min: pane.min, max: pane.max, size: pane.size })))
        } */
  },
  watch: {
    panes: {
      // Every time a pane is updated, update the panes accordingly.
      deep: !0,
      immediate: !1,
      handler() {
        this.updatePaneComponents();
      }
    },
    horizontal() {
      this.updatePaneComponents();
    },
    firstSplitter() {
      this.redoSplitters();
    },
    dblClickSplitter(i) {
      [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((t, r) => {
        t.ondblclick = i ? (o) => this.onSplitterDblClick(o, r) : void 0;
      });
    }
  },
  beforeUnmount() {
    this.ready = !1;
  },
  mounted() {
    this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit("ready"), this.ready = !0;
  },
  render() {
    return No(
      "div",
      {
        ref: "container",
        class: [
          "splitpanes",
          "default-theme",
          `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
          {
            "splitpanes--dragging": this.touch.dragging
          }
        ]
      },
      this.$slots.default()
    );
  }
}, Gy = {
  // eslint-disable-next-line vue/multi-word-component-names
  name: "pane",
  inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
  props: {
    size: { type: [Number, String], default: null },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  data: () => ({
    style: {}
  }),
  mounted() {
    this.onPaneAdd(this);
  },
  beforeUnmount() {
    this.onPaneRemove(this);
  },
  methods: {
    // Called from the splitpanes component.
    update(i) {
      this.style = i;
    }
  },
  computed: {
    sizeNumber() {
      return this.size || this.size === 0 ? parseFloat(this.size) : null;
    },
    minSizeNumber() {
      return parseFloat(this.minSize);
    },
    maxSizeNumber() {
      return parseFloat(this.maxSize);
    }
  },
  watch: {
    sizeNumber(i) {
      this.requestUpdate({ target: this, size: i });
    },
    minSizeNumber(i) {
      this.requestUpdate({ target: this, min: i });
    },
    maxSizeNumber(i) {
      this.requestUpdate({ target: this, max: i });
    }
  }
};
function Vy(i, e, t, r, o, s) {
  return Pe(), ht("div", {
    class: "splitpanes__pane",
    onClick: e[0] || (e[0] = (n) => s.onPaneClick(n, i._.uid)),
    style: ki(i.style)
  }, [
    ui(i.$slots, "default")
  ], 4);
}
const Hy = /* @__PURE__ */ xr(Gy, [["render", Vy]]), Xy = { class: "pane-box" }, Yy = /* @__PURE__ */ fi({
  __name: "splitpane",
  props: {
    keys: {
      type: Array,
      default: () => []
    },
    size: {
      type: Array,
      default: () => [25, 25, 25, 25]
    },
    minSize: {
      type: Array,
      default: () => [0, 0, 0, 0]
    },
    maxSize: {
      type: Array,
      default: () => [0, 0, 0, 0]
    },
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: !0 },
    dblClickSplitter: { type: Boolean, default: !0 },
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean }
  },
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  setup(i, { emit: e }) {
    return (t, r) => (Pe(), Li($y, {
      onReady: r[0] || (r[0] = (o) => e("ready", o)),
      onResize: r[1] || (r[1] = (o) => e("resize", o)),
      onResized: r[2] || (r[2] = (o) => e("resized", o)),
      onPaneClick: r[3] || (r[3] = (o) => e("pane-click", o)),
      onPaneMaximize: r[4] || (r[4] = (o) => e("pane-maximize", o)),
      onPaneAdd: r[5] || (r[5] = (o) => e("pane-add", o)),
      onPaneRemove: r[6] || (r[6] = (o) => e("pane-remove", o)),
      onSplitterClick: r[7] || (r[7] = (o) => e("splitter-click", o)),
      horizontal: i.horizontal,
      pushOtherPanes: i.pushOtherPanes,
      dblClickSplitter: i.dblClickSplitter,
      rtl: i.rtl,
      firstSplitter: i.firstSplitter
    }, {
      default: ga(() => [
        (Pe(!0), ht(et, null, Ep(i.keys, (o, s) => (Pe(), Li(Hy, {
          size: i.size[s] ? i.size[s] : 10,
          "min-size": i.minSize[s] ? i.minSize[s] : 0,
          "max-size": i.maxSize[s] ? i.maxSize[s] : 100
        }, {
          default: ga(() => [
            ke("div", Xy, [
              ui(t.$slots, o)
            ])
          ]),
          _: 2
        }, 1032, ["size", "min-size", "max-size"]))), 256))
      ]),
      _: 3
    }, 8, ["horizontal", "pushOtherPanes", "dblClickSplitter", "rtl", "firstSplitter"]));
  }
}), By = `:host{width:100%;height:100%;overflow:hidden;box-sizing:border-box}.splitpanes{display:flex;width:100%;height:100%}.splitpanes--vertical{flex-direction:row}.splitpanes--horizontal{flex-direction:column}.splitpanes--dragging *{user-select:none}.splitpanes__pane{width:100%;height:100%;overflow:hidden}.splitpanes--vertical .splitpanes__pane{transition:width .2s ease-out}.splitpanes--horizontal .splitpanes__pane{transition:height .2s ease-out}.splitpanes--dragging .splitpanes__pane{transition:none}.splitpanes__splitter{touch-action:none}.splitpanes--vertical>.splitpanes__splitter{min-width:1px;cursor:col-resize}.splitpanes--horizontal>.splitpanes__splitter{min-height:1px;cursor:row-resize}.splitpanes.default-theme .splitpanes__pane{background-color:#f2f2f2}.splitpanes.default-theme .splitpanes__splitter{background-color:#fff;box-sizing:border-box;position:relative;flex-shrink:0}.splitpanes.default-theme .splitpanes__splitter:before,.splitpanes.default-theme .splitpanes__splitter:after{content:"";position:absolute;top:50%;left:50%;background-color:#00000026;transition:background-color .3s}.splitpanes.default-theme .splitpanes__splitter:hover:before,.splitpanes.default-theme .splitpanes__splitter:hover:after{background-color:#00000040}.splitpanes.default-theme .splitpanes__splitter:first-child{cursor:auto}.default-theme.splitpanes .splitpanes .splitpanes__splitter{z-index:1}.default-theme.splitpanes--vertical>.splitpanes__splitter,.default-theme .splitpanes--vertical>.splitpanes__splitter{width:7px;border-left:1px solid #eee;margin-left:-1px}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{transform:translateY(-50%);width:1px;height:30px}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:before{margin-left:-2px}.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{margin-left:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter,.default-theme .splitpanes--horizontal>.splitpanes__splitter{height:7px;border-top:1px solid #eee;margin-top:-1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{transform:translate(-50%);width:30px;height:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before{margin-top:-2px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{margin-top:1px}
`, Fy = `.pane-box{height:100%;width:100%;background-color:#fff;box-sizing:border-box;overflow:hidden;overflow-y:auto;overflow-x:auto;border-radius:4px}.splitpanes__splitter{background-color:#f0f0f0!important}
`, Wy = /* @__PURE__ */ xr(Yy, [["styles", [By, Fy]]]), zy = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjkxMzg2NDA5MzAwIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjY0NzQiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PHBhdGggZD0iTTY0MCA2NGwwIDE4OS4xMiAxOTIgMEw2NDkuNDcyIDY0IDY0MCA2NHpNNjQwIDY0bDAgMTg5LjEyIDE5MiAwTDY0OS40NzIgNjQgNjQwIDY0ek02OTcuNiA3NjYuNGMtMTQuMDE2IDAtMjcuMTM2LTYuNTkyLTM1LjcxMi0xNy42TDUxNy43NiA1NjcuODcyQzUwMi45MTIgNTQ4LjIyNCA1MDYuNzUyIDUyMC4yNTYgNTI2LjQgNTA1LjM0NGMxOS43NzYtMTQuNzg0IDQ3LjYxNi0xMC45NDQgNjIuNDY0IDguNzA0bDEwNS4xNTIgMTI5LjE1MiAxODkuMjQ4LTMwMy43NDRjMTIuOTkyLTIwLjg2NCA0MC41MTItMjcuMjY0IDYxLjM3Ni0xNC4yNzIgMjAuOTkyIDEyLjk5MiAyNy4yNjQgNDAuNTEyIDE0LjI3MiA2MS40NGwtMjIzLjI5NiAzNTguNzJjLTcuNzQ0IDEyLjQxNi0yMS4yNDggMjAuMjI0LTM1Ljk2OCAyMC45OTJDNjk5LjAwOCA3NjYuNCA2OTguMjQgNzY2LjQgNjk3LjYgNzY2LjR6TTc4OS43NiA3NzkuMjY0Yy0xOC44MTYgMzAuMjcyLTUxLjM5MiA0OS4zNDQtODcuMTA0IDUxLjAwOGwtMS43OTIgMC4xMjhMNjk3LjYgODMwLjRjLTMzLjY2NCAwLTY1Ljk4NC0xNi04NS43Ni00MS43MjhMNDY2Ljc1MiA2MDYuNjU2QzQzMC42NTYgNTU4Ljg0OCA0NDAgNDkwLjYyNCA0ODggNDU0LjE0NGMxOS4wMDgtMTQuMjcyIDQxLjYtMjEuODI0IDY1LjM0NC0yMS44MjQgMzMuNzI4IDAgNjYuMTEyIDE2LjA2NCA4NS4yNDggNDEuMzQ0bDQ4LjM4NCA1OS41ODRMODE5LjkwNCAzMjAgNTc2IDMyMCA1NzYgNjQgOTUuMTY4IDY0Qzc2LjYwOCA2NCA2NCA3Ni42MDggNjQgOTIuMDMybDAgODQwQzY0IDk0Ny4zOTIgNzYuNjA4IDk2MCA5Mi4wMzIgOTYwbDcxMiAwQzgxOS4zOTIgOTYwIDgzMiA5NDcuMzkyIDgzMiA5MzEuOTY4bDAtMjIwLjU0NEw3ODkuNzYgNzc5LjI2NHpNMjI0IDI1NmwxOTIgMEM0MzMuNjY0IDI1NiA0NDggMjcwLjMzNiA0NDggMjg4UzQzMy42NjQgMzIwIDQxNiAzMjBsLTE5MiAwQzIwNi4zMzYgMzIwIDE5MiAzMDUuNjY0IDE5MiAyODhTMjA2LjMzNiAyNTYgMjI0IDI1NnpNMjI0IDM4NGwxOTIgMEM0MzMuNjY0IDM4NCA0NDggMzk4LjMzNiA0NDggNDE2UzQzMy42NjQgNDQ4IDQxNiA0NDhsLTE5MiAwQzIwNi4zMzYgNDQ4IDE5MiA0MzMuNjY0IDE5MiA0MTZTMjA2LjMzNiAzODQgMjI0IDM4NHpNMjI0IDUxMmwxMjggMEMzNjkuNjY0IDUxMiAzODQgNTI2LjMzNiAzODQgNTQ0IDM4NCA1NjEuNiAzNjkuNjY0IDU3NiAzNTIgNTc2bC0xMjggMEMyMDYuMzM2IDU3NiAxOTIgNTYxLjYgMTkyIDU0NCAxOTIgNTI2LjMzNiAyMDYuMzM2IDUxMiAyMjQgNTEyek0yMjQgNjQwbDE5MiAwQzQzMy42NjQgNjQwIDQ0OCA2NTQuNCA0NDggNjcyUzQzMy42NjQgNzA0IDQxNiA3MDRsLTE5MiAwQzIwNi4zMzYgNzA0IDE5MiA2ODkuNiAxOTIgNjcyUzIwNi4zMzYgNjQwIDIyNCA2NDB6TTQ4MCA4MzJsLTI1NiAwQzIwNi4zMzYgODMyIDE5MiA4MTcuNiAxOTIgODAwUzIwNi4zMzYgNzY4IDIyNCA3NjhsMjU2IDBDNDk3LjY2NCA3NjggNTEyIDc4Mi40IDUxMiA4MDBTNDk3LjY2NCA4MzIgNDgwIDgzMnoiIGZpbGw9IiMwMTAxMDEiIHAtaWQ9IjY0NzUiPjwvcGF0aD48L3N2Zz4=", Zy = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjkxMzg2OTA3NTE5IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9Ijc0NzkiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PHBhdGggZD0iTTYwMS4xNTIgNzA4LjI4OCA0MDAgNTY4IDM0NCA1NjhsMCAxMTItMjI0IDAgMCAxMTIgMjI0IDAgMCAxMTJMNDAwIDkwNGwyMDEuMTUyLTE0MC4yODhDNjI0IDc0OS41MDQgNjI0IDcyMi40OTYgNjAxLjE1MiA3MDguMjg4TDYwMS4xNTIgNzA4LjI4OHpNODkxLjI2NCAzMzEuMiA2MzguNjU2IDc2Ljg2NEM2MzAuNTI4IDY4LjYwOCA2MTkuNDU2IDY0IDYwNy45MzYgNjRMMjMyIDY0QzE5Ni4wMzIgNjQgMTc2IDgzLjcxMiAxNzYgMTIwTDE3NiA1MTIgMjg4IDUxMiAyODggMTc2bDI4MCAwIDAgMTY4YzAgMjQuMTkyIDMyIDU2IDU2IDU2bDE2OCAwIDAuNzY4IDQ0OEw2MjQgODQ4IDYyNCA5NjBsMjI0IDBjMzUuOTY4IDAgNTYtMTkuNzEyIDU2LTU2TDkwNCAzNjIuMTc2QzkwNCAzNTAuNTI4IDg5OS4zOTIgMzM5LjM5MiA4OTEuMjY0IDMzMS4yTDg5MS4yNjQgMzMxLjJ6IiBwLWlkPSI3NDgwIj48L3BhdGg+PC9zdmc+";
class Ce {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, r) {
    let o = [];
    return this.decompose(
      0,
      e,
      o,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      o,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      o,
      1
      /* Open.From */
    ), ji.from(o, this.length - (t - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    let r = [];
    return this.decompose(e, t, r, 0), ji.from(r, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), o = new aa(this), s = new aa(e);
    for (let n = t, a = t; ; ) {
      if (o.next(n), s.next(n), n = 0, o.lineBreak != s.lineBreak || o.done != s.done || o.value != s.value)
        return !1;
      if (a += o.value.length, o.done || a >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new aa(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new nA(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let o = this.line(e).from;
      r = this.iterRange(o, Math.max(o, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new aA(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Ce.empty : e.length <= 32 ? new ze(e) : ji.from(ze.split(e, []));
  }
}
class ze extends Ce {
  constructor(e, t = qy(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, r, o) {
    for (let s = 0; ; s++) {
      let n = this.text[s], a = o + n.length;
      if ((t ? r : a) >= e)
        return new jy(o, a, r, n);
      o = a + 1, r++;
    }
  }
  decompose(e, t, r, o) {
    let s = e <= 0 && t >= this.length ? this : new ze(pm(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (o & 1) {
      let n = r.pop(), a = Wl(s.text, n.text.slice(), 0, s.length);
      if (a.length <= 32)
        r.push(new ze(a, n.length + s.length));
      else {
        let l = a.length >> 1;
        r.push(new ze(a.slice(0, l)), new ze(a.slice(l)));
      }
    } else
      r.push(s);
  }
  replace(e, t, r) {
    if (!(r instanceof ze))
      return super.replace(e, t, r);
    let o = Wl(this.text, Wl(r.text, pm(this.text, 0, e)), t), s = this.length + r.length - (t - e);
    return o.length <= 32 ? new ze(o, s) : ji.from(ze.split(o, []), s);
  }
  sliceString(e, t = this.length, r = `
`) {
    let o = "";
    for (let s = 0, n = 0; s <= t && n < this.text.length; n++) {
      let a = this.text[n], l = s + a.length;
      s > e && n && (o += r), e < l && t > s && (o += a.slice(Math.max(0, e - s), t - s)), s = l + 1;
    }
    return o;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let r = [], o = -1;
    for (let s of e)
      r.push(s), o += s.length + 1, r.length == 32 && (t.push(new ze(r, o)), r = [], o = -1);
    return o > -1 && t.push(new ze(r, o)), t;
  }
}
class ji extends Ce {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, t, r, o) {
    for (let s = 0; ; s++) {
      let n = this.children[s], a = o + n.length, l = r + n.lines - 1;
      if ((t ? l : a) >= e)
        return n.lineInner(e, t, r, o);
      o = a + 1, r = l + 1;
    }
  }
  decompose(e, t, r, o) {
    for (let s = 0, n = 0; n <= t && s < this.children.length; s++) {
      let a = this.children[s], l = n + a.length;
      if (e <= l && t >= n) {
        let u = o & ((n <= e ? 1 : 0) | (l >= t ? 2 : 0));
        n >= e && l <= t && !u ? r.push(a) : a.decompose(e - n, t - n, r, u);
      }
      n = l + 1;
    }
  }
  replace(e, t, r) {
    if (r.lines < this.lines)
      for (let o = 0, s = 0; o < this.children.length; o++) {
        let n = this.children[o], a = s + n.length;
        if (e >= s && t <= a) {
          let l = n.replace(e - s, t - s, r), u = this.lines - n.lines + l.lines;
          if (l.lines < u >> 5 - 1 && l.lines > u >> 5 + 1) {
            let h = this.children.slice();
            return h[o] = l, new ji(h, this.length - (t - e) + r.length);
          }
          return super.replace(s, a, l);
        }
        s = a + 1;
      }
    return super.replace(e, t, r);
  }
  sliceString(e, t = this.length, r = `
`) {
    let o = "";
    for (let s = 0, n = 0; s < this.children.length && n <= t; s++) {
      let a = this.children[s], l = n + a.length;
      n > e && s && (o += r), e < l && t > n && (o += a.sliceString(e - n, t - n, r)), n = l + 1;
    }
    return o;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof ji))
      return 0;
    let r = 0, [o, s, n, a] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; o += t, s += t) {
      if (o == n || s == a)
        return r;
      let l = this.children[o], u = e.children[s];
      if (l != u)
        return r + l.scanIdentical(u, t);
      r += l.length + 1;
    }
  }
  static from(e, t = e.reduce((r, o) => r + o.length + 1, -1)) {
    let r = 0;
    for (let f of e)
      r += f.lines;
    if (r < 32) {
      let f = [];
      for (let p of e)
        p.flatten(f);
      return new ze(f, t);
    }
    let o = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), s = o << 1, n = o >> 1, a = [], l = 0, u = -1, h = [];
    function c(f) {
      let p;
      if (f.lines > s && f instanceof ji)
        for (let O of f.children)
          c(O);
      else
        f.lines > n && (l > n || !l) ? (d(), a.push(f)) : f instanceof ze && l && (p = h[h.length - 1]) instanceof ze && f.lines + p.lines <= 32 ? (l += f.lines, u += f.length + 1, h[h.length - 1] = new ze(p.text.concat(f.text), p.length + 1 + f.length)) : (l + f.lines > o && d(), l += f.lines, u += f.length + 1, h.push(f));
    }
    function d() {
      l != 0 && (a.push(h.length == 1 ? h[0] : ji.from(h, u)), u = -1, l = h.length = 0);
    }
    for (let f of e)
      c(f);
    return d(), a.length == 1 ? a[0] : new ji(a, t);
  }
}
Ce.empty = /* @__PURE__ */ new ze([""], 0);
function qy(i) {
  let e = -1;
  for (let t of i)
    e += t.length + 1;
  return e;
}
function Wl(i, e, t = 0, r = 1e9) {
  for (let o = 0, s = 0, n = !0; s < i.length && o <= r; s++) {
    let a = i[s], l = o + a.length;
    l >= t && (l > r && (a = a.slice(0, r - o)), o < t && (a = a.slice(t - o)), n ? (e[e.length - 1] += a, n = !1) : e.push(a)), o = l + 1;
  }
  return e;
}
function pm(i, e, t) {
  return Wl(i, [""], e, t);
}
class aa {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof ze ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, o = this.nodes[r], s = this.offsets[r], n = s >> 1, a = o instanceof ze ? o.text.length : o.children.length;
      if (n == (t > 0 ? a : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[r] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (o instanceof ze) {
        let l = o.text[n + (t < 0 ? -1 : 0)];
        if (this.offsets[r] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = o.children[n + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[r] += t) : (t < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof ze ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class nA {
  constructor(e, t, r) {
    this.value = "", this.done = !1, this.cursor = new aa(e, t > r ? -1 : 1), this.pos = t > r ? e.length : 0, this.from = Math.min(t, r), this.to = Math.max(t, r);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let r = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: o } = this.cursor.next(e);
    return this.pos += (o.length + e) * t, this.value = o.length <= r ? o : t < 0 ? o.slice(o.length - r) : o.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class aA {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: r, value: o } = this.inner.next(e);
    return t ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = o, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Ce.prototype[Symbol.iterator] = function() {
  return this.iter();
}, aa.prototype[Symbol.iterator] = nA.prototype[Symbol.iterator] = aA.prototype[Symbol.iterator] = function() {
  return this;
});
class jy {
  /**
  @internal
  */
  constructor(e, t, r, o) {
    this.from = e, this.to = t, this.number = r, this.text = o;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
let Vs = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((i) => i ? parseInt(i, 36) : 1);
for (let i = 1; i < Vs.length; i++)
  Vs[i] += Vs[i - 1];
function Ky(i) {
  for (let e = 1; e < Vs.length; e += 2)
    if (Vs[e] > i)
      return Vs[e - 1] <= i;
  return !1;
}
function Om(i) {
  return i >= 127462 && i <= 127487;
}
const Em = 8205;
function $t(i, e, t = !0, r = !0) {
  return (t ? lA : Jy)(i, e, r);
}
function lA(i, e, t) {
  if (e == i.length)
    return e;
  e && uA(i.charCodeAt(e)) && hA(i.charCodeAt(e - 1)) && e--;
  let r = mt(i, e);
  for (e += mi(r); e < i.length; ) {
    let o = mt(i, e);
    if (r == Em || o == Em || t && Ky(o))
      e += mi(o), r = o;
    else if (Om(o)) {
      let s = 0, n = e - 2;
      for (; n >= 0 && Om(mt(i, n)); )
        s++, n -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function Jy(i, e, t) {
  for (; e > 0; ) {
    let r = lA(i, e - 2, t);
    if (r < e)
      return r;
    e--;
  }
  return 0;
}
function uA(i) {
  return i >= 56320 && i < 57344;
}
function hA(i) {
  return i >= 55296 && i < 56320;
}
function mt(i, e) {
  let t = i.charCodeAt(e);
  if (!hA(t) || e + 1 == i.length)
    return t;
  let r = i.charCodeAt(e + 1);
  return uA(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function Zp(i) {
  return i <= 65535 ? String.fromCharCode(i) : (i -= 65536, String.fromCharCode((i >> 10) + 55296, (i & 1023) + 56320));
}
function mi(i) {
  return i < 65536 ? 1 : 2;
}
const Vd = /\r\n?|\n/;
var bt = /* @__PURE__ */ function(i) {
  return i[i.Simple = 0] = "Simple", i[i.TrackDel = 1] = "TrackDel", i[i.TrackBefore = 2] = "TrackBefore", i[i.TrackAfter = 3] = "TrackAfter", i;
}(bt || (bt = {}));
class sr {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t + 1];
      e += r < 0 ? this.sections[t] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, r = 0, o = 0; t < this.sections.length; ) {
      let s = this.sections[t++], n = this.sections[t++];
      n < 0 ? (e(r, o, s), o += s) : o += n, r += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    Hd(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], o = this.sections[t++];
      o < 0 ? e.push(r, o) : e.push(o, r);
    }
    return new sr(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : cA(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : Xd(this, e, t);
  }
  mapPos(e, t = -1, r = bt.Simple) {
    let o = 0, s = 0;
    for (let n = 0; n < this.sections.length; ) {
      let a = this.sections[n++], l = this.sections[n++], u = o + a;
      if (l < 0) {
        if (u > e)
          return s + (e - o);
        s += a;
      } else {
        if (r != bt.Simple && u >= e && (r == bt.TrackDel && o < e && u > e || r == bt.TrackBefore && o < e || r == bt.TrackAfter && u > e))
          return null;
        if (u > e || u == e && t < 0 && !a)
          return e == o || t < 0 ? s : s + l;
        s += l;
      }
      o = u;
    }
    if (e > o)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${o}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let r = 0, o = 0; r < this.sections.length && o <= t; ) {
      let s = this.sections[r++], n = this.sections[r++], a = o + s;
      if (n >= 0 && o <= t && a >= e)
        return o < e && a > t ? "cover" : !0;
      o = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], o = this.sections[t++];
      e += (e ? " " : "") + r + (o >= 0 ? ":" + o : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new sr(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new sr(e);
  }
}
class st extends sr {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Hd(this, (t, r, o, s, n) => e = e.replace(o, o + (r - t), n), !1), e;
  }
  mapDesc(e, t = !1) {
    return Xd(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), r = [];
    for (let o = 0, s = 0; o < t.length; o += 2) {
      let n = t[o], a = t[o + 1];
      if (a >= 0) {
        t[o] = a, t[o + 1] = n;
        let l = o >> 1;
        for (; r.length < l; )
          r.push(Ce.empty);
        r.push(n ? e.slice(s, s + n) : Ce.empty);
      }
      s += n;
    }
    return new st(t, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : cA(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : Xd(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    Hd(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return sr.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], r = [], o = [], s = new _a(this);
    e:
      for (let n = 0, a = 0; ; ) {
        let l = n == e.length ? 1e9 : e[n++];
        for (; a < l || a == l && s.len == 0; ) {
          if (s.done)
            break e;
          let h = Math.min(s.len, l - a);
          vt(o, h, -1);
          let c = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          vt(t, h, c), c > 0 && jr(r, t, s.text), s.forward(h), a += h;
        }
        let u = e[n++];
        for (; a < u; ) {
          if (s.done)
            break e;
          let h = Math.min(s.len, u - a);
          vt(t, h, -1), vt(o, h, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(h), a += h;
        }
      }
    return {
      changes: new st(t, r),
      filtered: sr.create(o)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t], o = this.sections[t + 1];
      o < 0 ? e.push(r) : o == 0 ? e.push([r]) : e.push([r].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, r) {
    let o = [], s = [], n = 0, a = null;
    function l(h = !1) {
      if (!h && !o.length)
        return;
      n < t && vt(o, t - n, -1);
      let c = new st(o, s);
      a = a ? a.compose(c.map(a)) : c, o = [], s = [], n = 0;
    }
    function u(h) {
      if (Array.isArray(h))
        for (let c of h)
          u(c);
      else if (h instanceof st) {
        if (h.length != t)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${t})`);
        l(), a = a ? a.compose(h.map(a)) : h;
      } else {
        let { from: c, to: d = c, insert: f } = h;
        if (c > d || c < 0 || d > t)
          throw new RangeError(`Invalid change range ${c} to ${d} (in doc of length ${t})`);
        let p = f ? typeof f == "string" ? Ce.of(f.split(r || Vd)) : f : Ce.empty, O = p.length;
        if (c == d && O == 0)
          return;
        c < n && l(), c > n && vt(o, c - n, -1), vt(o, d - c, O), jr(s, o, p), n = d;
      }
    }
    return u(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new st(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], r = [];
    for (let o = 0; o < e.length; o++) {
      let s = e[o];
      if (typeof s == "number")
        t.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((n, a) => a && typeof n != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          t.push(s[0], 0);
        else {
          for (; r.length < o; )
            r.push(Ce.empty);
          r[o] = Ce.of(s.slice(1)), t.push(s[0], r[o].length);
        }
      }
    }
    return new st(t, r);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new st(e, t);
  }
}
function vt(i, e, t, r = !1) {
  if (e == 0 && t <= 0)
    return;
  let o = i.length - 2;
  o >= 0 && t <= 0 && t == i[o + 1] ? i[o] += e : e == 0 && i[o] == 0 ? i[o + 1] += t : r ? (i[o] += e, i[o + 1] += t) : i.push(e, t);
}
function jr(i, e, t) {
  if (t.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < i.length)
    i[i.length - 1] = i[i.length - 1].append(t);
  else {
    for (; i.length < r; )
      i.push(Ce.empty);
    i.push(t);
  }
}
function Hd(i, e, t) {
  let r = i.inserted;
  for (let o = 0, s = 0, n = 0; n < i.sections.length; ) {
    let a = i.sections[n++], l = i.sections[n++];
    if (l < 0)
      o += a, s += a;
    else {
      let u = o, h = s, c = Ce.empty;
      for (; u += a, h += l, l && r && (c = c.append(r[n - 2 >> 1])), !(t || n == i.sections.length || i.sections[n + 1] < 0); )
        a = i.sections[n++], l = i.sections[n++];
      e(o, u, s, h, c), o = u, s = h;
    }
  }
}
function Xd(i, e, t, r = !1) {
  let o = [], s = r ? [] : null, n = new _a(i), a = new _a(e);
  for (let l = -1; ; )
    if (n.ins == -1 && a.ins == -1) {
      let u = Math.min(n.len, a.len);
      vt(o, u, -1), n.forward(u), a.forward(u);
    } else if (a.ins >= 0 && (n.ins < 0 || l == n.i || n.off == 0 && (a.len < n.len || a.len == n.len && !t))) {
      let u = a.len;
      for (vt(o, a.ins, -1); u; ) {
        let h = Math.min(n.len, u);
        n.ins >= 0 && l < n.i && n.len <= h && (vt(o, 0, n.ins), s && jr(s, o, n.text), l = n.i), n.forward(h), u -= h;
      }
      a.next();
    } else if (n.ins >= 0) {
      let u = 0, h = n.len;
      for (; h; )
        if (a.ins == -1) {
          let c = Math.min(h, a.len);
          u += c, h -= c, a.forward(c);
        } else if (a.ins == 0 && a.len < h)
          h -= a.len, a.next();
        else
          break;
      vt(o, u, l < n.i ? n.ins : 0), s && l < n.i && jr(s, o, n.text), l = n.i, n.forward(n.len - h);
    } else {
      if (n.done && a.done)
        return s ? st.createSet(o, s) : sr.create(o);
      throw new Error("Mismatched change set lengths");
    }
}
function cA(i, e, t = !1) {
  let r = [], o = t ? [] : null, s = new _a(i), n = new _a(e);
  for (let a = !1; ; ) {
    if (s.done && n.done)
      return o ? st.createSet(r, o) : sr.create(r);
    if (s.ins == 0)
      vt(r, s.len, 0, a), s.next();
    else if (n.len == 0 && !n.done)
      vt(r, 0, n.ins, a), o && jr(o, r, n.text), n.next();
    else {
      if (s.done || n.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(s.len2, n.len), u = r.length;
        if (s.ins == -1) {
          let h = n.ins == -1 ? -1 : n.off ? 0 : n.ins;
          vt(r, l, h, a), o && h && jr(o, r, n.text);
        } else
          n.ins == -1 ? (vt(r, s.off ? 0 : s.len, l, a), o && jr(o, r, s.textBit(l))) : (vt(r, s.off ? 0 : s.len, n.off ? 0 : n.ins, a), o && !n.off && jr(o, r, n.text));
        a = (s.ins > l || n.ins >= 0 && n.len > l) && (a || r.length > u), s.forward2(l), n.forward(l);
      }
    }
  }
}
class _a {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? Ce.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, r = this.i - 2 >> 1;
    return r >= t.length && !e ? Ce.empty : t[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class $o {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.flags = r;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 3;
    return e == 3 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 5;
    return e == 33554431 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let r, o;
    return this.empty ? r = o = e.mapPos(this.from, t) : (r = e.mapPos(this.from, 1), o = e.mapPos(this.to, -1)), r == this.from && o == this.to ? this : new $o(r, o, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return D.range(e, t);
    let r = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return D.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return D.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new $o(e, t, r);
  }
}
class D {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : D.create(this.ranges.map((r) => r.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let t = 0; t < this.ranges.length; t++)
      if (!this.ranges[t].eq(e.ranges[t]))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new D([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return D.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let r = this.ranges.slice();
    return r[t] = e, D.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new D(e.ranges.map((t) => $o.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new D([D.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, o = 0; o < e.length; o++) {
      let s = e[o];
      if (s.empty ? s.from <= r : s.from < r)
        return D.normalized(e.slice(), t);
      r = s.to;
    }
    return new D(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, r, o) {
    return $o.create(e, e, (t == 0 ? 0 : t < 0 ? 4 : 8) | (r == null ? 3 : Math.min(2, r)) | (o ?? 33554431) << 5);
  }
  /**
  Create a selection range.
  */
  static range(e, t, r, o) {
    let s = (r ?? 33554431) << 5 | (o == null ? 3 : Math.min(2, o));
    return t < e ? $o.create(t, e, 24 | s) : $o.create(e, t, (t > e ? 4 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let r = e[t];
    e.sort((o, s) => o.from - s.from), t = e.indexOf(r);
    for (let o = 1; o < e.length; o++) {
      let s = e[o], n = e[o - 1];
      if (s.empty ? s.from <= n.to : s.from < n.to) {
        let a = n.from, l = Math.max(s.to, n.to);
        o <= t && t--, e.splice(--o, 2, s.anchor > s.head ? D.range(l, a) : D.range(a, l));
      }
    }
    return new D(e, t);
  }
}
function dA(i, e) {
  for (let t of i.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let qp = 0;
class K {
  constructor(e, t, r, o, s) {
    this.combine = e, this.compareInput = t, this.compare = r, this.isStatic = o, this.id = qp++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new K(e.combine || ((t) => t), e.compareInput || ((t, r) => t === r), e.compare || (e.combine ? (t, r) => t === r : jp), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new zl([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new zl(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new zl(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (r) => r), this.compute([e], (r) => t(r.field(e)));
  }
}
function jp(i, e) {
  return i == e || i.length == e.length && i.every((t, r) => t === e[r]);
}
class zl {
  constructor(e, t, r, o) {
    this.dependencies = e, this.facet = t, this.type = r, this.value = o, this.id = qp++;
  }
  dynamicSlot(e) {
    var t;
    let r = this.value, o = this.facet.compareInput, s = this.id, n = e[s] >> 1, a = this.type == 2, l = !1, u = !1, h = [];
    for (let c of this.dependencies)
      c == "doc" ? l = !0 : c == "selection" ? u = !0 : ((t = e[c.id]) !== null && t !== void 0 ? t : 1) & 1 || h.push(e[c.id]);
    return {
      create(c) {
        return c.values[n] = r(c), 1;
      },
      update(c, d) {
        if (l && d.docChanged || u && (d.docChanged || d.selection) || Yd(c, h)) {
          let f = r(c);
          if (a ? !mm(f, c.values[n], o) : !o(f, c.values[n]))
            return c.values[n] = f, 1;
        }
        return 0;
      },
      reconfigure: (c, d) => {
        let f, p = d.config.address[s];
        if (p != null) {
          let O = Du(d, p);
          if (this.dependencies.every((m) => m instanceof K ? d.facet(m) === c.facet(m) : m instanceof ct ? d.field(m, !1) == c.field(m, !1) : !0) || (a ? mm(f = r(c), O, o) : o(f = r(c), O)))
            return c.values[n] = O, 0;
        } else
          f = r(c);
        return c.values[n] = f, 1;
      }
    };
  }
}
function mm(i, e, t) {
  if (i.length != e.length)
    return !1;
  for (let r = 0; r < i.length; r++)
    if (!t(i[r], e[r]))
      return !1;
  return !0;
}
function Yd(i, e) {
  let t = !1;
  for (let r of e)
    la(i, r) & 1 && (t = !0);
  return t;
}
function e1(i, e, t) {
  let r = t.map((l) => i[l.id]), o = t.map((l) => l.type), s = r.filter((l) => !(l & 1)), n = i[e.id] >> 1;
  function a(l) {
    let u = [];
    for (let h = 0; h < r.length; h++) {
      let c = Du(l, r[h]);
      if (o[h] == 2)
        for (let d of c)
          u.push(d);
      else
        u.push(c);
    }
    return e.combine(u);
  }
  return {
    create(l) {
      for (let u of r)
        la(l, u);
      return l.values[n] = a(l), 1;
    },
    update(l, u) {
      if (!Yd(l, s))
        return 0;
      let h = a(l);
      return e.compare(h, l.values[n]) ? 0 : (l.values[n] = h, 1);
    },
    reconfigure(l, u) {
      let h = Yd(l, r), c = u.config.facets[e.id], d = u.facet(e);
      if (c && !h && jp(t, c))
        return l.values[n] = d, 0;
      let f = a(l);
      return e.compare(f, d) ? (l.values[n] = d, 0) : (l.values[n] = f, 1);
    }
  };
}
const gm = /* @__PURE__ */ K.define({ static: !0 });
class ct {
  constructor(e, t, r, o, s) {
    this.id = e, this.createF = t, this.updateF = r, this.compareF = o, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new ct(qp++, e.create, e.update, e.compare || ((r, o) => r === o), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(gm).find((r) => r.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (r) => (r.values[t] = this.create(r), 1),
      update: (r, o) => {
        let s = r.values[t], n = this.updateF(s, o);
        return this.compareF(s, n) ? 0 : (r.values[t] = n, 1);
      },
      reconfigure: (r, o) => o.config.address[this.id] != null ? (r.values[t] = o.field(this), 0) : (r.values[t] = this.create(r), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, gm.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Do = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function wn(i) {
  return (e) => new fA(e, i);
}
const ds = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ wn(Do.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ wn(Do.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ wn(Do.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ wn(Do.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ wn(Do.lowest)
};
class fA {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class Qh {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Bd(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Qh.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Bd {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class yu {
  constructor(e, t, r, o, s, n) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = r, this.address = o, this.staticValues = s, this.facets = n, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, r) {
    let o = [], s = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ new Map();
    for (let d of t1(e, t, n))
      d instanceof ct ? o.push(d) : (s[d.facet.id] || (s[d.facet.id] = [])).push(d);
    let a = /* @__PURE__ */ Object.create(null), l = [], u = [];
    for (let d of o)
      a[d.id] = u.length << 1, u.push((f) => d.slot(f));
    let h = r == null ? void 0 : r.config.facets;
    for (let d in s) {
      let f = s[d], p = f[0].facet, O = h && h[d] || [];
      if (f.every(
        (m) => m.type == 0
        /* Provider.Static */
      ))
        if (a[p.id] = l.length << 1 | 1, jp(O, f))
          l.push(r.facet(p));
        else {
          let m = p.combine(f.map((E) => E.value));
          l.push(r && p.compare(m, r.facet(p)) ? r.facet(p) : m);
        }
      else {
        for (let m of f)
          m.type == 0 ? (a[m.id] = l.length << 1 | 1, l.push(m.value)) : (a[m.id] = u.length << 1, u.push((E) => m.dynamicSlot(E)));
        a[p.id] = u.length << 1, u.push((m) => e1(m, p, f));
      }
    }
    let c = u.map((d) => d(a));
    return new yu(e, n, c, a, l, s);
  }
}
function t1(i, e, t) {
  let r = [[], [], [], [], []], o = /* @__PURE__ */ new Map();
  function s(n, a) {
    let l = o.get(n);
    if (l != null) {
      if (l <= a)
        return;
      let u = r[l].indexOf(n);
      u > -1 && r[l].splice(u, 1), n instanceof Bd && t.delete(n.compartment);
    }
    if (o.set(n, a), Array.isArray(n))
      for (let u of n)
        s(u, a);
    else if (n instanceof Bd) {
      if (t.has(n.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = e.get(n.compartment) || n.inner;
      t.set(n.compartment, u), s(u, a);
    } else if (n instanceof fA)
      s(n.inner, n.prec);
    else if (n instanceof ct)
      r[a].push(n), n.provides && s(n.provides, a);
    else if (n instanceof zl)
      r[a].push(n), n.facet.extensions && s(n.facet.extensions, Do.default);
    else {
      let u = n.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${n}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(u, a);
    }
  }
  return s(i, Do.default), r.reduce((n, a) => n.concat(a));
}
function la(i, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, r = i.status[t];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  i.status[t] = 4;
  let o = i.computeSlot(i, i.config.dynamicSlots[t]);
  return i.status[t] = 2 | o;
}
function Du(i, e) {
  return e & 1 ? i.config.staticValues[e >> 1] : i.values[e >> 1];
}
const pA = /* @__PURE__ */ K.define(), OA = /* @__PURE__ */ K.define({
  combine: (i) => i.some((e) => e),
  static: !0
}), EA = /* @__PURE__ */ K.define({
  combine: (i) => i.length ? i[0] : void 0,
  static: !0
}), mA = /* @__PURE__ */ K.define(), gA = /* @__PURE__ */ K.define(), bA = /* @__PURE__ */ K.define(), TA = /* @__PURE__ */ K.define({
  combine: (i) => i.length ? i[0] : !1
});
class Mr {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new i1();
  }
}
class i1 {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Mr(this, e);
  }
}
class r1 {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new fe(this, e);
  }
}
class fe {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new fe(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new r1(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let r = [];
    for (let o of e) {
      let s = o.map(t);
      s && r.push(s);
    }
    return r;
  }
}
fe.reconfigure = /* @__PURE__ */ fe.define();
fe.appendConfig = /* @__PURE__ */ fe.define();
class nt {
  constructor(e, t, r, o, s, n) {
    this.startState = e, this.changes = t, this.selection = r, this.effects = o, this.annotations = s, this.scrollIntoView = n, this._doc = null, this._state = null, r && dA(r, t.newLength), s.some((a) => a.type == nt.time) || (this.annotations = s.concat(nt.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, r, o, s, n) {
    return new nt(e, t, r, o, s, n);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(nt.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
nt.time = /* @__PURE__ */ Mr.define();
nt.userEvent = /* @__PURE__ */ Mr.define();
nt.addToHistory = /* @__PURE__ */ Mr.define();
nt.remote = /* @__PURE__ */ Mr.define();
function o1(i, e) {
  let t = [];
  for (let r = 0, o = 0; ; ) {
    let s, n;
    if (r < i.length && (o == e.length || e[o] >= i[r]))
      s = i[r++], n = i[r++];
    else if (o < e.length)
      s = e[o++], n = e[o++];
    else
      return t;
    !t.length || t[t.length - 1] < s ? t.push(s, n) : t[t.length - 1] < n && (t[t.length - 1] = n);
  }
}
function SA(i, e, t) {
  var r;
  let o, s, n;
  return t ? (o = e.changes, s = st.empty(e.changes.length), n = i.changes.compose(e.changes)) : (o = e.changes.map(i.changes), s = i.changes.mapDesc(e.changes, !0), n = i.changes.compose(o)), {
    changes: n,
    selection: e.selection ? e.selection.map(s) : (r = i.selection) === null || r === void 0 ? void 0 : r.map(o),
    effects: fe.mapEffects(i.effects, o).concat(fe.mapEffects(e.effects, s)),
    annotations: i.annotations.length ? i.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: i.scrollIntoView || e.scrollIntoView
  };
}
function Fd(i, e, t) {
  let r = e.selection, o = Hs(e.annotations);
  return e.userEvent && (o = o.concat(nt.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof st ? e.changes : st.of(e.changes || [], t, i.facet(EA)),
    selection: r && (r instanceof D ? r : D.single(r.anchor, r.head)),
    effects: Hs(e.effects),
    annotations: o,
    scrollIntoView: !!e.scrollIntoView
  };
}
function RA(i, e, t) {
  let r = Fd(i, e.length ? e[0] : {}, i.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (t = !1);
    let n = !!e[s].sequential;
    r = SA(r, Fd(i, e[s], n ? r.changes.newLength : i.doc.length), n);
  }
  let o = nt.create(i, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return n1(t ? s1(o) : o);
}
function s1(i) {
  let e = i.startState, t = !0;
  for (let o of e.facet(mA)) {
    let s = o(i);
    if (s === !1) {
      t = !1;
      break;
    }
    Array.isArray(s) && (t = t === !0 ? s : o1(t, s));
  }
  if (t !== !0) {
    let o, s;
    if (t === !1)
      s = i.changes.invertedDesc, o = st.empty(e.doc.length);
    else {
      let n = i.changes.filter(t);
      o = n.changes, s = n.filtered.mapDesc(n.changes).invertedDesc;
    }
    i = nt.create(e, o, i.selection && i.selection.map(s), fe.mapEffects(i.effects, s), i.annotations, i.scrollIntoView);
  }
  let r = e.facet(gA);
  for (let o = r.length - 1; o >= 0; o--) {
    let s = r[o](i);
    s instanceof nt ? i = s : Array.isArray(s) && s.length == 1 && s[0] instanceof nt ? i = s[0] : i = RA(e, Hs(s), !1);
  }
  return i;
}
function n1(i) {
  let e = i.startState, t = e.facet(bA), r = i;
  for (let o = t.length - 1; o >= 0; o--) {
    let s = t[o](i);
    s && Object.keys(s).length && (r = SA(r, Fd(e, s, i.changes.newLength), !0));
  }
  return r == i ? i : nt.create(e, i.changes, i.selection, r.effects, r.annotations, r.scrollIntoView);
}
const a1 = [];
function Hs(i) {
  return i == null ? a1 : Array.isArray(i) ? i : [i];
}
var $e = /* @__PURE__ */ function(i) {
  return i[i.Word = 0] = "Word", i[i.Space = 1] = "Space", i[i.Other = 2] = "Other", i;
}($e || ($e = {}));
const l1 = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Wd;
try {
  Wd = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function u1(i) {
  if (Wd)
    return Wd.test(i);
  for (let e = 0; e < i.length; e++) {
    let t = i[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || l1.test(t)))
      return !0;
  }
  return !1;
}
function h1(i) {
  return (e) => {
    if (!/\S/.test(e))
      return $e.Space;
    if (u1(e))
      return $e.Word;
    for (let t = 0; t < i.length; t++)
      if (e.indexOf(i[t]) > -1)
        return $e.Word;
    return $e.Other;
  };
}
class Re {
  constructor(e, t, r, o, s, n) {
    this.config = e, this.doc = t, this.selection = r, this.values = o, this.status = e.statusTemplate.slice(), this.computeSlot = s, n && (n._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      la(this, a << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return la(this, r), Du(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return RA(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: r, compartments: o } = t;
    for (let n of e.effects)
      n.is(Qh.reconfigure) ? (t && (o = /* @__PURE__ */ new Map(), t.compartments.forEach((a, l) => o.set(l, a)), t = null), o.set(n.value.compartment, n.value.extension)) : n.is(fe.reconfigure) ? (t = null, r = n.value) : n.is(fe.appendConfig) && (t = null, r = Hs(r).concat(n.value));
    let s;
    t ? s = e.startState.values.slice() : (t = yu.resolve(r, o, this), s = new Re(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (a, l) => l.reconfigure(a, this), null).values), new Re(t, e.newDoc, e.newSelection, s, (n, a) => a.update(n, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: D.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, r = e(t.ranges[0]), o = this.changes(r.changes), s = [r.range], n = Hs(r.effects);
    for (let a = 1; a < t.ranges.length; a++) {
      let l = e(t.ranges[a]), u = this.changes(l.changes), h = u.map(o);
      for (let d = 0; d < a; d++)
        s[d] = s[d].map(h);
      let c = o.mapDesc(u, !0);
      s.push(l.range.map(c)), o = o.compose(h), n = fe.mapEffects(n, h).concat(fe.mapEffects(Hs(l.effects), c));
    }
    return {
      changes: o,
      selection: D.create(s, t.mainIndex),
      effects: n
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof st ? e : st.of(e, this.doc.length, this.facet(Re.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Ce.of(e.split(this.facet(Re.lineSeparator) || Vd));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (la(this, t), Du(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let o = e[r];
        o instanceof ct && this.config.address[o.id] != null && (t[r] = o.spec.toJSON(this.field(e[r]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let o = [];
    if (r) {
      for (let s in r)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let n = r[s], a = e[s];
          o.push(n.init((l) => n.spec.fromJSON(a, l)));
        }
    }
    return Re.create({
      doc: e.doc,
      selection: D.fromJSON(e.selection),
      extensions: t.extensions ? o.concat([t.extensions]) : o
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = yu.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof Ce ? e.doc : Ce.of((e.doc || "").split(t.staticFacet(Re.lineSeparator) || Vd)), o = e.selection ? e.selection instanceof D ? e.selection : D.single(e.selection.anchor, e.selection.head) : D.single(0);
    return dA(o, r.length), t.staticFacet(OA) || (o = o.asSingle()), new Re(t, r, o, t.dynamicSlots.map(() => null), (s, n) => n.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Re.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Re.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(TA);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let r of this.facet(Re.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (r, o) => {
      if (o == "$")
        return "$";
      let s = +(o || 1);
      return !s || s > t.length ? r : t[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, r = -1) {
    let o = [];
    for (let s of this.facet(pA))
      for (let n of s(this, t, r))
        Object.prototype.hasOwnProperty.call(n, e) && o.push(n[e]);
    return o;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return h1(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: r, length: o } = this.doc.lineAt(e), s = this.charCategorizer(e), n = e - r, a = e - r;
    for (; n > 0; ) {
      let l = $t(t, n, !1);
      if (s(t.slice(l, n)) != $e.Word)
        break;
      n = l;
    }
    for (; a < o; ) {
      let l = $t(t, a);
      if (s(t.slice(a, l)) != $e.Word)
        break;
      a = l;
    }
    return n == a ? null : D.range(n + r, a + r);
  }
}
Re.allowMultipleSelections = OA;
Re.tabSize = /* @__PURE__ */ K.define({
  combine: (i) => i.length ? i[0] : 4
});
Re.lineSeparator = EA;
Re.readOnly = TA;
Re.phrases = /* @__PURE__ */ K.define({
  compare(i, e) {
    let t = Object.keys(i), r = Object.keys(e);
    return t.length == r.length && t.every((o) => i[o] == e[o]);
  }
});
Re.languageData = pA;
Re.changeFilter = mA;
Re.transactionFilter = gA;
Re.transactionExtender = bA;
Qh.reconfigure = /* @__PURE__ */ fe.define();
function cr(i, e, t = {}) {
  let r = {};
  for (let o of i)
    for (let s of Object.keys(o)) {
      let n = o[s], a = r[s];
      if (a === void 0)
        r[s] = n;
      else if (!(a === n || n === void 0))
        if (Object.hasOwnProperty.call(t, s))
          r[s] = t[s](a, n);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let o in e)
    r[o] === void 0 && (r[o] = e[o]);
  return r;
}
class es {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return zd.create(e, t, this);
  }
}
es.prototype.startSide = es.prototype.endSide = 0;
es.prototype.point = !1;
es.prototype.mapMode = bt.TrackDel;
let zd = class AA {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.value = r;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new AA(e, t, r);
  }
};
function Zd(i, e) {
  return i.from - e.from || i.value.startSide - e.value.startSide;
}
class Kp {
  constructor(e, t, r, o) {
    this.from = e, this.to = t, this.value = r, this.maxPoint = o;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, r, o = 0) {
    let s = r ? this.to : this.from;
    for (let n = o, a = s.length; ; ) {
      if (n == a)
        return n;
      let l = n + a >> 1, u = s[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == n)
        return u >= 0 ? n : a;
      u >= 0 ? a = l : n = l + 1;
    }
  }
  between(e, t, r, o) {
    for (let s = this.findIndex(t, -1e9, !0), n = this.findIndex(r, 1e9, !1, s); s < n; s++)
      if (o(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, t) {
    let r = [], o = [], s = [], n = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let u = this.value[l], h = this.from[l] + e, c = this.to[l] + e, d, f;
      if (h == c) {
        let p = t.mapPos(h, u.startSide, u.mapMode);
        if (p == null || (d = f = p, u.startSide != u.endSide && (f = t.mapPos(h, u.endSide), f < d)))
          continue;
      } else if (d = t.mapPos(h, u.startSide), f = t.mapPos(c, u.endSide), d > f || d == f && u.startSide > 0 && u.endSide <= 0)
        continue;
      (f - d || u.endSide - u.startSide) < 0 || (n < 0 && (n = d), u.point && (a = Math.max(a, f - d)), r.push(u), o.push(d - n), s.push(f - n));
    }
    return { mapped: r.length ? new Kp(o, s, r, a) : null, pos: n };
  }
}
class Le {
  constructor(e, t, r, o) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = r, this.maxPoint = o;
  }
  /**
  @internal
  */
  static create(e, t, r, o) {
    return new Le(e, t, r, o);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: r = !1, filterFrom: o = 0, filterTo: s = this.length } = e, n = e.filter;
    if (t.length == 0 && !n)
      return this;
    if (r && (t = t.slice().sort(Zd)), this.isEmpty)
      return t.length ? Le.of(t) : this;
    let a = new CA(this, null, -1).goto(0), l = 0, u = [], h = new Eo();
    for (; a.value || l < t.length; )
      if (l < t.length && (a.from - t[l].from || a.startSide - t[l].value.startSide) >= 0) {
        let c = t[l++];
        h.addInner(c.from, c.to, c.value) || u.push(c);
      } else
        a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(a.chunkIndex) < t[l].from) && (!n || o > this.chunkEnd(a.chunkIndex) || s < this.chunkPos[a.chunkIndex]) && h.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!n || o > a.to || s < a.from || n(a.from, a.to, a.value)) && (h.addInner(a.from, a.to, a.value) || u.push(zd.create(a.from, a.to, a.value))), a.next());
    return h.finishInner(this.nextLayer.isEmpty && !u.length ? Le.empty : this.nextLayer.update({ add: u, filter: n, filterFrom: o, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], r = [], o = -1;
    for (let n = 0; n < this.chunk.length; n++) {
      let a = this.chunkPos[n], l = this.chunk[n], u = e.touchesRange(a, a + l.length);
      if (u === !1)
        o = Math.max(o, l.maxPoint), t.push(l), r.push(e.mapPos(a));
      else if (u === !0) {
        let { mapped: h, pos: c } = l.map(a, e);
        h && (o = Math.max(o, h.maxPoint), t.push(h), r.push(c));
      }
    }
    let s = this.nextLayer.map(e);
    return t.length == 0 ? s : new Le(r, t, s || Le.empty, o);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, r) {
    if (!this.isEmpty) {
      for (let o = 0; o < this.chunk.length; o++) {
        let s = this.chunkPos[o], n = this.chunk[o];
        if (t >= s && e <= s + n.length && n.between(s, e - s, t - s, r) === !1)
          return;
      }
      this.nextLayer.between(e, t, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Pa.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return Pa.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, r, o, s = -1) {
    let n = e.filter((c) => c.maxPoint > 0 || !c.isEmpty && c.maxPoint >= s), a = t.filter((c) => c.maxPoint > 0 || !c.isEmpty && c.maxPoint >= s), l = bm(n, a, r), u = new yn(n, l, s), h = new yn(a, l, s);
    r.iterGaps((c, d, f) => Tm(u, c, h, d, f, o)), r.empty && r.length == 0 && Tm(u, 0, h, 0, 0, o);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, r = 0, o) {
    o == null && (o = 1e9 - 1);
    let s = e.filter((h) => !h.isEmpty && t.indexOf(h) < 0), n = t.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (s.length != n.length)
      return !1;
    if (!s.length)
      return !0;
    let a = bm(s, n), l = new yn(s, a, 0).goto(r), u = new yn(n, a, 0).goto(r);
    for (; ; ) {
      if (l.to != u.to || !qd(l.active, u.active) || l.point && (!u.point || !l.point.eq(u.point)))
        return !1;
      if (l.to > o)
        return !0;
      l.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, r, o, s = -1) {
    let n = new yn(e, null, s).goto(t), a = t, l = n.openStart;
    for (; ; ) {
      let u = Math.min(n.to, r);
      if (n.point) {
        let h = n.activeForPoint(n.to), c = n.pointFrom < t ? h.length + 1 : Math.min(h.length, l);
        o.point(a, u, n.point, h, c, n.pointRank), l = Math.min(n.openEnd(u), h.length);
      } else
        u > a && (o.span(a, u, n.active, l), l = n.openEnd(u));
      if (n.to > r)
        return l + (n.point && n.to > r ? 1 : 0);
      a = n.to, n.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let r = new Eo();
    for (let o of e instanceof zd ? [e] : t ? c1(e) : e)
      r.add(o.from, o.to, o.value);
    return r.finish();
  }
}
Le.empty = /* @__PURE__ */ new Le([], [], null, -1);
function c1(i) {
  if (i.length > 1)
    for (let e = i[0], t = 1; t < i.length; t++) {
      let r = i[t];
      if (Zd(e, r) > 0)
        return i.slice().sort(Zd);
      e = r;
    }
  return i;
}
Le.empty.nextLayer = Le.empty;
class Eo {
  finishChunk(e) {
    this.chunks.push(new Kp(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, r) {
    this.addInner(e, t, r) || (this.nextLayer || (this.nextLayer = new Eo())).add(e, t, r);
  }
  /**
  @internal
  */
  addInner(e, t, r) {
    let o = e - this.lastTo || r.startSide - this.last.endSide;
    if (o <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return o < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = t, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let r = t.value.length - 1;
    return this.last = t.value[r], this.lastFrom = t.from[r] + e, this.lastTo = t.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Le.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = Le.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function bm(i, e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let s of i)
    for (let n = 0; n < s.chunk.length; n++)
      s.chunk[n].maxPoint <= 0 && r.set(s.chunk[n], s.chunkPos[n]);
  let o = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let n = 0; n < s.chunk.length; n++) {
      let a = r.get(s.chunk[n]);
      a != null && (t ? t.mapPos(a) : a) == s.chunkPos[n] && !(t != null && t.touchesRange(a, a + s.chunk[n].length)) && o.add(s.chunk[n]);
    }
  return o;
}
class CA {
  constructor(e, t, r, o = 0) {
    this.layer = e, this.skip = t, this.minPoint = r, this.rank = o;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let o = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(o) || this.layer.chunkEnd(this.chunkIndex) < e || o.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let o = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!r || this.rangeIndex < o) && this.setRangeIndex(o);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], r = e + t.from[this.rangeIndex];
        if (this.from = r, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Pa {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, r = -1) {
    let o = [];
    for (let s = 0; s < e.length; s++)
      for (let n = e[s]; !n.isEmpty; n = n.nextLayer)
        n.maxPoint >= r && o.push(new CA(n, t, r, s));
    return o.length == 1 ? o[0] : new Pa(o);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let r of this.heap)
      r.goto(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Cc(this.heap, r);
    return this.next(), this;
  }
  forward(e, t) {
    for (let r of this.heap)
      r.forward(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Cc(this.heap, r);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Cc(this.heap, 0);
    }
  }
}
function Cc(i, e) {
  for (let t = i[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= i.length)
      break;
    let o = i[r];
    if (r + 1 < i.length && o.compare(i[r + 1]) >= 0 && (o = i[r + 1], r++), t.compare(o) < 0)
      break;
    i[r] = t, i[e] = o, e = r;
  }
}
class yn {
  constructor(e, t, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Pa.from(e, t, r);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Sl(this.active, e), Sl(this.activeTo, e), Sl(this.activeRank, e), this.minActive = Sm(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: r, to: o, rank: s } = this.cursor;
    for (; t < this.activeRank.length && this.activeRank[t] <= s; )
      t++;
    Rl(this.active, t, r), Rl(this.activeTo, t, o), Rl(this.activeRank, t, s), e && Rl(e, t, this.cursor.from), this.minActive = Sm(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let o = this.minActive;
      if (o > -1 && (this.activeTo[o] - this.cursor.from || this.active[o].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[o] > e) {
          this.to = this.activeTo[o], this.endSide = this.active[o].endSide;
          break;
        }
        this.removeActive(o), r && Sl(r, o);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(r), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let o = r.length - 1; o >= 0 && r[o] < e; o--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && t.push(this.active[r]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      t++;
    return t;
  }
}
function Tm(i, e, t, r, o, s) {
  i.goto(e), t.goto(r);
  let n = r + o, a = r, l = r - e;
  for (; ; ) {
    let u = i.to + l - t.to || i.endSide - t.endSide, h = u < 0 ? i.to + l : t.to, c = Math.min(h, n);
    if (i.point || t.point ? i.point && t.point && (i.point == t.point || i.point.eq(t.point)) && qd(i.activeForPoint(i.to), t.activeForPoint(t.to)) || s.comparePoint(a, c, i.point, t.point) : c > a && !qd(i.active, t.active) && s.compareRange(a, c, i.active, t.active), h > n)
      break;
    a = h, u <= 0 && i.next(), u >= 0 && t.next();
  }
}
function qd(i, e) {
  if (i.length != e.length)
    return !1;
  for (let t = 0; t < i.length; t++)
    if (i[t] != e[t] && !i[t].eq(e[t]))
      return !1;
  return !0;
}
function Sl(i, e) {
  for (let t = e, r = i.length - 1; t < r; t++)
    i[t] = i[t + 1];
  i.pop();
}
function Rl(i, e, t) {
  for (let r = i.length - 1; r >= e; r--)
    i[r + 1] = i[r];
  i[e] = t;
}
function Sm(i, e) {
  let t = -1, r = 1e9;
  for (let o = 0; o < e.length; o++)
    (e[o] - r || i[o].endSide - i[t].endSide) < 0 && (t = o, r = e[o]);
  return t;
}
function qa(i, e, t = i.length) {
  let r = 0;
  for (let o = 0; o < t; )
    i.charCodeAt(o) == 9 ? (r += e - r % e, o++) : (r++, o = $t(i, o));
  return r;
}
function jd(i, e, t, r) {
  for (let o = 0, s = 0; ; ) {
    if (s >= e)
      return o;
    if (o == i.length)
      break;
    s += i.charCodeAt(o) == 9 ? t - s % t : 1, o = $t(i, o);
  }
  return r === !0 ? -1 : i.length;
}
const Kd = "ͼ", Rm = typeof Symbol > "u" ? "__" + Kd : Symbol.for(Kd), Jd = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), Am = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class mo {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: r } = t || {};
    function o(n) {
      return /^@/.test(n) ? [n] : n.split(/,\s*/);
    }
    function s(n, a, l, u) {
      let h = [], c = /^@(\w+)\b/.exec(n[0]), d = c && c[1] == "keyframes";
      if (c && a == null)
        return l.push(n[0] + ";");
      for (let f in a) {
        let p = a[f];
        if (/&/.test(f))
          s(
            f.split(/,\s*/).map((O) => n.map((m) => O.replace(/&/, m))).reduce((O, m) => O.concat(m)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!c)
            throw new RangeError("The value of a property (" + f + ") should be a primitive value.");
          s(o(f), p, h, d);
        } else
          p != null && h.push(f.replace(/_.*/, "").replace(/[A-Z]/g, (O) => "-" + O.toLowerCase()) + ": " + p + ";");
      }
      (h.length || d) && l.push((r && !c && !u ? n.map(r) : n).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let n in e)
      s(o(n), e[n], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = Am[Rm] || 1;
    return Am[Rm] = e + 1, Kd + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  static mount(e, t) {
    (e[Jd] || new d1(e)).mount(Array.isArray(t) ? t : [t]);
  }
}
let Cm = /* @__PURE__ */ new Map();
class d1 {
  constructor(e) {
    let t = e.ownerDocument || e, r = t.defaultView;
    if (!e.head && e.adoptedStyleSheets && r.CSSStyleSheet) {
      let o = Cm.get(t);
      if (o)
        return e.adoptedStyleSheets = [o.sheet, ...e.adoptedStyleSheets], e[Jd] = o;
      this.sheet = new r.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], Cm.set(t, this);
    } else {
      this.styleTag = t.createElement("style");
      let o = e.head || e;
      o.insertBefore(this.styleTag, o.firstChild);
    }
    this.modules = [], e[Jd] = this;
  }
  mount(e) {
    let t = this.sheet, r = 0, o = 0;
    for (let s = 0; s < e.length; s++) {
      let n = e[s], a = this.modules.indexOf(n);
      if (a < o && a > -1 && (this.modules.splice(a, 1), o--, a = -1), a == -1) {
        if (this.modules.splice(o++, 0, n), t)
          for (let l = 0; l < n.rules.length; l++)
            t.insertRule(n.rules[l], r++);
      } else {
        for (; o < a; )
          r += this.modules[o++].rules.length;
        r += n.rules.length, o++;
      }
    }
    if (!t) {
      let s = "";
      for (let n = 0; n < this.modules.length; n++)
        s += this.modules[n].getRules() + `
`;
      this.styleTag.textContent = s;
    }
  }
}
var go = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, La = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, f1 = typeof navigator < "u" && /Mac/.test(navigator.platform), p1 = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var gt = 0; gt < 10; gt++)
  go[48 + gt] = go[96 + gt] = String(gt);
for (var gt = 1; gt <= 24; gt++)
  go[gt + 111] = "F" + gt;
for (var gt = 65; gt <= 90; gt++)
  go[gt] = String.fromCharCode(gt + 32), La[gt] = String.fromCharCode(gt);
for (var Nc in go)
  La.hasOwnProperty(Nc) || (La[Nc] = go[Nc]);
function O1(i) {
  var e = f1 && i.metaKey && i.shiftKey && !i.ctrlKey && !i.altKey || p1 && i.shiftKey && i.key && i.key.length == 1 || i.key == "Unidentified", t = !e && i.key || (i.shiftKey ? La : go)[i.keyCode] || i.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function xu(i) {
  let e;
  return i.nodeType == 11 ? e = i.getSelection ? i : i.ownerDocument : e = i, e.getSelection();
}
function sn(i, e) {
  return e ? i == e || i.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function E1(i) {
  let e = i.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function Zl(i, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return sn(i, e.anchorNode);
  } catch {
    return !1;
  }
}
function wa(i) {
  return i.nodeType == 3 ? nn(i, 0, i.nodeValue.length).getClientRects() : i.nodeType == 1 ? i.getClientRects() : [];
}
function Mu(i, e, t, r) {
  return t ? Nm(i, e, t, r, -1) || Nm(i, e, t, r, 1) : !1;
}
function Uu(i) {
  for (var e = 0; ; e++)
    if (i = i.previousSibling, !i)
      return e;
}
function Nm(i, e, t, r, o) {
  for (; ; ) {
    if (i == t && e == r)
      return !0;
    if (e == (o < 0 ? 0 : bo(i))) {
      if (i.nodeName == "DIV")
        return !1;
      let s = i.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = Uu(i) + (o < 0 ? 0 : 1), i = s;
    } else if (i.nodeType == 1) {
      if (i = i.childNodes[e + (o < 0 ? -1 : 0)], i.nodeType == 1 && i.contentEditable == "false")
        return !1;
      e = o < 0 ? bo(i) : 0;
    } else
      return !1;
  }
}
function bo(i) {
  return i.nodeType == 3 ? i.nodeValue.length : i.childNodes.length;
}
function Jp(i, e) {
  let t = e ? i.left : i.right;
  return { left: t, right: t, top: i.top, bottom: i.bottom };
}
function m1(i) {
  return {
    left: 0,
    right: i.innerWidth,
    top: 0,
    bottom: i.innerHeight
  };
}
function g1(i, e, t, r, o, s, n, a) {
  let l = i.ownerDocument, u = l.defaultView || window;
  for (let h = i; h; )
    if (h.nodeType == 1) {
      let c, d = h == l.body;
      if (d)
        c = m1(u);
      else {
        if (h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let O = h.getBoundingClientRect();
        c = {
          left: O.left,
          right: O.left + h.clientWidth,
          top: O.top,
          bottom: O.top + h.clientHeight
        };
      }
      let f = 0, p = 0;
      if (o == "nearest")
        e.top < c.top ? (p = -(c.top - e.top + n), t > 0 && e.bottom > c.bottom + p && (p = e.bottom - c.bottom + p + n)) : e.bottom > c.bottom && (p = e.bottom - c.bottom + n, t < 0 && e.top - p < c.top && (p = -(c.top + p - e.top + n)));
      else {
        let O = e.bottom - e.top, m = c.bottom - c.top;
        p = (o == "center" && O <= m ? e.top + O / 2 - m / 2 : o == "start" || o == "center" && t < 0 ? e.top - n : e.bottom - m + n) - c.top;
      }
      if (r == "nearest" ? e.left < c.left ? (f = -(c.left - e.left + s), t > 0 && e.right > c.right + f && (f = e.right - c.right + f + s)) : e.right > c.right && (f = e.right - c.right + s, t < 0 && e.left < c.left + f && (f = -(c.left + f - e.left + s))) : f = (r == "center" ? e.left + (e.right - e.left) / 2 - (c.right - c.left) / 2 : r == "start" == a ? e.left - s : e.right - (c.right - c.left) + s) - c.left, f || p)
        if (d)
          u.scrollBy(f, p);
        else {
          let O = 0, m = 0;
          if (p) {
            let E = h.scrollTop;
            h.scrollTop += p, m = h.scrollTop - E;
          }
          if (f) {
            let E = h.scrollLeft;
            h.scrollLeft += f, O = h.scrollLeft - E;
          }
          e = {
            left: e.left - O,
            top: e.top - m,
            right: e.right - O,
            bottom: e.bottom - m
          }, O && Math.abs(O - f) < 1 && (r = "nearest"), m && Math.abs(m - p) < 1 && (o = "nearest");
        }
      if (d)
        break;
      h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function b1(i) {
  let e = i.ownerDocument;
  for (let t = i.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
class T1 {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: r } = e;
    this.set(t, Math.min(e.anchorOffset, t ? bo(t) : 0), r, Math.min(e.focusOffset, r ? bo(r) : 0));
  }
  set(e, t, r, o) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = r, this.focusOffset = o;
  }
}
let As = null;
function NA(i) {
  if (i.setActive)
    return i.setActive();
  if (As)
    return i.focus(As);
  let e = [];
  for (let t = i; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (i.focus(As == null ? {
    get preventScroll() {
      return As = { preventScroll: !0 }, !0;
    }
  } : void 0), !As) {
    As = !1;
    for (let t = 0; t < e.length; ) {
      let r = e[t++], o = e[t++], s = e[t++];
      r.scrollTop != o && (r.scrollTop = o), r.scrollLeft != s && (r.scrollLeft = s);
    }
  }
}
let Im;
function nn(i, e, t = e) {
  let r = Im || (Im = document.createRange());
  return r.setEnd(i, t), r.setStart(i, e), r;
}
function Xs(i, e, t) {
  let r = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, o = new KeyboardEvent("keydown", r);
  o.synthetic = !0, i.dispatchEvent(o);
  let s = new KeyboardEvent("keyup", r);
  return s.synthetic = !0, i.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented;
}
function S1(i) {
  for (; i; ) {
    if (i && (i.nodeType == 9 || i.nodeType == 11 && i.host))
      return i;
    i = i.assignedSlot || i.parentNode;
  }
  return null;
}
function IA(i) {
  for (; i.attributes.length; )
    i.removeAttributeNode(i.attributes[0]);
}
function R1(i, e) {
  let t = e.focusNode, r = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, bo(t)); ; )
    if (r) {
      if (t.nodeType != 1)
        return !1;
      let o = t.childNodes[r - 1];
      o.contentEditable == "false" ? r-- : (t = o, r = bo(t));
    } else {
      if (t == i)
        return !0;
      r = Uu(t), t = t.parentNode;
    }
}
class Tt {
  constructor(e, t, r = !0) {
    this.node = e, this.offset = t, this.precise = r;
  }
  static before(e, t) {
    return new Tt(e.parentNode, Uu(e), t);
  }
  static after(e, t) {
    return new Tt(e.parentNode, Uu(e) + 1, t);
  }
}
const eO = [];
class Me {
  constructor() {
    this.parent = null, this.dom = null, this.dirty = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return t;
      t += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.dirty & 2) {
      let r = this.dom, o = null, s;
      for (let n of this.children) {
        if (n.dirty) {
          if (!n.dom && (s = o ? o.nextSibling : r.firstChild)) {
            let a = Me.get(s);
            (!a || !a.parent && a.canReuseDOM(n)) && n.reuseDOM(s);
          }
          n.sync(e, t), n.dirty = 0;
        }
        if (s = o ? o.nextSibling : r.firstChild, t && !t.written && t.node == r && s != n.dom && (t.written = !0), n.dom.parentNode == r)
          for (; s && s != n.dom; )
            s = vm(s);
        else
          r.insertBefore(n.dom, s);
        o = n.dom;
      }
      for (s = o ? o.nextSibling : r.firstChild, s && t && t.node == r && (t.written = !0); s; )
        s = vm(s);
    } else if (this.dirty & 1)
      for (let r of this.children)
        r.dirty && (r.sync(e, t), r.dirty = 0);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[t];
    else {
      let o = bo(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        o == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? o = -1 : o = 1), e = s;
      }
      o < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !Me.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let o = 0, s = 0; ; o++) {
      let n = this.children[o];
      if (n.dom == r)
        return s;
      s += n.length + n.breakAfter;
    }
  }
  domBoundsAround(e, t, r = 0) {
    let o = -1, s = -1, n = -1, a = -1;
    for (let l = 0, u = r, h = r; l < this.children.length; l++) {
      let c = this.children[l], d = u + c.length;
      if (u < e && d > t)
        return c.domBoundsAround(e, t, u);
      if (d >= e && o == -1 && (o = l, s = u), u > t && c.dom.parentNode == this.dom) {
        n = l, a = h;
        break;
      }
      h = d, u = d + c.breakAfter;
    }
    return {
      from: s,
      to: a < 0 ? r + this.length : a,
      startDOM: (o ? this.children[o - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: n < this.children.length && n >= 0 ? this.children[n].dom : null
    };
  }
  markDirty(e = !1) {
    this.dirty |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.dirty |= 2), t.dirty & 1)
        return;
      t.dirty |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.dirty && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this;
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, r = eO) {
    this.markDirty();
    for (let o = e; o < t; o++) {
      let s = this.children[o];
      s.parent == this && s.destroy();
    }
    this.children.splice(e, t - e, ...r);
    for (let o = 0; o < r.length; o++)
      r[o].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new vA(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, r, o, s, n) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor;
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
Me.prototype.breakAfter = 0;
function vm(i) {
  let e = i.nextSibling;
  return i.parentNode.removeChild(i), e;
}
class vA {
  constructor(e, t, r) {
    this.children = e, this.pos = t, this.i = r, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function _A(i, e, t, r, o, s, n, a, l) {
  let { children: u } = i, h = u.length ? u[e] : null, c = s.length ? s[s.length - 1] : null, d = c ? c.breakAfter : n;
  if (!(e == r && h && !n && !d && s.length < 2 && h.merge(t, o, s.length ? c : null, t == 0, a, l))) {
    if (r < u.length) {
      let f = u[r];
      f && o < f.length ? (e == r && (f = f.split(o), o = 0), !d && c && f.merge(0, o, c, !0, 0, l) ? s[s.length - 1] = f : (o && f.merge(0, o, null, !1, 0, l), s.push(f))) : f != null && f.breakAfter && (c ? c.breakAfter = 1 : n = 1), r++;
    }
    for (h && (h.breakAfter = n, t > 0 && (!n && s.length && h.merge(t, h.length, s[0], !1, a, 0) ? h.breakAfter = s.shift().breakAfter : (t < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(t, h.length, null, !1, a, 0), e++)); e < r && s.length; )
      if (u[r - 1].become(s[s.length - 1]))
        r--, s.pop(), l = s.length ? 0 : a;
      else if (u[e].become(s[0]))
        e++, s.shift(), a = s.length ? 0 : l;
      else
        break;
    !s.length && e && r < u.length && !u[e - 1].breakAfter && u[r].merge(0, 0, u[e - 1], !1, a, l) && e--, (e < r || s.length) && i.replaceChildren(e, r, s);
  }
}
function PA(i, e, t, r, o, s) {
  let n = i.childCursor(), { i: a, off: l } = n.findPos(t, 1), { i: u, off: h } = n.findPos(e, -1), c = e - t;
  for (let d of r)
    c += d.length;
  i.length += c, _A(i, u, h, a, l, r, 0, o, s);
}
let ni = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, ef = typeof document < "u" ? document : { documentElement: { style: {} } };
const tf = /* @__PURE__ */ /Edge\/(\d+)/.exec(ni.userAgent), LA = /* @__PURE__ */ /MSIE \d/.test(ni.userAgent), rf = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ni.userAgent), kh = !!(LA || rf || tf), _m = !kh && /* @__PURE__ */ /gecko\/(\d+)/i.test(ni.userAgent), Ic = !kh && /* @__PURE__ */ /Chrome\/(\d+)/.exec(ni.userAgent), Pm = "webkitFontSmoothing" in ef.documentElement.style, wA = !kh && /* @__PURE__ */ /Apple Computer/.test(ni.vendor), Lm = wA && (/* @__PURE__ */ /Mobile\/\w+/.test(ni.userAgent) || ni.maxTouchPoints > 2);
var J = {
  mac: Lm || /* @__PURE__ */ /Mac/.test(ni.platform),
  windows: /* @__PURE__ */ /Win/.test(ni.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(ni.platform),
  ie: kh,
  ie_version: LA ? ef.documentMode || 6 : rf ? +rf[1] : tf ? +tf[1] : 0,
  gecko: _m,
  gecko_version: _m ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(ni.userAgent) || [0, 0])[1] : 0,
  chrome: !!Ic,
  chrome_version: Ic ? +Ic[1] : 0,
  ios: Lm,
  android: /* @__PURE__ */ /Android\b/.test(ni.userAgent),
  webkit: Pm,
  safari: wA,
  webkit_version: Pm ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: ef.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const A1 = 256;
class ts extends Me {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, r) {
    return r && (!(r instanceof ts) || this.length - (t - e) + r.length > A1) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new ts(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Tt(this.dom, e);
  }
  domBoundsAround(e, t, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return of(this.dom, e, t);
  }
}
class Ir extends Me {
  constructor(e, t = [], r = 0) {
    super(), this.mark = e, this.children = t, this.length = r;
    for (let o of t)
      o.setParent(this);
  }
  setAttrs(e) {
    if (IA(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e, t) {
    this.dom ? this.dirty & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, r, o, s, n) {
    return r && (!(r instanceof Ir && r.mark.eq(this.mark)) || e && s <= 0 || t < this.length && n <= 0) ? !1 : (PA(this, e, t, r ? r.children : [], s - 1, n - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], r = 0, o = -1, s = 0;
    for (let a of this.children) {
      let l = r + a.length;
      l > e && t.push(r < e ? a.split(e - r) : a), o < 0 && r >= e && (o = s), r = l, s++;
    }
    let n = this.length - e;
    return this.length = e, o > -1 && (this.children.length = o, this.markDirty()), new Ir(this.mark, t, n);
  }
  domAtPos(e) {
    return UA(this, e);
  }
  coordsAt(e, t) {
    return kA(this, e, t);
  }
}
function of(i, e, t) {
  let r = i.nodeValue.length;
  e > r && (e = r);
  let o = e, s = e, n = 0;
  e == 0 && t < 0 || e == r && t >= 0 ? J.chrome || J.gecko || (e ? (o--, n = 1) : s < r && (s++, n = -1)) : t < 0 ? o-- : s < r && s++;
  let a = nn(i, o, s).getClientRects();
  if (!a.length)
    return null;
  let l = a[(n ? n < 0 : t >= 0) ? 0 : a.length - 1];
  return J.safari && !n && l.width == 0 && (l = Array.prototype.find.call(a, (u) => u.width) || l), n ? Jp(l, n < 0) : l || null;
}
class Kr extends Me {
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.side = r, this.prevWidget = null;
  }
  static create(e, t, r) {
    return new (e.customView || Kr)(e, t, r);
  }
  split(e) {
    let t = Kr.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e, t, r, o, s, n) {
    return r && (!(r instanceof Kr) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && n <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof Kr && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Ce.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, r = t && t.state.doc, o = this.posAtStart;
    return r ? r.slice(o, o + this.length) : Ce.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Tt.before(this.dom) : Tt.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    if (r)
      return r;
    let o = this.dom.getClientRects(), s = null;
    if (!o.length)
      return null;
    let n = this.side ? this.side < 0 : e > 0;
    for (let a = n ? o.length - 1 : 0; s = o[a], !(e > 0 ? a == 0 : a == o.length - 1 || s.top < s.bottom); a += n ? -1 : 1)
      ;
    return Jp(s, !n);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class yA extends Kr {
  domAtPos(e) {
    let { topView: t, text: r } = this.widget;
    return t ? sf(e, 0, t, r, this.length - t.length, (o, s) => o.domAtPos(s), (o, s) => new Tt(o, Math.min(s, o.nodeValue.length))) : new Tt(r, Math.min(e, r.nodeValue.length));
  }
  sync() {
    this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(e, t) {
    let { topView: r, text: o } = this.widget;
    return r ? xA(e, t, r, o, this.length - r.length) : Math.min(t, this.length);
  }
  ignoreMutation() {
    return !1;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(e, t) {
    let { topView: r, text: o } = this.widget;
    return r ? sf(e, t, r, o, this.length - r.length, (s, n, a) => s.coordsAt(n, a), (s, n, a) => of(s, n, a)) : of(o, e, t);
  }
  destroy() {
    var e;
    super.destroy(), (e = this.widget.topView) === null || e === void 0 || e.destroy();
  }
  get isEditable() {
    return !0;
  }
  canReuseDOM() {
    return !0;
  }
}
function sf(i, e, t, r, o, s, n) {
  if (t instanceof Ir) {
    for (let a = t.dom.firstChild; a; a = a.nextSibling) {
      let l = Me.get(a);
      if (l) {
        let u = sn(a, r), h = l.length + (u ? o : 0);
        if (i < h || i == h && l.getSide() <= 0)
          return u ? sf(i, e, l, r, o, s, n) : s(l, i, e);
        i -= h;
      } else {
        let u = DA(i, e, a, n);
        if (typeof u != "number")
          return u;
        i = u;
      }
    }
    return s(t, t.length, -1);
  } else
    return t.dom == r ? n(r, i, e) : s(t, i, e);
}
function DA(i, e, t, r) {
  if (t.nodeType == 3) {
    let o = t.nodeValue.length;
    if (i <= o)
      return r(t, i, e);
    i -= o;
  } else if (t.nodeType == 1 && t.contentEditable != "false")
    for (let o = t.firstChild; o; o = o.nextSibling) {
      let s = DA(i, e, o, r);
      if (typeof s != "number")
        return s;
      i = s;
    }
  return i;
}
function xA(i, e, t, r, o) {
  if (t instanceof Ir) {
    let s = 0;
    for (let n = t.dom.firstChild; n; n = n.nextSibling) {
      let a = Me.get(n);
      if (a) {
        let l = sn(n, r);
        if (sn(n, i))
          return s + (l ? xA(i, e, a, r, o) : a.localPosFromDOM(i, e));
        s += a.length + (l ? o : 0);
      } else {
        let l = MA(i, e, n);
        if (l.result != null)
          return s + l.result;
        s += l.size;
      }
    }
  } else if (t.dom == r)
    return Math.min(e, r.nodeValue.length);
  return t.localPosFromDOM(i, e);
}
function MA(i, e, t) {
  if (t.nodeType == 3)
    return i == t ? { result: e } : { size: t.nodeValue.length };
  if (t.nodeType == 1 && t.contentEditable != "false") {
    let r = 0;
    for (let o = t.firstChild, s = 0; ; o = o.nextSibling, s++) {
      if (i == t && s == e)
        return { result: r };
      if (!o)
        return { size: r };
      let n = MA(i, e, o);
      if (n.result != null)
        return { result: e + n.result };
      r += n.size;
    }
  } else
    return t.contains(i) ? { result: 0 } : { size: 0 };
}
class an extends Me {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof an && e.side == this.side;
  }
  split() {
    return new an(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Tt.before(this.dom) : Tt.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Ce.empty;
  }
  get isHidden() {
    return !0;
  }
}
ts.prototype.children = Kr.prototype.children = an.prototype.children = eO;
function UA(i, e) {
  let t = i.dom, { children: r } = i, o = 0;
  for (let s = 0; o < r.length; o++) {
    let n = r[o], a = s + n.length;
    if (!(a == s && n.getSide() <= 0)) {
      if (e > s && e < a && n.dom.parentNode == t)
        return n.domAtPos(e - s);
      if (e <= s)
        break;
      s = a;
    }
  }
  for (let s = o; s > 0; s--) {
    let n = r[s - 1];
    if (n.dom.parentNode == t)
      return n.domAtPos(n.length);
  }
  for (let s = o; s < r.length; s++) {
    let n = r[s];
    if (n.dom.parentNode == t)
      return n.domAtPos(0);
  }
  return new Tt(t, 0);
}
function QA(i, e, t) {
  let r, { children: o } = i;
  t > 0 && e instanceof Ir && o.length && (r = o[o.length - 1]) instanceof Ir && r.mark.eq(e.mark) ? QA(r, e.children[0], t - 1) : (o.push(e), e.setParent(i)), i.length += e.length;
}
function kA(i, e, t) {
  let r = null, o = -1, s = null, n = -1;
  function a(u, h) {
    for (let c = 0, d = 0; c < u.children.length && d <= h; c++) {
      let f = u.children[c], p = d + f.length;
      p >= h && (f.children.length ? a(f, h - d) : (!s || s.isHidden && t > 0) && (p > h || d == p && f.getSide() > 0) ? (s = f, n = h - d) : (d < h || d == p && f.getSide() < 0 && !f.isHidden) && (r = f, o = h - d)), d = p;
    }
  }
  a(i, e);
  let l = (t < 0 ? r : s) || r || s;
  return l ? l.coordsAt(Math.max(0, l == r ? o : n), t) : C1(i);
}
function C1(i) {
  let e = i.dom.lastChild;
  if (!e)
    return i.dom.getBoundingClientRect();
  let t = wa(e);
  return t[t.length - 1] || null;
}
function nf(i, e) {
  for (let t in i)
    t == "class" && e.class ? e.class += " " + i.class : t == "style" && e.style ? e.style += ";" + i.style : e[t] = i[t];
  return e;
}
function tO(i, e) {
  if (i == e)
    return !0;
  if (!i || !e)
    return !1;
  let t = Object.keys(i), r = Object.keys(e);
  if (t.length != r.length)
    return !1;
  for (let o of t)
    if (r.indexOf(o) == -1 || i[o] !== e[o])
      return !1;
  return !0;
}
function af(i, e, t) {
  let r = null;
  if (e)
    for (let o in e)
      t && o in t || i.removeAttribute(r = o);
  if (t)
    for (let o in t)
      e && e[o] == t[o] || i.setAttribute(r = o, t[o]);
  return !!r;
}
class Ur {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, r) {
    return null;
  }
  /**
  @internal
  */
  get customView() {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Ye = /* @__PURE__ */ function(i) {
  return i[i.Text = 0] = "Text", i[i.WidgetBefore = 1] = "WidgetBefore", i[i.WidgetAfter = 2] = "WidgetAfter", i[i.WidgetRange = 3] = "WidgetRange", i;
}(Ye || (Ye = {}));
class ie extends es {
  constructor(e, t, r, o) {
    super(), this.startSide = e, this.endSide = t, this.widget = r, this.spec = o;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new $h(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return t += r && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new To(e, t, t, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, r, o;
    if (e.isBlockGap)
      r = -5e8, o = 4e8;
    else {
      let { start: s, end: n } = $A(e, t);
      r = (s ? t ? -3e8 : -1 : 5e8) - 1, o = (n ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new To(e, r, o, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new ja(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return Le.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
ie.none = Le.empty;
class $h extends ie {
  constructor(e) {
    let { start: t, end: r } = $A(e);
    super(t ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    return this == e || e instanceof $h && this.tagName == e.tagName && this.class == e.class && tO(this.attrs, e.attrs);
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
$h.prototype.point = !1;
class ja extends ie {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof ja && this.spec.class == e.spec.class && tO(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
ja.prototype.mapMode = bt.TrackBefore;
ja.prototype.point = !0;
class To extends ie {
  constructor(e, t, r, o, s, n) {
    super(t, r, s, e), this.block = o, this.isReplace = n, this.mapMode = o ? t <= 0 ? bt.TrackBefore : bt.TrackAfter : bt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide < this.endSide ? Ye.WidgetRange : this.startSide <= 0 ? Ye.WidgetBefore : Ye.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof To && N1(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
To.prototype.point = !0;
function $A(i, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: r } = i;
  return t == null && (t = i.inclusive), r == null && (r = i.inclusive), { start: t ?? e, end: r ?? e };
}
function N1(i, e) {
  return i == e || !!(i && e && i.compare(e));
}
function lf(i, e, t, r = 0) {
  let o = t.length - 1;
  o >= 0 && t[o] + r >= i ? t[o] = Math.max(t[o], e) : t.push(i, e);
}
class Ft extends Me {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, r, o, s, n) {
    if (r) {
      if (!(r instanceof Ft))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return o && this.setDeco(r ? r.attrs : null), PA(this, e, t, r ? r.children : [], s, n), !0;
  }
  split(e) {
    let t = new Ft();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: r, off: o } = this.childPos(e);
    o && (t.append(this.children[r].split(o), 0), this.children[r].merge(o, this.children[r].length, null, !1, 0, 0), r++);
    for (let s = r; s < this.children.length; s++)
      t.append(this.children[s], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    tO(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    QA(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, r = e.spec.class;
    t && (this.attrs = nf(t, this.attrs || {})), r && (this.attrs = nf({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return UA(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e, t) {
    var r;
    this.dom ? this.dirty & 4 && (IA(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (af(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let o = this.dom.lastChild;
    for (; o && Me.get(o) instanceof Ir; )
      o = o.lastChild;
    if (!o || !this.length || o.nodeName != "BR" && ((r = Me.get(o)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!J.ios || !this.children.some((s) => s instanceof ts))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let r of this.children) {
      if (!(r instanceof ts) || /[^ -~]/.test(r.text))
        return null;
      let o = wa(r.dom);
      if (o.length != 1)
        return null;
      e += o[0].width, t = o[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let r = kA(this, e, t);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: o } = this.parent.view.viewState, s = r.bottom - r.top;
      if (Math.abs(s - o.lineHeight) < 2 && o.textHeight < s) {
        let n = (s - o.textHeight) / 2;
        return { top: r.top + n, bottom: r.bottom - n, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return !1;
  }
  get type() {
    return Ye.Text;
  }
  static find(e, t) {
    for (let r = 0, o = 0; r < e.children.length; r++) {
      let s = e.children[r], n = o + s.length;
      if (n >= t) {
        if (s instanceof Ft)
          return s;
        if (n > t)
          break;
      }
      o = n + s.breakAfter;
    }
    return null;
  }
}
class Wo extends Me {
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.type = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, r, o, s, n) {
    return r && (!(r instanceof Wo) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && n <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? Tt.before(this.dom) : Tt.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let r = new Wo(this.widget, t, this.type);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return eO;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Ce.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Wo && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.type = e.type, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    return this.widget.coordsAt(this.dom, e, t);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class iO {
  constructor(e, t, r, o) {
    this.doc = e, this.pos = t, this.end = r, this.disallowBlockEffectsFor = o, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !e.breakAfter && !(e instanceof Wo && e.type == Ye.WidgetBefore);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Ft()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Al(new an(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || this.getLine();
  }
  buildText(e, t, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: n, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (n) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let o = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* Chunk */
      );
      this.flushBuffer(t.slice(t.length - r)), this.getLine().append(Al(new ts(this.text.slice(this.textOff, this.textOff + o)), t), r), this.atCursorPos = !0, this.textOff += o, e -= o, r = 0;
    }
  }
  span(e, t, r, o) {
    this.buildText(t - e, r, o), this.pos = t, this.openStart < 0 && (this.openStart = o);
  }
  point(e, t, r, o, s, n) {
    if (this.disallowBlockEffectsFor[n] && r instanceof To) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = t - e;
    if (r instanceof To)
      if (r.block) {
        let { type: l } = r;
        l == Ye.WidgetAfter && !this.posCovered() && this.getLine(), this.addBlockWidget(new Wo(r.widget || new wm("div"), a, l));
      } else {
        let l = Kr.create(r.widget || new wm("span"), a, a ? 0 : r.startSide), u = this.atCursorPos && !l.isEditable && s <= o.length && (e < t || r.startSide > 0), h = !l.isEditable && (e < t || s > o.length || r.startSide <= 0), c = this.getLine();
        this.pendingBuffer == 2 && !u && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(o), u && (c.append(Al(new an(1), o), s), s = o.length + Math.max(0, s - o.length)), c.append(Al(l, o), s), this.atCursorPos = h, this.pendingBuffer = h ? e < t || s > o.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = o.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, t, r, o, s) {
    let n = new iO(e, t, r, s);
    return n.openEnd = Le.spans(o, t, r, n), n.openStart < 0 && (n.openStart = n.openEnd), n.finish(n.openEnd), n;
  }
}
function Al(i, e) {
  for (let t of e)
    i = new Ir(t, [i], i.length);
  return i;
}
class wm extends Ur {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
const GA = /* @__PURE__ */ K.define(), VA = /* @__PURE__ */ K.define(), HA = /* @__PURE__ */ K.define(), XA = /* @__PURE__ */ K.define(), uf = /* @__PURE__ */ K.define(), YA = /* @__PURE__ */ K.define(), BA = /* @__PURE__ */ K.define(), FA = /* @__PURE__ */ K.define({
  combine: (i) => i.some((e) => e)
}), WA = /* @__PURE__ */ K.define({
  combine: (i) => i.some((e) => e)
});
class Qu {
  constructor(e, t = "nearest", r = "nearest", o = 5, s = 5) {
    this.range = e, this.y = t, this.x = r, this.yMargin = o, this.xMargin = s;
  }
  map(e) {
    return e.empty ? this : new Qu(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const ym = /* @__PURE__ */ fe.define({ map: (i, e) => i.map(e) });
function Ri(i, e, t) {
  let r = i.facet(XA);
  r.length ? r[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const Gh = /* @__PURE__ */ K.define({ combine: (i) => i.length ? i[0] : !0 });
let I1 = 0;
const Yn = /* @__PURE__ */ K.define();
class lt {
  constructor(e, t, r, o) {
    this.id = e, this.create = t, this.domEventHandlers = r, this.extension = o(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: r, provide: o, decorations: s } = t || {};
    return new lt(I1++, e, r, (n) => {
      let a = [Yn.of(n)];
      return s && a.push(ya.of((l) => {
        let u = l.plugin(n);
        return u ? s(u) : ie.none;
      })), o && a.push(o(n)), a;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return lt.define((r) => new e(r), t);
  }
}
class vc {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (r) {
            if (Ri(t.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        Ri(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Ri(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const zA = /* @__PURE__ */ K.define(), rO = /* @__PURE__ */ K.define(), ya = /* @__PURE__ */ K.define(), oO = /* @__PURE__ */ K.define(), ZA = /* @__PURE__ */ K.define();
function qA(i) {
  let e = 0, t = 0, r = 0, o = 0;
  for (let s of i.state.facet(ZA)) {
    let n = s(i);
    n && (n.left != null && (e = Math.max(e, n.left)), n.right != null && (t = Math.max(t, n.right)), n.top != null && (r = Math.max(r, n.top)), n.bottom != null && (o = Math.max(o, n.bottom)));
  }
  return { left: e, right: t, top: r, bottom: o };
}
const Bn = /* @__PURE__ */ K.define();
class nr {
  constructor(e, t, r, o) {
    this.fromA = e, this.toA = t, this.fromB = r, this.toB = o;
  }
  join(e) {
    return new nr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, r = this;
    for (; t > 0; t--) {
      let o = e[t - 1];
      if (!(o.fromA > r.toA)) {
        if (o.toA < r.fromA)
          break;
        r = r.join(o), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, r), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let r = [];
    for (let o = 0, s = 0, n = 0, a = 0; ; o++) {
      let l = o == e.length ? null : e[o], u = n - a, h = l ? l.fromB : 1e9;
      for (; s < t.length && t[s] < h; ) {
        let c = t[s], d = t[s + 1], f = Math.max(a, c), p = Math.min(h, d);
        if (f <= p && new nr(f + u, p + u, f, p).addToSet(r), d > h)
          break;
        s += 2;
      }
      if (!l)
        return r;
      new nr(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), n = l.toA, a = l.toB;
    }
  }
}
class ku {
  constructor(e, t, r) {
    this.view = e, this.state = t, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = st.empty(this.startState.doc.length);
    for (let s of r)
      this.changes = this.changes.compose(s.changes);
    let o = [];
    this.changes.iterChangedRanges((s, n, a, l) => o.push(new nr(s, n, a, l))), this.changedRanges = o;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new ku(e, t, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var He = /* @__PURE__ */ function(i) {
  return i[i.LTR = 0] = "LTR", i[i.RTL = 1] = "RTL", i;
}(He || (He = {}));
const hf = He.LTR, v1 = He.RTL;
function jA(i) {
  let e = [];
  for (let t = 0; t < i.length; t++)
    e.push(1 << +i[t]);
  return e;
}
const _1 = /* @__PURE__ */ jA("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), P1 = /* @__PURE__ */ jA("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), cf = /* @__PURE__ */ Object.create(null), Hi = [];
for (let i of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ i.charCodeAt(0), t = /* @__PURE__ */ i.charCodeAt(1);
  cf[e] = t, cf[t] = -e;
}
function L1(i) {
  return i <= 247 ? _1[i] : 1424 <= i && i <= 1524 ? 2 : 1536 <= i && i <= 1785 ? P1[i - 1536] : 1774 <= i && i <= 2220 ? 4 : 8192 <= i && i <= 8203 ? 256 : 64336 <= i && i <= 65023 ? 4 : i == 8204 ? 256 : 1;
}
const w1 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Ys {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.level = r;
  }
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? v1 : hf;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  static find(e, t, r, o) {
    let s = -1;
    for (let n = 0; n < e.length; n++) {
      let a = e[n];
      if (a.from <= t && a.to >= t) {
        if (a.level == r)
          return n;
        (s < 0 || (o != 0 ? o < 0 ? a.from < t : a.to > t : e[s].level > a.level)) && (s = n);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
const Ve = [];
function y1(i, e) {
  let t = i.length, r = e == hf ? 1 : 2, o = e == hf ? 2 : 1;
  if (!i || r == 1 && !w1.test(i))
    return KA(t);
  for (let n = 0, a = r, l = r; n < t; n++) {
    let u = L1(i.charCodeAt(n));
    u == 512 ? u = a : u == 8 && l == 4 && (u = 16), Ve[n] = u == 4 ? 2 : u, u & 7 && (l = u), a = u;
  }
  for (let n = 0, a = r, l = r; n < t; n++) {
    let u = Ve[n];
    if (u == 128)
      n < t - 1 && a == Ve[n + 1] && a & 24 ? u = Ve[n] = a : Ve[n] = 256;
    else if (u == 64) {
      let h = n + 1;
      for (; h < t && Ve[h] == 64; )
        h++;
      let c = n && a == 8 || h < t && Ve[h] == 8 ? l == 1 ? 1 : 8 : 256;
      for (let d = n; d < h; d++)
        Ve[d] = c;
      n = h - 1;
    } else
      u == 8 && l == 1 && (Ve[n] = 1);
    a = u, u & 7 && (l = u);
  }
  for (let n = 0, a = 0, l = 0, u, h, c; n < t; n++)
    if (h = cf[u = i.charCodeAt(n)])
      if (h < 0) {
        for (let d = a - 3; d >= 0; d -= 3)
          if (Hi[d + 1] == -h) {
            let f = Hi[d + 2], p = f & 2 ? r : f & 4 ? f & 1 ? o : r : 0;
            p && (Ve[n] = Ve[Hi[d]] = p), a = d;
            break;
          }
      } else {
        if (Hi.length == 189)
          break;
        Hi[a++] = n, Hi[a++] = u, Hi[a++] = l;
      }
    else if ((c = Ve[n]) == 2 || c == 1) {
      let d = c == r;
      l = d ? 0 : 1;
      for (let f = a - 3; f >= 0; f -= 3) {
        let p = Hi[f + 2];
        if (p & 2)
          break;
        if (d)
          Hi[f + 2] |= 2;
        else {
          if (p & 4)
            break;
          Hi[f + 2] |= 4;
        }
      }
    }
  for (let n = 0; n < t; n++)
    if (Ve[n] == 256) {
      let a = n + 1;
      for (; a < t && Ve[a] == 256; )
        a++;
      let l = (n ? Ve[n - 1] : r) == 1, u = (a < t ? Ve[a] : r) == 1, h = l == u ? l ? 1 : 2 : r;
      for (let c = n; c < a; c++)
        Ve[c] = h;
      n = a - 1;
    }
  let s = [];
  if (r == 1)
    for (let n = 0; n < t; ) {
      let a = n, l = Ve[n++] != 1;
      for (; n < t && l == (Ve[n] != 1); )
        n++;
      if (l)
        for (let u = n; u > a; ) {
          let h = u, c = Ve[--u] != 2;
          for (; u > a && c == (Ve[u - 1] != 2); )
            u--;
          s.push(new Ys(u, h, c ? 2 : 1));
        }
      else
        s.push(new Ys(a, n, 0));
    }
  else
    for (let n = 0; n < t; ) {
      let a = n, l = Ve[n++] == 2;
      for (; n < t && l == (Ve[n] == 2); )
        n++;
      s.push(new Ys(a, n, l ? 1 : 2));
    }
  return s;
}
function KA(i) {
  return [new Ys(0, i, 0)];
}
let JA = "";
function D1(i, e, t, r, o) {
  var s;
  let n = r.head - i.from, a = -1;
  if (n == 0) {
    if (!o || !i.length)
      return null;
    e[0].level != t && (n = e[0].side(!1, t), a = 0);
  } else if (n == i.length) {
    if (o)
      return null;
    let d = e[e.length - 1];
    d.level != t && (n = d.side(!0, t), a = e.length - 1);
  }
  a < 0 && (a = Ys.find(e, n, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc));
  let l = e[a];
  n == l.side(o, t) && (l = e[a += o ? 1 : -1], n = l.side(!o, t));
  let u = o == (l.dir == t), h = $t(i.text, n, u);
  if (JA = i.text.slice(Math.min(n, h), Math.max(n, h)), h != l.side(o, t))
    return D.cursor(h + i.from, u ? -1 : 1, l.level);
  let c = a == (o ? e.length - 1 : 0) ? null : e[a + (o ? 1 : -1)];
  return !c && l.level != t ? D.cursor(o ? i.to : i.from, o ? -1 : 1, t) : c && c.level < l.level ? D.cursor(c.side(!o, t) + i.from, o ? 1 : -1, c.level) : D.cursor(h + i.from, o ? -1 : 1, l.level);
}
const ys = "￿";
class eC {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(Re.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += ys;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let o = e; ; ) {
      this.findPointBefore(r, o);
      let s = this.text.length;
      this.readNode(o);
      let n = o.nextSibling;
      if (n == t)
        break;
      let a = Me.get(o), l = Me.get(n);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Dm(o)) || Dm(n) && (o.nodeName != "BR" || o.cmIgnore) && this.text.length > s) && this.lineBreak(), o = n;
    }
    return this.findPointBefore(r, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, t.length));
    for (let r = 0, o = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, n = 1, a;
      if (this.lineSeparator ? (s = t.indexOf(this.lineSeparator, r), n = this.lineSeparator.length) : (a = o.exec(t)) && (s = a.index, n = a[0].length), this.append(t.slice(r, s < 0 ? t.length : s)), s < 0)
        break;
      if (this.lineBreak(), n > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= n - 1);
      r = s + n;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Me.get(e), r = t && t.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let o = r.iter(); !o.next().done; )
        o.lineBreak ? this.lineBreak() : this.append(o.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == t && (r.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + Math.min(t, r.offset));
  }
}
function Dm(i) {
  return i.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(i.nodeName);
}
class xm {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class Mm extends Me {
  constructor(e) {
    super(), this.view = e, this.compositionDeco = ie.none, this.decorations = [], this.dynamicDecorationMap = [], this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Ft()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new nr(0, 0, 0, e.state.doc.length)], 0);
  }
  get length() {
    return this.view.state.doc.length;
  }
  // Update the document view to a given state.
  update(e) {
    let t = e.changedRanges;
    this.minWidth > 0 && t.length && (t.every(({ fromA: n, toA: a }) => a < this.minWidthFrom || n > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.view.inputState.composing < 0 ? this.compositionDeco = ie.none : (e.transactions.length || this.dirty) && (this.compositionDeco = M1(this.view, e.changes)), (J.ie || J.chrome) && !this.compositionDeco.size && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let r = this.decorations, o = this.updateDeco(), s = $1(r, o, e.changes);
    return t = nr.extendWithRanges(t, s), this.dirty == 0 && t.length == 0 ? !1 : (this.updateInner(t, e.startState.doc.length), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t);
    let { observer: r } = this.view;
    r.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let s = J.chrome || J.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, s), this.dirty = 0, s && (s.written || r.selectionRange.focusNode != s.node) && (this.forceSelection = !0), this.dom.style.height = "";
    });
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let s of this.children)
        s instanceof Wo && s.widget instanceof Um && o.push(s.dom);
    r.updateGaps(o);
  }
  updateChildren(e, t) {
    let r = this.childCursor(t);
    for (let o = e.length - 1; ; o--) {
      let s = o >= 0 ? e[o] : null;
      if (!s)
        break;
      let { fromA: n, toA: a, fromB: l, toB: u } = s, { content: h, breakAtStart: c, openStart: d, openEnd: f } = iO.build(this.view.state.doc, l, u, this.decorations, this.dynamicDecorationMap), { i: p, off: O } = r.findPos(a, 1), { i: m, off: E } = r.findPos(n, -1);
      _A(this, m, E, p, O, h, c, d, f);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, o = r == this.dom, s = !o && Zl(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(o || t || s))
      return;
    let n = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.domAtPos(a.anchor), u = a.empty ? l : this.domAtPos(a.head);
    if (J.gecko && a.empty && !this.compositionDeco.size && x1(l)) {
      let c = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(c, l.node.childNodes[l.offset] || null)), l = u = new Tt(c, 0), n = !0;
    }
    let h = this.view.observer.selectionRange;
    (n || !h.focusNode || !Mu(l.node, l.offset, h.anchorNode, h.anchorOffset) || !Mu(u.node, u.offset, h.focusNode, h.focusOffset)) && (this.view.observer.ignore(() => {
      J.android && J.chrome && this.dom.contains(h.focusNode) && G1(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let c = xu(this.view.root);
      if (c)
        if (a.empty) {
          if (J.gecko) {
            let d = Q1(l.node, l.offset);
            if (d && d != 3) {
              let f = iC(l.node, l.offset, d == 1 ? 1 : -1);
              f && (l = new Tt(f, d == 1 ? 0 : f.nodeValue.length));
            }
          }
          c.collapse(l.node, l.offset), a.bidiLevel != null && h.cursorBidiLevel != null && (h.cursorBidiLevel = a.bidiLevel);
        } else if (c.extend) {
          c.collapse(l.node, l.offset);
          try {
            c.extend(u.node, u.offset);
          } catch {
          }
        } else {
          let d = document.createRange();
          a.anchor > a.head && ([l, u] = [u, l]), d.setEnd(u.node, u.offset), d.setStart(l.node, l.offset), c.removeAllRanges(), c.addRange(d);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(l, u)), this.impreciseAnchor = l.precise ? null : new Tt(h.anchorNode, h.anchorOffset), this.impreciseHead = u.precise ? null : new Tt(h.focusNode, h.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.compositionDeco.size)
      return;
    let { view: e } = this, t = e.state.selection.main, r = xu(e.root), { anchorNode: o, anchorOffset: s } = e.observer.selectionRange;
    if (!r || !t.empty || !t.assoc || !r.modify)
      return;
    let n = Ft.find(this, t.head);
    if (!n)
      return;
    let a = n.posAtStart;
    if (t.head == a || t.head == a + n.length)
      return;
    let l = this.coordsAt(t.head, -1), u = this.coordsAt(t.head, 1);
    if (!l || !u || l.bottom > u.top)
      return;
    let h = this.domAtPos(t.head + t.assoc);
    r.collapse(h.node, h.offset), r.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let c = e.observer.selectionRange;
    e.docView.posFromDOM(c.anchorNode, c.anchorOffset) != t.from && r.collapse(o, s);
  }
  nearest(e) {
    for (let t = e; t; ) {
      let r = Me.get(t);
      if (r && r.rootView == this)
        return r;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, t) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: r } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let o = this.children[t];
      if (r < o.length || o instanceof Ft)
        break;
      t++, r = 0;
    }
    return this.children[t].domAtPos(r);
  }
  coordsAt(e, t) {
    for (let r = this.length, o = this.children.length - 1; ; o--) {
      let s = this.children[o], n = r - s.breakAfter - s.length;
      if (e > n || e == n && s.type != Ye.WidgetBefore && s.type != Ye.WidgetAfter && (!o || t == 2 || this.children[o - 1].breakAfter || this.children[o - 1].type == Ye.WidgetBefore && t > -2))
        return s.coordsAt(e - n, t);
      r = n;
    }
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: r, to: o } = e, s = this.view.contentDOM.clientWidth, n = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == He.LTR;
    for (let u = 0, h = 0; h < this.children.length; h++) {
      let c = this.children[h], d = u + c.length;
      if (d > o)
        break;
      if (u >= r) {
        let f = c.dom.getBoundingClientRect();
        if (t.push(f.height), n) {
          let p = c.dom.lastChild, O = p ? wa(p) : [];
          if (O.length) {
            let m = O[O.length - 1], E = l ? m.right - f.left : f.right - m.left;
            E > a && (a = E, this.minWidth = s, this.minWidthFrom = u, this.minWidthTo = d);
          }
        }
      }
      u = d + c.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? He.RTL : He.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Ft) {
        let n = s.measureTextSize();
        if (n)
          return n;
      }
    let e = document.createElement("div"), t, r, o;
    return e.className = "cm-line", e.style.width = "99999px", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = wa(e.firstChild)[0];
      t = e.getBoundingClientRect().height, r = s ? s.width / 27 : 7, o = s ? s.height : t, e.remove();
    }), { lineHeight: t, charWidth: r, textHeight: o };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new vA(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let r = 0, o = 0; ; o++) {
      let s = o == t.viewports.length ? null : t.viewports[o], n = s ? s.from - 1 : this.length;
      if (n > r) {
        let a = t.lineBlockAt(n).bottom - t.lineBlockAt(r).top;
        e.push(ie.replace({
          widget: new Um(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, n));
      }
      if (!s)
        break;
      r = s.to + 1;
    }
    return ie.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(ya).map((t, r) => (this.dynamicDecorationMap[r] = typeof t == "function") ? t(this.view) : t);
    for (let t = e.length; t < e.length + 3; t++)
      this.dynamicDecorationMap[t] = !1;
    return this.decorations = [
      ...e,
      this.compositionDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    let { range: t } = e, r = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), o;
    if (!r)
      return;
    !t.empty && (o = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, o.left),
      top: Math.min(r.top, o.top),
      right: Math.max(r.right, o.right),
      bottom: Math.max(r.bottom, o.bottom)
    });
    let s = qA(this.view), n = {
      left: r.left - s.left,
      top: r.top - s.top,
      right: r.right + s.right,
      bottom: r.bottom + s.bottom
    };
    g1(this.view.scrollDOM, n, t.head < t.anchor ? -1 : 1, e.x, e.y, e.xMargin, e.yMargin, this.view.textDirection == He.LTR);
  }
}
function x1(i) {
  return i.node.nodeType == 1 && i.node.firstChild && (i.offset == 0 || i.node.childNodes[i.offset - 1].contentEditable == "false") && (i.offset == i.node.childNodes.length || i.node.childNodes[i.offset].contentEditable == "false");
}
class Um extends Ur {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function tC(i) {
  let e = i.observer.selectionRange, t = e.focusNode && iC(e.focusNode, e.focusOffset, 0);
  if (!t)
    return null;
  let r = i.docView.nearest(t);
  if (!r)
    return null;
  if (r instanceof Ft) {
    let o = t;
    for (; o.parentNode != r.dom; )
      o = o.parentNode;
    let s = o.previousSibling;
    for (; s && !Me.get(s); )
      s = s.previousSibling;
    let n = s ? Me.get(s).posAtEnd : r.posAtStart;
    return { from: n, to: n, node: o, text: t };
  } else {
    for (; ; ) {
      let { parent: s } = r;
      if (!s)
        return null;
      if (s instanceof Ft)
        break;
      r = s;
    }
    let o = r.posAtStart;
    return { from: o, to: o + r.length, node: r.dom, text: t };
  }
}
function M1(i, e) {
  let t = tC(i);
  if (!t)
    return ie.none;
  let { from: r, to: o, node: s, text: n } = t, a = e.mapPos(r, 1), l = Math.max(a, e.mapPos(o, -1)), { state: u } = i, h = new eC([], u);
  s.nodeType == 3 ? h.readTextNode(s) : h.readRange(s.firstChild, null);
  let { text: c } = h;
  if (c.indexOf(ys) > -1)
    return ie.none;
  if (l - a < c.length)
    if (u.doc.sliceString(a, Math.min(u.doc.length, a + c.length)) == c)
      l = a + c.length;
    else if (u.doc.sliceString(Math.max(0, l - c.length), l) == c)
      a = l - c.length;
    else
      return ie.none;
  else if (u.doc.sliceString(a, l) != c)
    return ie.none;
  let d = Me.get(s);
  return d instanceof yA ? d = d.widget.topView : d && (d.parent = null), ie.set(ie.replace({ widget: new U1(s, n, d), inclusive: !0 }).range(a, l));
}
class U1 extends Ur {
  constructor(e, t, r) {
    super(), this.top = e, this.text = t, this.topView = r;
  }
  eq(e) {
    return this.top == e.top && this.text == e.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return !1;
  }
  get customView() {
    return yA;
  }
}
function iC(i, e, t) {
  if (t <= 0)
    for (let r = i, o = e; ; ) {
      if (r.nodeType == 3)
        return r;
      if (r.nodeType == 1 && o > 0)
        r = r.childNodes[o - 1], o = bo(r);
      else
        break;
    }
  if (t >= 0)
    for (let r = i, o = e; ; ) {
      if (r.nodeType == 3)
        return r;
      if (r.nodeType == 1 && o < r.childNodes.length && t >= 0)
        r = r.childNodes[o], o = 0;
      else
        break;
    }
  return null;
}
function Q1(i, e) {
  return i.nodeType != 1 ? 0 : (e && i.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < i.childNodes.length && i.childNodes[e].contentEditable == "false" ? 2 : 0);
}
class k1 {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    lf(e, t, this.changes);
  }
  comparePoint(e, t) {
    lf(e, t, this.changes);
  }
}
function $1(i, e, t) {
  let r = new k1();
  return Le.compare(i, e, t, r), r.changes;
}
function G1(i, e) {
  for (let t = i; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function V1(i, e, t = 1) {
  let r = i.charCategorizer(e), o = i.doc.lineAt(e), s = e - o.from;
  if (o.length == 0)
    return D.cursor(e);
  s == 0 ? t = 1 : s == o.length && (t = -1);
  let n = s, a = s;
  t < 0 ? n = $t(o.text, s, !1) : a = $t(o.text, s);
  let l = r(o.text.slice(n, a));
  for (; n > 0; ) {
    let u = $t(o.text, n, !1);
    if (r(o.text.slice(u, n)) != l)
      break;
    n = u;
  }
  for (; a < o.length; ) {
    let u = $t(o.text, a);
    if (r(o.text.slice(a, u)) != l)
      break;
    a = u;
  }
  return D.range(n + o.from, a + o.from);
}
function H1(i, e) {
  return e.left > i ? e.left - i : Math.max(0, i - e.right);
}
function X1(i, e) {
  return e.top > i ? e.top - i : Math.max(0, i - e.bottom);
}
function _c(i, e) {
  return i.top < e.bottom - 1 && i.bottom > e.top + 1;
}
function Qm(i, e) {
  return e < i.top ? { top: e, left: i.left, right: i.right, bottom: i.bottom } : i;
}
function km(i, e) {
  return e > i.bottom ? { top: i.top, left: i.left, right: i.right, bottom: e } : i;
}
function df(i, e, t) {
  let r, o, s, n, a = !1, l, u, h, c;
  for (let p = i.firstChild; p; p = p.nextSibling) {
    let O = wa(p);
    for (let m = 0; m < O.length; m++) {
      let E = O[m];
      o && _c(o, E) && (E = Qm(km(E, o.bottom), o.top));
      let g = H1(e, E), A = X1(t, E);
      if (g == 0 && A == 0)
        return p.nodeType == 3 ? $m(p, e, t) : df(p, e, t);
      if (!r || n > A || n == A && s > g) {
        r = p, o = E, s = g, n = A;
        let S = A ? t < E.top ? -1 : 1 : g ? e < E.left ? -1 : 1 : 0;
        a = !S || (S > 0 ? m < O.length - 1 : m > 0);
      }
      g == 0 ? t > E.bottom && (!h || h.bottom < E.bottom) ? (l = p, h = E) : t < E.top && (!c || c.top > E.top) && (u = p, c = E) : h && _c(h, E) ? h = km(h, E.bottom) : c && _c(c, E) && (c = Qm(c, E.top));
    }
  }
  if (h && h.bottom >= t ? (r = l, o = h) : c && c.top <= t && (r = u, o = c), !r)
    return { node: i, offset: 0 };
  let d = Math.max(o.left, Math.min(o.right, e));
  if (r.nodeType == 3)
    return $m(r, d, t);
  if (a && r.contentEditable != "false")
    return df(r, d, t);
  let f = Array.prototype.indexOf.call(i.childNodes, r) + (e >= (o.left + o.right) / 2 ? 1 : 0);
  return { node: i, offset: f };
}
function $m(i, e, t) {
  let r = i.nodeValue.length, o = -1, s = 1e9, n = 0;
  for (let a = 0; a < r; a++) {
    let l = nn(i, a, a + 1).getClientRects();
    for (let u = 0; u < l.length; u++) {
      let h = l[u];
      if (h.top == h.bottom)
        continue;
      n || (n = e - h.left);
      let c = (h.top > t ? h.top - t : t - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && c < s) {
        let d = e >= (h.left + h.right) / 2, f = d;
        if ((J.chrome || J.gecko) && nn(i, a).getBoundingClientRect().left == h.right && (f = !d), c <= 0)
          return { node: i, offset: a + (f ? 1 : 0) };
        o = a + (f ? 1 : 0), s = c;
      }
    }
  }
  return { node: i, offset: o > -1 ? o : n > 0 ? i.nodeValue.length : 0 };
}
function rC(i, e, t, r = -1) {
  var o, s;
  let n = i.contentDOM.getBoundingClientRect(), a = n.top + i.viewState.paddingTop, l, { docHeight: u } = i.viewState, { x: h, y: c } = e, d = c - a;
  if (d < 0)
    return 0;
  if (d > u)
    return i.state.doc.length;
  for (let S = i.viewState.heightOracle.textHeight / 2, R = !1; l = i.elementAtHeight(d), l.type != Ye.Text; )
    for (; d = r > 0 ? l.bottom + S : l.top - S, !(d >= 0 && d <= u); ) {
      if (R)
        return t ? null : 0;
      R = !0, r = -r;
    }
  c = a + d;
  let f = l.from;
  if (f < i.viewport.from)
    return i.viewport.from == 0 ? 0 : t ? null : Gm(i, n, l, h, c);
  if (f > i.viewport.to)
    return i.viewport.to == i.state.doc.length ? i.state.doc.length : t ? null : Gm(i, n, l, h, c);
  let p = i.dom.ownerDocument, O = i.root.elementFromPoint ? i.root : p, m = O.elementFromPoint(h, c);
  m && !i.contentDOM.contains(m) && (m = null), m || (h = Math.max(n.left + 1, Math.min(n.right - 1, h)), m = O.elementFromPoint(h, c), m && !i.contentDOM.contains(m) && (m = null));
  let E, g = -1;
  if (m && ((o = i.docView.nearest(m)) === null || o === void 0 ? void 0 : o.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let S = p.caretPositionFromPoint(h, c);
      S && ({ offsetNode: E, offset: g } = S);
    } else if (p.caretRangeFromPoint) {
      let S = p.caretRangeFromPoint(h, c);
      S && ({ startContainer: E, startOffset: g } = S, (!i.contentDOM.contains(E) || J.safari && Y1(E, g, h) || J.chrome && B1(E, g, h)) && (E = void 0));
    }
  }
  if (!E || !i.docView.dom.contains(E)) {
    let S = Ft.find(i.docView, f);
    if (!S)
      return d > l.top + l.height / 2 ? l.to : l.from;
    ({ node: E, offset: g } = df(S.dom, h, c));
  }
  let A = i.docView.nearest(E);
  if (!A)
    return null;
  if (A.isWidget && ((s = A.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let S = A.dom.getBoundingClientRect();
    return e.y < S.top || e.y <= S.bottom && e.x <= (S.left + S.right) / 2 ? A.posAtStart : A.posAtEnd;
  } else
    return A.localPosFromDOM(E, g) + A.posAtStart;
}
function Gm(i, e, t, r, o) {
  let s = Math.round((r - e.left) * i.defaultCharacterWidth);
  if (i.lineWrapping && t.height > i.defaultLineHeight * 1.5) {
    let a = i.viewState.heightOracle.textHeight, l = Math.floor((o - t.top - (i.defaultLineHeight - a) * 0.5) / a);
    s += l * i.viewState.heightOracle.lineLength;
  }
  let n = i.state.sliceDoc(t.from, t.to);
  return t.from + jd(n, s, i.state.tabSize);
}
function Y1(i, e, t) {
  let r;
  if (i.nodeType != 3 || e != (r = i.nodeValue.length))
    return !1;
  for (let o = i.nextSibling; o; o = o.nextSibling)
    if (o.nodeType != 1 || o.nodeName != "BR")
      return !1;
  return nn(i, r - 1, r).getBoundingClientRect().left > t;
}
function B1(i, e, t) {
  if (e != 0)
    return !1;
  for (let o = i; ; ) {
    let s = o.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != o)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    o = s;
  }
  let r = i.nodeType == 1 ? i.getBoundingClientRect() : nn(i, 0, Math.max(i.nodeValue.length, 1)).getBoundingClientRect();
  return t - r.left > 5;
}
function ff(i, e) {
  let t = i.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let r of t.type)
      if (r.to > e || r.to == e && (r.to == t.to || r.type == Ye.Text))
        return r;
  }
  return t;
}
function F1(i, e, t, r) {
  let o = ff(i, e.head), s = !r || o.type != Ye.Text || !(i.lineWrapping || o.widgetLineBreaks) ? null : i.coordsAtPos(e.assoc < 0 && e.head > o.from ? e.head - 1 : e.head);
  if (s) {
    let n = i.dom.getBoundingClientRect(), a = i.textDirectionAt(o.from), l = i.posAtCoords({
      x: t == (a == He.LTR) ? n.right - 1 : n.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (l != null)
      return D.cursor(l, t ? -1 : 1);
  }
  return D.cursor(t ? o.to : o.from, t ? -1 : 1);
}
function Vm(i, e, t, r) {
  let o = i.state.doc.lineAt(e.head), s = i.bidiSpans(o), n = i.textDirectionAt(o.from);
  for (let a = e, l = null; ; ) {
    let u = D1(o, s, n, a, t), h = JA;
    if (!u) {
      if (o.number == (t ? i.state.doc.lines : 1))
        return a;
      h = `
`, o = i.state.doc.line(o.number + (t ? 1 : -1)), s = i.bidiSpans(o), u = D.cursor(t ? o.from : o.to);
    }
    if (l) {
      if (!l(h))
        return a;
    } else {
      if (!r)
        return u;
      l = r(h);
    }
    a = u;
  }
}
function W1(i, e, t) {
  let r = i.state.charCategorizer(e), o = r(t);
  return (s) => {
    let n = r(s);
    return o == $e.Space && (o = n), o == n;
  };
}
function z1(i, e, t, r) {
  let o = e.head, s = t ? 1 : -1;
  if (o == (t ? i.state.doc.length : 0))
    return D.cursor(o, e.assoc);
  let n = e.goalColumn, a, l = i.contentDOM.getBoundingClientRect(), u = i.coordsAtPos(o), h = i.documentTop;
  if (u)
    n == null && (n = u.left - l.left), a = s < 0 ? u.top : u.bottom;
  else {
    let f = i.viewState.lineBlockAt(o);
    n == null && (n = Math.min(l.right - l.left, i.defaultCharacterWidth * (o - f.from))), a = (s < 0 ? f.top : f.bottom) + h;
  }
  let c = l.left + n, d = r ?? i.viewState.heightOracle.textHeight >> 1;
  for (let f = 0; ; f += 10) {
    let p = a + (d + f) * s, O = rC(i, { x: c, y: p }, !1, s);
    if (p < l.top || p > l.bottom || (s < 0 ? O < o : O > o))
      return D.cursor(O, e.assoc, void 0, n);
  }
}
function ql(i, e, t) {
  for (; ; ) {
    let r = 0;
    for (let o of i)
      o.between(e - 1, e + 1, (s, n, a) => {
        if (e > s && e < n) {
          let l = r || t || (e - s < n - e ? -1 : 1);
          e = l < 0 ? s : n, r = l;
        }
      });
    if (!r)
      return e;
  }
}
function Pc(i, e, t) {
  let r = ql(i.state.facet(oO).map((o) => o(i)), t.from, e.head > t.from ? -1 : 1);
  return r == t.from ? t : D.cursor(r, r < t.from ? 1 : -1);
}
class Z1 {
  constructor(e) {
    this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.chromeScrollHack = -1, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.registeredEvents = [], this.customHandlers = [], this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null;
    let t = (r, o) => {
      this.ignoreDuringComposition(o) || o.type == "keydown" && this.keydown(e, o) || (this.mustFlushObserver(o) && e.observer.forceFlush(), this.runCustomHandlers(o.type, e, o) ? o.preventDefault() : r(e, o));
    };
    for (let r in rt) {
      let o = rt[r];
      e.contentDOM.addEventListener(r, (s) => {
        Hm(e, s) && t(o, s);
      }, pf[r]), this.registeredEvents.push(r);
    }
    e.scrollDOM.addEventListener("mousedown", (r) => {
      if (r.target == e.scrollDOM && r.clientY > e.contentDOM.getBoundingClientRect().bottom && (t(rt.mousedown, r), !r.defaultPrevented && r.button == 2)) {
        let o = e.contentDOM.style.minHeight;
        e.contentDOM.style.minHeight = "100%", setTimeout(() => e.contentDOM.style.minHeight = o, 200);
      }
    }), e.scrollDOM.addEventListener("drop", (r) => {
      r.target == e.scrollDOM && r.clientY > e.contentDOM.getBoundingClientRect().bottom && t(rt.drop, r);
    }), J.chrome && J.chrome_version == 102 && e.scrollDOM.addEventListener("wheel", () => {
      this.chromeScrollHack < 0 ? e.contentDOM.style.pointerEvents = "none" : window.clearTimeout(this.chromeScrollHack), this.chromeScrollHack = setTimeout(() => {
        this.chromeScrollHack = -1, e.contentDOM.style.pointerEvents = "";
      }, 100);
    }, { passive: !0 }), this.notifiedFocused = e.hasFocus, J.safari && e.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  ensureHandlers(e, t) {
    var r;
    let o;
    this.customHandlers = [];
    for (let s of t)
      if (o = (r = s.update(e).spec) === null || r === void 0 ? void 0 : r.domEventHandlers) {
        this.customHandlers.push({ plugin: s.value, handlers: o });
        for (let n in o)
          this.registeredEvents.indexOf(n) < 0 && n != "scroll" && (this.registeredEvents.push(n), e.contentDOM.addEventListener(n, (a) => {
            Hm(e, a) && this.runCustomHandlers(n, e, a) && a.preventDefault();
          }));
      }
  }
  runCustomHandlers(e, t, r) {
    for (let o of this.customHandlers) {
      let s = o.handlers[e];
      if (s)
        try {
          if (s.call(o.plugin, r, t) || r.defaultPrevented)
            return !0;
        } catch (n) {
          Ri(t.state, n);
        }
    }
    return !1;
  }
  runScrollHandlers(e, t) {
    this.lastScrollTop = e.scrollDOM.scrollTop, this.lastScrollLeft = e.scrollDOM.scrollLeft;
    for (let r of this.customHandlers) {
      let o = r.handlers.scroll;
      if (o)
        try {
          o.call(r.plugin, t, e);
        } catch (s) {
          Ri(e.state, s);
        }
    }
  }
  keydown(e, t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (t.keyCode != 27 && sC.indexOf(t.keyCode) < 0 && (e.inputState.lastEscPress = 0), J.android && J.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return e.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let r;
    return J.ios && !t.synthetic && !t.altKey && !t.metaKey && ((r = oC.find((o) => o.keyCode == t.keyCode)) && !t.ctrlKey || q1.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = r || t, setTimeout(() => this.flushIOSKey(e), 250), !0) : !1;
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return t ? (this.pendingIOSKey = void 0, Xs(e.contentDOM, t.key, t.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : J.safari && !J.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  mustFlushObserver(e) {
    return e.type == "keydown" && e.keyCode != 229;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
const oC = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], q1 = "dthko", sC = [16, 17, 18, 20, 91, 92, 224, 225], Cl = 6;
function Nl(i) {
  return Math.max(0, i) * 0.7 + 8;
}
class j1 {
  constructor(e, t, r, o) {
    this.view = e, this.style = r, this.mustSelect = o, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = b1(e.contentDOM), this.atoms = e.state.facet(oO).map((n) => n(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(Re.allowMultipleSelections) && K1(e, t), this.dragging = eD(e, t) && uC(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && (e.preventDefault(), this.select(e));
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging !== !1)
      return;
    this.select(this.lastEvent = e);
    let r = 0, o = 0, s = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, n = qA(this.view);
    e.clientX - n.left <= s.left + Cl ? r = -Nl(s.left - e.clientX) : e.clientX + n.right >= s.right - Cl && (r = Nl(e.clientX - s.right)), e.clientY - n.top <= s.top + Cl ? o = -Nl(s.top - e.clientY) : e.clientY + n.bottom >= s.bottom - Cl && (o = Nl(e.clientY - s.bottom)), this.setScrollSpeed(r, o);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let o = e.ranges[r], s = null;
      if (o.empty) {
        let n = ql(this.atoms, o.from, 0);
        n != o.from && (s = D.cursor(n, -1));
      } else {
        let n = ql(this.atoms, o.from, -1), a = ql(this.atoms, o.to, 1);
        (n != o.from || a != o.to) && (s = D.range(o.from == o.anchor ? n : a, o.from == o.head ? n : a));
      }
      s && (t || (t = e.ranges.slice()), t[r] = s);
    }
    return t ? D.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(t.state.selection) || r.main.assoc != t.state.selection.main.assoc) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.docChanged && this.dragging && (this.dragging = this.dragging.map(e.changes)), this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function K1(i, e) {
  let t = i.state.facet(GA);
  return t.length ? t[0](e) : J.mac ? e.metaKey : e.ctrlKey;
}
function J1(i, e) {
  let t = i.state.facet(VA);
  return t.length ? t[0](e) : J.mac ? !e.altKey : !e.ctrlKey;
}
function eD(i, e) {
  let { main: t } = i.state.selection;
  if (t.empty)
    return !1;
  let r = xu(i.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let o = r.getRangeAt(0).getClientRects();
  for (let s = 0; s < o.length; s++) {
    let n = o[s];
    if (n.left <= e.clientX && n.right >= e.clientX && n.top <= e.clientY && n.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function Hm(i, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, r; t != i.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (r = Me.get(t)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const rt = /* @__PURE__ */ Object.create(null), pf = /* @__PURE__ */ Object.create(null), nC = J.ie && J.ie_version < 15 || J.ios && J.webkit_version < 604;
function tD(i) {
  let e = i.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    i.focus(), t.remove(), aC(i, t.value);
  }, 50);
}
function aC(i, e) {
  let { state: t } = i, r, o = 1, s = t.toText(e), n = s.lines == t.selection.ranges.length;
  if (Of != null && t.selection.ranges.every((l) => l.empty) && Of == s.toString()) {
    let l = -1;
    r = t.changeByRange((u) => {
      let h = t.doc.lineAt(u.from);
      if (h.from == l)
        return { range: u };
      l = h.from;
      let c = t.toText((n ? s.line(o++).text : e) + t.lineBreak);
      return {
        changes: { from: h.from, insert: c },
        range: D.cursor(u.from + c.length)
      };
    });
  } else
    n ? r = t.changeByRange((l) => {
      let u = s.line(o++);
      return {
        changes: { from: l.from, to: l.to, insert: u.text },
        range: D.cursor(l.from + u.length)
      };
    }) : r = t.replaceSelection(s);
  i.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
rt.keydown = (i, e) => {
  i.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (i.inputState.lastEscPress = Date.now());
};
rt.touchstart = (i, e) => {
  i.inputState.lastTouchTime = Date.now(), i.inputState.setSelectionOrigin("select.pointer");
};
rt.touchmove = (i) => {
  i.inputState.setSelectionOrigin("select.pointer");
};
pf.touchstart = pf.touchmove = { passive: !0 };
rt.mousedown = (i, e) => {
  if (i.observer.flush(), i.inputState.lastTouchTime > Date.now() - 2e3)
    return;
  let t = null;
  for (let r of i.state.facet(HA))
    if (t = r(i, e), t)
      break;
  if (!t && e.button == 0 && (t = oD(i, e)), t) {
    let r = i.root.activeElement != i.contentDOM;
    i.inputState.startMouseSelection(new j1(i, e, t, r)), r && i.observer.ignore(() => NA(i.contentDOM)), i.inputState.mouseSelection && i.inputState.mouseSelection.start(e);
  }
};
function Xm(i, e, t, r) {
  if (r == 1)
    return D.cursor(e, t);
  if (r == 2)
    return V1(i.state, e, t);
  {
    let o = Ft.find(i.docView, e), s = i.state.doc.lineAt(o ? o.posAtEnd : e), n = o ? o.posAtStart : s.from, a = o ? o.posAtEnd : s.to;
    return a < i.state.doc.length && a == s.to && a++, D.range(n, a);
  }
}
let lC = (i, e) => i >= e.top && i <= e.bottom, Ym = (i, e, t) => lC(e, t) && i >= t.left && i <= t.right;
function iD(i, e, t, r) {
  let o = Ft.find(i.docView, e);
  if (!o)
    return 1;
  let s = e - o.posAtStart;
  if (s == 0)
    return 1;
  if (s == o.length)
    return -1;
  let n = o.coordsAt(s, -1);
  if (n && Ym(t, r, n))
    return -1;
  let a = o.coordsAt(s, 1);
  return a && Ym(t, r, a) ? 1 : n && lC(r, n) ? -1 : 1;
}
function Bm(i, e) {
  let t = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: iD(i, t, e.clientX, e.clientY) };
}
const rD = J.ie && J.ie_version <= 11;
let Fm = null, Wm = 0, zm = 0;
function uC(i) {
  if (!rD)
    return i.detail;
  let e = Fm, t = zm;
  return Fm = i, zm = Date.now(), Wm = !e || t > Date.now() - 400 && Math.abs(e.clientX - i.clientX) < 2 && Math.abs(e.clientY - i.clientY) < 2 ? (Wm + 1) % 3 : 1;
}
function oD(i, e) {
  let t = Bm(i, e), r = uC(e), o = i.state.selection;
  return {
    update(s) {
      s.docChanged && (t.pos = s.changes.mapPos(t.pos), o = o.map(s.changes));
    },
    get(s, n, a) {
      let l = Bm(i, s), u, h = Xm(i, l.pos, l.bias, r);
      if (t.pos != l.pos && !n) {
        let c = Xm(i, t.pos, t.bias, r), d = Math.min(c.from, h.from), f = Math.max(c.to, h.to);
        h = d < h.from ? D.range(d, f) : D.range(f, d);
      }
      return n ? o.replaceRange(o.main.extend(h.from, h.to)) : a && r == 1 && o.ranges.length > 1 && (u = sD(o, l.pos)) ? u : a ? o.addRange(h) : D.create([h]);
    }
  };
}
function sD(i, e) {
  for (let t = 0; t < i.ranges.length; t++) {
    let { from: r, to: o } = i.ranges[t];
    if (r <= e && o >= e)
      return D.create(i.ranges.slice(0, t).concat(i.ranges.slice(t + 1)), i.mainIndex == t ? 0 : i.mainIndex - (i.mainIndex > t ? 1 : 0));
  }
  return null;
}
rt.dragstart = (i, e) => {
  let { selection: { main: t } } = i.state, { mouseSelection: r } = i.inputState;
  r && (r.dragging = t), e.dataTransfer && (e.dataTransfer.setData("Text", i.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove");
};
function Zm(i, e, t, r) {
  if (!t)
    return;
  let o = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  e.preventDefault();
  let { mouseSelection: s } = i.inputState, n = r && s && s.dragging && J1(i, e) ? { from: s.dragging.from, to: s.dragging.to } : null, a = { from: o, insert: t }, l = i.state.changes(n ? [n, a] : a);
  i.focus(), i.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(o, -1), head: l.mapPos(o, 1) },
    userEvent: n ? "move.drop" : "input.drop"
  });
}
rt.drop = (i, e) => {
  if (!e.dataTransfer)
    return;
  if (i.state.readOnly)
    return e.preventDefault();
  let t = e.dataTransfer.files;
  if (t && t.length) {
    e.preventDefault();
    let r = Array(t.length), o = 0, s = () => {
      ++o == t.length && Zm(i, e, r.filter((n) => n != null).join(i.state.lineBreak), !1);
    };
    for (let n = 0; n < t.length; n++) {
      let a = new FileReader();
      a.onerror = s, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[n] = a.result), s();
      }, a.readAsText(t[n]);
    }
  } else
    Zm(i, e, e.dataTransfer.getData("Text"), !0);
};
rt.paste = (i, e) => {
  if (i.state.readOnly)
    return e.preventDefault();
  i.observer.flush();
  let t = nC ? null : e.clipboardData;
  t ? (aC(i, t.getData("text/plain") || t.getData("text/uri-text")), e.preventDefault()) : tD(i);
};
function nD(i, e) {
  let t = i.dom.parentNode;
  if (!t)
    return;
  let r = t.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), i.focus();
  }, 50);
}
function aD(i) {
  let e = [], t = [], r = !1;
  for (let o of i.selection.ranges)
    o.empty || (e.push(i.sliceDoc(o.from, o.to)), t.push(o));
  if (!e.length) {
    let o = -1;
    for (let { from: s } of i.selection.ranges) {
      let n = i.doc.lineAt(s);
      n.number > o && (e.push(n.text), t.push({ from: n.from, to: Math.min(i.doc.length, n.to + 1) })), o = n.number;
    }
    r = !0;
  }
  return { text: e.join(i.lineBreak), ranges: t, linewise: r };
}
let Of = null;
rt.copy = rt.cut = (i, e) => {
  let { text: t, ranges: r, linewise: o } = aD(i.state);
  if (!t && !o)
    return;
  Of = o ? t : null;
  let s = nC ? null : e.clipboardData;
  s ? (e.preventDefault(), s.clearData(), s.setData("text/plain", t)) : nD(i, t), e.type == "cut" && !i.state.readOnly && i.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
};
const hC = /* @__PURE__ */ Mr.define();
function cC(i, e) {
  let t = [];
  for (let r of i.facet(BA)) {
    let o = r(i, e);
    o && t.push(o);
  }
  return t ? i.update({ effects: t, annotations: hC.of(!0) }) : null;
}
function dC(i) {
  setTimeout(() => {
    let e = i.hasFocus;
    if (e != i.inputState.notifiedFocused) {
      let t = cC(i.state, e);
      t ? i.dispatch(t) : i.update([]);
    }
  }, 10);
}
rt.focus = (i) => {
  i.inputState.lastFocusTime = Date.now(), !i.scrollDOM.scrollTop && (i.inputState.lastScrollTop || i.inputState.lastScrollLeft) && (i.scrollDOM.scrollTop = i.inputState.lastScrollTop, i.scrollDOM.scrollLeft = i.inputState.lastScrollLeft), dC(i);
};
rt.blur = (i) => {
  i.observer.clearSelectionRange(), dC(i);
};
rt.compositionstart = rt.compositionupdate = (i) => {
  i.inputState.compositionFirstChange == null && (i.inputState.compositionFirstChange = !0), i.inputState.composing < 0 && (i.inputState.composing = 0);
};
rt.compositionend = (i) => {
  i.inputState.composing = -1, i.inputState.compositionEndedAt = Date.now(), i.inputState.compositionPendingKey = !0, i.inputState.compositionPendingChange = i.observer.pendingRecords().length > 0, i.inputState.compositionFirstChange = null, J.chrome && J.android ? i.observer.flushSoon() : i.inputState.compositionPendingChange ? Promise.resolve().then(() => i.observer.flush()) : setTimeout(() => {
    i.inputState.composing < 0 && i.docView.compositionDeco.size && i.update([]);
  }, 50);
};
rt.contextmenu = (i) => {
  i.inputState.lastContextMenu = Date.now();
};
rt.beforeinput = (i, e) => {
  var t;
  let r;
  if (J.chrome && J.android && (r = oC.find((o) => o.inputType == e.inputType)) && (i.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) {
    let o = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > o + 10 && i.hasFocus && (i.contentDOM.blur(), i.focus());
    }, 100);
  }
};
const qm = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class lD {
  constructor(e) {
    this.lineWrapping = e, this.doc = Ce.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let r = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((t - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return qm.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let r = 0; r < e.length; r++) {
      let o = e[r];
      o < 0 ? r++ : this.heightSamples[Math.floor(o * 10)] || (t = !0, this.heightSamples[Math.floor(o * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, r, o, s, n) {
    let a = qm.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = t, this.charWidth = r, this.textHeight = o, this.lineLength = s, l) {
      this.heightSamples = {};
      for (let u = 0; u < n.length; u++) {
        let h = n[u];
        h < 0 ? u++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return l;
  }
}
class uD {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Ki {
  /**
  @internal
  */
  constructor(e, t, r, o, s) {
    this.from = e, this.length = t, this.top = r, this.height = o, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Ye.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof To ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Ki(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var Ue = /* @__PURE__ */ function(i) {
  return i[i.ByPos = 0] = "ByPos", i[i.ByHeight = 1] = "ByHeight", i[i.ByPosNoHeight = 2] = "ByPosNoHeight", i;
}(Ue || (Ue = {}));
const jl = 1e-3;
class Gt {
  constructor(e, t, r = 2) {
    this.length = e, this.height = t, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > jl && (e.heightChanged = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, r) {
    return Gt.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, r, o) {
    let s = this, n = r.doc;
    for (let a = o.length - 1; a >= 0; a--) {
      let { fromA: l, toA: u, fromB: h, toB: c } = o[a], d = s.lineAt(l, Ue.ByPosNoHeight, r.setDoc(t), 0, 0), f = d.to >= u ? d : s.lineAt(u, Ue.ByPosNoHeight, r, 0, 0);
      for (c += f.to - u, u = f.to; a > 0 && d.from <= o[a - 1].toA; )
        l = o[a - 1].fromA, h = o[a - 1].fromB, a--, l < d.from && (d = s.lineAt(l, Ue.ByPosNoHeight, r, 0, 0));
      h += d.from - l, l = d.from;
      let p = sO.build(r.setDoc(n), e, h, c);
      s = s.replace(l, u, p);
    }
    return s.updateHeight(r, 0);
  }
  static empty() {
    return new ii(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, r = e.length, o = 0, s = 0;
    for (; ; )
      if (t == r)
        if (o > s * 2) {
          let a = e[t - 1];
          a.break ? e.splice(--t, 1, a.left, null, a.right) : e.splice(--t, 1, a.left, a.right), r += 1 + a.break, o -= a.size;
        } else if (s > o * 2) {
          let a = e[r];
          a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), r += 2 + a.break, s -= a.size;
        } else
          break;
      else if (o < s) {
        let a = e[t++];
        a && (o += a.size);
      } else {
        let a = e[--r];
        a && (s += a.size);
      }
    let n = 0;
    return e[t - 1] == null ? (n = 1, t--) : e[t] == null && (n = 1, r++), new hD(Gt.of(e.slice(0, t)), n, Gt.of(e.slice(r)));
  }
}
Gt.prototype.size = 1;
class fC extends Gt {
  constructor(e, t, r) {
    super(e, t), this.deco = r;
  }
  blockAt(e, t, r, o) {
    return new Ki(o, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, t, r, o, s) {
    return this.blockAt(0, r, o, s);
  }
  forEachLine(e, t, r, o, s, n) {
    e <= s + this.length && t >= s && n(this.blockAt(0, r, o, s));
  }
  updateHeight(e, t = 0, r = !1, o) {
    return o && o.from <= t && o.more && this.setHeight(e, o.heights[o.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class ii extends fC {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, r, o) {
    return new Ki(o, this.length, r, this.height, this.breaks);
  }
  replace(e, t, r) {
    let o = r[0];
    return r.length == 1 && (o instanceof ii || o instanceof Et && o.flags & 4) && Math.abs(this.length - o.length) < 10 ? (o instanceof Et ? o = new ii(o.length, this.height) : o.height = this.height, this.outdated || (o.outdated = !1), o) : Gt.of(r);
  }
  updateHeight(e, t = 0, r = !1, o) {
    return o && o.from <= t && o.more ? this.setHeight(e, o.heights[o.index++]) : (r || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Et extends Gt {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let r = e.doc.lineAt(t).number, o = e.doc.lineAt(t + this.length).number, s = o - r + 1, n, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * s);
      n = l / s, this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1));
    } else
      n = this.height / s;
    return { firstLine: r, lastLine: o, perLine: n, perChar: a };
  }
  blockAt(e, t, r, o) {
    let { firstLine: s, lastLine: n, perLine: a, perChar: l } = this.heightMetrics(t, o);
    if (t.lineWrapping) {
      let u = o + Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length), h = t.doc.lineAt(u), c = a + h.length * l, d = Math.max(r, e - c / 2);
      return new Ki(h.from, h.length, d, c, 0);
    } else {
      let u = Math.max(0, Math.min(n - s, Math.floor((e - r) / a))), { from: h, length: c } = t.doc.line(s + u);
      return new Ki(h, c, r + a * u, a, 0);
    }
  }
  lineAt(e, t, r, o, s) {
    if (t == Ue.ByHeight)
      return this.blockAt(e, r, o, s);
    if (t == Ue.ByPosNoHeight) {
      let { from: f, to: p } = r.doc.lineAt(e);
      return new Ki(f, p - f, 0, 0, 0);
    }
    let { firstLine: n, perLine: a, perChar: l } = this.heightMetrics(r, s), u = r.doc.lineAt(e), h = a + u.length * l, c = u.number - n, d = o + a * c + l * (u.from - s - c);
    return new Ki(u.from, u.length, Math.max(o, Math.min(d, o + this.height - h)), h, 0);
  }
  forEachLine(e, t, r, o, s, n) {
    e = Math.max(e, s), t = Math.min(t, s + this.length);
    let { firstLine: a, perLine: l, perChar: u } = this.heightMetrics(r, s);
    for (let h = e, c = o; h <= t; ) {
      let d = r.doc.lineAt(h);
      if (h == e) {
        let p = d.number - a;
        c += l * p + u * (e - s - p);
      }
      let f = l + u * d.length;
      n(new Ki(d.from, d.length, c, f, 0)), c += f, h = d.to + 1;
    }
  }
  replace(e, t, r) {
    let o = this.length - t;
    if (o > 0) {
      let s = r[r.length - 1];
      s instanceof Et ? r[r.length - 1] = new Et(s.length + o) : r.push(null, new Et(o - 1));
    }
    if (e > 0) {
      let s = r[0];
      s instanceof Et ? r[0] = new Et(e + s.length) : r.unshift(new Et(e - 1), null);
    }
    return Gt.of(r);
  }
  decomposeLeft(e, t) {
    t.push(new Et(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new Et(this.length - e - 1));
  }
  updateHeight(e, t = 0, r = !1, o) {
    let s = t + this.length;
    if (o && o.from <= t + this.length && o.more) {
      let n = [], a = Math.max(t, o.from), l = -1;
      for (o.from > t && n.push(new Et(o.from - t - 1).updateHeight(e, t)); a <= s && o.more; ) {
        let h = e.doc.lineAt(a).length;
        n.length && n.push(null);
        let c = o.heights[o.index++];
        l == -1 ? l = c : Math.abs(c - l) >= jl && (l = -2);
        let d = new ii(h, c);
        d.outdated = !1, n.push(d), a += h + 1;
      }
      a <= s && n.push(null, new Et(s - a).updateHeight(e, a));
      let u = Gt.of(n);
      return (l < 0 || Math.abs(u.height - this.height) >= jl || Math.abs(l - this.heightMetrics(e, t).perLine) >= jl) && (e.heightChanged = !0), u;
    } else
      (r || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class hD extends Gt {
  constructor(e, t, r) {
    super(e.length + t + r.length, e.height + r.height, t | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, r, o) {
    let s = r + this.left.height;
    return e < s ? this.left.blockAt(e, t, r, o) : this.right.blockAt(e, t, s, o + this.left.length + this.break);
  }
  lineAt(e, t, r, o, s) {
    let n = o + this.left.height, a = s + this.left.length + this.break, l = t == Ue.ByHeight ? e < n : e < a, u = l ? this.left.lineAt(e, t, r, o, s) : this.right.lineAt(e, t, r, n, a);
    if (this.break || (l ? u.to < a : u.from > a))
      return u;
    let h = t == Ue.ByPosNoHeight ? Ue.ByPosNoHeight : Ue.ByPos;
    return l ? u.join(this.right.lineAt(a, h, r, n, a)) : this.left.lineAt(a, h, r, o, s).join(u);
  }
  forEachLine(e, t, r, o, s, n) {
    let a = o + this.left.height, l = s + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, r, o, s, n), t >= l && this.right.forEachLine(e, t, r, a, l, n);
    else {
      let u = this.lineAt(l, Ue.ByPos, r, o, s);
      e < u.from && this.left.forEachLine(e, u.from - 1, r, o, s, n), u.to >= e && u.from <= t && n(u), t > u.to && this.right.forEachLine(u.to + 1, t, r, a, l, n);
    }
  }
  replace(e, t, r) {
    let o = this.left.length + this.break;
    if (t < o)
      return this.balanced(this.left.replace(e, t, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - o, t - o, r));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let n = s.length;
    for (let a of r)
      s.push(a);
    if (e > 0 && jm(s, n - 1), t < this.length) {
      let a = s.length;
      this.decomposeRight(t, s), jm(s, a);
    }
    return Gt.of(s);
  }
  decomposeLeft(e, t) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (r++, e >= r && t.push(null)), e > r && this.right.decomposeLeft(e - r, t);
  }
  decomposeRight(e, t) {
    let r = this.left.length, o = r + this.break;
    if (e >= o)
      return this.right.decomposeRight(e - o, t);
    e < r && this.left.decomposeRight(e, t), this.break && e < o && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Gt.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, r = !1, o) {
    let { left: s, right: n } = this, a = t + s.length + this.break, l = null;
    return o && o.from <= t + s.length && o.more ? l = s = s.updateHeight(e, t, r, o) : s.updateHeight(e, t, r), o && o.from <= a + n.length && o.more ? l = n = n.updateHeight(e, a, r, o) : n.updateHeight(e, a, r), l ? this.balanced(s, n) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function jm(i, e) {
  let t, r;
  i[e] == null && (t = i[e - 1]) instanceof Et && (r = i[e + 1]) instanceof Et && i.splice(e - 1, 3, new Et(t.length + 1 + r.length));
}
const cD = 5;
class sO {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let r = Math.min(t, this.lineEnd), o = this.nodes[this.nodes.length - 1];
      o instanceof ii ? o.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new ii(r - this.pos, -1)), this.writtenTo = r, t > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, r) {
    if (e < t || r.heightRelevant) {
      let o = r.widget ? r.widget.estimatedHeight : 0, s = r.widget ? r.widget.lineBreaks : 0;
      o < 0 && (o = this.oracle.lineHeight);
      let n = t - e;
      r.block ? this.addBlock(new fC(n, o, r)) : (n || s || o >= cD) && this.addLineDeco(o, s, n);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new ii(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let r = new Et(t - e);
    return this.oracle.doc.lineAt(e).to == t && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof ii)
      return e;
    let t = new ii(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    var t;
    this.enterLine();
    let r = (t = e.deco) === null || t === void 0 ? void 0 : t.type;
    r == Ye.WidgetAfter && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, r != Ye.WidgetBefore && (this.covering = e);
  }
  addLineDeco(e, t, r) {
    let o = this.ensureLine();
    o.length += r, o.collapsed += r, o.widgetHeight = Math.max(o.widgetHeight, e), o.breaks += t, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof ii) && !this.isCovered ? this.nodes.push(new ii(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let o of this.nodes)
      o instanceof ii && o.updateHeight(this.oracle, r), r += o ? o.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, r, o) {
    let s = new sO(r, e);
    return Le.spans(t, r, o, s, 0), s.finish(r);
  }
}
function dD(i, e, t) {
  let r = new fD();
  return Le.compare(i, e, t, r, 0), r.changes;
}
class fD {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, r, o) {
    (e < t || r && r.heightRelevant || o && o.heightRelevant) && lf(e, t, this.changes, 5);
  }
}
function pD(i, e) {
  let t = i.getBoundingClientRect(), r = i.ownerDocument, o = r.defaultView || window, s = Math.max(0, t.left), n = Math.min(o.innerWidth, t.right), a = Math.max(0, t.top), l = Math.min(o.innerHeight, t.bottom);
  for (let u = i.parentNode; u && u != r.body; )
    if (u.nodeType == 1) {
      let h = u, c = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && c.overflow != "visible") {
        let d = h.getBoundingClientRect();
        s = Math.max(s, d.left), n = Math.min(n, d.right), a = Math.max(a, d.top), l = u == i.parentNode ? d.bottom : Math.min(l, d.bottom);
      }
      u = c.position == "absolute" || c.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: s - t.left,
    right: Math.max(s, n) - t.left,
    top: a - (t.top + e),
    bottom: Math.max(a, l) - (t.top + e)
  };
}
function OD(i, e) {
  let t = i.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class Lc {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.size = r;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let o = e[r], s = t[r];
      if (o.from != s.from || o.to != s.to || o.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e) {
    return ie.replace({ widget: new ED(this.size, e) }).range(this.from, this.to);
  }
}
class ED extends Ur {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class Km {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = Jm, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = He.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(rO).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new lD(t), this.stateDeco = e.facet(ya).filter((r) => typeof r != "function"), this.heightMap = Gt.empty().applyChanges(this.stateDeco, Ce.empty, this.heightOracle.setDoc(e.doc), [new nr(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = ie.set(this.lineGaps.map((r) => r.draw(!1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let o = r ? t.head : t.anchor;
      if (!e.some(({ from: s, to: n }) => o >= s && o <= n)) {
        let { from: s, to: n } = this.lineBlockAt(o);
        e.push(new Il(s, n));
      }
    }
    this.viewports = e.sort((r, o) => r.from - o.from), this.scaler = this.heightMap.height <= 7e6 ? Jm : new bD(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : Fn(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(ya).filter((h) => typeof h != "function");
    let o = e.changedRanges, s = nr.extendWithRanges(o, dD(r, this.stateDeco, e ? e.changes : st.empty(this.state.doc.length))), n = this.heightMap.height, a = this.scrolledToBottom ? null : this.lineBlockAtHeight(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != n && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let u = !e.changes.empty || e.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), u && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(WA) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, r = window.getComputedStyle(t), o = this.heightOracle, s = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? He.RTL : He.LTR;
    let n = this.heightOracle.mustRefreshForWrapping(s), a = t.getBoundingClientRect(), l = n || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let u = 0, h = 0, c = parseInt(r.paddingTop) || 0, d = parseInt(r.paddingBottom) || 0;
    (this.paddingTop != c || this.paddingBottom != d) && (this.paddingTop = c, this.paddingBottom = d, u |= 10), this.editorWidth != e.scrollDOM.clientWidth && (o.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, u |= 8), this.scrollTop != e.scrollDOM.scrollTop && (this.scrollAnchorHeight = -1, this.scrollTop = e.scrollDOM.scrollTop), this.scrolledToBottom = this.scrollTop > e.scrollDOM.scrollHeight - e.scrollDOM.clientHeight - 4;
    let f = (this.printing ? OD : pD)(t, this.paddingTop), p = f.top - this.pixelViewport.top, O = f.bottom - this.pixelViewport.bottom;
    this.pixelViewport = f;
    let m = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (m != this.inView && (this.inView = m, m && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let E = a.width;
    if ((this.contentDOMWidth != E || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, u |= 8), l) {
      let A = e.docView.measureVisibleLineHeights(this.viewport);
      if (o.mustRefreshForHeights(A) && (n = !0), n || o.lineWrapping && Math.abs(E - this.contentDOMWidth) > o.charWidth) {
        let { lineHeight: S, charWidth: R, textHeight: v } = e.docView.measureTextSize();
        n = S > 0 && o.refresh(s, S, R, v, E / R, A), n && (e.docView.minWidth = 0, u |= 8);
      }
      p > 0 && O > 0 ? h = Math.max(p, O) : p < 0 && O < 0 && (h = Math.min(p, O)), o.heightChanged = !1;
      for (let S of this.viewports) {
        let R = S.from == this.viewport.from ? A : e.docView.measureVisibleLineHeights(S);
        this.heightMap = (n ? Gt.empty().applyChanges(this.stateDeco, Ce.empty, this.heightOracle, [new nr(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(o, 0, n, new uD(S.from, R));
      }
      o.heightChanged && (u |= 2);
    }
    let g = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return g && (this.viewport = this.getViewport(h, this.scrollTarget)), this.updateForViewport(), (u & 2 || g) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(n ? [] : this.lineGaps, e)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), o = this.heightMap, s = this.heightOracle, { visibleTop: n, visibleBottom: a } = this, l = new Il(o.lineAt(n - r * 1e3, Ue.ByHeight, s, 0, 0).from, o.lineAt(a + (1 - r) * 1e3, Ue.ByHeight, s, 0, 0).to);
    if (t) {
      let { head: u } = t.range;
      if (u < l.from || u > l.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), c = o.lineAt(u, Ue.ByPos, s, 0, 0), d;
        t.y == "center" ? d = (c.top + c.bottom) / 2 - h / 2 : t.y == "start" || t.y == "nearest" && u < l.from ? d = c.top : d = c.bottom - h, l = new Il(o.lineAt(d - 1e3 / 2, Ue.ByHeight, s, 0, 0).from, o.lineAt(d + h + 1e3 / 2, Ue.ByHeight, s, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let r = t.mapPos(e.from, -1), o = t.mapPos(e.to, 1);
    return new Il(this.heightMap.lineAt(r, Ue.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(o, Ue.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: o } = this.heightMap.lineAt(e, Ue.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(t, Ue.ByPos, this.heightOracle, 0, 0), { visibleTop: n, visibleBottom: a } = this;
    return (e == 0 || o <= n - Math.max(10, Math.min(
      -r,
      250
      /* MaxCoverMargin */
    ))) && (t == this.state.doc.length || s >= a + Math.max(10, Math.min(
      r,
      250
      /* MaxCoverMargin */
    ))) && o > n - 2 * 1e3 && s < a + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let r = [];
    for (let o of e)
      t.touchesRange(o.from, o.to) || r.push(new Lc(t.mapPos(o.from), t.mapPos(o.to), o.size));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let r = this.heightOracle.lineWrapping, o = r ? 1e4 : 2e3, s = o >> 1, n = o << 1;
    if (this.defaultTextDirection != He.LTR && !r)
      return [];
    let a = [], l = (u, h, c, d) => {
      if (h - u < s)
        return;
      let f = this.state.selection.main, p = [f.from];
      f.empty || p.push(f.to);
      for (let m of p)
        if (m > u && m < h) {
          l(u, m - 10, c, d), l(m + 10, h, c, d);
          return;
        }
      let O = gD(e, (m) => m.from >= c.from && m.to <= c.to && Math.abs(m.from - u) < s && Math.abs(m.to - h) < s && !p.some((E) => m.from < E && m.to > E));
      if (!O) {
        if (h < c.to && t && r && t.visibleRanges.some((m) => m.from <= h && m.to >= h)) {
          let m = t.moveToLineBoundary(D.cursor(h), !1, !0).head;
          m > u && (h = m);
        }
        O = new Lc(u, h, this.gapSize(c, u, h, d));
      }
      a.push(O);
    };
    for (let u of this.viewportLines) {
      if (u.length < n)
        continue;
      let h = mD(u.from, u.to, this.stateDeco);
      if (h.total < n)
        continue;
      let c = this.scrollTarget ? this.scrollTarget.range.head : null, d, f;
      if (r) {
        let p = o / this.heightOracle.lineLength * this.heightOracle.lineHeight, O, m;
        if (c != null) {
          let E = _l(h, c), g = ((this.visibleBottom - this.visibleTop) / 2 + p) / u.height;
          O = E - g, m = E + g;
        } else
          O = (this.visibleTop - u.top - p) / u.height, m = (this.visibleBottom - u.top + p) / u.height;
        d = vl(h, O), f = vl(h, m);
      } else {
        let p = h.total * this.heightOracle.charWidth, O = o * this.heightOracle.charWidth, m, E;
        if (c != null) {
          let g = _l(h, c), A = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + O) / p;
          m = g - A, E = g + A;
        } else
          m = (this.pixelViewport.left - O) / p, E = (this.pixelViewport.right + O) / p;
        d = vl(h, m), f = vl(h, E);
      }
      d > u.from && l(u.from, d, u, h), f < u.to && l(f, u.to, u, h);
    }
    return a;
  }
  gapSize(e, t, r, o) {
    let s = _l(o, r) - _l(o, t);
    return this.heightOracle.lineWrapping ? e.height * s : o.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Lc.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = ie.set(e.map((t) => t.draw(this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    Le.spans(e, this.viewport.from, this.viewport.to, {
      span(o, s) {
        t.push({ from: o, to: s });
      },
      point() {
      }
    }, 20);
    let r = t.length != this.visibleRanges.length || this.visibleRanges.some((o, s) => o.from != t[s].from || o.to != t[s].to);
    return this.visibleRanges = t, r ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || Fn(this.heightMap.lineAt(e, Ue.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return Fn(this.heightMap.lineAt(this.scaler.fromDOM(e), Ue.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  elementAtHeight(e) {
    return Fn(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Il {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function mD(i, e, t) {
  let r = [], o = i, s = 0;
  return Le.spans(t, i, e, {
    span() {
    },
    point(n, a) {
      n > o && (r.push({ from: o, to: n }), s += n - o), o = a;
    }
  }, 20), o < e && (r.push({ from: o, to: e }), s += e - o), { total: s, ranges: r };
}
function vl({ total: i, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(i * t);
  for (let o = 0; ; o++) {
    let { from: s, to: n } = e[o], a = n - s;
    if (r <= a)
      return s + r;
    r -= a;
  }
}
function _l(i, e) {
  let t = 0;
  for (let { from: r, to: o } of i.ranges) {
    if (e <= o) {
      t += e - r;
      break;
    }
    t += o - r;
  }
  return t / i.total;
}
function gD(i, e) {
  for (let t of i)
    if (e(t))
      return t;
}
const Jm = {
  toDOM(i) {
    return i;
  },
  fromDOM(i) {
    return i;
  },
  scale: 1
};
class bD {
  constructor(e, t, r) {
    let o = 0, s = 0, n = 0;
    this.viewports = r.map(({ from: a, to: l }) => {
      let u = t.lineAt(a, Ue.ByPos, e, 0, 0).top, h = t.lineAt(l, Ue.ByPos, e, 0, 0).bottom;
      return o += h - u, { from: a, to: l, top: u, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - o) / (t.height - o);
    for (let a of this.viewports)
      a.domTop = n + (a.top - s) * this.scale, n = a.domBottom = a.domTop + (a.bottom - a.top), s = a.bottom;
  }
  toDOM(e) {
    for (let t = 0, r = 0, o = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.top)
        return o + (e - r) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      r = s.bottom, o = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, r = 0, o = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.domTop)
        return r + (e - o) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      r = s.bottom, o = s.domBottom;
    }
  }
}
function Fn(i, e) {
  if (e.scale == 1)
    return i;
  let t = e.toDOM(i.top), r = e.toDOM(i.bottom);
  return new Ki(i.from, i.length, t, r - t, Array.isArray(i._content) ? i._content.map((o) => Fn(o, e)) : i._content);
}
const Pl = /* @__PURE__ */ K.define({ combine: (i) => i.join(" ") }), Ef = /* @__PURE__ */ K.define({ combine: (i) => i.indexOf(!0) > -1 }), mf = /* @__PURE__ */ mo.newName(), pC = /* @__PURE__ */ mo.newName(), OC = /* @__PURE__ */ mo.newName(), EC = { "&light": "." + pC, "&dark": "." + OC };
function gf(i, e, t) {
  return new mo(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (o) => {
        if (o == "&")
          return i;
        if (!t || !t[o])
          throw new RangeError(`Unsupported selector: ${o}`);
        return t[o];
      }) : i + " " + r;
    }
  });
}
const TD = /* @__PURE__ */ gf("." + mf, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, EC);
class SD {
  constructor(e, t, r, o) {
    this.typeOver = o, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: n } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, r, 0))) {
      let a = s || n ? [] : AD(e), l = new eC(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = CD(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = s && s.node == a.focusNode && s.offset == a.focusOffset || !sn(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), u = n && n.node == a.anchorNode && n.offset == a.anchorOffset || !sn(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset);
      this.newSel = D.single(u, l);
    }
  }
}
function mC(i, e) {
  let t, { newSel: r } = e, o = i.state.selection.main, s = i.inputState.lastKeyTime > Date.now() - 100 ? i.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: n, to: a } = e.bounds, l = o.from, u = null;
    (s === 8 || J.android && e.text.length < a - n) && (l = o.to, u = "end");
    let h = RD(i.state.doc.sliceString(n, a, ys), e.text, l - n, u);
    h && (J.chrome && s == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == ys + ys && h.toB--, t = {
      from: n + h.from,
      to: n + h.toA,
      insert: Ce.of(e.text.slice(h.from, h.toB).split(ys))
    });
  } else
    r && (!i.hasFocus && i.state.facet(Gh) || r.main.eq(o)) && (r = null);
  if (!t && !r)
    return !1;
  if (!t && e.typeOver && !o.empty && r && r.main.empty ? t = { from: o.from, to: o.to, insert: i.state.doc.slice(o.from, o.to) } : t && t.from >= o.from && t.to <= o.to && (t.from != o.from || t.to != o.to) && o.to - o.from - (t.to - t.from) <= 4 ? t = {
    from: o.from,
    to: o.to,
    insert: i.state.doc.slice(o.from, t.from).append(t.insert).append(i.state.doc.slice(t.to, o.to))
  } : (J.mac || J.android) && t && t.from == t.to && t.from == o.head - 1 && /^\. ?$/.test(t.insert.toString()) && i.contentDOM.getAttribute("autocorrect") == "off" ? (r && t.insert.length == 2 && (r = D.single(r.main.anchor - 1, r.main.head - 1)), t = { from: o.from, to: o.to, insert: Ce.of([" "]) }) : J.chrome && t && t.from == t.to && t.from == o.head && t.insert.toString() == `
 ` && i.lineWrapping && (r && (r = D.single(r.main.anchor - 1, r.main.head - 1)), t = { from: o.from, to: o.to, insert: Ce.of([" "]) }), t) {
    let n = i.state;
    if (J.ios && i.inputState.flushIOSKey(i) || J.android && (t.from == o.from && t.to == o.to && t.insert.length == 1 && t.insert.lines == 2 && Xs(i.contentDOM, "Enter", 13) || (t.from == o.from - 1 && t.to == o.to && t.insert.length == 0 || s == 8 && t.insert.length < t.to - t.from) && Xs(i.contentDOM, "Backspace", 8) || t.from == o.from && t.to == o.to + 1 && t.insert.length == 0 && Xs(i.contentDOM, "Delete", 46)))
      return !0;
    let a = t.insert.toString();
    if (i.state.facet(YA).some((h) => h(i, t.from, t.to, a)))
      return !0;
    i.inputState.composing >= 0 && i.inputState.composing++;
    let l;
    if (t.from >= o.from && t.to <= o.to && t.to - t.from >= (o.to - o.from) / 3 && (!r || r.main.empty && r.main.from == t.from + t.insert.length) && i.inputState.composing < 0) {
      let h = o.from < t.from ? n.sliceDoc(o.from, t.from) : "", c = o.to > t.to ? n.sliceDoc(t.to, o.to) : "";
      l = n.replaceSelection(i.state.toText(h + t.insert.sliceString(0, void 0, i.state.lineBreak) + c));
    } else {
      let h = n.changes(t), c = r && r.main.to <= h.newLength ? r.main : void 0;
      if (n.selection.ranges.length > 1 && i.inputState.composing >= 0 && t.to <= o.to && t.to >= o.to - 10) {
        let d = i.state.sliceDoc(t.from, t.to), f = tC(i) || i.state.doc.lineAt(o.head), p = o.to - t.to, O = o.to - o.from;
        l = n.changeByRange((m) => {
          if (m.from == o.from && m.to == o.to)
            return { changes: h, range: c || m.map(h) };
          let E = m.to - p, g = E - d.length;
          if (m.to - m.from != O || i.state.sliceDoc(g, E) != d || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          f && m.to >= f.from && m.from <= f.to)
            return { range: m };
          let A = n.changes({ from: g, to: E, insert: t.insert }), S = m.to - o.to;
          return {
            changes: A,
            range: c ? D.range(Math.max(0, c.anchor + S), Math.max(0, c.head + S)) : m.map(A)
          };
        });
      } else
        l = {
          changes: h,
          selection: c && n.selection.replaceRange(c)
        };
    }
    let u = "input.type";
    return (i.composing || i.inputState.compositionPendingChange && i.inputState.compositionEndedAt > Date.now() - 50) && (i.inputState.compositionPendingChange = !1, u += ".compose", i.inputState.compositionFirstChange && (u += ".start", i.inputState.compositionFirstChange = !1)), i.dispatch(l, { scrollIntoView: !0, userEvent: u }), !0;
  } else if (r && !r.main.eq(o)) {
    let n = !1, a = "select";
    return i.inputState.lastSelectionTime > Date.now() - 50 && (i.inputState.lastSelectionOrigin == "select" && (n = !0), a = i.inputState.lastSelectionOrigin), i.dispatch({ selection: r, scrollIntoView: n, userEvent: a }), !0;
  } else
    return !1;
}
function RD(i, e, t, r) {
  let o = Math.min(i.length, e.length), s = 0;
  for (; s < o && i.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == o && i.length == e.length)
    return null;
  let n = i.length, a = e.length;
  for (; n > 0 && a > 0 && i.charCodeAt(n - 1) == e.charCodeAt(a - 1); )
    n--, a--;
  if (r == "end") {
    let l = Math.max(0, s - Math.min(n, a));
    t -= n + l - s;
  }
  if (n < s && i.length < e.length) {
    let l = t <= s && t >= n ? s - t : 0;
    s -= l, a = s + (a - n), n = s;
  } else if (a < s) {
    let l = t <= s && t >= a ? s - t : 0;
    s -= l, n = s + (n - a), a = s;
  }
  return { from: s, toA: n, toB: a };
}
function AD(i) {
  let e = [];
  if (i.root.activeElement != i.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: r, focusNode: o, focusOffset: s } = i.observer.selectionRange;
  return t && (e.push(new xm(t, r)), (o != t || s != r) && e.push(new xm(o, s))), e;
}
function CD(i, e) {
  if (i.length == 0)
    return null;
  let t = i[0].pos, r = i.length == 2 ? i[1].pos : t;
  return t > -1 && r > -1 ? D.single(t + e, r + e) : null;
}
const ND = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, wc = J.ie && J.ie_version <= 11;
class ID {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new T1(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.resizeContent = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let r of t)
        this.queue.push(r);
      (J.ie && J.ie_version <= 11 || J.ios && e.composing) && t.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), wc && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM), this.resizeContent = new ResizeObserver(() => this.view.requestMeasure()), this.resizeContent.observe(e.contentDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runScrollHandlers(this.view, e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, r) => t != e[r]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, o = this.selectionRange;
    if (r.state.facet(Gh) ? r.root.activeElement != this.dom : !Zl(r.dom, o))
      return;
    let s = o.anchorNode && r.docView.nearest(o.anchorNode);
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (J.ie && J.ie_version <= 11 || J.android && J.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    o.focusNode && Mu(o.focusNode, o.focusOffset, o.anchorNode, o.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = J.safari && e.root.nodeType == 11 && E1(this.dom.ownerDocument) == this.dom && vD(this.view) || xu(e.root);
    if (!t || this.selectionRange.eq(t))
      return !1;
    let r = Zl(this.dom, t);
    return r && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && R1(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(t), r && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = t)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, ND), wc && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), wc && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var r;
    if (!this.delayedAndroidKey) {
      let o = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && Xs(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(o);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, r = -1, o = !1;
    for (let s of e) {
      let n = this.readMutation(s);
      n && (n.typeOver && (o = !0), t == -1 ? { from: t, to: r } = n : (t = Math.min(n.from, t), r = Math.max(n.to, r)));
    }
    return { from: t, to: r, typeOver: o };
  }
  readChange() {
    let { from: e, to: t, typeOver: r } = this.processRecords(), o = this.selectionChanged && Zl(this.dom, this.selectionRange);
    return e < 0 && !o ? null : (e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1, new SD(this.view, e, t, r));
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return !1;
    let r = this.view.state, o = mC(this.view, t);
    return this.view.state == r && this.view.update([]), o;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.dirty |= 4), e.type == "childList") {
      let r = eg(t, e.previousSibling || e.target.previousSibling, -1), o = eg(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? t.posAfter(r) : t.posAtStart,
        to: o ? t.posBefore(o) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, r, o;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect(), (o = this.resizeContent) === null || o === void 0 || o.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function eg(i, e, t) {
  for (; e; ) {
    let r = Me.get(e);
    if (r && r.parent == i)
      return r;
    let o = e.parentNode;
    e = o != i.dom ? o : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function vD(i) {
  let e = null;
  function t(l) {
    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];
  }
  if (i.contentDOM.addEventListener("beforeinput", t, !0), i.dom.ownerDocument.execCommand("indent"), i.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let r = e.startContainer, o = e.startOffset, s = e.endContainer, n = e.endOffset, a = i.docView.domAtPos(i.state.selection.main.anchor);
  return Mu(a.node, a.offset, s, n) && ([r, o, s, n] = [s, n, r, o]), { anchorNode: r, anchorOffset: o, focusNode: s, focusOffset: n };
}
class q {
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: fixed; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), this._dispatch = e.dispatch || ((t) => this.update([t])), this.dispatch = this.dispatch.bind(this), this._root = e.root || S1(e.parent) || document, this.viewState = new Km(e.state || Re.create(e)), this.plugins = this.state.facet(Yn).map((t) => new vc(t));
    for (let t of this.plugins)
      t.update(this);
    this.observer = new ID(this), this.inputState = new Z1(this), this.inputState.ensureHandlers(this, this.plugins), this.docView = new Mm(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), e.parent && e.parent.appendChild(this.dom);
  }
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof nt ? e[0] : this.state.update(...e);
    this._dispatch(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, r = !1, o, s = this.state;
    for (let d of e) {
      if (d.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let n = this.hasFocus, a = 0, l = null;
    e.some((d) => d.annotation(hC)) ? (this.inputState.notifiedFocused = n, a = 1) : n != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = n, l = cC(s, n), l || (a = 1));
    let u = this.observer.delayedAndroidKey, h = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (h = null)) : this.observer.clear(), s.facet(Re.phrases) != this.state.facet(Re.phrases))
      return this.setState(s);
    o = ku.create(this, s, e), o.flags |= a;
    let c = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if (c && (c = c.map(d.changes)), d.scrollIntoView) {
          let { main: f } = d.state.selection;
          c = new Qu(f.empty ? f : D.cursor(f.head, f.head > f.anchor ? -1 : 1));
        }
        for (let f of d.effects)
          f.is(ym) && (c = f.value);
      }
      this.viewState.update(o, c), this.bidiCache = $u.update(this.bidiCache, o.changes), o.empty || (this.updatePlugins(o), this.inputState.update(o)), t = this.docView.update(o), this.state.facet(Bn) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (o.startState.facet(Pl) != o.state.facet(Pl) && (this.viewState.mustMeasureContent = !0), (t || r || c || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !o.empty)
      for (let d of this.state.facet(uf))
        d(o);
    (l || h) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), h && !mC(this, h) && u.force && Xs(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new Km(e), this.plugins = e.facet(Yn).map((r) => new vc(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView = new Mm(this), this.inputState.ensureHandlers(this, this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(Yn), r = e.state.facet(Yn);
    if (t != r) {
      let o = [];
      for (let s of r) {
        let n = t.indexOf(s);
        if (n < 0)
          o.push(new vc(s));
        else {
          let a = this.plugins[n];
          a.mustUpdate = e, o.push(a);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = o, this.pluginMap.clear(), this.inputState.ensureHandlers(this, this.plugins);
    } else
      for (let o of this.plugins)
        o.mustUpdate = e;
    for (let o = 0; o < this.plugins.length; o++)
      this.plugins[o].update(this);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, r = this.scrollDOM, { scrollTop: o } = r, { scrollAnchorPos: s, scrollAnchorHeight: n } = this.viewState;
    if (this.viewState.scrollAnchorHeight = -1, n < 0 || o != this.viewState.scrollTop)
      if (o > r.scrollHeight - r.clientHeight - 4)
        s = -1, n = this.viewState.heightMap.height;
      else {
        let a = this.viewState.lineBlockAtHeight(o);
        s = a.from, n = a.top;
      }
    try {
      for (let a = 0; ; a++) {
        this.updateState = 1;
        let l = this.viewport, u = this.viewState.measure(this);
        if (!u && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let h = [];
        u & 4 || ([this.measureRequests, h] = [h, this.measureRequests]);
        let c = h.map((O) => {
          try {
            return O.read(this);
          } catch (m) {
            return Ri(this.state, m), tg;
          }
        }), d = ku.create(this, this.state, []), f = !1, p = !1;
        d.flags |= u, t ? t.flags |= u : t = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), f = this.docView.update(d));
        for (let O = 0; O < h.length; O++)
          if (c[O] != tg)
            try {
              let m = h[O];
              m.write && m.write(c[O], this);
            } catch (m) {
              Ri(this.state, m);
            }
        if (this.viewState.editorHeight) {
          if (this.viewState.scrollTarget)
            this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, p = !0;
          else if (n > -1) {
            let m = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - n;
            (m > 1 || m < -1) && (r.scrollTop = o + m, p = !0);
          }
        }
        if (f && this.docView.updateSelection(!0), this.viewport.from == l.from && this.viewport.to == l.to && !p && this.measureRequests.length == 0)
          break;
        n = -1;
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let a of this.state.facet(uf))
        a(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return mf + " " + (this.state.facet(Ef) ? OC : pC) + " " + this.state.facet(Pl);
  }
  updateAttrs() {
    let e = ig(this, zA, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(Gh) ? "true" : "false",
      class: "cm-content",
      style: `${J.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), ig(this, rO, t);
    let r = this.observer.ignore(() => {
      let o = af(this.contentDOM, this.contentAttrs, t), s = af(this.dom, this.editorAttrs, e);
      return o || s;
    });
    return this.editorAttrs = e, this.contentAttrs = t, r;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let r of e)
      for (let o of r.effects)
        if (o.is(q.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = o.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Bn), mo.mount(this.root, this.styleModules.concat(TD).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((r) => r.spec == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, r) {
    return Pc(this, e, Vm(this, e, t, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return Pc(this, e, Vm(this, e, t, (r) => W1(this, e.head, r)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, r = !0) {
    return F1(this, e, t, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, r) {
    return Pc(this, e, z1(this, e, t, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), rC(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, t);
    if (!r || r.left == r.right)
      return r;
    let o = this.state.doc.lineAt(e), s = this.bidiSpans(o), n = s[Ys.find(s, e - o.from, -1, t)];
    return Jp(r, n.dir == He.LTR == t > 0);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(FA) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > _D)
      return KA(e.length);
    let t = this.textDirectionAt(e.from);
    for (let o of this.bidiCache)
      if (o.from == e.from && o.dir == t)
        return o.order;
    let r = y1(e.text, t);
    return this.bidiCache.push(new $u(e.from, e.to, t, r)), r;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || J.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      NA(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return ym.of(new Qu(typeof e == "number" ? D.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return lt.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let r = mo.newName(), o = [Pl.of(r), Bn.of(gf(`.${r}`, e))];
    return t && t.dark && o.push(Ef.of(!0)), o;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return ds.lowest(Bn.of(gf("." + mf, e, EC)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let r = e.querySelector(".cm-content"), o = r && Me.get(r) || Me.get(e);
    return ((t = o == null ? void 0 : o.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
q.styleModule = Bn;
q.inputHandler = YA;
q.focusChangeEffect = BA;
q.perLineTextDirection = FA;
q.exceptionSink = XA;
q.updateListener = uf;
q.editable = Gh;
q.mouseSelectionStyle = HA;
q.dragMovesSelection = VA;
q.clickAddsSelectionRange = GA;
q.decorations = ya;
q.atomicRanges = oO;
q.scrollMargins = ZA;
q.darkTheme = Ef;
q.contentAttributes = rO;
q.editorAttributes = zA;
q.lineWrapping = /* @__PURE__ */ q.contentAttributes.of({ class: "cm-lineWrapping" });
q.announce = /* @__PURE__ */ fe.define();
const _D = 4096, tg = {};
class $u {
  constructor(e, t, r, o) {
    this.from = e, this.to = t, this.dir = r, this.order = o;
  }
  static update(e, t) {
    if (t.empty)
      return e;
    let r = [], o = e.length ? e[e.length - 1].dir : He.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let n = e[s];
      n.dir == o && !t.touchesRange(n.from, n.to) && r.push(new $u(t.mapPos(n.from, 1), t.mapPos(n.to, -1), n.dir, n.order));
    }
    return r;
  }
}
function ig(i, e, t) {
  for (let r = i.state.facet(e), o = r.length - 1; o >= 0; o--) {
    let s = r[o], n = typeof s == "function" ? s(i) : s;
    n && nf(n, t);
  }
  return t;
}
const PD = J.mac ? "mac" : J.windows ? "win" : J.linux ? "linux" : "key";
function LD(i, e) {
  const t = i.split(/-(?!$)/);
  let r = t[t.length - 1];
  r == "Space" && (r = " ");
  let o, s, n, a;
  for (let l = 0; l < t.length - 1; ++l) {
    const u = t[l];
    if (/^(cmd|meta|m)$/i.test(u))
      a = !0;
    else if (/^a(lt)?$/i.test(u))
      o = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      s = !0;
    else if (/^s(hift)?$/i.test(u))
      n = !0;
    else if (/^mod$/i.test(u))
      e == "mac" ? a = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return o && (r = "Alt-" + r), s && (r = "Ctrl-" + r), a && (r = "Meta-" + r), n && (r = "Shift-" + r), r;
}
function Ll(i, e, t) {
  return e.altKey && (i = "Alt-" + i), e.ctrlKey && (i = "Ctrl-" + i), e.metaKey && (i = "Meta-" + i), t !== !1 && e.shiftKey && (i = "Shift-" + i), i;
}
const wD = /* @__PURE__ */ ds.default(/* @__PURE__ */ q.domEventHandlers({
  keydown(i, e) {
    return bC(gC(e.state), i, e, "editor");
  }
})), Ka = /* @__PURE__ */ K.define({ enables: wD }), rg = /* @__PURE__ */ new WeakMap();
function gC(i) {
  let e = i.facet(Ka), t = rg.get(e);
  return t || rg.set(e, t = xD(e.reduce((r, o) => r.concat(o), []))), t;
}
function yD(i, e, t) {
  return bC(gC(i.state), e, i, t);
}
let Zr = null;
const DD = 4e3;
function xD(i, e = PD) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), o = (n, a) => {
    let l = r[n];
    if (l == null)
      r[n] = a;
    else if (l != a)
      throw new Error("Key binding " + n + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (n, a, l, u) => {
    var h, c;
    let d = t[n] || (t[n] = /* @__PURE__ */ Object.create(null)), f = a.split(/ (?!$)/).map((m) => LD(m, e));
    for (let m = 1; m < f.length; m++) {
      let E = f.slice(0, m).join(" ");
      o(E, !0), d[E] || (d[E] = {
        preventDefault: !0,
        run: [(g) => {
          let A = Zr = { view: g, prefix: E, scope: n };
          return setTimeout(() => {
            Zr == A && (Zr = null);
          }, DD), !0;
        }]
      });
    }
    let p = f.join(" ");
    o(p, !1);
    let O = d[p] || (d[p] = { preventDefault: !1, run: ((c = (h = d._any) === null || h === void 0 ? void 0 : h.run) === null || c === void 0 ? void 0 : c.slice()) || [] });
    l && O.run.push(l), u && (O.preventDefault = !0);
  };
  for (let n of i) {
    let a = n.scope ? n.scope.split(" ") : ["editor"];
    if (n.any)
      for (let u of a) {
        let h = t[u] || (t[u] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, run: [] });
        for (let c in h)
          h[c].run.push(n.any);
      }
    let l = n[e] || n.key;
    if (l)
      for (let u of a)
        s(u, l, n.run, n.preventDefault), n.shift && s(u, "Shift-" + l, n.shift, n.preventDefault);
  }
  return t;
}
function bC(i, e, t, r) {
  let o = O1(e), s = mt(o, 0), n = mi(s) == o.length && o != " ", a = "", l = !1;
  Zr && Zr.view == t && Zr.scope == r && (a = Zr.prefix + " ", (l = sC.indexOf(e.keyCode) < 0) && (Zr = null));
  let u = /* @__PURE__ */ new Set(), h = (p) => {
    if (p) {
      for (let O of p.run)
        if (!u.has(O) && (u.add(O), O(t, e)))
          return !0;
      p.preventDefault && (l = !0);
    }
    return !1;
  }, c = i[r], d, f;
  if (c) {
    if (h(c[a + Ll(o, e, !n)]))
      return !0;
    if (n && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(J.windows && e.ctrlKey && e.altKey) && (d = go[e.keyCode]) && d != o) {
      if (h(c[a + Ll(d, e, !0)]))
        return !0;
      if (e.shiftKey && (f = La[e.keyCode]) != o && f != d && h(c[a + Ll(f, e, !1)]))
        return !0;
    } else if (n && e.shiftKey && h(c[a + Ll(o, e, !0)]))
      return !0;
    if (h(c._any))
      return !0;
  }
  return l;
}
class Ja {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, r, o, s) {
    this.className = e, this.left = t, this.top = r, this.width = o, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, r) {
    if (r.empty) {
      let o = e.coordsAtPos(r.head, r.assoc || 1);
      if (!o)
        return [];
      let s = TC(e);
      return [new Ja(t, o.left - s.left, o.top - s.top, null, o.bottom - o.top)];
    } else
      return MD(e, t, r);
  }
}
function TC(i) {
  let e = i.scrollDOM.getBoundingClientRect();
  return { left: (i.textDirection == He.LTR ? e.left : e.right - i.scrollDOM.clientWidth) - i.scrollDOM.scrollLeft, top: e.top - i.scrollDOM.scrollTop };
}
function og(i, e, t) {
  let r = D.cursor(e);
  return {
    from: Math.max(t.from, i.moveToLineBoundary(r, !1, !0).from),
    to: Math.min(t.to, i.moveToLineBoundary(r, !0, !0).from),
    type: Ye.Text
  };
}
function MD(i, e, t) {
  if (t.to <= i.viewport.from || t.from >= i.viewport.to)
    return [];
  let r = Math.max(t.from, i.viewport.from), o = Math.min(t.to, i.viewport.to), s = i.textDirection == He.LTR, n = i.contentDOM, a = n.getBoundingClientRect(), l = TC(i), u = n.querySelector(".cm-line"), h = u && window.getComputedStyle(u), c = a.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), d = a.right - (h ? parseInt(h.paddingRight) : 0), f = ff(i, r), p = ff(i, o), O = f.type == Ye.Text ? f : null, m = p.type == Ye.Text ? p : null;
  if (O && (i.lineWrapping || f.widgetLineBreaks) && (O = og(i, r, O)), m && (i.lineWrapping || p.widgetLineBreaks) && (m = og(i, o, m)), O && m && O.from == m.from)
    return g(A(t.from, t.to, O));
  {
    let R = O ? A(t.from, null, O) : S(f, !1), v = m ? A(null, t.to, m) : S(p, !0), I = [];
    return (O || f).to < (m || p).from - (O && m ? 1 : 0) || f.widgetLineBreaks > 1 && R.bottom + i.defaultLineHeight / 2 < v.top ? I.push(E(c, R.bottom, d, v.top)) : R.bottom < v.top && i.elementAtHeight((R.bottom + v.top) / 2).type == Ye.Text && (R.bottom = v.top = (R.bottom + v.top) / 2), g(R).concat(I).concat(g(v));
  }
  function E(R, v, I, C) {
    return new Ja(
      e,
      R - l.left,
      v - l.top - 0.01,
      I - R,
      C - v + 0.01
      /* Epsilon */
    );
  }
  function g({ top: R, bottom: v, horizontal: I }) {
    let C = [];
    for (let P = 0; P < I.length; P += 2)
      C.push(E(I[P], R, I[P + 1], v));
    return C;
  }
  function A(R, v, I) {
    let C = 1e9, P = -1e9, w = [];
    function x(G, ee, re, le, oe) {
      let Ee = i.coordsAtPos(G, G == I.to ? -2 : 2), ve = i.coordsAtPos(re, re == I.from ? 2 : -2);
      !Ee || !ve || (C = Math.min(Ee.top, ve.top, C), P = Math.max(Ee.bottom, ve.bottom, P), oe == He.LTR ? w.push(s && ee ? c : Ee.left, s && le ? d : ve.right) : w.push(!s && le ? c : ve.left, !s && ee ? d : Ee.right));
    }
    let _ = R ?? I.from, X = v ?? I.to;
    for (let G of i.visibleRanges)
      if (G.to > _ && G.from < X)
        for (let ee = Math.max(G.from, _), re = Math.min(G.to, X); ; ) {
          let le = i.state.doc.lineAt(ee);
          for (let oe of i.bidiSpans(le)) {
            let Ee = oe.from + le.from, ve = oe.to + le.from;
            if (Ee >= re)
              break;
            ve > ee && x(Math.max(Ee, ee), R == null && Ee <= _, Math.min(ve, re), v == null && ve >= X, oe.dir);
          }
          if (ee = le.to + 1, ee >= re)
            break;
        }
    return w.length == 0 && x(_, R == null, X, v == null, i.textDirection), { top: C, bottom: P, horizontal: w };
  }
  function S(R, v) {
    let I = a.top + (v ? R.top : R.bottom);
    return { top: I, bottom: I, horizontal: [] };
  }
}
function UD(i, e) {
  return i.constructor == e.constructor && i.eq(e);
}
class QD {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Kl) != e.state.facet(Kl) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && e.view.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, r = e.facet(Kl);
    for (; t < r.length && r[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, r) => !UD(t, this.drawn[r]))) {
      let t = this.dom.firstChild, r = 0;
      for (let o of e)
        o.update && t && o.constructor && this.drawn[r].constructor && o.update(t, this.drawn[r]) ? (t = t.nextSibling, r++) : this.dom.insertBefore(o.draw(), t);
      for (; t; ) {
        let o = t.nextSibling;
        t.remove(), t = o;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Kl = /* @__PURE__ */ K.define();
function SC(i) {
  return [
    lt.define((e) => new QD(e, i)),
    Kl.of(i)
  ];
}
const RC = !J.ios, Da = /* @__PURE__ */ K.define({
  combine(i) {
    return cr(i, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function kD(i = {}) {
  return [
    Da.of(i),
    $D,
    GD,
    VD,
    WA.of(!0)
  ];
}
function AC(i) {
  return i.startState.facet(Da) != i.state.facet(Da);
}
const $D = /* @__PURE__ */ SC({
  above: !0,
  markers(i) {
    let { state: e } = i, t = e.facet(Da), r = [];
    for (let o of e.selection.ranges) {
      let s = o == e.selection.main;
      if (o.empty ? !s || RC : t.drawRangeCursor) {
        let n = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = o.empty ? o : D.cursor(o.head, o.head > o.anchor ? -1 : 1);
        for (let l of Ja.forRange(i, n, a))
          r.push(l);
      }
    }
    return r;
  },
  update(i, e) {
    i.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = AC(i);
    return t && sg(i.state, e), i.docChanged || i.selectionSet || t;
  },
  mount(i, e) {
    sg(e.state, i);
  },
  class: "cm-cursorLayer"
});
function sg(i, e) {
  e.style.animationDuration = i.facet(Da).cursorBlinkRate + "ms";
}
const GD = /* @__PURE__ */ SC({
  above: !1,
  markers(i) {
    return i.state.selection.ranges.map((e) => e.empty ? [] : Ja.forRange(i, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(i, e) {
    return i.docChanged || i.selectionSet || i.viewportChanged || AC(i);
  },
  class: "cm-selectionLayer"
}), CC = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
RC && (CC[".cm-line"].caretColor = "transparent !important");
const VD = /* @__PURE__ */ ds.highest(/* @__PURE__ */ q.theme(CC)), NC = /* @__PURE__ */ fe.define({
  map(i, e) {
    return i == null ? null : e.mapPos(i);
  }
}), Wn = /* @__PURE__ */ ct.define({
  create() {
    return null;
  },
  update(i, e) {
    return i != null && (i = e.changes.mapPos(i)), e.effects.reduce((t, r) => r.is(NC) ? r.value : t, i);
  }
}), HD = /* @__PURE__ */ lt.fromClass(class {
  constructor(i) {
    this.view = i, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(i) {
    var e;
    let t = i.state.field(Wn);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (i.startState.field(Wn) != t || i.docChanged || i.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let i = this.view.state.field(Wn), e = i != null && this.view.coordsAtPos(i);
    if (!e)
      return null;
    let t = this.view.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - t.left + this.view.scrollDOM.scrollLeft,
      top: e.top - t.top + this.view.scrollDOM.scrollTop,
      height: e.bottom - e.top
    };
  }
  drawCursor(i) {
    this.cursor && (i ? (this.cursor.style.left = i.left + "px", this.cursor.style.top = i.top + "px", this.cursor.style.height = i.height + "px") : this.cursor.style.left = "-100000px");
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(i) {
    this.view.state.field(Wn) != i && this.view.dispatch({ effects: NC.of(i) });
  }
}, {
  eventHandlers: {
    dragover(i) {
      this.setDropPos(this.view.posAtCoords({ x: i.clientX, y: i.clientY }));
    },
    dragleave(i) {
      (i.target == this.view.contentDOM || !this.view.contentDOM.contains(i.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function XD() {
  return [Wn, HD];
}
function ng(i, e, t, r, o) {
  e.lastIndex = 0;
  for (let s = i.iterRange(t, r), n = t, a; !s.next().done; n += s.value.length)
    if (!s.lineBreak)
      for (; a = e.exec(s.value); )
        o(n + a.index, a);
}
function YD(i, e) {
  let t = i.visibleRanges;
  if (t.length == 1 && t[0].from == i.viewport.from && t[0].to == i.viewport.to)
    return t;
  let r = [];
  for (let { from: o, to: s } of t)
    o = Math.max(i.state.doc.lineAt(o).from, o - e), s = Math.min(i.state.doc.lineAt(s).to, s + e), r.length && r[r.length - 1].to >= o ? r[r.length - 1].to = s : r.push({ from: o, to: s });
  return r;
}
class BD {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: r, decorate: o, boundary: s, maxLength: n = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, o)
      this.addMatch = (a, l, u, h) => o(h, u, u + a[0].length, a, l);
    else if (typeof r == "function")
      this.addMatch = (a, l, u, h) => {
        let c = r(a, l, u);
        c && h(u, u + a[0].length, c);
      };
    else if (r)
      this.addMatch = (a, l, u, h) => h(u, u + a[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = n;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new Eo(), r = t.add.bind(t);
    for (let { from: o, to: s } of YD(e, this.maxLength))
      ng(e.state.doc, this.regexp, o, s, (n, a) => this.addMatch(a, e, n, r));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let r = 1e9, o = -1;
    return e.docChanged && e.changes.iterChanges((s, n, a, l) => {
      l > e.view.viewport.from && a < e.view.viewport.to && (r = Math.min(a, r), o = Math.max(l, o));
    }), e.viewportChanged || o - r > 1e3 ? this.createDeco(e.view) : o > -1 ? this.updateRange(e.view, t.map(e.changes), r, o) : t;
  }
  updateRange(e, t, r, o) {
    for (let s of e.visibleRanges) {
      let n = Math.max(s.from, r), a = Math.min(s.to, o);
      if (a > n) {
        let l = e.state.doc.lineAt(n), u = l.to < a ? e.state.doc.lineAt(a) : l, h = Math.max(s.from, l.from), c = Math.min(s.to, u.to);
        if (this.boundary) {
          for (; n > l.from; n--)
            if (this.boundary.test(l.text[n - 1 - l.from])) {
              h = n;
              break;
            }
          for (; a < u.to; a++)
            if (this.boundary.test(u.text[a - u.from])) {
              c = a;
              break;
            }
        }
        let d = [], f, p = (O, m, E) => d.push(E.range(O, m));
        if (l == u)
          for (this.regexp.lastIndex = h - l.from; (f = this.regexp.exec(l.text)) && f.index < c - l.from; )
            this.addMatch(f, e, f.index + l.from, p);
        else
          ng(e.state.doc, this.regexp, h, c, (O, m) => this.addMatch(m, e, O, p));
        t = t.update({ filterFrom: h, filterTo: c, filter: (O, m) => O < h || m > c, add: d });
      }
    }
    return t;
  }
}
const bf = /x/.unicode != null ? "gu" : "g", FD = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, bf), WD = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let yc = null;
function zD() {
  var i;
  if (yc == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    yc = ((i = e.tabSize) !== null && i !== void 0 ? i : e.MozTabSize) != null;
  }
  return yc || !1;
}
const Jl = /* @__PURE__ */ K.define({
  combine(i) {
    let e = cr(i, {
      render: null,
      specialChars: FD,
      addSpecialChars: null
    });
    return (e.replaceTabs = !zD()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, bf)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, bf)), e;
  }
});
function ZD(i = {}) {
  return [Jl.of(i), qD()];
}
let ag = null;
function qD() {
  return ag || (ag = lt.fromClass(class {
    constructor(i) {
      this.view = i, this.decorations = ie.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(i.state.facet(Jl)), this.decorations = this.decorator.createDeco(i);
    }
    makeDecorator(i) {
      return new BD({
        regexp: i.specialChars,
        decoration: (e, t, r) => {
          let { doc: o } = t.state, s = mt(e[0], 0);
          if (s == 9) {
            let n = o.lineAt(r), a = t.state.tabSize, l = qa(n.text, a, r - n.from);
            return ie.replace({ widget: new ex((a - l % a) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = ie.replace({ widget: new JD(i, s) }));
        },
        boundary: i.replaceTabs ? void 0 : /[^]/
      });
    }
    update(i) {
      let e = i.state.facet(Jl);
      i.startState.facet(Jl) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(i.view)) : this.decorations = this.decorator.updateDeco(i, this.decorations);
    }
  }, {
    decorations: (i) => i.decorations
  }));
}
const jD = "•";
function KD(i) {
  return i >= 32 ? jD : i == 10 ? "␤" : String.fromCharCode(9216 + i);
}
class JD extends Ur {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = KD(this.code), r = e.state.phrase("Control character") + " " + (WD[this.code] || "0x" + this.code.toString(16)), o = this.options.render && this.options.render(this.code, r, t);
    if (o)
      return o;
    let s = document.createElement("span");
    return s.textContent = t, s.title = r, s.setAttribute("aria-label", r), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class ex extends Ur {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function tx() {
  return rx;
}
const ix = /* @__PURE__ */ ie.line({ class: "cm-activeLine" }), rx = /* @__PURE__ */ lt.fromClass(class {
  constructor(i) {
    this.decorations = this.getDeco(i);
  }
  update(i) {
    (i.docChanged || i.selectionSet) && (this.decorations = this.getDeco(i.view));
  }
  getDeco(i) {
    let e = -1, t = [];
    for (let r of i.state.selection.ranges) {
      let o = i.lineBlockAt(r.head);
      o.from > e && (t.push(ix.range(o.from)), e = o.from);
    }
    return ie.set(t);
  }
}, {
  decorations: (i) => i.decorations
}), Tf = 2e3;
function ox(i, e, t) {
  let r = Math.min(e.line, t.line), o = Math.max(e.line, t.line), s = [];
  if (e.off > Tf || t.off > Tf || e.col < 0 || t.col < 0) {
    let n = Math.min(e.off, t.off), a = Math.max(e.off, t.off);
    for (let l = r; l <= o; l++) {
      let u = i.doc.line(l);
      u.length <= a && s.push(D.range(u.from + n, u.to + a));
    }
  } else {
    let n = Math.min(e.col, t.col), a = Math.max(e.col, t.col);
    for (let l = r; l <= o; l++) {
      let u = i.doc.line(l), h = jd(u.text, n, i.tabSize, !0);
      if (h < 0)
        s.push(D.cursor(u.to));
      else {
        let c = jd(u.text, a, i.tabSize);
        s.push(D.range(u.from + h, u.from + c));
      }
    }
  }
  return s;
}
function sx(i, e) {
  let t = i.coordsAtPos(i.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / i.defaultCharacterWidth)) : -1;
}
function lg(i, e) {
  let t = i.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = i.state.doc.lineAt(t), o = t - r.from, s = o > Tf ? -1 : o == r.length ? sx(i, e.clientX) : qa(r.text, i.state.tabSize, t - r.from);
  return { line: r.number, col: s, off: o };
}
function nx(i, e) {
  let t = lg(i, e), r = i.state.selection;
  return t ? {
    update(o) {
      if (o.docChanged) {
        let s = o.changes.mapPos(o.startState.doc.line(t.line).from), n = o.state.doc.lineAt(s);
        t = { line: n.number, col: t.col, off: Math.min(t.off, n.length) }, r = r.map(o.changes);
      }
    },
    get(o, s, n) {
      let a = lg(i, o);
      if (!a)
        return r;
      let l = ox(i.state, t, a);
      return l.length ? n ? D.create(l.concat(r.ranges)) : D.create(l) : r;
    }
  } : null;
}
function ax(i) {
  let e = (i == null ? void 0 : i.eventFilter) || ((t) => t.altKey && t.button == 0);
  return q.mouseSelectionStyle.of((t, r) => e(r) ? nx(t, r) : null);
}
const lx = {
  Alt: [18, (i) => !!i.altKey],
  Control: [17, (i) => !!i.ctrlKey],
  Shift: [16, (i) => !!i.shiftKey],
  Meta: [91, (i) => !!i.metaKey]
}, ux = { style: "cursor: crosshair" };
function hx(i = {}) {
  let [e, t] = lx[i.key || "Alt"], r = lt.fromClass(class {
    constructor(o) {
      this.view = o, this.isDown = !1;
    }
    set(o) {
      this.isDown != o && (this.isDown = o, this.view.update([]));
    }
  }, {
    eventHandlers: {
      keydown(o) {
        this.set(o.keyCode == e || t(o));
      },
      keyup(o) {
        (o.keyCode == e || !t(o)) && this.set(!1);
      },
      mousemove(o) {
        this.set(t(o));
      }
    }
  });
  return [
    r,
    q.contentAttributes.of((o) => {
      var s;
      return !((s = o.plugin(r)) === null || s === void 0) && s.isDown ? ux : null;
    })
  ];
}
const wl = "-10000px";
class IC {
  constructor(e, t, r) {
    this.facet = t, this.createTooltipView = r, this.input = e.state.facet(t), this.tooltips = this.input.filter((o) => o), this.tooltipViews = this.tooltips.map(r);
  }
  update(e) {
    var t;
    let r = e.state.facet(this.facet), o = r.filter((n) => n);
    if (r === this.input) {
      for (let n of this.tooltipViews)
        n.update && n.update(e);
      return !1;
    }
    let s = [];
    for (let n = 0; n < o.length; n++) {
      let a = o[n], l = -1;
      if (a) {
        for (let u = 0; u < this.tooltips.length; u++) {
          let h = this.tooltips[u];
          h && h.create == a.create && (l = u);
        }
        if (l < 0)
          s[n] = this.createTooltipView(a);
        else {
          let u = s[n] = this.tooltipViews[l];
          u.update && u.update(e);
        }
      }
    }
    for (let n of this.tooltipViews)
      s.indexOf(n) < 0 && (n.dom.remove(), (t = n.destroy) === null || t === void 0 || t.call(n));
    return this.input = r, this.tooltips = o, this.tooltipViews = s, !0;
  }
}
function cx(i) {
  let { win: e } = i;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const Dc = /* @__PURE__ */ K.define({
  combine: (i) => {
    var e, t, r;
    return {
      position: J.ios ? "absolute" : ((e = i.find((o) => o.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = i.find((o) => o.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((r = i.find((o) => o.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || cx
    };
  }
}), ug = /* @__PURE__ */ new WeakMap(), vC = /* @__PURE__ */ lt.fromClass(class {
  constructor(i) {
    this.view = i, this.inView = !0, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = i.state.facet(Dc);
    this.position = e.position, this.parent = e.parent, this.classes = i.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new IC(i, nO, (t) => this.createTooltip(t)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), i.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let i of this.manager.tooltipViews)
        this.intersectionObserver.observe(i.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(i) {
    i.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(i);
    e && this.observeIntersection();
    let t = e || i.geometryChanged, r = i.state.facet(Dc);
    if (r.position != this.position) {
      this.position = r.position;
      for (let o of this.manager.tooltipViews)
        o.dom.style.position = this.position;
      t = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let o of this.manager.tooltipViews)
        this.container.appendChild(o.dom);
      t = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(i) {
    let e = i.create(this.view);
    if (e.dom.classList.add("cm-tooltip"), i.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let t = document.createElement("div");
      t.className = "cm-tooltip-arrow", e.dom.appendChild(t);
    }
    return e.dom.style.position = this.position, e.dom.style.top = wl, this.container.appendChild(e.dom), e.mount && e.mount(this.view), e;
  }
  destroy() {
    var i, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let t of this.manager.tooltipViews)
      t.dom.remove(), (i = t.destroy) === null || i === void 0 || i.call(t);
    (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let i = this.view.dom.getBoundingClientRect();
    return {
      editor: i,
      parent: this.parent ? this.container.getBoundingClientRect() : i,
      pos: this.manager.tooltips.map((e, t) => {
        let r = this.manager.tooltipViews[t];
        return r.getCoords ? r.getCoords(e.pos) : this.view.coordsAtPos(e.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: e }) => e.getBoundingClientRect()),
      space: this.view.state.facet(Dc).tooltipSpace(this.view)
    };
  }
  writeMeasure(i) {
    var e;
    let { editor: t, space: r } = i, o = [];
    for (let s = 0; s < this.manager.tooltips.length; s++) {
      let n = this.manager.tooltips[s], a = this.manager.tooltipViews[s], { dom: l } = a, u = i.pos[s], h = i.size[s];
      if (!u || u.bottom <= Math.max(t.top, r.top) || u.top >= Math.min(t.bottom, r.bottom) || u.right < Math.max(t.left, r.left) - 0.1 || u.left > Math.min(t.right, r.right) + 0.1) {
        l.style.top = wl;
        continue;
      }
      let c = n.arrow ? a.dom.querySelector(".cm-tooltip-arrow") : null, d = c ? 7 : 0, f = h.right - h.left, p = (e = ug.get(a)) !== null && e !== void 0 ? e : h.bottom - h.top, O = a.offset || fx, m = this.view.textDirection == He.LTR, E = h.width > r.right - r.left ? m ? r.left : r.right - h.width : m ? Math.min(u.left - (c ? 14 : 0) + O.x, r.right - f) : Math.max(r.left, u.left - f + (c ? 14 : 0) - O.x), g = !!n.above;
      !n.strictSide && (g ? u.top - (h.bottom - h.top) - O.y < r.top : u.bottom + (h.bottom - h.top) + O.y > r.bottom) && g == r.bottom - u.bottom > u.top - r.top && (g = !g);
      let A = (g ? u.top - r.top : r.bottom - u.bottom) - d;
      if (A < p && a.resize !== !1) {
        if (A < this.view.defaultLineHeight) {
          l.style.top = wl;
          continue;
        }
        ug.set(a, p), l.style.height = (p = A) + "px";
      } else
        l.style.height && (l.style.height = "");
      let S = g ? u.top - p - d - O.y : u.bottom + d + O.y, R = E + f;
      if (a.overlap !== !0)
        for (let v of o)
          v.left < R && v.right > E && v.top < S + p && v.bottom > S && (S = g ? v.top - p - 2 - d : v.bottom + d + 2);
      this.position == "absolute" ? (l.style.top = S - i.parent.top + "px", l.style.left = E - i.parent.left + "px") : (l.style.top = S + "px", l.style.left = E + "px"), c && (c.style.left = `${u.left + (m ? O.x : -O.x) - (E + 14 - 7)}px`), a.overlap !== !0 && o.push({ left: E, top: S, right: R, bottom: S + p }), l.classList.toggle("cm-tooltip-above", g), l.classList.toggle("cm-tooltip-below", !g), a.positioned && a.positioned(i.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let i of this.manager.tooltipViews)
        i.dom.style.top = wl;
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), dx = /* @__PURE__ */ q.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), fx = { x: 0, y: 0 }, nO = /* @__PURE__ */ K.define({
  enables: [vC, dx]
}), Gu = /* @__PURE__ */ K.define();
class aO {
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new IC(e, Gu, (t) => this.createHostedView(t));
  }
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new aO(e);
  }
  createHostedView(e) {
    let t = e.create(this.view);
    return t.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(t.dom), this.mounted && t.mount && t.mount(this.view), t;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
}
const px = /* @__PURE__ */ nO.compute([Gu], (i) => {
  let e = i.facet(Gu).filter((t) => t);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.filter((t) => t.end != null).map((t) => t.end)),
    create: aO.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class Ox {
  constructor(e, t, r, o, s) {
    this.view = e, this.source = t, this.field = r, this.setHover = o, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { lastMove: e } = this, t = this.view.contentDOM.contains(e.target) ? this.view.posAtCoords(e) : null;
    if (t == null)
      return;
    let r = this.view.coordsAtPos(t);
    if (r == null || e.y < r.top || e.y > r.bottom || e.x < r.left - this.view.defaultCharacterWidth || e.x > r.right + this.view.defaultCharacterWidth)
      return;
    let o = this.view.bidiSpans(this.view.state.doc.lineAt(t)).find((a) => a.from <= t && a.to >= t), s = o && o.dir == He.RTL ? -1 : 1, n = this.source(this.view, t, e.x < r.left ? -s : s);
    if (n != null && n.then) {
      let a = this.pending = { pos: t };
      n.then((l) => {
        this.pending == a && (this.pending = null, l && this.view.dispatch({ effects: this.setHover.of(l) }));
      }, (l) => Ri(this.view.state, l, "hover tooltip"));
    } else
      n && this.view.dispatch({ effects: this.setHover.of(n) });
  }
  mousemove(e) {
    var t;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let r = this.active;
    if (r && !hg(this.lastMove.target) || this.pending) {
      let { pos: o } = r || this.pending, s = (t = r == null ? void 0 : r.end) !== null && t !== void 0 ? t : o;
      (o == s ? this.view.posAtCoords(this.lastMove) != o : !Ex(
        this.view,
        o,
        s,
        e.clientX,
        e.clientY,
        6
        /* MaxDist */
      )) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1, this.active && !hg(e.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
function hg(i) {
  for (let e = i; e; e = e.parentNode)
    if (e.nodeType == 1 && e.classList.contains("cm-tooltip"))
      return !0;
  return !1;
}
function Ex(i, e, t, r, o, s) {
  let n = document.createRange(), a = i.domAtPos(e), l = i.domAtPos(t);
  n.setEnd(l.node, l.offset), n.setStart(a.node, a.offset);
  let u = n.getClientRects();
  n.detach();
  for (let h = 0; h < u.length; h++) {
    let c = u[h];
    if (Math.max(c.top - o, o - c.bottom, c.left - r, r - c.right) <= s)
      return !0;
  }
  return !1;
}
function mx(i, e = {}) {
  let t = fe.define(), r = ct.define({
    create() {
      return null;
    },
    update(o, s) {
      if (o && (e.hideOnChange && (s.docChanged || s.selection) || e.hideOn && e.hideOn(s, o)))
        return null;
      if (o && s.docChanged) {
        let n = s.changes.mapPos(o.pos, -1, bt.TrackDel);
        if (n == null)
          return null;
        let a = Object.assign(/* @__PURE__ */ Object.create(null), o);
        a.pos = n, o.end != null && (a.end = s.changes.mapPos(o.end)), o = a;
      }
      for (let n of s.effects)
        n.is(t) && (o = n.value), n.is(gx) && (o = null);
      return o;
    },
    provide: (o) => Gu.from(o)
  });
  return [
    r,
    lt.define((o) => new Ox(
      o,
      i,
      r,
      t,
      e.hoverTime || 300
      /* Time */
    )),
    px
  ];
}
function _C(i, e) {
  let t = i.plugin(vC);
  if (!t)
    return null;
  let r = t.manager.tooltips.indexOf(e);
  return r < 0 ? null : t.manager.tooltipViews[r];
}
const gx = /* @__PURE__ */ fe.define(), cg = /* @__PURE__ */ K.define({
  combine(i) {
    let e, t;
    for (let r of i)
      e = e || r.topContainer, t = t || r.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function xa(i, e) {
  let t = i.plugin(PC), r = t ? t.specs.indexOf(e) : -1;
  return r > -1 ? t.panels[r] : null;
}
const PC = /* @__PURE__ */ lt.fromClass(class {
  constructor(i) {
    this.input = i.state.facet(Ma), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(i));
    let e = i.state.facet(cg);
    this.top = new yl(i, !0, e.topContainer), this.bottom = new yl(i, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(i) {
    let e = i.state.facet(cg);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new yl(i.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new yl(i.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = i.state.facet(Ma);
    if (t != this.input) {
      let r = t.filter((l) => l), o = [], s = [], n = [], a = [];
      for (let l of r) {
        let u = this.specs.indexOf(l), h;
        u < 0 ? (h = l(i.view), a.push(h)) : (h = this.panels[u], h.update && h.update(i)), o.push(h), (h.top ? s : n).push(h);
      }
      this.specs = r, this.panels = o, this.top.sync(s), this.bottom.sync(n);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(i);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (i) => q.scrollMargins.of((e) => {
    let t = e.plugin(i);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class yl {
  constructor(e, t, r) {
    this.view = e, this.top = t, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = dg(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = dg(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function dg(i) {
  let e = i.nextSibling;
  return i.remove(), e;
}
const Ma = /* @__PURE__ */ K.define({
  enables: PC
});
class vr extends es {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
vr.prototype.elementClass = "";
vr.prototype.toDOM = void 0;
vr.prototype.mapMode = bt.TrackBefore;
vr.prototype.startSide = vr.prototype.endSide = -1;
vr.prototype.point = !0;
const eu = /* @__PURE__ */ K.define(), bx = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Le.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, ua = /* @__PURE__ */ K.define();
function Tx(i) {
  return [LC(), ua.of(Object.assign(Object.assign({}, bx), i))];
}
const Sf = /* @__PURE__ */ K.define({
  combine: (i) => i.some((e) => e)
});
function LC(i) {
  let e = [
    Sx
  ];
  return i && i.fixed === !1 && e.push(Sf.of(!0)), e;
}
const Sx = /* @__PURE__ */ lt.fromClass(class {
  constructor(i) {
    this.view = i, this.prevViewport = i.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight + "px", this.gutters = i.state.facet(ua).map((e) => new pg(i, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !i.state.facet(Sf), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), i.scrollDOM.insertBefore(this.dom, i.contentDOM);
  }
  update(i) {
    if (this.updateGutters(i)) {
      let e = this.prevViewport, t = i.view.viewport, r = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(r < (t.to - t.from) * 0.8);
    }
    i.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(Sf) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = i.view.viewport;
  }
  syncGutters(i) {
    let e = this.dom.nextSibling;
    i && this.dom.remove();
    let t = Le.iter(this.view.state.facet(eu), this.view.viewport.from), r = [], o = this.gutters.map((s) => new Rx(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(s.type)) {
        let n = !0;
        for (let a of s.type)
          if (a.type == Ye.Text && n) {
            Rf(t, r, a.from);
            for (let l of o)
              l.line(this.view, a, r);
            n = !1;
          } else if (a.widget)
            for (let l of o)
              l.widget(this.view, a);
      } else if (s.type == Ye.Text) {
        Rf(t, r, s.from);
        for (let n of o)
          n.line(this.view, s, r);
      }
    for (let s of o)
      s.finish();
    i && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(i) {
    let e = i.startState.facet(ua), t = i.state.facet(ua), r = i.docChanged || i.heightChanged || i.viewportChanged || !Le.eq(i.startState.facet(eu), i.state.facet(eu), i.view.viewport.from, i.view.viewport.to);
    if (e == t)
      for (let o of this.gutters)
        o.update(i) && (r = !0);
    else {
      r = !0;
      let o = [];
      for (let s of t) {
        let n = e.indexOf(s);
        n < 0 ? o.push(new pg(this.view, s)) : (this.gutters[n].update(i), o.push(this.gutters[n]));
      }
      for (let s of this.gutters)
        s.dom.remove(), o.indexOf(s) < 0 && s.destroy();
      for (let s of o)
        this.dom.appendChild(s.dom);
      this.gutters = o;
    }
    return r;
  }
  destroy() {
    for (let i of this.gutters)
      i.destroy();
    this.dom.remove();
  }
}, {
  provide: (i) => q.scrollMargins.of((e) => {
    let t = e.plugin(i);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == He.LTR ? { left: t.dom.offsetWidth } : { right: t.dom.offsetWidth };
  })
});
function fg(i) {
  return Array.isArray(i) ? i : [i];
}
function Rf(i, e, t) {
  for (; i.value && i.from <= t; )
    i.from == t && e.push(i.value), i.next();
}
class Rx {
  constructor(e, t, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = Le.iter(e.markers, t.from);
  }
  addElement(e, t, r) {
    let { gutter: o } = this, s = t.top - this.height;
    if (this.i == o.elements.length) {
      let n = new wC(e, t.height, s, r);
      o.elements.push(n), o.dom.appendChild(n.dom);
    } else
      o.elements[this.i].update(e, t.height, s, r);
    this.height = t.bottom, this.i++;
  }
  line(e, t, r) {
    let o = [];
    Rf(this.cursor, o, t.from), r.length && (o = o.concat(r));
    let s = this.gutter.config.lineMarker(e, t, o);
    s && o.unshift(s);
    let n = this.gutter;
    o.length == 0 && !n.config.renderEmptyElements || this.addElement(e, t, o);
  }
  widget(e, t) {
    let r = this.gutter.config.widgetMarker(e, t.widget, t);
    r && this.addElement(e, t, [r]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class pg {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in t.domEventHandlers)
      this.dom.addEventListener(r, (o) => {
        let s = o.target, n;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let l = s.getBoundingClientRect();
          n = (l.top + l.bottom) / 2;
        } else
          n = o.clientY;
        let a = e.lineBlockAtHeight(n - e.documentTop);
        t.domEventHandlers[r](e, a, o) && o.preventDefault();
      });
    this.markers = fg(t.markers(e)), t.initialSpacer && (this.spacer = new wC(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = fg(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let o = this.config.updateSpacer(this.spacer.markers[0], e);
      o != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [o]);
    }
    let r = e.view.viewport;
    return !Le.eq(this.markers, t, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class wC {
  constructor(e, t, r, o) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, r, o);
  }
  update(e, t, r, o) {
    this.height != t && (this.dom.style.height = (this.height = t) + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), Ax(this.markers, o) || this.setMarkers(e, o);
  }
  setMarkers(e, t) {
    let r = "cm-gutterElement", o = this.dom.firstChild;
    for (let s = 0, n = 0; ; ) {
      let a = n, l = s < t.length ? t[s++] : null, u = !1;
      if (l) {
        let h = l.elementClass;
        h && (r += " " + h);
        for (let c = n; c < this.markers.length; c++)
          if (this.markers[c].compare(l)) {
            a = c, u = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; n < a; ) {
        let h = this.markers[n++];
        if (h.toDOM) {
          h.destroy(o);
          let c = o.nextSibling;
          o.remove(), o = c;
        }
      }
      if (!l)
        break;
      l.toDOM && (u ? o = o.nextSibling : this.dom.insertBefore(l.toDOM(e), o)), u && n++;
    }
    this.dom.className = r, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function Ax(i, e) {
  if (i.length != e.length)
    return !1;
  for (let t = 0; t < i.length; t++)
    if (!i[t].compare(e[t]))
      return !1;
  return !0;
}
const Cx = /* @__PURE__ */ K.define(), Ds = /* @__PURE__ */ K.define({
  combine(i) {
    return cr(i, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let r = Object.assign({}, e);
        for (let o in t) {
          let s = r[o], n = t[o];
          r[o] = s ? (a, l, u) => s(a, l, u) || n(a, l, u) : n;
        }
        return r;
      }
    });
  }
});
class xc extends vr {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Mc(i, e) {
  return i.state.facet(Ds).formatNumber(e, i.state);
}
const Nx = /* @__PURE__ */ ua.compute([Ds], (i) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(Cx);
  },
  lineMarker(e, t, r) {
    return r.some((o) => o.toDOM) ? null : new xc(Mc(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(Ds) != e.state.facet(Ds),
  initialSpacer(e) {
    return new xc(Mc(e, Og(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let r = Mc(t.view, Og(t.view.state.doc.lines));
    return r == e.number ? e : new xc(r);
  },
  domEventHandlers: i.facet(Ds).domEventHandlers
}));
function Ix(i = {}) {
  return [
    Ds.of(i),
    LC(),
    Nx
  ];
}
function Og(i) {
  let e = 9;
  for (; e < i; )
    e = e * 10 + 9;
  return e;
}
const vx = /* @__PURE__ */ new class extends vr {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), _x = /* @__PURE__ */ eu.compute(["selection"], (i) => {
  let e = [], t = -1;
  for (let r of i.selection.ranges) {
    let o = i.doc.lineAt(r.head).from;
    o > t && (t = o, e.push(vx.range(o)));
  }
  return Le.of(e);
});
function Px() {
  return _x;
}
const yC = 1024;
let Lx = 0;
class Ti {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class Oe {
  /// Create a new node prop type.
  constructor(e = {}) {
    this.id = Lx++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /// This is meant to be used with
  /// [`NodeSet.extend`](#common.NodeSet.extend) or
  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
  /// prop values for each node type in the set. Takes a [match
  /// object](#common.NodeType^match) or function that returns undefined
  /// if the node type doesn't get this prop, and the prop's value if
  /// it does.
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = di.match(e)), (t) => {
      let r = e(t);
      return r === void 0 ? null : [this, r];
    };
  }
}
Oe.closedBy = new Oe({ deserialize: (i) => i.split(" ") });
Oe.openedBy = new Oe({ deserialize: (i) => i.split(" ") });
Oe.group = new Oe({ deserialize: (i) => i.split(" ") });
Oe.contextHash = new Oe({ perNode: !0 });
Oe.lookAhead = new Oe({ perNode: !0 });
Oe.mounted = new Oe({ perNode: !0 });
class wx {
  constructor(e, t, r) {
    this.tree = e, this.overlay = t, this.parser = r;
  }
}
const yx = /* @__PURE__ */ Object.create(null);
let di = class DC {
  /// @internal
  constructor(e, t, r, o = 0) {
    this.name = e, this.props = t, this.id = r, this.flags = o;
  }
  /// Define a node type.
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : yx, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), o = new DC(e.name || "", t, e.id, r);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(o)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[s[0].id] = s[1];
        }
    }
    return o;
  }
  /// Retrieves a node prop for this type. Will return `undefined` if
  /// the prop isn't present on this node.
  prop(e) {
    return this.props[e.id];
  }
  /// True when this is the top node of a grammar.
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /// True when this node is produced by a skip rule.
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /// Indicates whether this is an error node.
  get isError() {
    return (this.flags & 4) > 0;
  }
  /// When true, this node type doesn't correspond to a user-declared
  /// named node, for example because it is used to cache repetition.
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /// Returns true when this node's name or one of its
  /// [groups](#common.NodeProp^group) matches the given string.
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(Oe.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /// Create a function from node types to arbitrary values by
  /// specifying an object whose property names are node or
  /// [group](#common.NodeProp^group) names. Often useful with
  /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  /// names, separated by spaces, in a single property name to map
  /// multiple node names to a single value.
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let o of r.split(" "))
        t[o] = e[r];
    return (r) => {
      for (let o = r.prop(Oe.group), s = -1; s < (o ? o.length : 0); s++) {
        let n = t[s < 0 ? r.name : o[s]];
        if (n)
          return n;
      }
    };
  }
};
di.none = new di(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class lO {
  /// Create a set with the given types. The `id` property of each
  /// type should correspond to its position within the array.
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /// Create a copy of this set with some node properties added. The
  /// arguments to this method can be created with
  /// [`NodeProp.add`](#common.NodeProp.add).
  extend(...e) {
    let t = [];
    for (let r of this.types) {
      let o = null;
      for (let s of e) {
        let n = s(r);
        n && (o || (o = Object.assign({}, r.props)), o[n[0].id] = n[1]);
      }
      t.push(o ? new di(r.name, o, r.id, r.flags) : r);
    }
    return new lO(t);
  }
}
const Dl = /* @__PURE__ */ new WeakMap(), Eg = /* @__PURE__ */ new WeakMap();
var Qe;
(function(i) {
  i[i.ExcludeBuffers = 1] = "ExcludeBuffers", i[i.IncludeAnonymous = 2] = "IncludeAnonymous", i[i.IgnoreMounts = 4] = "IgnoreMounts", i[i.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Qe || (Qe = {}));
class Xe {
  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  constructor(e, t, r, o, s) {
    if (this.type = e, this.children = t, this.positions = r, this.length = o, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [n, a] of s)
        this.props[typeof n == "number" ? n : n.id] = a;
    }
  }
  /// @internal
  toString() {
    let e = this.prop(Oe.mounted);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let r of this.children) {
      let o = r.toString();
      o && (t && (t += ","), t += o);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /// Get a [tree cursor](#common.TreeCursor) positioned at the top of
  /// the tree. Mode can be used to [control](#common.IterMode) which
  /// nodes the cursor visits.
  cursor(e = 0) {
    return new Ua(this.topNode, e);
  }
  /// Get a [tree cursor](#common.TreeCursor) pointing into this tree
  /// at the given position and side (see
  /// [`moveTo`](#common.TreeCursor.moveTo).
  cursorAt(e, t = 0, r = 0) {
    let o = Dl.get(this) || this.topNode, s = new Ua(o);
    return s.moveTo(e, t), Dl.set(this, s._tree), s;
  }
  /// Get a [syntax node](#common.SyntaxNode) object for the top of the
  /// tree.
  get topNode() {
    return new Ai(this, 0, 0, null);
  }
  /// Get the [syntax node](#common.SyntaxNode) at the given position.
  /// If `side` is -1, this will move into nodes that end at the
  /// position. If 1, it'll move into nodes that start at the
  /// position. With 0, it'll only enter nodes that cover the position
  /// from both sides.
  ///
  /// Note that this will not enter
  /// [overlays](#common.MountedTree.overlay), and you often want
  /// [`resolveInner`](#common.Tree.resolveInner) instead.
  resolve(e, t = 0) {
    let r = ln(Dl.get(this) || this.topNode, e, t, !1);
    return Dl.set(this, r), r;
  }
  /// Like [`resolve`](#common.Tree.resolve), but will enter
  /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  /// pointing into the innermost overlaid tree at the given position
  /// (with parent links going through all parent structure, including
  /// the host trees).
  resolveInner(e, t = 0) {
    let r = ln(Eg.get(this) || this.topNode, e, t, !0);
    return Eg.set(this, r), r;
  }
  /// Iterate over the tree and its children, calling `enter` for any
  /// node that touches the `from`/`to` region (if given) before
  /// running over such a node's children, and `leave` (if given) when
  /// leaving the node. When `enter` returns `false`, that node will
  /// not have its children iterated over (or `leave` called).
  iterate(e) {
    let { enter: t, leave: r, from: o = 0, to: s = this.length } = e, n = e.mode || 0, a = (n & Qe.IncludeAnonymous) > 0;
    for (let l = this.cursor(n | Qe.IncludeAnonymous); ; ) {
      let u = !1;
      if (l.from <= s && l.to >= o && (!a && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        u = !0;
      }
      for (; u && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        u = !0;
      }
    }
  }
  /// Get the value of the given [node prop](#common.NodeProp) for this
  /// node. Works with both per-node and per-type props.
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
  /// format that can be passed to the [`Tree`](#common.Tree)
  /// constructor.
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /// Balance the direct children of this tree, producing a copy of
  /// which may have children grouped into subtrees with type
  /// [`NodeType.none`](#common.NodeType^none).
  balance(e = {}) {
    return this.children.length <= 8 ? this : cO(di.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, r, o) => new Xe(this.type, t, r, o, this.propValues), e.makeTree || ((t, r, o) => new Xe(di.none, t, r, o)));
  }
  /// Build a tree from a postfix-ordered buffer of node information,
  /// or a cursor over such a buffer.
  static build(e) {
    return xx(e);
  }
}
Xe.empty = new Xe(di.none, [], [], 0);
class uO {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new uO(this.buffer, this.index);
  }
}
class fs {
  /// Create a tree buffer.
  constructor(e, t, r) {
    this.buffer = e, this.length = t, this.set = r;
  }
  /// @internal
  get type() {
    return di.none;
  }
  /// @internal
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /// @internal
  childString(e) {
    let t = this.buffer[e], r = this.buffer[e + 3], o = this.set.types[t], s = o.name;
    if (/\W/.test(s) && !o.isError && (s = JSON.stringify(s)), e += 4, r == e)
      return s;
    let n = [];
    for (; e < r; )
      n.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + n.join(",") + ")";
  }
  /// @internal
  findChild(e, t, r, o, s) {
    let { buffer: n } = this, a = -1;
    for (let l = e; l != t && !(xC(s, o, n[l + 1], n[l + 2]) && (a = l, r > 0)); l = n[l + 3])
      ;
    return a;
  }
  /// @internal
  slice(e, t, r) {
    let o = this.buffer, s = new Uint16Array(t - e), n = 0;
    for (let a = e, l = 0; a < t; ) {
      s[l++] = o[a++], s[l++] = o[a++] - r;
      let u = s[l++] = o[a++] - r;
      s[l++] = o[a++] - e, n = Math.max(n, u);
    }
    return new fs(s, n, this.set);
  }
}
function xC(i, e, t, r) {
  switch (i) {
    case -2:
      return t < e;
    case -1:
      return r >= e && t < e;
    case 0:
      return t < e && r > e;
    case 1:
      return t <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function MC(i, e) {
  let t = i.childBefore(e);
  for (; t; ) {
    let r = t.lastChild;
    if (!r || r.to != t.to)
      break;
    r.type.isError && r.from == r.to ? (i = t, t = r.prevSibling) : t = r;
  }
  return i;
}
function ln(i, e, t, r) {
  for (var o; i.from == i.to || (t < 1 ? i.from >= e : i.from > e) || (t > -1 ? i.to <= e : i.to < e); ) {
    let n = !r && i instanceof Ai && i.index < 0 ? null : i.parent;
    if (!n)
      return i;
    i = n;
  }
  let s = r ? 0 : Qe.IgnoreOverlays;
  if (r)
    for (let n = i, a = n.parent; a; n = a, a = n.parent)
      n instanceof Ai && n.index < 0 && ((o = a.enter(e, t, s)) === null || o === void 0 ? void 0 : o.from) != n.from && (i = a);
  for (; ; ) {
    let n = i.enter(e, t, s);
    if (!n)
      return i;
    i = n;
  }
}
class Ai {
  constructor(e, t, r, o) {
    this._tree = e, this.from = t, this.index = r, this._parent = o;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, r, o, s = 0) {
    for (let n = this; ; ) {
      for (let { children: a, positions: l } = n._tree, u = t > 0 ? a.length : -1; e != u; e += t) {
        let h = a[e], c = l[e] + n.from;
        if (xC(o, r, c, c + h.length)) {
          if (h instanceof fs) {
            if (s & Qe.ExcludeBuffers)
              continue;
            let d = h.findChild(0, h.buffer.length, t, r - c, o);
            if (d > -1)
              return new er(new Dx(n, h, e, c), null, d);
          } else if (s & Qe.IncludeAnonymous || !h.type.isAnonymous || hO(h)) {
            let d;
            if (!(s & Qe.IgnoreMounts) && h.props && (d = h.prop(Oe.mounted)) && !d.overlay)
              return new Ai(d.tree, c, e, n);
            let f = new Ai(h, c, e, n);
            return s & Qe.IncludeAnonymous || !f.type.isAnonymous ? f : f.nextChild(t < 0 ? h.children.length - 1 : 0, t, r, o);
          }
        }
      }
      if (s & Qe.IncludeAnonymous || !n.type.isAnonymous || (n.index >= 0 ? e = n.index + t : e = t < 0 ? -1 : n._parent._tree.children.length, n = n._parent, !n))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    let o;
    if (!(r & Qe.IgnoreOverlays) && (o = this._tree.prop(Oe.mounted)) && o.overlay) {
      let s = e - this.from;
      for (let { from: n, to: a } of o.overlay)
        if ((t > 0 ? n <= s : n < s) && (t < 0 ? a >= s : a > s))
          return new Ai(o.tree, o.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  cursor(e = 0) {
    return new Ua(this, e);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(e, t = 0) {
    return ln(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return ln(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return MC(this, e);
  }
  getChild(e, t = null, r = null) {
    let o = Vu(this, e, t, r);
    return o.length ? o[0] : null;
  }
  getChildren(e, t = null, r = null) {
    return Vu(this, e, t, r);
  }
  /// @internal
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return Hu(this, e);
  }
}
function Vu(i, e, t, r) {
  let o = i.cursor(), s = [];
  if (!o.firstChild())
    return s;
  if (t != null) {
    for (; !o.type.is(t); )
      if (!o.nextSibling())
        return s;
  }
  for (; ; ) {
    if (r != null && o.type.is(r))
      return s;
    if (o.type.is(e) && s.push(o.node), !o.nextSibling())
      return r == null ? s : [];
  }
}
function Hu(i, e, t = e.length - 1) {
  for (let r = i.parent; t >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[t] && e[t] != r.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class Dx {
  constructor(e, t, r, o) {
    this.parent = e, this.buffer = t, this.index = r, this.start = o;
  }
}
class er {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, r) {
    this.context = e, this._parent = t, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, t, r) {
    let { buffer: o } = this.context, s = o.findChild(this.index + 4, o.buffer[this.index + 3], e, t - this.context.start, r);
    return s < 0 ? null : new er(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    if (r & Qe.ExcludeBuffers)
      return null;
    let { buffer: o } = this.context, s = o.findChild(this.index + 4, o.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return s < 0 ? null : new er(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new er(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new er(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  cursor(e = 0) {
    return new Ua(this, e);
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: r } = this.context, o = this.index + 4, s = r.buffer[this.index + 3];
    if (s > o) {
      let n = r.buffer[this.index + 1];
      e.push(r.slice(o, s, n)), t.push(0);
    }
    return new Xe(this.type, e, t, this.to - this.from);
  }
  resolve(e, t = 0) {
    return ln(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return ln(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return MC(this, e);
  }
  /// @internal
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(e, t = null, r = null) {
    let o = Vu(this, e, t, r);
    return o.length ? o[0] : null;
  }
  getChildren(e, t = null, r = null) {
    return Vu(this, e, t, r);
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return Hu(this, e);
  }
}
class Ua {
  /// Shorthand for `.type.name`.
  get name() {
    return this.type.name;
  }
  /// @internal
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Ai)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: r, buffer: o } = this.buffer;
    return this.type = t || o.set.types[o.buffer[e]], this.from = r + o.buffer[e + 1], this.to = r + o.buffer[e + 2], !0;
  }
  yield(e) {
    return e ? e instanceof Ai ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /// @internal
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /// @internal
  enterChild(e, t, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, r, this.mode));
    let { buffer: o } = this.buffer, s = o.findChild(this.index + 4, o.buffer[this.index + 3], e, t - this.buffer.start, r);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /// Move the cursor to this node's first child. When this returns
  /// false, the node has no child, and the cursor has not been moved.
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to this node's last child.
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to the first child that ends after `pos`.
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /// Move to the last child that starts before `pos`.
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /// Move the cursor to the child around `pos`. If side is -1 the
  /// child may end at that position, when 1 it may start there. This
  /// will also enter [overlaid](#common.MountedTree.overlay)
  /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  /// set to false.
  enter(e, t, r = this.mode) {
    return this.buffer ? r & Qe.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, r));
  }
  /// Move to the node's parent node, if this isn't the top node.
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Qe.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Qe.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /// @internal
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let o = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != o)
        return this.yieldBuf(t.findChild(
          o,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let o = t.buffer[this.index + 3];
      if (o < (r < 0 ? t.buffer.length : t.buffer[this.stack[r] + 3]))
        return this.yieldBuf(o);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /// Move to this node's next sibling, if any.
  nextSibling() {
    return this.sibling(1);
  }
  /// Move to this node's previous sibling, if any.
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, r, { buffer: o } = this;
    if (o) {
      if (e > 0) {
        if (this.index < o.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (o.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: t, parent: r } = o);
    } else
      ({ index: t, _parent: r } = this._tree);
    for (; r; { index: t, _parent: r } = r)
      if (t > -1)
        for (let s = t + e, n = e < 0 ? -1 : r._tree.children.length; s != n; s += e) {
          let a = r._tree.children[s];
          if (this.mode & Qe.IncludeAnonymous || a instanceof fs || !a.type.isAnonymous || hO(a))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /// Move to the next node in a
  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  /// traversal, going from a node to its first child or, if the
  /// current node is empty or `enter` is false, its next sibling or
  /// the next sibling of the first parent node that has one.
  next(e = !0) {
    return this.move(1, e);
  }
  /// Move to the next node in a last-to-first pre-order traveral. A
  /// node is followed by its last child or, if it has none, its
  /// previous sibling or the previous sibling of the first parent
  /// node that has one.
  prev(e = !0) {
    return this.move(-1, e);
  }
  /// Move the cursor to the innermost node that covers `pos`. If
  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  /// it will enter nodes that start at `pos`.
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
  /// position.
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, r = 0;
    if (e && e.context == this.buffer)
      e:
        for (let o = this.index, s = this.stack.length; s >= 0; ) {
          for (let n = e; n; n = n._parent)
            if (n.index == o) {
              if (o == this.index)
                return n;
              t = n, r = s + 1;
              break e;
            }
          o = this.stack[--s];
        }
    for (let o = r; o < this.stack.length; o++)
      t = new er(this.buffer, t, this.stack[o]);
    return this.bufferNode = new er(this.buffer, t, this.index);
  }
  /// Get the [tree](#common.Tree) that represents the current node, if
  /// any. Will return null when the node is in a [tree
  /// buffer](#common.TreeBuffer).
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /// Iterate over the current node and all its descendants, calling
  /// `enter` when entering a node and `leave`, if given, when leaving
  /// one. When `enter` returns `false`, any children of that node are
  /// skipped, and `leave` isn't called for it.
  iterate(e, t) {
    for (let r = 0; ; ) {
      let o = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (o = !0);
      }
      for (; o && t && t(this), o = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!r)
          return;
        this.parent(), r--, o = !0;
      }
    }
  }
  /// Test whether the current node matches a given context—a sequence
  /// of direct parent node names. Empty strings in the context array
  /// are treated as wildcards.
  matchContext(e) {
    if (!this.buffer)
      return Hu(this.node, e);
    let { buffer: t } = this.buffer, { types: r } = t.set;
    for (let o = e.length - 1, s = this.stack.length - 1; o >= 0; s--) {
      if (s < 0)
        return Hu(this.node, e, o);
      let n = r[t.buffer[this.stack[s]]];
      if (!n.isAnonymous) {
        if (e[o] && e[o] != n.name)
          return !1;
        o--;
      }
    }
    return !0;
  }
}
function hO(i) {
  return i.children.some((e) => e instanceof fs || !e.type.isAnonymous || hO(e));
}
function xx(i) {
  var e;
  let { buffer: t, nodeSet: r, maxBufferLength: o = yC, reused: s = [], minRepeatType: n = r.types.length } = i, a = Array.isArray(t) ? new uO(t, t.length) : t, l = r.types, u = 0, h = 0;
  function c(S, R, v, I, C) {
    let { id: P, start: w, end: x, size: _ } = a, X = h;
    for (; _ < 0; )
      if (a.next(), _ == -1) {
        let oe = s[P];
        v.push(oe), I.push(w - S);
        return;
      } else if (_ == -3) {
        u = P;
        return;
      } else if (_ == -4) {
        h = P;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${_}`);
    let G = l[P], ee, re, le = w - S;
    if (x - w <= o && (re = O(a.pos - R, C))) {
      let oe = new Uint16Array(re.size - re.skip), Ee = a.pos - re.size, ve = oe.length;
      for (; a.pos > Ee; )
        ve = m(re.start, oe, ve);
      ee = new fs(oe, x - re.start, r), le = re.start - S;
    } else {
      let oe = a.pos - _;
      a.next();
      let Ee = [], ve = [], qt = P >= n ? P : -1, jt = 0, Kt = x;
      for (; a.pos > oe; )
        qt >= 0 && a.id == qt && a.size >= 0 ? (a.end <= Kt - o && (f(Ee, ve, w, jt, a.end, Kt, qt, X), jt = Ee.length, Kt = a.end), a.next()) : c(w, oe, Ee, ve, qt);
      if (qt >= 0 && jt > 0 && jt < Ee.length && f(Ee, ve, w, jt, w, Kt, qt, X), Ee.reverse(), ve.reverse(), qt > -1 && jt > 0) {
        let gs = d(G);
        ee = cO(G, Ee, ve, 0, Ee.length, 0, x - w, gs, gs);
      } else
        ee = p(G, Ee, ve, x - w, X - x);
    }
    v.push(ee), I.push(le);
  }
  function d(S) {
    return (R, v, I) => {
      let C = 0, P = R.length - 1, w, x;
      if (P >= 0 && (w = R[P]) instanceof Xe) {
        if (!P && w.type == S && w.length == I)
          return w;
        (x = w.prop(Oe.lookAhead)) && (C = v[P] + w.length + x);
      }
      return p(S, R, v, I, C);
    };
  }
  function f(S, R, v, I, C, P, w, x) {
    let _ = [], X = [];
    for (; S.length > I; )
      _.push(S.pop()), X.push(R.pop() + v - C);
    S.push(p(r.types[w], _, X, P - C, x - P)), R.push(C - v);
  }
  function p(S, R, v, I, C = 0, P) {
    if (u) {
      let w = [Oe.contextHash, u];
      P = P ? [w].concat(P) : [w];
    }
    if (C > 25) {
      let w = [Oe.lookAhead, C];
      P = P ? [w].concat(P) : [w];
    }
    return new Xe(S, R, v, I, P);
  }
  function O(S, R) {
    let v = a.fork(), I = 0, C = 0, P = 0, w = v.end - o, x = { size: 0, start: 0, skip: 0 };
    e:
      for (let _ = v.pos - S; v.pos > _; ) {
        let X = v.size;
        if (v.id == R && X >= 0) {
          x.size = I, x.start = C, x.skip = P, P += 4, I += 4, v.next();
          continue;
        }
        let G = v.pos - X;
        if (X < 0 || G < _ || v.start < w)
          break;
        let ee = v.id >= n ? 4 : 0, re = v.start;
        for (v.next(); v.pos > G; ) {
          if (v.size < 0)
            if (v.size == -3)
              ee += 4;
            else
              break e;
          else
            v.id >= n && (ee += 4);
          v.next();
        }
        C = re, I += X, P += ee;
      }
    return (R < 0 || I == S) && (x.size = I, x.start = C, x.skip = P), x.size > 4 ? x : void 0;
  }
  function m(S, R, v) {
    let { id: I, start: C, end: P, size: w } = a;
    if (a.next(), w >= 0 && I < n) {
      let x = v;
      if (w > 4) {
        let _ = a.pos - (w - 4);
        for (; a.pos > _; )
          v = m(S, R, v);
      }
      R[--v] = x, R[--v] = P - S, R[--v] = C - S, R[--v] = I;
    } else
      w == -3 ? u = I : w == -4 && (h = I);
    return v;
  }
  let E = [], g = [];
  for (; a.pos > 0; )
    c(i.start || 0, i.bufferStart || 0, E, g, -1);
  let A = (e = i.length) !== null && e !== void 0 ? e : E.length ? g[0] + E[0].length : 0;
  return new Xe(l[i.topID], E.reverse(), g.reverse(), A);
}
const mg = /* @__PURE__ */ new WeakMap();
function tu(i, e) {
  if (!i.isAnonymous || e instanceof fs || e.type != i)
    return 1;
  let t = mg.get(e);
  if (t == null) {
    t = 1;
    for (let r of e.children) {
      if (r.type != i || !(r instanceof Xe)) {
        t = 1;
        break;
      }
      t += tu(i, r);
    }
    mg.set(e, t);
  }
  return t;
}
function cO(i, e, t, r, o, s, n, a, l) {
  let u = 0;
  for (let p = r; p < o; p++)
    u += tu(i, e[p]);
  let h = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), c = [], d = [];
  function f(p, O, m, E, g) {
    for (let A = m; A < E; ) {
      let S = A, R = O[A], v = tu(i, p[A]);
      for (A++; A < E; A++) {
        let I = tu(i, p[A]);
        if (v + I >= h)
          break;
        v += I;
      }
      if (A == S + 1) {
        if (v > h) {
          let I = p[S];
          f(I.children, I.positions, 0, I.children.length, O[S] + g);
          continue;
        }
        c.push(p[S]);
      } else {
        let I = O[A - 1] + p[A - 1].length - R;
        c.push(cO(i, p, O, S, A, R, I, null, l));
      }
      d.push(R + g - s);
    }
  }
  return f(e, t, r, o, 0), (a || l)(c, d, n);
}
class Mx {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, r) {
    let o = this.map.get(e);
    o || this.map.set(e, o = /* @__PURE__ */ new Map()), o.set(t, r);
  }
  getBuffer(e, t) {
    let r = this.map.get(e);
    return r && r.get(t);
  }
  /// Set the value for this syntax node.
  set(e, t) {
    e instanceof er ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof Ai && this.map.set(e.tree, t);
  }
  /// Retrieve value for this syntax node, if it exists in the map.
  get(e) {
    return e instanceof er ? this.getBuffer(e.context.buffer, e.index) : e instanceof Ai ? this.map.get(e.tree) : void 0;
  }
  /// Set the value for the node that a cursor currently points to.
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /// Retrieve the value for the node that a cursor currently points
  /// to.
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class Sr {
  /// Construct a tree fragment. You'll usually want to use
  /// [`addTree`](#common.TreeFragment^addTree) and
  /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  /// calling this directly.
  constructor(e, t, r, o, s = !1, n = !1) {
    this.from = e, this.to = t, this.tree = r, this.offset = o, this.open = (s ? 1 : 0) | (n ? 2 : 0);
  }
  /// Whether the start of the fragment represents the start of a
  /// parse, or the end of a change. (In the second case, it may not
  /// be safe to reuse some nodes at the start, depending on the
  /// parsing algorithm.)
  get openStart() {
    return (this.open & 1) > 0;
  }
  /// Whether the end of the fragment represents the end of a
  /// full-document parse, or the start of a change.
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /// Create a set of fragments from a freshly parsed tree, or update
  /// an existing set of fragments by replacing the ones that overlap
  /// with a tree with content from the new tree. When `partial` is
  /// true, the parse is treated as incomplete, and the resulting
  /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  /// true.
  static addTree(e, t = [], r = !1) {
    let o = [new Sr(0, e.length, e, 0, !1, r)];
    for (let s of t)
      s.to > e.length && o.push(s);
    return o;
  }
  /// Apply a set of edits to an array of fragments, removing or
  /// splitting fragments as necessary to remove edited ranges, and
  /// adjusting offsets for fragments that moved.
  static applyChanges(e, t, r = 128) {
    if (!t.length)
      return e;
    let o = [], s = 1, n = e.length ? e[0] : null;
    for (let a = 0, l = 0, u = 0; ; a++) {
      let h = a < t.length ? t[a] : null, c = h ? h.fromA : 1e9;
      if (c - l >= r)
        for (; n && n.from < c; ) {
          let d = n;
          if (l >= d.from || c <= d.to || u) {
            let f = Math.max(d.from, l) - u, p = Math.min(d.to, c) - u;
            d = f >= p ? null : new Sr(f, p, d.tree, d.offset + u, a > 0, !!h);
          }
          if (d && o.push(d), n.to > c)
            break;
          n = s < e.length ? e[s++] : null;
        }
      if (!h)
        break;
      l = h.toA, u = h.toA - h.toB;
    }
    return o;
  }
}
class UC {
  /// Start a parse, returning a [partial parse](#common.PartialParse)
  /// object. [`fragments`](#common.TreeFragment) can be passed in to
  /// make the parse incremental.
  ///
  /// By default, the entire input is parsed. You can pass `ranges`,
  /// which should be a sorted array of non-empty, non-overlapping
  /// ranges, to parse only those ranges. The tree returned in that
  /// case will start at `ranges[0].from`.
  startParse(e, t, r) {
    return typeof e == "string" && (e = new Ux(e)), r = r ? r.length ? r.map((o) => new Ti(o.from, o.to)) : [new Ti(0, 0)] : [new Ti(0, e.length)], this.createParse(e, t || [], r);
  }
  /// Run a full parse, returning the resulting tree.
  parse(e, t, r) {
    let o = this.startParse(e, t, r);
    for (; ; ) {
      let s = o.advance();
      if (s)
        return s;
    }
  }
}
class Ux {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function Qx(i) {
  return (e, t, r, o) => new $x(e, i, t, r, o);
}
class gg {
  constructor(e, t, r, o, s) {
    if (this.parser = e, this.parse = t, this.overlay = r, this.target = o, this.ranges = s, !s.length || s.some((n) => n.from >= n.to))
      throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(s));
  }
}
class kx {
  constructor(e, t, r, o, s, n, a) {
    this.parser = e, this.predicate = t, this.mounts = r, this.index = o, this.start = s, this.target = n, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const Af = new Oe({ perNode: !0 });
class $x {
  constructor(e, t, r, o, s) {
    this.nest = t, this.input = r, this.fragments = o, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let o of this.inner)
          o.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new Xe(r.type, r.children, r.positions, r.length, r.propValues.concat([[Af, this.stoppedAt]]))), r;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      r[Oe.mounted.id] = new wx(t, e.overlay, e.parser), e.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].ranges[0].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new Hx(this.fragments), t = null, r = null, o = new Ua(new Ai(this.baseTree, this.ranges[0].from, 0, null), Qe.IncludeAnonymous | Qe.IgnoreMounts);
    e:
      for (let s, n; this.stoppedAt == null || o.from < this.stoppedAt; ) {
        let a = !0, l;
        if (e.hasNode(o)) {
          if (t) {
            let u = t.mounts.find((h) => h.frag.from <= o.from && h.frag.to >= o.to && h.mount.overlay);
            if (u)
              for (let h of u.mount.overlay) {
                let c = h.from + u.pos, d = h.to + u.pos;
                c >= o.from && d <= o.to && !t.ranges.some((f) => f.from < d && f.to > c) && t.ranges.push({ from: c, to: d });
              }
          }
          a = !1;
        } else if (r && (n = Gx(r.ranges, o.from, o.to)))
          a = n != 2;
        else if (!o.type.isAnonymous && o.from < o.to && (s = this.nest(o, this.input))) {
          o.tree || Vx(o);
          let u = e.findMounts(o.from, s.parser);
          if (typeof s.overlay == "function")
            t = new kx(s.parser, s.overlay, u, this.inner.length, o.from, o.tree, t);
          else {
            let h = Sg(this.ranges, s.overlay || [new Ti(o.from, o.to)]);
            h.length && this.inner.push(new gg(s.parser, s.parser.startParse(this.input, Rg(u, h), h), s.overlay ? s.overlay.map((c) => new Ti(c.from - o.from, c.to - o.from)) : null, o.tree, h)), s.overlay ? h.length && (r = { ranges: h, depth: 0, prev: r }) : a = !1;
          }
        } else
          t && (l = t.predicate(o)) && (l === !0 && (l = new Ti(o.from, o.to)), l.from < l.to && t.ranges.push(l));
        if (a && o.firstChild())
          t && t.depth++, r && r.depth++;
        else
          for (; !o.nextSibling(); ) {
            if (!o.parent())
              break e;
            if (t && !--t.depth) {
              let u = Sg(this.ranges, t.ranges);
              u.length && this.inner.splice(t.index, 0, new gg(t.parser, t.parser.startParse(this.input, Rg(t.mounts, u), u), t.ranges.map((h) => new Ti(h.from - t.start, h.to - t.start)), t.target, u)), t = t.prev;
            }
            r && !--r.depth && (r = r.prev);
          }
      }
  }
}
function Gx(i, e, t) {
  for (let r of i) {
    if (r.from >= t)
      break;
    if (r.to > e)
      return r.from <= e && r.to >= t ? 2 : 1;
  }
  return 0;
}
function bg(i, e, t, r, o, s) {
  if (e < t) {
    let n = i.buffer[e + 1];
    r.push(i.slice(e, t, n)), o.push(n - s);
  }
}
function Vx(i) {
  let { node: e } = i, t = 0;
  do
    i.parent(), t++;
  while (!i.tree);
  let r = 0, o = i.tree, s = 0;
  for (; s = o.positions[r] + i.from, !(s <= e.from && s + o.children[r].length >= e.to); r++)
    ;
  let n = o.children[r], a = n.buffer;
  function l(u, h, c, d, f) {
    let p = u;
    for (; a[p + 2] + s <= e.from; )
      p = a[p + 3];
    let O = [], m = [];
    bg(n, u, p, O, m, d);
    let E = a[p + 1], g = a[p + 2], A = E + s == e.from && g + s == e.to && a[p] == e.type.id;
    return O.push(A ? e.toTree() : l(p + 4, a[p + 3], n.set.types[a[p]], E, g - E)), m.push(E - d), bg(n, a[p + 3], h, O, m, d), new Xe(c, O, m, f);
  }
  o.children[r] = l(0, a.length, di.none, 0, n.length);
  for (let u = 0; u <= t; u++)
    i.childAfter(e.from);
}
class Tg {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Qe.IncludeAnonymous | Qe.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, r = e - this.offset;
    for (; !this.done && t.from < r; )
      t.to >= e && t.enter(r, 1, Qe.IgnoreOverlays | Qe.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof Xe)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
let Hx = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let r = this.curFrag = e[0];
      this.curTo = (t = r.tree.prop(Af)) !== null && t !== void 0 ? t : r.to, this.inner = new Tg(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(Af)) !== null && e !== void 0 ? e : t.to, this.inner = new Tg(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var r;
    let o = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let n = (r = s.tree) === null || r === void 0 ? void 0 : r.prop(Oe.mounted);
        if (n && n.parser == t)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= s.to)
              break;
            l.tree == this.curFrag.tree && o.push({
              frag: l,
              pos: s.from - l.offset,
              mount: n
            });
          }
      }
    }
    return o;
  }
};
function Sg(i, e) {
  let t = null, r = e;
  for (let o = 1, s = 0; o < i.length; o++) {
    let n = i[o - 1].to, a = i[o].from;
    for (; s < r.length; s++) {
      let l = r[s];
      if (l.from >= a)
        break;
      l.to <= n || (t || (r = t = e.slice()), l.from < n ? (t[s] = new Ti(l.from, n), l.to > a && t.splice(s + 1, 0, new Ti(a, l.to))) : l.to > a ? t[s--] = new Ti(a, l.to) : t.splice(s--, 1));
    }
  }
  return r;
}
function Xx(i, e, t, r) {
  let o = 0, s = 0, n = !1, a = !1, l = -1e9, u = [];
  for (; ; ) {
    let h = o == i.length ? 1e9 : n ? i[o].to : i[o].from, c = s == e.length ? 1e9 : a ? e[s].to : e[s].from;
    if (n != a) {
      let d = Math.max(l, t), f = Math.min(h, c, r);
      d < f && u.push(new Ti(d, f));
    }
    if (l = Math.min(h, c), l == 1e9)
      break;
    h == l && (n ? (n = !1, o++) : n = !0), c == l && (a ? (a = !1, s++) : a = !0);
  }
  return u;
}
function Rg(i, e) {
  let t = [];
  for (let { pos: r, mount: o, frag: s } of i) {
    let n = r + (o.overlay ? o.overlay[0].from : 0), a = n + o.tree.length, l = Math.max(s.from, n), u = Math.min(s.to, a);
    if (o.overlay) {
      let h = o.overlay.map((d) => new Ti(d.from + r, d.to + r)), c = Xx(e, h, l, u);
      for (let d = 0, f = l; ; d++) {
        let p = d == c.length, O = p ? u : c[d].from;
        if (O > f && t.push(new Sr(f, O, o.tree, -n, s.from >= f || s.openStart, s.to <= O || s.openEnd)), p)
          break;
        f = c[d].to;
      }
    } else
      t.push(new Sr(l, u, o.tree, -n, s.from >= n || s.openStart, s.to <= a || s.openEnd));
  }
  return t;
}
let Yx = 0;
class Zi {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.set = e, this.base = t, this.modified = r, this.id = Yx++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new Zi([], null, []);
    if (t.set.push(t), e)
      for (let r of e.set)
        t.set.push(r);
    return t;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new Xu();
    return (t) => t.modified.indexOf(e) > -1 ? t : Xu.get(t.base || t, t.modified.concat(e).sort((r, o) => r.id - o.id));
  }
}
let Bx = 0;
class Xu {
  constructor() {
    this.instances = [], this.id = Bx++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let r = t[0].instances.find((a) => a.base == e && Fx(t, a.modified));
    if (r)
      return r;
    let o = [], s = new Zi(o, e, t);
    for (let a of t)
      a.instances.push(s);
    let n = Wx(t);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of n)
          o.push(Xu.get(a, l));
    return s;
  }
}
function Fx(i, e) {
  return i.length == e.length && i.every((t, r) => t == e[r]);
}
function Wx(i) {
  let e = [[]];
  for (let t = 0; t < i.length; t++)
    for (let r = 0, o = e.length; r < o; r++)
      e.push(e[r].concat(i[t]));
  return e.sort((t, r) => r.length - t.length);
}
function ps(i) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in i) {
    let r = i[t];
    Array.isArray(r) || (r = [r]);
    for (let o of t.split(" "))
      if (o) {
        let s = [], n = 2, a = o;
        for (let c = 0; ; ) {
          if (a == "..." && c > 0 && c + 3 == o.length) {
            n = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!d)
            throw new RangeError("Invalid path: " + o);
          if (s.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), c += d[0].length, c == o.length)
            break;
          let f = o[c++];
          if (c == o.length && f == "!") {
            n = 0;
            break;
          }
          if (f != "/")
            throw new RangeError("Invalid path: " + o);
          a = o.slice(c);
        }
        let l = s.length - 1, u = s[l];
        if (!u)
          throw new RangeError("Invalid path: " + o);
        let h = new Yu(r, n, l > 0 ? s.slice(0, l) : null);
        e[u] = h.sort(e[u]);
      }
  }
  return QC.add(e);
}
const QC = new Oe();
class Yu {
  constructor(e, t, r, o) {
    this.tags = e, this.mode = t, this.context = r, this.next = o;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Yu.empty = new Yu([], 2, null);
function kC(i, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let s of i)
    if (!Array.isArray(s.tag))
      t[s.tag.id] = s.class;
    else
      for (let n of s.tag)
        t[n.id] = s.class;
  let { scope: r, all: o = null } = e || {};
  return {
    style: (s) => {
      let n = o;
      for (let a of s)
        for (let l of a.set) {
          let u = t[l.id];
          if (u) {
            n = n ? n + " " + u : u;
            break;
          }
        }
      return n;
    },
    scope: r
  };
}
function zx(i, e) {
  let t = null;
  for (let r of i) {
    let o = r.style(e);
    o && (t = t ? t + " " + o : o);
  }
  return t;
}
function Zx(i, e, t, r = 0, o = i.length) {
  let s = new qx(r, Array.isArray(e) ? e : [e], t);
  s.highlightRange(i.cursor(), r, o, "", s.highlighters), s.flush(o);
}
class qx {
  constructor(e, t, r) {
    this.at = e, this.highlighters = t, this.span = r, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, r, o, s) {
    let { type: n, from: a, to: l } = e;
    if (a >= r || l <= t)
      return;
    n.isTop && (s = this.highlighters.filter((f) => !f.scope || f.scope(n)));
    let u = o, h = jx(e) || Yu.empty, c = zx(s, h.tags);
    if (c && (u && (u += " "), u += c, h.mode == 1 && (o += (o ? " " : "") + c)), this.startSpan(Math.max(t, a), u), h.opaque)
      return;
    let d = e.tree && e.tree.prop(Oe.mounted);
    if (d && d.overlay) {
      let f = e.node.enter(d.overlay[0].from + a, 1), p = this.highlighters.filter((m) => !m.scope || m.scope(d.tree.type)), O = e.firstChild();
      for (let m = 0, E = a; ; m++) {
        let g = m < d.overlay.length ? d.overlay[m] : null, A = g ? g.from + a : l, S = Math.max(t, E), R = Math.min(r, A);
        if (S < R && O)
          for (; e.from < R && (this.highlightRange(e, S, R, o, s), this.startSpan(Math.min(R, e.to), u), !(e.to >= A || !e.nextSibling())); )
            ;
        if (!g || A > r)
          break;
        E = g.to + a, E > t && (this.highlightRange(f.cursor(), Math.max(t, g.from + a), Math.min(r, E), "", p), this.startSpan(Math.min(r, E), u));
      }
      O && e.parent();
    } else if (e.firstChild()) {
      d && (o = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, t, r, o, s), this.startSpan(Math.min(r, e.to), u);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function jx(i) {
  let e = i.type.prop(QC);
  for (; e && e.context && !i.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const F = Zi.define, xl = F(), Br = F(), Ag = F(Br), Cg = F(Br), Fr = F(), Ml = F(Fr), Uc = F(Fr), Bi = F(), Po = F(Bi), Xi = F(), Yi = F(), Cf = F(), Dn = F(Cf), Ul = F(), b = {
  /**
  A comment.
  */
  comment: xl,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: F(xl),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: F(xl),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: F(xl),
  /**
  Any kind of identifier.
  */
  name: Br,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: F(Br),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: Ag,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: F(Ag),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Cg,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: F(Cg),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: F(Br),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: F(Br),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: F(Br),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: F(Br),
  /**
  A literal value.
  */
  literal: Fr,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Ml,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: F(Ml),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: F(Ml),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: F(Ml),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Uc,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: F(Uc),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: F(Uc),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: F(Fr),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: F(Fr),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: F(Fr),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: F(Fr),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: F(Fr),
  /**
  A language keyword.
  */
  keyword: Xi,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: F(Xi),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: F(Xi),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: F(Xi),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: F(Xi),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: F(Xi),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: F(Xi),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: F(Xi),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: F(Xi),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: F(Xi),
  /**
  An operator.
  */
  operator: Yi,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: F(Yi),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: F(Yi),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: F(Yi),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: F(Yi),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: F(Yi),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: F(Yi),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: F(Yi),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: F(Yi),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: F(Yi),
  /**
  Program or markup punctuation.
  */
  punctuation: Cf,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: F(Cf),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Dn,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: F(Dn),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: F(Dn),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: F(Dn),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: F(Dn),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Bi,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Po,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: F(Po),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: F(Po),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: F(Po),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: F(Po),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: F(Po),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: F(Po),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: F(Bi),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: F(Bi),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: F(Bi),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: F(Bi),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: F(Bi),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: F(Bi),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: F(Bi),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: F(Bi),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: F(),
  /**
  Deleted text.
  */
  deleted: F(),
  /**
  Changed text.
  */
  changed: F(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: F(),
  /**
  Metadata or meta-instruction.
  */
  meta: Ul,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: F(Ul),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: F(Ul),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: F(Ul),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Zi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Zi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Zi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Zi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Zi.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Zi.defineModifier()
};
kC([
  { tag: b.link, class: "tok-link" },
  { tag: b.heading, class: "tok-heading" },
  { tag: b.emphasis, class: "tok-emphasis" },
  { tag: b.strong, class: "tok-strong" },
  { tag: b.keyword, class: "tok-keyword" },
  { tag: b.atom, class: "tok-atom" },
  { tag: b.bool, class: "tok-bool" },
  { tag: b.url, class: "tok-url" },
  { tag: b.labelName, class: "tok-labelName" },
  { tag: b.inserted, class: "tok-inserted" },
  { tag: b.deleted, class: "tok-deleted" },
  { tag: b.literal, class: "tok-literal" },
  { tag: b.string, class: "tok-string" },
  { tag: b.number, class: "tok-number" },
  { tag: [b.regexp, b.escape, b.special(b.string)], class: "tok-string2" },
  { tag: b.variableName, class: "tok-variableName" },
  { tag: b.local(b.variableName), class: "tok-variableName tok-local" },
  { tag: b.definition(b.variableName), class: "tok-variableName tok-definition" },
  { tag: b.special(b.variableName), class: "tok-variableName2" },
  { tag: b.definition(b.propertyName), class: "tok-propertyName tok-definition" },
  { tag: b.typeName, class: "tok-typeName" },
  { tag: b.namespace, class: "tok-namespace" },
  { tag: b.className, class: "tok-className" },
  { tag: b.macroName, class: "tok-macroName" },
  { tag: b.propertyName, class: "tok-propertyName" },
  { tag: b.operator, class: "tok-operator" },
  { tag: b.comment, class: "tok-comment" },
  { tag: b.meta, class: "tok-meta" },
  { tag: b.invalid, class: "tok-invalid" },
  { tag: b.punctuation, class: "tok-punctuation" }
]);
var Qc;
const xs = /* @__PURE__ */ new Oe();
function Kx(i) {
  return K.define({
    combine: i ? (e) => e.concat(i) : void 0
  });
}
const Jx = /* @__PURE__ */ new Oe();
class Di {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, r = [], o = "") {
    this.data = e, this.name = o, Re.prototype.hasOwnProperty("tree") || Object.defineProperty(Re.prototype, "tree", { get() {
      return Be(this);
    } }), this.parser = t, this.extension = [
      So.of(this),
      Re.languageData.of((s, n, a) => {
        let l = Ng(s, n, a), u = l.type.prop(xs);
        if (!u)
          return [];
        let h = s.facet(u), c = l.type.prop(Jx);
        if (c) {
          let d = l.resolve(n - l.from, a);
          for (let f of c)
            if (f.test(d, s)) {
              let p = s.facet(f.facet);
              return f.type == "replace" ? p : p.concat(h);
            }
        }
        return h;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, r = -1) {
    return Ng(e, t, r).type.prop(xs) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(So);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let r = [], o = (s, n) => {
      if (s.prop(xs) == this.data) {
        r.push({ from: n, to: n + s.length });
        return;
      }
      let a = s.prop(Oe.mounted);
      if (a) {
        if (a.tree.prop(xs) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              r.push({ from: l.from + n, to: l.to + n });
          else
            r.push({ from: n, to: n + s.length });
          return;
        } else if (a.overlay) {
          let l = r.length;
          if (o(a.tree, a.overlay[0].from + n), r.length > l)
            return;
        }
      }
      for (let l = 0; l < s.children.length; l++) {
        let u = s.children[l];
        u instanceof Xe && o(u, s.positions[l] + n);
      }
    };
    return o(Be(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Di.setState = /* @__PURE__ */ fe.define();
function Ng(i, e, t) {
  let r = i.facet(So), o = Be(i).topNode;
  if (!r || r.allowsNesting)
    for (let s = o; s; s = s.enter(e, t, Qe.ExcludeBuffers))
      s.type.isTop && (o = s);
  return o;
}
class _r extends Di {
  constructor(e, t, r) {
    super(e, t, [], r), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = Kx(e.languageData);
    return new _r(t, e.parser.configure({
      props: [xs.add((r) => r.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new _r(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Be(i) {
  let e = i.field(Di.state, !1);
  return e ? e.tree : Xe.empty;
}
class eM {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length;
    return e < r || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - r, t - r);
  }
}
let xn = null;
class Bu {
  constructor(e, t, r = [], o, s, n, a, l) {
    this.parser = e, this.state = t, this.fragments = r, this.tree = o, this.treeLen = s, this.viewport = n, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Bu(e, t, [], Xe.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new eM(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != Xe.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let o = Date.now() + e;
        e = () => Date.now() > o;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let o = this.parse.advance();
        if (o)
          if (this.fragments = this.withoutTempSkipped(Sr.addTree(o, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = o, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(Sr.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = xn;
    xn = this;
    try {
      return e();
    } finally {
      xn = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = Ig(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: r, tree: o, treeLen: s, viewport: n, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((u, h, c, d) => l.push({ fromA: u, toA: h, fromB: c, toB: d })), r = Sr.applyChanges(r, l), o = Xe.empty, s = 0, n = { from: e.mapPos(n.from, -1), to: e.mapPos(n.to, 1) }, this.skipped.length) {
        a = [];
        for (let u of this.skipped) {
          let h = e.mapPos(u.from, 1), c = e.mapPos(u.to, -1);
          h < c && a.push({ from: h, to: c });
        }
      }
    }
    return new Bu(this.parser, t, r, o, s, n, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: o, to: s } = this.skipped[r];
      o < e.to && s > e.from && (this.fragments = Ig(this.fragments, o, s), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends UC {
      createParse(t, r, o) {
        let s = o[0].from, n = o[o.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let l = xn;
            if (l) {
              for (let u of o)
                l.tempSkipped.push(u);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = n, new Xe(di.none, [], [], n - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return xn;
  }
}
function Ig(i, e, t) {
  return Sr.applyChanges(i, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class un {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, r) || t.takeTree(), new un(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), r = Bu.create(e.facet(So).parser, e, { from: 0, to: t });
    return r.work(20, t) || r.takeTree(), new un(r);
  }
}
Di.state = /* @__PURE__ */ ct.define({
  create: un.init,
  update(i, e) {
    for (let t of e.effects)
      if (t.is(Di.setState))
        return t.value;
    return e.startState.facet(So) != e.state.facet(So) ? un.init(e.state) : i.apply(e);
  }
});
let $C = (i) => {
  let e = setTimeout(
    () => i(),
    500
    /* MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && ($C = (i) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(i, {
        timeout: 500 - 100
        /* MinPause */
      });
    },
    100
    /* MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const kc = typeof navigator < "u" && (!((Qc = navigator.scheduling) === null || Qc === void 0) && Qc.isInputPending) ? () => navigator.scheduling.isInputPending() : null, tM = /* @__PURE__ */ lt.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(Di.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), e.docChanged && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(Di.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = $C(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: o } } = this.view, s = r.field(Di.state);
    if (s.tree == s.context.tree && s.context.isDone(
      o + 1e5
      /* MaxParseAhead */
    ))
      return;
    let n = Date.now() + Math.min(this.chunkBudget, 100, e && !kc ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = s.context.treeLen < o && r.doc.length > o + 1e3, l = s.context.work(() => kc && kc() || Date.now() > n, o + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: Di.setState.of(new un(s.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Ri(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), So = /* @__PURE__ */ K.define({
  combine(i) {
    return i.length ? i[0] : null;
  },
  enables: (i) => [
    Di.state,
    tM,
    q.contentAttributes.compute([i], (e) => {
      let t = e.facet(i);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class mn {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const iM = /* @__PURE__ */ K.define(), Vh = /* @__PURE__ */ K.define({
  combine: (i) => {
    if (!i.length)
      return "  ";
    let e = i[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(i[0]));
    return e;
  }
});
function Fu(i) {
  let e = i.facet(Vh);
  return e.charCodeAt(0) == 9 ? i.tabSize * e.length : e.length;
}
function Qa(i, e) {
  let t = "", r = i.tabSize, o = i.facet(Vh)[0];
  if (o == "	") {
    for (; e >= r; )
      t += "	", e -= r;
    o = " ";
  }
  for (let s = 0; s < e; s++)
    t += o;
  return t;
}
function dO(i, e) {
  i instanceof Re && (i = new Hh(i));
  for (let r of i.state.facet(iM)) {
    let o = r(i, e);
    if (o !== void 0)
      return o;
  }
  let t = Be(i.state);
  return t ? rM(i, t, e) : null;
}
class Hh {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = Fu(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: o, simulateDoubleBreak: s } = this.options;
    return o != null && o >= r.from && o <= r.to ? s && o == e ? { text: "", from: e } : (t < 0 ? o < e : o <= e) ? { text: r.text.slice(o - r.from), from: o } : { text: r.text.slice(0, o - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: o } = this.lineAt(e, t);
    return r.slice(e - o, Math.min(r.length, e + 100 - o));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: r, from: o } = this.lineAt(e, t), s = this.countColumn(r, e - o), n = this.options.overrideIndentation ? this.options.overrideIndentation(o) : -1;
    return n > -1 && (s += n - this.countColumn(r, r.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return qa(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: r, from: o } = this.lineAt(e, t), s = this.options.overrideIndentation;
    if (s) {
      let n = s(o);
      if (n > -1)
        return n;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Os = /* @__PURE__ */ new Oe();
function rM(i, e, t) {
  return GC(e.resolveInner(t).enterUnfinishedNodesBefore(t), t, i);
}
function oM(i) {
  return i.pos == i.options.simulateBreak && i.options.simulateDoubleBreak;
}
function sM(i) {
  let e = i.type.prop(Os);
  if (e)
    return e;
  let t = i.firstChild, r;
  if (t && (r = t.type.prop(Oe.closedBy))) {
    let o = i.lastChild, s = o && r.indexOf(o.name) > -1;
    return (n) => HC(n, !0, 1, void 0, s && !oM(n) ? o.from : void 0);
  }
  return i.parent == null ? nM : null;
}
function GC(i, e, t) {
  for (; i; i = i.parent) {
    let r = sM(i);
    if (r)
      return r(fO.create(t, e, i));
  }
  return null;
}
function nM() {
  return 0;
}
class fO extends Hh {
  constructor(e, t, r) {
    super(e.state, e.options), this.base = e, this.pos = t, this.node = r;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new fO(e, t, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(t.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (aM(r, e))
        break;
      t = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    let e = this.node.parent;
    return e ? GC(e, this.pos, this.base) : 0;
  }
}
function aM(i, e) {
  for (let t = e; t; t = t.parent)
    if (i == t)
      return !0;
  return !1;
}
function lM(i) {
  let e = i.node, t = e.childAfter(e.from), r = e.lastChild;
  if (!t)
    return null;
  let o = i.options.simulateBreak, s = i.state.doc.lineAt(t.from), n = o == null || o <= s.from ? s.to : Math.min(s.to, o);
  for (let a = t.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == r)
      return null;
    if (!l.type.isSkipped)
      return l.from < n ? t : null;
    a = l.to;
  }
}
function VC({ closing: i, align: e = !0, units: t = 1 }) {
  return (r) => HC(r, e, t, i);
}
function HC(i, e, t, r, o) {
  let s = i.textAfter, n = s.match(/^\s*/)[0].length, a = r && s.slice(n, n + r.length) == r || o == i.pos + n, l = e ? lM(i) : null;
  return l ? a ? i.column(l.from) : i.column(l.to) : i.baseIndent + (a ? 0 : i.unit * t);
}
const XC = (i) => i.baseIndent;
function ar({ except: i, units: e = 1 } = {}) {
  return (t) => {
    let r = i && i.test(t.textAfter);
    return t.baseIndent + (r ? 0 : e * t.unit);
  };
}
const uM = 200;
function hM() {
  return Re.transactionFilter.of((i) => {
    if (!i.docChanged || !i.isUserEvent("input.type") && !i.isUserEvent("input.complete"))
      return i;
    let e = i.startState.languageDataAt("indentOnInput", i.startState.selection.main.head);
    if (!e.length)
      return i;
    let t = i.newDoc, { head: r } = i.newSelection.main, o = t.lineAt(r);
    if (r > o.from + uM)
      return i;
    let s = t.sliceString(o.from, r);
    if (!e.some((u) => u.test(s)))
      return i;
    let { state: n } = i, a = -1, l = [];
    for (let { head: u } of n.selection.ranges) {
      let h = n.doc.lineAt(u);
      if (h.from == a)
        continue;
      a = h.from;
      let c = dO(n, h.from);
      if (c == null)
        continue;
      let d = /^\s*/.exec(h.text)[0], f = Qa(n, c);
      d != f && l.push({ from: h.from, to: h.from + d.length, insert: f });
    }
    return l.length ? [i, { changes: l, sequential: !0 }] : i;
  });
}
const cM = /* @__PURE__ */ K.define(), Es = /* @__PURE__ */ new Oe();
function Xh(i) {
  let e = i.firstChild, t = i.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? i.to : t.from } : null;
}
function dM(i, e, t) {
  let r = Be(i);
  if (r.length < t)
    return null;
  let o = r.resolveInner(t, 1), s = null;
  for (let n = o; n; n = n.parent) {
    if (n.to <= t || n.from > t)
      continue;
    if (s && n.from < e)
      break;
    let a = n.type.prop(Es);
    if (a && (n.to < r.length - 50 || r.length == i.doc.length || !fM(n))) {
      let l = a(n, i);
      l && l.from <= t && l.from >= e && l.to > t && (s = l);
    }
  }
  return s;
}
function fM(i) {
  let e = i.lastChild;
  return e && e.to == i.to && e.type.isError;
}
function Wu(i, e, t) {
  for (let r of i.facet(cM)) {
    let o = r(i, e, t);
    if (o)
      return o;
  }
  return dM(i, e, t);
}
function YC(i, e) {
  let t = e.mapPos(i.from, 1), r = e.mapPos(i.to, -1);
  return t >= r ? void 0 : { from: t, to: r };
}
const Yh = /* @__PURE__ */ fe.define({ map: YC }), el = /* @__PURE__ */ fe.define({ map: YC });
function BC(i) {
  let e = [];
  for (let { head: t } of i.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(i.lineBlockAt(t));
  return e;
}
const is = /* @__PURE__ */ ct.define({
  create() {
    return ie.none;
  },
  update(i, e) {
    i = i.map(e.changes);
    for (let t of e.effects)
      t.is(Yh) && !pM(i, t.value.from, t.value.to) ? i = i.update({ add: [vg.range(t.value.from, t.value.to)] }) : t.is(el) && (i = i.update({
        filter: (r, o) => t.value.from != r || t.value.to != o,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    if (e.selection) {
      let t = !1, { head: r } = e.selection.main;
      i.between(r, r, (o, s) => {
        o < r && s > r && (t = !0);
      }), t && (i = i.update({
        filterFrom: r,
        filterTo: r,
        filter: (o, s) => s <= r || o >= r
      }));
    }
    return i;
  },
  provide: (i) => q.decorations.from(i),
  toJSON(i, e) {
    let t = [];
    return i.between(0, e.doc.length, (r, o) => {
      t.push(r, o);
    }), t;
  },
  fromJSON(i) {
    if (!Array.isArray(i) || i.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < i.length; ) {
      let r = i[t++], o = i[t++];
      if (typeof r != "number" || typeof o != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(vg.range(r, o));
    }
    return ie.set(e, !0);
  }
});
function zu(i, e, t) {
  var r;
  let o = null;
  return (r = i.field(is, !1)) === null || r === void 0 || r.between(e, t, (s, n) => {
    (!o || o.from > s) && (o = { from: s, to: n });
  }), o;
}
function pM(i, e, t) {
  let r = !1;
  return i.between(e, e, (o, s) => {
    o == e && s == t && (r = !0);
  }), r;
}
function FC(i, e) {
  return i.field(is, !1) ? e : e.concat(fe.appendConfig.of(ZC()));
}
const OM = (i) => {
  for (let e of BC(i)) {
    let t = Wu(i.state, e.from, e.to);
    if (t)
      return i.dispatch({ effects: FC(i.state, [Yh.of(t), WC(i, t)]) }), !0;
  }
  return !1;
}, EM = (i) => {
  if (!i.state.field(is, !1))
    return !1;
  let e = [];
  for (let t of BC(i)) {
    let r = zu(i.state, t.from, t.to);
    r && e.push(el.of(r), WC(i, r, !1));
  }
  return e.length && i.dispatch({ effects: e }), e.length > 0;
};
function WC(i, e, t = !0) {
  let r = i.state.doc.lineAt(e.from).number, o = i.state.doc.lineAt(e.to).number;
  return q.announce.of(`${i.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${r} ${i.state.phrase("to")} ${o}.`);
}
const mM = (i) => {
  let { state: e } = i, t = [];
  for (let r = 0; r < e.doc.length; ) {
    let o = i.lineBlockAt(r), s = Wu(e, o.from, o.to);
    s && t.push(Yh.of(s)), r = (s ? i.lineBlockAt(s.to) : o).to + 1;
  }
  return t.length && i.dispatch({ effects: FC(i.state, t) }), !!t.length;
}, gM = (i) => {
  let e = i.state.field(is, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, i.state.doc.length, (r, o) => {
    t.push(el.of({ from: r, to: o }));
  }), i.dispatch({ effects: t }), !0;
}, bM = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: OM },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: EM },
  { key: "Ctrl-Alt-[", run: mM },
  { key: "Ctrl-Alt-]", run: gM }
], TM = {
  placeholderDOM: null,
  placeholderText: "…"
}, zC = /* @__PURE__ */ K.define({
  combine(i) {
    return cr(i, TM);
  }
});
function ZC(i) {
  let e = [is, AM];
  return i && e.push(zC.of(i)), e;
}
const vg = /* @__PURE__ */ ie.replace({ widget: /* @__PURE__ */ new class extends Ur {
  toDOM(i) {
    let { state: e } = i, t = e.facet(zC), r = (s) => {
      let n = i.lineBlockAt(i.posAtDOM(s.target)), a = zu(i.state, n.from, n.to);
      a && i.dispatch({ effects: el.of(a) }), s.preventDefault();
    };
    if (t.placeholderDOM)
      return t.placeholderDOM(i, r);
    let o = document.createElement("span");
    return o.textContent = t.placeholderText, o.setAttribute("aria-label", e.phrase("folded code")), o.title = e.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = r, o;
  }
}() }), SM = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class $c extends vr {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function RM(i = {}) {
  let e = Object.assign(Object.assign({}, SM), i), t = new $c(e, !0), r = new $c(e, !1), o = lt.fromClass(class {
    constructor(n) {
      this.from = n.viewport.from, this.markers = this.buildMarkers(n);
    }
    update(n) {
      (n.docChanged || n.viewportChanged || n.startState.facet(So) != n.state.facet(So) || n.startState.field(is, !1) != n.state.field(is, !1) || Be(n.startState) != Be(n.state) || e.foldingChanged(n)) && (this.markers = this.buildMarkers(n.view));
    }
    buildMarkers(n) {
      let a = new Eo();
      for (let l of n.viewportLineBlocks) {
        let u = zu(n.state, l.from, l.to) ? r : Wu(n.state, l.from, l.to) ? t : null;
        u && a.add(l.from, l.from, u);
      }
      return a.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    o,
    Tx({
      class: "cm-foldGutter",
      markers(n) {
        var a;
        return ((a = n.plugin(o)) === null || a === void 0 ? void 0 : a.markers) || Le.empty;
      },
      initialSpacer() {
        return new $c(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (n, a, l) => {
        if (s.click && s.click(n, a, l))
          return !0;
        let u = zu(n.state, a.from, a.to);
        if (u)
          return n.dispatch({ effects: el.of(u) }), !0;
        let h = Wu(n.state, a.from, a.to);
        return h ? (n.dispatch({ effects: Yh.of(h) }), !0) : !1;
      } })
    }),
    ZC()
  ];
}
const AM = /* @__PURE__ */ q.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class tl {
  constructor(e, t) {
    this.specs = e;
    let r;
    function o(a) {
      let l = mo.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const s = typeof t.all == "string" ? t.all : t.all ? o(t.all) : void 0, n = t.scope;
    this.scope = n instanceof Di ? (a) => a.prop(xs) == n.data : n ? (a) => a == n : void 0, this.style = kC(e.map((a) => ({
      tag: a.tag,
      class: a.class || o(Object.assign({}, a, { tag: null }))
    })), {
      all: s
    }).style, this.module = r ? new mo(r) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new tl(e, t || {});
  }
}
const Nf = /* @__PURE__ */ K.define(), qC = /* @__PURE__ */ K.define({
  combine(i) {
    return i.length ? [i[0]] : null;
  }
});
function Gc(i) {
  let e = i.facet(Nf);
  return e.length ? e : i.facet(qC);
}
function jC(i, e) {
  let t = [NM], r;
  return i instanceof tl && (i.module && t.push(q.styleModule.of(i.module)), r = i.themeType), e != null && e.fallback ? t.push(qC.of(i)) : r ? t.push(Nf.computeN([q.darkTheme], (o) => o.facet(q.darkTheme) == (r == "dark") ? [i] : [])) : t.push(Nf.of(i)), t;
}
class CM {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Be(e.state), this.decorations = this.buildDeco(e, Gc(e.state));
  }
  update(e) {
    let t = Be(e.state), r = Gc(e.state), o = r != Gc(e.startState);
    t.length < e.view.viewport.to && !o && t.type == this.tree.type ? this.decorations = this.decorations.map(e.changes) : (t != this.tree || e.viewportChanged || o) && (this.tree = t, this.decorations = this.buildDeco(e.view, r));
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return ie.none;
    let r = new Eo();
    for (let { from: o, to: s } of e.visibleRanges)
      Zx(this.tree, t, (n, a, l) => {
        r.add(n, a, this.markCache[l] || (this.markCache[l] = ie.mark({ class: l })));
      }, o, s);
    return r.finish();
  }
}
const NM = /* @__PURE__ */ ds.high(/* @__PURE__ */ lt.fromClass(CM, {
  decorations: (i) => i.decorations
})), IM = /* @__PURE__ */ tl.define([
  {
    tag: b.meta,
    color: "#404740"
  },
  {
    tag: b.link,
    textDecoration: "underline"
  },
  {
    tag: b.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: b.emphasis,
    fontStyle: "italic"
  },
  {
    tag: b.strong,
    fontWeight: "bold"
  },
  {
    tag: b.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: b.keyword,
    color: "#708"
  },
  {
    tag: [b.atom, b.bool, b.url, b.contentSeparator, b.labelName],
    color: "#219"
  },
  {
    tag: [b.literal, b.inserted],
    color: "#164"
  },
  {
    tag: [b.string, b.deleted],
    color: "#a11"
  },
  {
    tag: [b.regexp, b.escape, /* @__PURE__ */ b.special(b.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ b.definition(b.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ b.local(b.variableName),
    color: "#30a"
  },
  {
    tag: [b.typeName, b.namespace],
    color: "#085"
  },
  {
    tag: b.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ b.special(b.variableName), b.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ b.definition(b.propertyName),
    color: "#00c"
  },
  {
    tag: b.comment,
    color: "#940"
  },
  {
    tag: b.invalid,
    color: "#f00"
  }
]), vM = /* @__PURE__ */ q.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), KC = 1e4, JC = "()[]{}", eN = /* @__PURE__ */ K.define({
  combine(i) {
    return cr(i, {
      afterCursor: !0,
      brackets: JC,
      maxScanDistance: KC,
      renderMatch: LM
    });
  }
}), _M = /* @__PURE__ */ ie.mark({ class: "cm-matchingBracket" }), PM = /* @__PURE__ */ ie.mark({ class: "cm-nonmatchingBracket" });
function LM(i) {
  let e = [], t = i.matched ? _M : PM;
  return e.push(t.range(i.start.from, i.start.to)), i.end && e.push(t.range(i.end.from, i.end.to)), e;
}
const wM = /* @__PURE__ */ ct.define({
  create() {
    return ie.none;
  },
  update(i, e) {
    if (!e.docChanged && !e.selection)
      return i;
    let t = [], r = e.state.facet(eN);
    for (let o of e.state.selection.ranges) {
      if (!o.empty)
        continue;
      let s = tr(e.state, o.head, -1, r) || o.head > 0 && tr(e.state, o.head - 1, 1, r) || r.afterCursor && (tr(e.state, o.head, 1, r) || o.head < e.state.doc.length && tr(e.state, o.head + 1, -1, r));
      s && (t = t.concat(r.renderMatch(s, e.state)));
    }
    return ie.set(t, !0);
  },
  provide: (i) => q.decorations.from(i)
}), yM = [
  wM,
  vM
];
function DM(i = {}) {
  return [eN.of(i), yM];
}
const xM = /* @__PURE__ */ new Oe();
function If(i, e, t) {
  let r = i.prop(e < 0 ? Oe.openedBy : Oe.closedBy);
  if (r)
    return r;
  if (i.name.length == 1) {
    let o = t.indexOf(i.name);
    if (o > -1 && o % 2 == (e < 0 ? 1 : 0))
      return [t[o + e]];
  }
  return null;
}
function vf(i) {
  let e = i.type.prop(xM);
  return e ? e(i.node) : i;
}
function tr(i, e, t, r = {}) {
  let o = r.maxScanDistance || KC, s = r.brackets || JC, n = Be(i), a = n.resolveInner(e, t);
  for (let l = a; l; l = l.parent) {
    let u = If(l.type, t, s);
    if (u && l.from < l.to) {
      let h = vf(l);
      if (h && (t > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return MM(i, e, t, l, h, u, s);
    }
  }
  return UM(i, e, t, n, a.type, o, s);
}
function MM(i, e, t, r, o, s, n) {
  let a = r.parent, l = { from: o.from, to: o.to }, u = 0, h = a == null ? void 0 : a.cursor();
  if (h && (t < 0 ? h.childBefore(r.from) : h.childAfter(r.to)))
    do
      if (t < 0 ? h.to <= r.from : h.from >= r.to) {
        if (u == 0 && s.indexOf(h.type.name) > -1 && h.from < h.to) {
          let c = vf(h);
          return { start: l, end: c ? { from: c.from, to: c.to } : void 0, matched: !0 };
        } else if (If(h.type, t, n))
          u++;
        else if (If(h.type, -t, n)) {
          if (u == 0) {
            let c = vf(h);
            return {
              start: l,
              end: c && c.from < c.to ? { from: c.from, to: c.to } : void 0,
              matched: !1
            };
          }
          u--;
        }
      }
    while (t < 0 ? h.prevSibling() : h.nextSibling());
  return { start: l, matched: !1 };
}
function UM(i, e, t, r, o, s, n) {
  let a = t < 0 ? i.sliceDoc(e - 1, e) : i.sliceDoc(e, e + 1), l = n.indexOf(a);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let u = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, h = i.doc.iterRange(e, t > 0 ? i.doc.length : 0), c = 0;
  for (let d = 0; !h.next().done && d <= s; ) {
    let f = h.value;
    t < 0 && (d += f.length);
    let p = e + d * t;
    for (let O = t > 0 ? 0 : f.length - 1, m = t > 0 ? f.length : -1; O != m; O += t) {
      let E = n.indexOf(f[O]);
      if (!(E < 0 || r.resolveInner(p + O, 1).type != o))
        if (E % 2 == 0 == t > 0)
          c++;
        else {
          if (c == 1)
            return { start: u, end: { from: p + O, to: p + O + 1 }, matched: E >> 1 == l >> 1 };
          c--;
        }
    }
    t > 0 && (d += f.length);
  }
  return h.done ? { start: u, matched: !1 } : null;
}
const QM = /* @__PURE__ */ Object.create(null), _g = [di.none], Pg = [], kM = /* @__PURE__ */ Object.create(null);
for (let [i, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  kM[i] = /* @__PURE__ */ $M(QM, e);
function Vc(i, e) {
  Pg.indexOf(i) > -1 || (Pg.push(i), console.warn(e));
}
function $M(i, e) {
  let t = null;
  for (let s of e.split(".")) {
    let n = i[s] || b[s];
    n ? typeof n == "function" ? t ? t = n(t) : Vc(s, `Modifier ${s} used at start of tag`) : t ? Vc(s, `Tag ${s} used as modifier`) : t = n : Vc(s, `Unknown highlighting tag ${s}`);
  }
  if (!t)
    return 0;
  let r = e.replace(/ /g, "_"), o = di.define({
    id: _g.length,
    name: r,
    props: [ps({ [r]: t })]
  });
  return _g.push(o), o.id;
}
const GM = (i) => {
  let { state: e } = i, t = e.doc.lineAt(e.selection.main.from), r = OO(i.state, t.from);
  return r.line ? VM(i) : r.block ? XM(i) : !1;
};
function pO(i, e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return !1;
    let o = i(e, t);
    return o ? (r(t.update(o)), !0) : !1;
  };
}
const VM = /* @__PURE__ */ pO(
  FM,
  0
  /* CommentOption.Toggle */
), HM = /* @__PURE__ */ pO(
  tN,
  0
  /* CommentOption.Toggle */
), XM = /* @__PURE__ */ pO(
  (i, e) => tN(i, e, BM(e)),
  0
  /* CommentOption.Toggle */
);
function OO(i, e) {
  let t = i.languageDataAt("commentTokens", e);
  return t.length ? t[0] : {};
}
const Mn = 50;
function YM(i, { open: e, close: t }, r, o) {
  let s = i.sliceDoc(r - Mn, r), n = i.sliceDoc(o, o + Mn), a = /\s*$/.exec(s)[0].length, l = /^\s*/.exec(n)[0].length, u = s.length - a;
  if (s.slice(u - e.length, u) == e && n.slice(l, l + t.length) == t)
    return {
      open: { pos: r - a, margin: a && 1 },
      close: { pos: o + l, margin: l && 1 }
    };
  let h, c;
  o - r <= 2 * Mn ? h = c = i.sliceDoc(r, o) : (h = i.sliceDoc(r, r + Mn), c = i.sliceDoc(o - Mn, o));
  let d = /^\s*/.exec(h)[0].length, f = /\s*$/.exec(c)[0].length, p = c.length - f - t.length;
  return h.slice(d, d + e.length) == e && c.slice(p, p + t.length) == t ? {
    open: {
      pos: r + d + e.length,
      margin: /\s/.test(h.charAt(d + e.length)) ? 1 : 0
    },
    close: {
      pos: o - f - t.length,
      margin: /\s/.test(c.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function BM(i) {
  let e = [];
  for (let t of i.selection.ranges) {
    let r = i.doc.lineAt(t.from), o = t.to <= r.to ? r : i.doc.lineAt(t.to), s = e.length - 1;
    s >= 0 && e[s].to > r.from ? e[s].to = o.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: o.to });
  }
  return e;
}
function tN(i, e, t = e.selection.ranges) {
  let r = t.map((s) => OO(e, s.from).block);
  if (!r.every((s) => s))
    return null;
  let o = t.map((s, n) => YM(e, r[n], s.from, s.to));
  if (i != 2 && !o.every((s) => s))
    return { changes: e.changes(t.map((s, n) => o[n] ? [] : [{ from: s.from, insert: r[n].open + " " }, { from: s.to, insert: " " + r[n].close }])) };
  if (i != 1 && o.some((s) => s)) {
    let s = [];
    for (let n = 0, a; n < o.length; n++)
      if (a = o[n]) {
        let l = r[n], { open: u, close: h } = a;
        s.push({ from: u.pos - l.open.length, to: u.pos + u.margin }, { from: h.pos - h.margin, to: h.pos + l.close.length });
      }
    return { changes: s };
  }
  return null;
}
function FM(i, e, t = e.selection.ranges) {
  let r = [], o = -1;
  for (let { from: s, to: n } of t) {
    let a = r.length, l = 1e9, u = OO(e, s).line;
    if (u) {
      for (let h = s; h <= n; ) {
        let c = e.doc.lineAt(h);
        if (c.from > o && (s == n || n > c.from)) {
          o = c.from;
          let d = /^\s*/.exec(c.text)[0].length, f = d == c.length, p = c.text.slice(d, d + u.length) == u ? d : -1;
          d < c.text.length && d < l && (l = d), r.push({ line: c, comment: p, token: u, indent: d, empty: f, single: !1 });
        }
        h = c.to + 1;
      }
      if (l < 1e9)
        for (let h = a; h < r.length; h++)
          r[h].indent < r[h].line.text.length && (r[h].indent = l);
      r.length == a + 1 && (r[a].single = !0);
    }
  }
  if (i != 2 && r.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: a, token: l, indent: u, empty: h, single: c } of r)
      (c || !h) && s.push({ from: a.from + u, insert: l + " " });
    let n = e.changes(s);
    return { changes: n, selection: e.selection.map(n, 1) };
  } else if (i != 1 && r.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: n, comment: a, token: l } of r)
      if (a >= 0) {
        let u = n.from + a, h = u + l.length;
        n.text[h - n.from] == " " && h++, s.push({ from: u, to: h });
      }
    return { changes: s };
  }
  return null;
}
const _f = /* @__PURE__ */ Mr.define(), WM = /* @__PURE__ */ Mr.define(), zM = /* @__PURE__ */ K.define(), iN = /* @__PURE__ */ K.define({
  combine(i) {
    return cr(i, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (r, o) => e(r, o) || t(r, o)
    });
  }
});
function ZM(i) {
  let e = 0;
  return i.iterChangedRanges((t, r) => e = r), e;
}
const rN = /* @__PURE__ */ ct.define({
  create() {
    return ir.empty;
  },
  update(i, e) {
    let t = e.state.facet(iN), r = e.annotation(_f);
    if (r) {
      let l = e.docChanged ? D.single(ZM(e.changes)) : void 0, u = Wt.fromTransaction(e, l), h = r.side, c = h == 0 ? i.undone : i.done;
      return u ? c = Zu(c, c.length, t.minDepth, u) : c = nN(c, e.startState.selection), new ir(h == 0 ? r.rest : c, h == 0 ? c : r.rest);
    }
    let o = e.annotation(WM);
    if ((o == "full" || o == "before") && (i = i.isolate()), e.annotation(nt.addToHistory) === !1)
      return e.changes.empty ? i : i.addMapping(e.changes.desc);
    let s = Wt.fromTransaction(e), n = e.annotation(nt.time), a = e.annotation(nt.userEvent);
    return s ? i = i.addChanges(s, n, a, t, e) : e.selection && (i = i.addSelection(e.startState.selection, n, a, t.newGroupDelay)), (o == "full" || o == "after") && (i = i.isolate()), i;
  },
  toJSON(i) {
    return { done: i.done.map((e) => e.toJSON()), undone: i.undone.map((e) => e.toJSON()) };
  },
  fromJSON(i) {
    return new ir(i.done.map(Wt.fromJSON), i.undone.map(Wt.fromJSON));
  }
});
function qM(i = {}) {
  return [
    rN,
    iN.of(i),
    q.domEventHandlers({
      beforeinput(e, t) {
        let r = e.inputType == "historyUndo" ? oN : e.inputType == "historyRedo" ? Pf : null;
        return r ? (e.preventDefault(), r(t)) : !1;
      }
    })
  ];
}
function Bh(i, e) {
  return function({ state: t, dispatch: r }) {
    if (!e && t.readOnly)
      return !1;
    let o = t.field(rN, !1);
    if (!o)
      return !1;
    let s = o.pop(i, t, e);
    return s ? (r(s), !0) : !1;
  };
}
const oN = /* @__PURE__ */ Bh(0, !1), Pf = /* @__PURE__ */ Bh(1, !1), jM = /* @__PURE__ */ Bh(0, !0), KM = /* @__PURE__ */ Bh(1, !0);
class Wt {
  constructor(e, t, r, o, s) {
    this.changes = e, this.effects = t, this.mapped = r, this.startSelection = o, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new Wt(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((o) => o.toJSON())
    };
  }
  static fromJSON(e) {
    return new Wt(e.changes && st.fromJSON(e.changes), [], e.mapped && sr.fromJSON(e.mapped), e.startSelection && D.fromJSON(e.startSelection), e.selectionsAfter.map(D.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let r = Si;
    for (let o of e.startState.facet(zM)) {
      let s = o(e);
      s.length && (r = r.concat(s));
    }
    return !r.length && e.changes.empty ? null : new Wt(e.changes.invert(e.startState.doc), r, void 0, t || e.startState.selection, Si);
  }
  static selection(e) {
    return new Wt(void 0, Si, void 0, void 0, e);
  }
}
function Zu(i, e, t, r) {
  let o = e + 1 > t + 20 ? e - t - 1 : 0, s = i.slice(o, e);
  return s.push(r), s;
}
function JM(i, e) {
  let t = [], r = !1;
  return i.iterChangedRanges((o, s) => t.push(o, s)), e.iterChangedRanges((o, s, n, a) => {
    for (let l = 0; l < t.length; ) {
      let u = t[l++], h = t[l++];
      a >= u && n <= h && (r = !0);
    }
  }), r;
}
function eU(i, e) {
  return i.ranges.length == e.ranges.length && i.ranges.filter((t, r) => t.empty != e.ranges[r].empty).length === 0;
}
function sN(i, e) {
  return i.length ? e.length ? i.concat(e) : i : e;
}
const Si = [], tU = 200;
function nN(i, e) {
  if (i.length) {
    let t = i[i.length - 1], r = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - tU));
    return r.length && r[r.length - 1].eq(e) ? i : (r.push(e), Zu(i, i.length - 1, 1e9, t.setSelAfter(r)));
  } else
    return [Wt.selection([e])];
}
function iU(i) {
  let e = i[i.length - 1], t = i.slice();
  return t[i.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function Hc(i, e) {
  if (!i.length)
    return i;
  let t = i.length, r = Si;
  for (; t; ) {
    let o = rU(i[t - 1], e, r);
    if (o.changes && !o.changes.empty || o.effects.length) {
      let s = i.slice(0, t);
      return s[t - 1] = o, s;
    } else
      e = o.mapped, t--, r = o.selectionsAfter;
  }
  return r.length ? [Wt.selection(r)] : Si;
}
function rU(i, e, t) {
  let r = sN(i.selectionsAfter.length ? i.selectionsAfter.map((a) => a.map(e)) : Si, t);
  if (!i.changes)
    return Wt.selection(r);
  let o = i.changes.map(e), s = e.mapDesc(i.changes, !0), n = i.mapped ? i.mapped.composeDesc(s) : s;
  return new Wt(o, fe.mapEffects(i.effects, e), n, i.startSelection.map(s), r);
}
const oU = /^(input\.type|delete)($|\.)/;
class ir {
  constructor(e, t, r = 0, o = void 0) {
    this.done = e, this.undone = t, this.prevTime = r, this.prevUserEvent = o;
  }
  isolate() {
    return this.prevTime ? new ir(this.done, this.undone) : this;
  }
  addChanges(e, t, r, o, s) {
    let n = this.done, a = n[n.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!r || oU.test(r)) && (!a.selectionsAfter.length && t - this.prevTime < o.newGroupDelay && o.joinToEvent(s, JM(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? n = Zu(n, n.length - 1, o.minDepth, new Wt(e.changes.compose(a.changes), sN(e.effects, a.effects), a.mapped, a.startSelection, Si)) : n = Zu(n, n.length, o.minDepth, e), new ir(n, Si, t, r);
  }
  addSelection(e, t, r, o) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Si;
    return s.length > 0 && t - this.prevTime < o && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && eU(s[s.length - 1], e) ? this : new ir(nN(this.done, e), this.undone, t, r);
  }
  addMapping(e) {
    return new ir(Hc(this.done, e), Hc(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, r) {
    let o = e == 0 ? this.done : this.undone;
    if (o.length == 0)
      return null;
    let s = o[o.length - 1];
    if (r && s.selectionsAfter.length)
      return t.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: _f.of({ side: e, rest: iU(o) }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let n = o.length == 1 ? Si : o.slice(0, o.length - 1);
      return s.mapped && (n = Hc(n, s.mapped)), t.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: _f.of({ side: e, rest: n }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
ir.empty = /* @__PURE__ */ new ir(Si, Si);
const sU = [
  { key: "Mod-z", run: oN, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Pf, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Pf, preventDefault: !0 },
  { key: "Mod-u", run: jM, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: KM, preventDefault: !0 }
];
function gn(i, e) {
  return D.create(i.ranges.map(e), i.mainIndex);
}
function dr(i, e) {
  return i.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function $i({ state: i, dispatch: e }, t) {
  let r = gn(i.selection, t);
  return r.eq(i.selection) ? !1 : (e(dr(i, r)), !0);
}
function Fh(i, e) {
  return D.cursor(e ? i.to : i.from);
}
function aN(i, e) {
  return $i(i, (t) => t.empty ? i.moveByChar(t, e) : Fh(t, e));
}
function yt(i) {
  return i.textDirectionAt(i.state.selection.main.head) == He.LTR;
}
const lN = (i) => aN(i, !yt(i)), uN = (i) => aN(i, yt(i));
function hN(i, e) {
  return $i(i, (t) => t.empty ? i.moveByGroup(t, e) : Fh(t, e));
}
const nU = (i) => hN(i, !yt(i)), aU = (i) => hN(i, yt(i));
function lU(i, e, t) {
  if (e.type.prop(t))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(i.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Wh(i, e, t) {
  let r = Be(i).resolveInner(e.head), o = t ? Oe.closedBy : Oe.openedBy;
  for (let l = e.head; ; ) {
    let u = t ? r.childAfter(l) : r.childBefore(l);
    if (!u)
      break;
    lU(i, u, o) ? r = u : l = t ? u.to : u.from;
  }
  let s = r.type.prop(o), n, a;
  return s && (n = t ? tr(i, r.from, 1) : tr(i, r.to, -1)) && n.matched ? a = t ? n.end.to : n.end.from : a = t ? r.to : r.from, D.cursor(a, t ? -1 : 1);
}
const uU = (i) => $i(i, (e) => Wh(i.state, e, !yt(i))), hU = (i) => $i(i, (e) => Wh(i.state, e, yt(i)));
function cN(i, e) {
  return $i(i, (t) => {
    if (!t.empty)
      return Fh(t, e);
    let r = i.moveVertically(t, e);
    return r.head != t.head ? r : i.moveToLineBoundary(t, e);
  });
}
const dN = (i) => cN(i, !1), fN = (i) => cN(i, !0);
function pN(i) {
  let e = i.scrollDOM.clientHeight < i.scrollDOM.scrollHeight - 2, t = 0, r = 0, o;
  if (e) {
    for (let s of i.state.facet(q.scrollMargins)) {
      let n = s(i);
      n != null && n.top && (t = Math.max(n == null ? void 0 : n.top, t)), n != null && n.bottom && (r = Math.max(n == null ? void 0 : n.bottom, r));
    }
    o = i.scrollDOM.clientHeight - t - r;
  } else
    o = (i.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(i.defaultLineHeight, o - 5)
  };
}
function ON(i, e) {
  let t = pN(i), { state: r } = i, o = gn(r.selection, (n) => n.empty ? i.moveVertically(n, e, t.height) : Fh(n, e));
  if (o.eq(r.selection))
    return !1;
  let s;
  if (t.selfScroll) {
    let n = i.coordsAtPos(r.selection.main.head), a = i.scrollDOM.getBoundingClientRect(), l = a.top + t.marginTop, u = a.bottom - t.marginBottom;
    n && n.top > l && n.bottom < u && (s = q.scrollIntoView(o.main.head, { y: "start", yMargin: n.top - l }));
  }
  return i.dispatch(dr(r, o), { effects: s }), !0;
}
const Lg = (i) => ON(i, !1), Lf = (i) => ON(i, !0);
function Io(i, e, t) {
  let r = i.lineBlockAt(e.head), o = i.moveToLineBoundary(e, t);
  if (o.head == e.head && o.head != (t ? r.to : r.from) && (o = i.moveToLineBoundary(e, t, !1)), !t && o.head == r.from && r.length) {
    let s = /^\s*/.exec(i.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    s && e.head != r.from + s && (o = D.cursor(r.from + s));
  }
  return o;
}
const cU = (i) => $i(i, (e) => Io(i, e, !0)), dU = (i) => $i(i, (e) => Io(i, e, !1)), fU = (i) => $i(i, (e) => Io(i, e, !yt(i))), pU = (i) => $i(i, (e) => Io(i, e, yt(i))), OU = (i) => $i(i, (e) => D.cursor(i.lineBlockAt(e.head).from, 1)), EU = (i) => $i(i, (e) => D.cursor(i.lineBlockAt(e.head).to, -1));
function mU(i, e, t) {
  let r = !1, o = gn(i.selection, (s) => {
    let n = tr(i, s.head, -1) || tr(i, s.head, 1) || s.head > 0 && tr(i, s.head - 1, 1) || s.head < i.doc.length && tr(i, s.head + 1, -1);
    if (!n || !n.end)
      return s;
    r = !0;
    let a = n.start.from == s.head ? n.end.to : n.end.from;
    return t ? D.range(s.anchor, a) : D.cursor(a);
  });
  return r ? (e(dr(i, o)), !0) : !1;
}
const gU = ({ state: i, dispatch: e }) => mU(i, e, !1);
function Ni(i, e) {
  let t = gn(i.state.selection, (r) => {
    let o = e(r);
    return D.range(r.anchor, o.head, o.goalColumn, o.bidiLevel || void 0);
  });
  return t.eq(i.state.selection) ? !1 : (i.dispatch(dr(i.state, t)), !0);
}
function EN(i, e) {
  return Ni(i, (t) => i.moveByChar(t, e));
}
const mN = (i) => EN(i, !yt(i)), gN = (i) => EN(i, yt(i));
function bN(i, e) {
  return Ni(i, (t) => i.moveByGroup(t, e));
}
const bU = (i) => bN(i, !yt(i)), TU = (i) => bN(i, yt(i)), SU = (i) => Ni(i, (e) => Wh(i.state, e, !yt(i))), RU = (i) => Ni(i, (e) => Wh(i.state, e, yt(i)));
function TN(i, e) {
  return Ni(i, (t) => i.moveVertically(t, e));
}
const SN = (i) => TN(i, !1), RN = (i) => TN(i, !0);
function AN(i, e) {
  return Ni(i, (t) => i.moveVertically(t, e, pN(i).height));
}
const wg = (i) => AN(i, !1), yg = (i) => AN(i, !0), AU = (i) => Ni(i, (e) => Io(i, e, !0)), CU = (i) => Ni(i, (e) => Io(i, e, !1)), NU = (i) => Ni(i, (e) => Io(i, e, !yt(i))), IU = (i) => Ni(i, (e) => Io(i, e, yt(i))), vU = (i) => Ni(i, (e) => D.cursor(i.lineBlockAt(e.head).from)), _U = (i) => Ni(i, (e) => D.cursor(i.lineBlockAt(e.head).to)), Dg = ({ state: i, dispatch: e }) => (e(dr(i, { anchor: 0 })), !0), xg = ({ state: i, dispatch: e }) => (e(dr(i, { anchor: i.doc.length })), !0), Mg = ({ state: i, dispatch: e }) => (e(dr(i, { anchor: i.selection.main.anchor, head: 0 })), !0), Ug = ({ state: i, dispatch: e }) => (e(dr(i, { anchor: i.selection.main.anchor, head: i.doc.length })), !0), PU = ({ state: i, dispatch: e }) => (e(i.update({ selection: { anchor: 0, head: i.doc.length }, userEvent: "select" })), !0), LU = ({ state: i, dispatch: e }) => {
  let t = Zh(i).map(({ from: r, to: o }) => D.range(r, Math.min(o + 1, i.doc.length)));
  return e(i.update({ selection: D.create(t), userEvent: "select" })), !0;
}, wU = ({ state: i, dispatch: e }) => {
  let t = gn(i.selection, (r) => {
    var o;
    let s = Be(i).resolveInner(r.head, 1);
    for (; !(s.from < r.from && s.to >= r.to || s.to > r.to && s.from <= r.from || !(!((o = s.parent) === null || o === void 0) && o.parent)); )
      s = s.parent;
    return D.range(s.to, s.from);
  });
  return e(dr(i, t)), !0;
}, yU = ({ state: i, dispatch: e }) => {
  let t = i.selection, r = null;
  return t.ranges.length > 1 ? r = D.create([t.main]) : t.main.empty || (r = D.create([D.cursor(t.main.head)])), r ? (e(dr(i, r)), !0) : !1;
};
function zh(i, e) {
  if (i.state.readOnly)
    return !1;
  let t = "delete.selection", { state: r } = i, o = r.changeByRange((s) => {
    let { from: n, to: a } = s;
    if (n == a) {
      let l = e(n);
      l < n ? (t = "delete.backward", l = Ql(i, l, !1)) : l > n && (t = "delete.forward", l = Ql(i, l, !0)), n = Math.min(n, l), a = Math.max(a, l);
    } else
      n = Ql(i, n, !1), a = Ql(i, a, !0);
    return n == a ? { range: s } : { changes: { from: n, to: a }, range: D.cursor(n) };
  });
  return o.changes.empty ? !1 : (i.dispatch(r.update(o, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? q.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function Ql(i, e, t) {
  if (i instanceof q)
    for (let r of i.state.facet(q.atomicRanges).map((o) => o(i)))
      r.between(e, e, (o, s) => {
        o < e && s > e && (e = t ? s : o);
      });
  return e;
}
const CN = (i, e) => zh(i, (t) => {
  let { state: r } = i, o = r.doc.lineAt(t), s, n;
  if (!e && t > o.from && t < o.from + 200 && !/[^ \t]/.test(s = o.text.slice(0, t - o.from))) {
    if (s[s.length - 1] == "	")
      return t - 1;
    let a = qa(s, r.tabSize), l = a % Fu(r) || Fu(r);
    for (let u = 0; u < l && s[s.length - 1 - u] == " "; u++)
      t--;
    n = t;
  } else
    n = $t(o.text, t - o.from, e, e) + o.from, n == t && o.number != (e ? r.doc.lines : 1) && (n += e ? 1 : -1);
  return n;
}), wf = (i) => CN(i, !1), NN = (i) => CN(i, !0), IN = (i, e) => zh(i, (t) => {
  let r = t, { state: o } = i, s = o.doc.lineAt(r), n = o.charCategorizer(r);
  for (let a = null; ; ) {
    if (r == (e ? s.to : s.from)) {
      r == t && s.number != (e ? o.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let l = $t(s.text, r - s.from, e) + s.from, u = s.text.slice(Math.min(r, l) - s.from, Math.max(r, l) - s.from), h = n(u);
    if (a != null && h != a)
      break;
    (u != " " || r != t) && (a = h), r = l;
  }
  return r;
}), vN = (i) => IN(i, !1), DU = (i) => IN(i, !0), _N = (i) => zh(i, (e) => {
  let t = i.lineBlockAt(e).to;
  return e < t ? t : Math.min(i.state.doc.length, e + 1);
}), xU = (i) => zh(i, (e) => {
  let t = i.lineBlockAt(e).from;
  return e > t ? t : Math.max(0, e - 1);
}), MU = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = i.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: Ce.of(["", ""]) },
    range: D.cursor(r.from)
  }));
  return e(i.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, UU = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = i.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == i.doc.length)
      return { range: r };
    let o = r.from, s = i.doc.lineAt(o), n = o == s.from ? o - 1 : $t(s.text, o - s.from, !1) + s.from, a = o == s.to ? o + 1 : $t(s.text, o - s.from, !0) + s.from;
    return {
      changes: { from: n, to: a, insert: i.doc.slice(o, a).append(i.doc.slice(n, o)) },
      range: D.cursor(a)
    };
  });
  return t.changes.empty ? !1 : (e(i.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Zh(i) {
  let e = [], t = -1;
  for (let r of i.selection.ranges) {
    let o = i.doc.lineAt(r.from), s = i.doc.lineAt(r.to);
    if (!r.empty && r.to == s.from && (s = i.doc.lineAt(r.to - 1)), t >= o.number) {
      let n = e[e.length - 1];
      n.to = s.to, n.ranges.push(r);
    } else
      e.push({ from: o.from, to: s.to, ranges: [r] });
    t = s.number + 1;
  }
  return e;
}
function PN(i, e, t) {
  if (i.readOnly)
    return !1;
  let r = [], o = [];
  for (let s of Zh(i)) {
    if (t ? s.to == i.doc.length : s.from == 0)
      continue;
    let n = i.doc.lineAt(t ? s.to + 1 : s.from - 1), a = n.length + 1;
    if (t) {
      r.push({ from: s.to, to: n.to }, { from: s.from, insert: n.text + i.lineBreak });
      for (let l of s.ranges)
        o.push(D.range(Math.min(i.doc.length, l.anchor + a), Math.min(i.doc.length, l.head + a)));
    } else {
      r.push({ from: n.from, to: s.from }, { from: s.to, insert: i.lineBreak + n.text });
      for (let l of s.ranges)
        o.push(D.range(l.anchor - a, l.head - a));
    }
  }
  return r.length ? (e(i.update({
    changes: r,
    scrollIntoView: !0,
    selection: D.create(o, i.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const QU = ({ state: i, dispatch: e }) => PN(i, e, !1), kU = ({ state: i, dispatch: e }) => PN(i, e, !0);
function LN(i, e, t) {
  if (i.readOnly)
    return !1;
  let r = [];
  for (let o of Zh(i))
    t ? r.push({ from: o.from, insert: i.doc.slice(o.from, o.to) + i.lineBreak }) : r.push({ from: o.to, insert: i.lineBreak + i.doc.slice(o.from, o.to) });
  return e(i.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const $U = ({ state: i, dispatch: e }) => LN(i, e, !1), GU = ({ state: i, dispatch: e }) => LN(i, e, !0), VU = (i) => {
  if (i.state.readOnly)
    return !1;
  let { state: e } = i, t = e.changes(Zh(e).map(({ from: o, to: s }) => (o > 0 ? o-- : s < e.doc.length && s++, { from: o, to: s }))), r = gn(e.selection, (o) => i.moveVertically(o, !0)).map(t);
  return i.dispatch({ changes: t, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function HU(i, e) {
  if (/\(\)|\[\]|\{\}/.test(i.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = Be(i).resolveInner(e), r = t.childBefore(e), o = t.childAfter(e), s;
  return r && o && r.to <= e && o.from >= e && (s = r.type.prop(Oe.closedBy)) && s.indexOf(o.name) > -1 && i.doc.lineAt(r.to).from == i.doc.lineAt(o.from).from ? { from: r.to, to: o.from } : null;
}
const XU = /* @__PURE__ */ wN(!1), YU = /* @__PURE__ */ wN(!0);
function wN(i) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((o) => {
      let { from: s, to: n } = o, a = e.doc.lineAt(s), l = !i && s == n && HU(e, s);
      i && (s = n = (n <= a.to ? a : e.doc.lineAt(n)).to);
      let u = new Hh(e, { simulateBreak: s, simulateDoubleBreak: !!l }), h = dO(u, s);
      for (h == null && (h = /^\s*/.exec(e.doc.lineAt(s).text)[0].length); n < a.to && /\s/.test(a.text[n - a.from]); )
        n++;
      l ? { from: s, to: n } = l : s > a.from && s < a.from + 100 && !/\S/.test(a.text.slice(0, s)) && (s = a.from);
      let c = ["", Qa(e, h)];
      return l && c.push(Qa(e, u.lineIndent(a.from, -1))), {
        changes: { from: s, to: n, insert: Ce.of(c) },
        range: D.cursor(s + 1 + c[1].length)
      };
    });
    return t(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function EO(i, e) {
  let t = -1;
  return i.changeByRange((r) => {
    let o = [];
    for (let n = r.from; n <= r.to; ) {
      let a = i.doc.lineAt(n);
      a.number > t && (r.empty || r.to > a.from) && (e(a, o, r), t = a.number), n = a.to + 1;
    }
    let s = i.changes(o);
    return {
      changes: o,
      range: D.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))
    };
  });
}
const BU = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), r = new Hh(i, { overrideIndentation: (s) => {
    let n = t[s];
    return n ?? -1;
  } }), o = EO(i, (s, n, a) => {
    let l = dO(r, s.from);
    if (l == null)
      return;
    /\S/.test(s.text) || (l = 0);
    let u = /^\s*/.exec(s.text)[0], h = Qa(i, l);
    (u != h || a.from < s.from + u.length) && (t[s.from] = l, n.push({ from: s.from, to: s.from + u.length, insert: h }));
  });
  return o.changes.empty || e(i.update(o, { userEvent: "indent" })), !0;
}, FU = ({ state: i, dispatch: e }) => i.readOnly ? !1 : (e(i.update(EO(i, (t, r) => {
  r.push({ from: t.from, insert: i.facet(Vh) });
}), { userEvent: "input.indent" })), !0), WU = ({ state: i, dispatch: e }) => i.readOnly ? !1 : (e(i.update(EO(i, (t, r) => {
  let o = /^\s*/.exec(t.text)[0];
  if (!o)
    return;
  let s = qa(o, i.tabSize), n = 0, a = Qa(i, Math.max(0, s - Fu(i)));
  for (; n < o.length && n < a.length && o.charCodeAt(n) == a.charCodeAt(n); )
    n++;
  r.push({ from: t.from + n, to: t.from + o.length, insert: a.slice(n) });
}), { userEvent: "delete.dedent" })), !0), zU = [
  { key: "Ctrl-b", run: lN, shift: mN, preventDefault: !0 },
  { key: "Ctrl-f", run: uN, shift: gN },
  { key: "Ctrl-p", run: dN, shift: SN },
  { key: "Ctrl-n", run: fN, shift: RN },
  { key: "Ctrl-a", run: OU, shift: vU },
  { key: "Ctrl-e", run: EU, shift: _U },
  { key: "Ctrl-d", run: NN },
  { key: "Ctrl-h", run: wf },
  { key: "Ctrl-k", run: _N },
  { key: "Ctrl-Alt-h", run: vN },
  { key: "Ctrl-o", run: MU },
  { key: "Ctrl-t", run: UU },
  { key: "Ctrl-v", run: Lf }
], ZU = /* @__PURE__ */ [
  { key: "ArrowLeft", run: lN, shift: mN, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: nU, shift: bU, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: fU, shift: NU, preventDefault: !0 },
  { key: "ArrowRight", run: uN, shift: gN, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: aU, shift: TU, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: pU, shift: IU, preventDefault: !0 },
  { key: "ArrowUp", run: dN, shift: SN, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Dg, shift: Mg },
  { mac: "Ctrl-ArrowUp", run: Lg, shift: wg },
  { key: "ArrowDown", run: fN, shift: RN, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: xg, shift: Ug },
  { mac: "Ctrl-ArrowDown", run: Lf, shift: yg },
  { key: "PageUp", run: Lg, shift: wg },
  { key: "PageDown", run: Lf, shift: yg },
  { key: "Home", run: dU, shift: CU, preventDefault: !0 },
  { key: "Mod-Home", run: Dg, shift: Mg },
  { key: "End", run: cU, shift: AU, preventDefault: !0 },
  { key: "Mod-End", run: xg, shift: Ug },
  { key: "Enter", run: XU },
  { key: "Mod-a", run: PU },
  { key: "Backspace", run: wf, shift: wf },
  { key: "Delete", run: NN },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: vN },
  { key: "Mod-Delete", mac: "Alt-Delete", run: DU },
  { mac: "Mod-Backspace", run: xU },
  { mac: "Mod-Delete", run: _N }
].concat(/* @__PURE__ */ zU.map((i) => ({ mac: i.key, run: i.run, shift: i.shift }))), yN = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: uU, shift: SU },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: hU, shift: RU },
  { key: "Alt-ArrowUp", run: QU },
  { key: "Shift-Alt-ArrowUp", run: $U },
  { key: "Alt-ArrowDown", run: kU },
  { key: "Shift-Alt-ArrowDown", run: GU },
  { key: "Escape", run: yU },
  { key: "Mod-Enter", run: YU },
  { key: "Alt-l", mac: "Ctrl-l", run: LU },
  { key: "Mod-i", run: wU, preventDefault: !0 },
  { key: "Mod-[", run: WU },
  { key: "Mod-]", run: FU },
  { key: "Mod-Alt-\\", run: BU },
  { key: "Shift-Mod-k", run: VU },
  { key: "Shift-Mod-\\", run: gU },
  { key: "Mod-/", run: GM },
  { key: "Alt-A", run: HM }
].concat(ZU);
function De() {
  var i = arguments[0];
  typeof i == "string" && (i = document.createElement(i));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var r in t)
      if (Object.prototype.hasOwnProperty.call(t, r)) {
        var o = t[r];
        typeof o == "string" ? i.setAttribute(r, o) : o != null && (i[r] = o);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    DN(i, arguments[e]);
  return i;
}
function DN(i, e) {
  if (typeof e == "string")
    i.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      i.appendChild(e);
    else if (Array.isArray(e))
      for (var t = 0; t < e.length; t++)
        DN(i, e[t]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const Qg = typeof String.prototype.normalize == "function" ? (i) => i.normalize("NFKD") : (i) => i;
class hn {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, r = 0, o = e.length, s, n) {
    this.test = n, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, o), this.bufferStart = r, this.normalize = s ? (a) => s(Qg(a)) : Qg, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return mt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = Zp(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += mi(e);
      let o = this.normalize(t);
      for (let s = 0, n = r; ; s++) {
        let a = o.charCodeAt(s), l = this.match(a, n);
        if (l)
          return this.value = l, this;
        if (s == o.length - 1)
          break;
        n == r && s < t.length && t.charCodeAt(s) == a && n++;
      }
    }
  }
  match(e, t) {
    let r = null;
    for (let o = 0; o < this.matches.length; o += 2) {
      let s = this.matches[o], n = !1;
      this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? r = { from: this.matches[o + 1], to: t + 1 } : (this.matches[o]++, n = !0)), n || (this.matches.splice(o, 2), o -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? r = { from: t, to: t + 1 } : this.matches.push(1, t)), r && this.test && !this.test(r.from, r.to, this.buffer, this.bufferPos) && (r = null), r;
  }
}
typeof Symbol < "u" && (hn.prototype[Symbol.iterator] = function() {
  return this;
});
const xN = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, mO = "gm" + (/x/.unicode == null ? "" : "u");
class MN {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, r, o = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = xN, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new UN(e, t, r, o, s);
    this.re = new RegExp(t, mO + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.iter = e.iter();
    let n = e.lineAt(o);
    this.curLineStart = n.from, this.matchPos = qu(e, o), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let r = this.curLineStart + t.index, o = r + t[0].length;
        if (this.matchPos = qu(this.text, o + (r == o ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < o || r > this.value.to) && (!this.test || this.test(r, o, t)))
          return this.value = { from: r, to: o, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Xc = /* @__PURE__ */ new WeakMap();
class Bs {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, r) {
    let o = Xc.get(e);
    if (!o || o.from >= r || o.to <= t) {
      let a = new Bs(t, e.sliceString(t, r));
      return Xc.set(e, a), a;
    }
    if (o.from == t && o.to == r)
      return o;
    let { text: s, from: n } = o;
    return n > t && (s = e.sliceString(t, n) + s, n = t), o.to < r && (s += e.sliceString(o.to, r)), Xc.set(e, new Bs(n, s)), new Bs(t, s.slice(t - n, r - n));
  }
}
class UN {
  constructor(e, t, r, o, s) {
    this.text = e, this.to = s, this.done = !1, this.value = xN, this.matchPos = qu(e, o), this.re = new RegExp(t, mO + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.flat = Bs.get(e, o, this.chunkEnd(
      o + 5e3
      /* Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let r = this.flat.from + t.index, o = r + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, o, t)))
          return this.value = { from: r, to: o, match: t }, this.matchPos = qu(this.text, o + (r == o ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Bs.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (MN.prototype[Symbol.iterator] = UN.prototype[Symbol.iterator] = function() {
  return this;
});
function qU(i) {
  try {
    return new RegExp(i, mO), !0;
  } catch {
    return !1;
  }
}
function qu(i, e) {
  if (e >= i.length)
    return e;
  let t = i.lineAt(e), r;
  for (; e < t.to && (r = t.text.charCodeAt(e - t.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function yf(i) {
  let e = De("input", { class: "cm-textfield", name: "line" }), t = De("form", {
    class: "cm-gotoLine",
    onkeydown: (o) => {
      o.keyCode == 27 ? (o.preventDefault(), i.dispatch({ effects: ju.of(!1) }), i.focus()) : o.keyCode == 13 && (o.preventDefault(), r());
    },
    onsubmit: (o) => {
      o.preventDefault(), r();
    }
  }, De("label", i.state.phrase("Go to line"), ": ", e), " ", De("button", { class: "cm-button", type: "submit" }, i.state.phrase("go")));
  function r() {
    let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value);
    if (!o)
      return;
    let { state: s } = i, n = s.doc.lineAt(s.selection.main.head), [, a, l, u, h] = o, c = u ? +u.slice(1) : 0, d = l ? +l : n.number;
    if (l && h) {
      let p = d / 100;
      a && (p = p * (a == "-" ? -1 : 1) + n.number / s.doc.lines), d = Math.round(s.doc.lines * p);
    } else
      l && a && (d = d * (a == "-" ? -1 : 1) + n.number);
    let f = s.doc.line(Math.max(1, Math.min(s.doc.lines, d)));
    i.dispatch({
      effects: ju.of(!1),
      selection: D.cursor(f.from + Math.max(0, Math.min(c, f.length))),
      scrollIntoView: !0
    }), i.focus();
  }
  return { dom: t };
}
const ju = /* @__PURE__ */ fe.define(), kg = /* @__PURE__ */ ct.define({
  create() {
    return !0;
  },
  update(i, e) {
    for (let t of e.effects)
      t.is(ju) && (i = t.value);
    return i;
  },
  provide: (i) => Ma.from(i, (e) => e ? yf : null)
}), jU = (i) => {
  let e = xa(i, yf);
  if (!e) {
    let t = [ju.of(!0)];
    i.state.field(kg, !1) == null && t.push(fe.appendConfig.of([kg, KU])), i.dispatch({ effects: t }), e = xa(i, yf);
  }
  return e && e.dom.querySelector("input").focus(), !0;
}, KU = /* @__PURE__ */ q.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), JU = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, QN = /* @__PURE__ */ K.define({
  combine(i) {
    return cr(i, JU, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function eQ(i) {
  let e = [sQ, oQ];
  return i && e.push(QN.of(i)), e;
}
const tQ = /* @__PURE__ */ ie.mark({ class: "cm-selectionMatch" }), iQ = /* @__PURE__ */ ie.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function $g(i, e, t, r) {
  return (t == 0 || i(e.sliceDoc(t - 1, t)) != $e.Word) && (r == e.doc.length || i(e.sliceDoc(r, r + 1)) != $e.Word);
}
function rQ(i, e, t, r) {
  return i(e.sliceDoc(t, t + 1)) == $e.Word && i(e.sliceDoc(r - 1, r)) == $e.Word;
}
const oQ = /* @__PURE__ */ lt.fromClass(class {
  constructor(i) {
    this.decorations = this.getDeco(i);
  }
  update(i) {
    (i.selectionSet || i.docChanged || i.viewportChanged) && (this.decorations = this.getDeco(i.view));
  }
  getDeco(i) {
    let e = i.state.facet(QN), { state: t } = i, r = t.selection;
    if (r.ranges.length > 1)
      return ie.none;
    let o = r.main, s, n = null;
    if (o.empty) {
      if (!e.highlightWordAroundCursor)
        return ie.none;
      let l = t.wordAt(o.head);
      if (!l)
        return ie.none;
      n = t.charCategorizer(o.head), s = t.sliceDoc(l.from, l.to);
    } else {
      let l = o.to - o.from;
      if (l < e.minSelectionLength || l > 200)
        return ie.none;
      if (e.wholeWords) {
        if (s = t.sliceDoc(o.from, o.to), n = t.charCategorizer(o.head), !($g(n, t, o.from, o.to) && rQ(n, t, o.from, o.to)))
          return ie.none;
      } else if (s = t.sliceDoc(o.from, o.to).trim(), !s)
        return ie.none;
    }
    let a = [];
    for (let l of i.visibleRanges) {
      let u = new hn(t.doc, s, l.from, l.to);
      for (; !u.next().done; ) {
        let { from: h, to: c } = u.value;
        if ((!n || $g(n, t, h, c)) && (o.empty && h <= o.from && c >= o.to ? a.push(iQ.range(h, c)) : (h >= o.to || c <= o.from) && a.push(tQ.range(h, c)), a.length > e.maxMatches))
          return ie.none;
      }
    }
    return ie.set(a);
  }
}, {
  decorations: (i) => i.decorations
}), sQ = /* @__PURE__ */ q.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), nQ = ({ state: i, dispatch: e }) => {
  let { selection: t } = i, r = D.create(t.ranges.map((o) => i.wordAt(o.head) || D.cursor(o.head)), t.mainIndex);
  return r.eq(t) ? !1 : (e(i.update({ selection: r })), !0);
};
function aQ(i, e) {
  let { main: t, ranges: r } = i.selection, o = i.wordAt(t.head), s = o && o.from == t.from && o.to == t.to;
  for (let n = !1, a = new hn(i.doc, e, r[r.length - 1].to); ; )
    if (a.next(), a.done) {
      if (n)
        return null;
      a = new hn(i.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), n = !0;
    } else {
      if (n && r.some((l) => l.from == a.value.from))
        continue;
      if (s) {
        let l = i.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const lQ = ({ state: i, dispatch: e }) => {
  let { ranges: t } = i.selection;
  if (t.some((s) => s.from === s.to))
    return nQ({ state: i, dispatch: e });
  let r = i.sliceDoc(t[0].from, t[0].to);
  if (i.selection.ranges.some((s) => i.sliceDoc(s.from, s.to) != r))
    return !1;
  let o = aQ(i, r);
  return o ? (e(i.update({
    selection: i.selection.addRange(D.range(o.from, o.to), !1),
    effects: q.scrollIntoView(o.to)
  })), !0) : !1;
}, bn = /* @__PURE__ */ K.define({
  combine(i) {
    return cr(i, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new TQ(e),
      scrollToMatch: (e) => q.scrollIntoView(e)
    });
  }
});
class kN {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || qU(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new dQ(this) : new hQ(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, r) {
    let o = e.doc ? e : Re.create({ doc: e });
    return r == null && (r = o.doc.length), this.regexp ? _s(this, o, t, r) : vs(this, o, t, r);
  }
}
class $N {
  constructor(e) {
    this.spec = e;
  }
}
function vs(i, e, t, r) {
  return new hn(e.doc, i.unquoted, t, r, i.caseSensitive ? void 0 : (o) => o.toLowerCase(), i.wholeWord ? uQ(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function uQ(i, e) {
  return (t, r, o, s) => ((s > t || s + o.length < r) && (s = Math.max(0, t - 2), o = i.sliceString(s, Math.min(i.length, r + 2))), (e(Ku(o, t - s)) != $e.Word || e(Ju(o, t - s)) != $e.Word) && (e(Ju(o, r - s)) != $e.Word || e(Ku(o, r - s)) != $e.Word));
}
class hQ extends $N {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, r) {
    let o = vs(this.spec, e, r, e.doc.length).nextOverlapping();
    return o.done && (o = vs(this.spec, e, 0, t).nextOverlapping()), o.done ? null : o.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, r) {
    for (let o = r; ; ) {
      let s = Math.max(t, o - 1e4 - this.spec.unquoted.length), n = vs(this.spec, e, s, o), a = null;
      for (; !n.nextOverlapping().done; )
        a = n.value;
      if (a)
        return a;
      if (s == t)
        return null;
      o -= 1e4;
    }
  }
  prevMatch(e, t, r) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let r = vs(this.spec, e, 0, e.doc.length), o = [];
    for (; !r.next().done; ) {
      if (o.length >= t)
        return null;
      o.push(r.value);
    }
    return o;
  }
  highlight(e, t, r, o) {
    let s = vs(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      o(s.value.from, s.value.to);
  }
}
function _s(i, e, t, r) {
  return new MN(e.doc, i.search, {
    ignoreCase: !i.caseSensitive,
    test: i.wholeWord ? cQ(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, r);
}
function Ku(i, e) {
  return i.slice($t(i, e, !1), e);
}
function Ju(i, e) {
  return i.slice(e, $t(i, e));
}
function cQ(i) {
  return (e, t, r) => !r[0].length || (i(Ku(r.input, r.index)) != $e.Word || i(Ju(r.input, r.index)) != $e.Word) && (i(Ju(r.input, r.index + r[0].length)) != $e.Word || i(Ku(r.input, r.index + r[0].length)) != $e.Word);
}
class dQ extends $N {
  nextMatch(e, t, r) {
    let o = _s(this.spec, e, r, e.doc.length).next();
    return o.done && (o = _s(this.spec, e, 0, t).next()), o.done ? null : o.value;
  }
  prevMatchInRange(e, t, r) {
    for (let o = 1; ; o++) {
      let s = Math.max(
        t,
        r - o * 1e4
        /* ChunkSize */
      ), n = _s(this.spec, e, s, r), a = null;
      for (; !n.next().done; )
        a = n.value;
      if (a && (s == t || a.from > s + 10))
        return a;
      if (s == t)
        return null;
    }
  }
  prevMatch(e, t, r) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (t, r) => r == "$" ? "$" : r == "&" ? e.match[0] : r != "0" && +r < e.match.length ? e.match[r] : t));
  }
  matchAll(e, t) {
    let r = _s(this.spec, e, 0, e.doc.length), o = [];
    for (; !r.next().done; ) {
      if (o.length >= t)
        return null;
      o.push(r.value);
    }
    return o;
  }
  highlight(e, t, r, o) {
    let s = _s(this.spec, e, Math.max(
      0,
      t - 250
      /* HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !s.next().done; )
      o(s.value.from, s.value.to);
  }
}
const ka = /* @__PURE__ */ fe.define(), gO = /* @__PURE__ */ fe.define(), so = /* @__PURE__ */ ct.define({
  create(i) {
    return new Yc(Df(i).create(), null);
  },
  update(i, e) {
    for (let t of e.effects)
      t.is(ka) ? i = new Yc(t.value.create(), i.panel) : t.is(gO) && (i = new Yc(i.query, t.value ? bO : null));
    return i;
  },
  provide: (i) => Ma.from(i, (e) => e.panel)
});
class Yc {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const fQ = /* @__PURE__ */ ie.mark({ class: "cm-searchMatch" }), pQ = /* @__PURE__ */ ie.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), OQ = /* @__PURE__ */ lt.fromClass(class {
  constructor(i) {
    this.view = i, this.decorations = this.highlight(i.state.field(so));
  }
  update(i) {
    let e = i.state.field(so);
    (e != i.startState.field(so) || i.docChanged || i.selectionSet || i.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: i, panel: e }) {
    if (!e || !i.spec.valid)
      return ie.none;
    let { view: t } = this, r = new Eo();
    for (let o = 0, s = t.visibleRanges, n = s.length; o < n; o++) {
      let { from: a, to: l } = s[o];
      for (; o < n - 1 && l > s[o + 1].from - 2 * 250; )
        l = s[++o].to;
      i.highlight(t.state, a, l, (u, h) => {
        let c = t.state.selection.ranges.some((d) => d.from == u && d.to == h);
        r.add(u, h, c ? pQ : fQ);
      });
    }
    return r.finish();
  }
}, {
  decorations: (i) => i.decorations
});
function il(i) {
  return (e) => {
    let t = e.state.field(so, !1);
    return t && t.query.spec.valid ? i(e, t) : HN(e);
  };
}
const eh = /* @__PURE__ */ il((i, { query: e }) => {
  let { to: t } = i.state.selection.main, r = e.nextMatch(i.state, t, t);
  if (!r)
    return !1;
  let o = D.single(r.from, r.to), s = i.state.facet(bn);
  return i.dispatch({
    selection: o,
    effects: [TO(i, r), s.scrollToMatch(o.main, i)],
    userEvent: "select.search"
  }), VN(i), !0;
}), th = /* @__PURE__ */ il((i, { query: e }) => {
  let { state: t } = i, { from: r } = t.selection.main, o = e.prevMatch(t, r, r);
  if (!o)
    return !1;
  let s = D.single(o.from, o.to), n = i.state.facet(bn);
  return i.dispatch({
    selection: s,
    effects: [TO(i, o), n.scrollToMatch(s.main, i)],
    userEvent: "select.search"
  }), VN(i), !0;
}), EQ = /* @__PURE__ */ il((i, { query: e }) => {
  let t = e.matchAll(i.state, 1e3);
  return !t || !t.length ? !1 : (i.dispatch({
    selection: D.create(t.map((r) => D.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), mQ = ({ state: i, dispatch: e }) => {
  let t = i.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: r, to: o } = t.main, s = [], n = 0;
  for (let a = new hn(i.doc, i.sliceDoc(r, o)); !a.next().done; ) {
    if (s.length > 1e3)
      return !1;
    a.value.from == r && (n = s.length), s.push(D.range(a.value.from, a.value.to));
  }
  return e(i.update({
    selection: D.create(s, n),
    userEvent: "select.search.matches"
  })), !0;
}, Gg = /* @__PURE__ */ il((i, { query: e }) => {
  let { state: t } = i, { from: r, to: o } = t.selection.main;
  if (t.readOnly)
    return !1;
  let s = e.nextMatch(t, r, r);
  if (!s)
    return !1;
  let n = [], a, l, u = [];
  if (s.from == r && s.to == o && (l = t.toText(e.getReplacement(s)), n.push({ from: s.from, to: s.to, insert: l }), s = e.nextMatch(t, s.from, s.to), u.push(q.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(r).number) + "."))), s) {
    let h = n.length == 0 || n[0].from >= s.to ? 0 : s.to - s.from - l.length;
    a = D.single(s.from - h, s.to - h), u.push(TO(i, s)), u.push(t.facet(bn).scrollToMatch(a.main, i));
  }
  return i.dispatch({
    changes: n,
    selection: a,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), gQ = /* @__PURE__ */ il((i, { query: e }) => {
  if (i.state.readOnly)
    return !1;
  let t = e.matchAll(i.state, 1e9).map((o) => {
    let { from: s, to: n } = o;
    return { from: s, to: n, insert: e.getReplacement(o) };
  });
  if (!t.length)
    return !1;
  let r = i.state.phrase("replaced $ matches", t.length) + ".";
  return i.dispatch({
    changes: t,
    effects: q.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function bO(i) {
  return i.state.facet(bn).createPanel(i);
}
function Df(i, e) {
  var t, r, o, s, n;
  let a = i.selection.main, l = a.empty || a.to > a.from + 100 ? "" : i.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let u = i.facet(bn);
  return new kN({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : u.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0 ? r : u.caseSensitive,
    literal: (o = e == null ? void 0 : e.literal) !== null && o !== void 0 ? o : u.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : u.regexp,
    wholeWord: (n = e == null ? void 0 : e.wholeWord) !== null && n !== void 0 ? n : u.wholeWord
  });
}
function GN(i) {
  let e = xa(i, bO);
  return e && e.dom.querySelector("[main-field]");
}
function VN(i) {
  let e = GN(i);
  e && e == i.root.activeElement && e.select();
}
const HN = (i) => {
  let e = i.state.field(so, !1);
  if (e && e.panel) {
    let t = GN(i);
    if (t && t != i.root.activeElement) {
      let r = Df(i.state, e.query.spec);
      r.valid && i.dispatch({ effects: ka.of(r) }), t.focus(), t.select();
    }
  } else
    i.dispatch({ effects: [
      gO.of(!0),
      e ? ka.of(Df(i.state, e.query.spec)) : fe.appendConfig.of(RQ)
    ] });
  return !0;
}, XN = (i) => {
  let e = i.state.field(so, !1);
  if (!e || !e.panel)
    return !1;
  let t = xa(i, bO);
  return t && t.dom.contains(i.root.activeElement) && i.focus(), i.dispatch({ effects: gO.of(!1) }), !0;
}, bQ = [
  { key: "Mod-f", run: HN, scope: "editor search-panel" },
  { key: "F3", run: eh, shift: th, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: eh, shift: th, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: XN, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: mQ },
  { key: "Alt-g", run: jU },
  { key: "Mod-d", run: lQ, preventDefault: !0 }
];
class TQ {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(so).query.spec;
    this.commit = this.commit.bind(this), this.searchField = De("input", {
      value: t.search,
      placeholder: Jt(e, "Find"),
      "aria-label": Jt(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = De("input", {
      value: t.replace,
      placeholder: Jt(e, "Replace"),
      "aria-label": Jt(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = De("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = De("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = De("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function r(o, s, n) {
      return De("button", { class: "cm-button", name: o, onclick: s, type: "button" }, n);
    }
    this.dom = De("div", { onkeydown: (o) => this.keydown(o), class: "cm-search" }, [
      this.searchField,
      r("next", () => eh(e), [Jt(e, "next")]),
      r("prev", () => th(e), [Jt(e, "previous")]),
      r("select", () => EQ(e), [Jt(e, "all")]),
      De("label", null, [this.caseField, Jt(e, "match case")]),
      De("label", null, [this.reField, Jt(e, "regexp")]),
      De("label", null, [this.wordField, Jt(e, "by word")]),
      ...e.state.readOnly ? [] : [
        De("br"),
        this.replaceField,
        r("replace", () => Gg(e), [Jt(e, "replace")]),
        r("replaceAll", () => gQ(e), [Jt(e, "replace all")])
      ],
      De("button", {
        name: "close",
        onclick: () => XN(e),
        "aria-label": Jt(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new kN({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: ka.of(e) }));
  }
  keydown(e) {
    yD(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? th : eh)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Gg(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(ka) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(bn).top;
  }
}
function Jt(i, e) {
  return i.state.phrase(e);
}
const kl = 30, $l = /[\s\.,:;?!]/;
function TO(i, { from: e, to: t }) {
  let r = i.state.doc.lineAt(e), o = i.state.doc.lineAt(t).to, s = Math.max(r.from, e - kl), n = Math.min(o, t + kl), a = i.state.sliceDoc(s, n);
  if (s != r.from) {
    for (let l = 0; l < kl; l++)
      if (!$l.test(a[l + 1]) && $l.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (n != o) {
    for (let l = a.length - 1; l > a.length - kl; l--)
      if (!$l.test(a[l - 1]) && $l.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return q.announce.of(`${i.state.phrase("current match")}. ${a} ${i.state.phrase("on line")} ${r.number}.`);
}
const SQ = /* @__PURE__ */ q.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), RQ = [
  so,
  /* @__PURE__ */ ds.lowest(OQ),
  SQ
];
class YN {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, r) {
    this.state = e, this.pos = t, this.explicit = r, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = Be(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), r = Math.max(t.from, this.pos - 250), o = t.text.slice(r - t.from, this.pos - t.from), s = o.search(FN(e, !1));
    return s < 0 ? null : { from: r + s, to: this.pos, text: o.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, t) {
    e == "abort" && this.abortListeners && this.abortListeners.push(t);
  }
}
function Vg(i) {
  let e = Object.keys(i).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function AQ(i) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: o } of i) {
    e[o[0]] = !0;
    for (let s = 1; s < o.length; s++)
      t[o[s]] = !0;
  }
  let r = Vg(e) + Vg(t) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function SO(i) {
  let e = i.map((o) => typeof o == "string" ? { label: o } : o), [t, r] = e.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : AQ(e);
  return (o) => {
    let s = o.matchBefore(r);
    return s || o.explicit ? { from: s ? s.from : o.pos, options: e, validFor: t } : null;
  };
}
function BN(i, e) {
  return (t) => {
    for (let r = Be(t.state).resolveInner(t.pos, -1); r; r = r.parent) {
      if (i.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(t);
  };
}
class Hg {
  constructor(e, t, r, o) {
    this.completion = e, this.source = t, this.match = r, this.score = o;
  }
}
function no(i) {
  return i.selection.main.from;
}
function FN(i, e) {
  var t;
  let { source: r } = i, o = e && r[0] != "^", s = r[r.length - 1] != "$";
  return !o && !s ? i : new RegExp(`${o ? "^" : ""}(?:${r})${s ? "$" : ""}`, (t = i.flags) !== null && t !== void 0 ? t : i.ignoreCase ? "i" : "");
}
const WN = /* @__PURE__ */ Mr.define();
function CQ(i, e, t, r) {
  let { main: o } = i.selection, s = t - o.from, n = r - o.from;
  return Object.assign(Object.assign({}, i.changeByRange((a) => a != o && t != r && i.sliceDoc(a.from + s, a.from + n) != i.sliceDoc(t, r) ? { range: a } : {
    changes: { from: a.from + s, to: r == o.from ? a.to : a.from + n, insert: e },
    range: D.cursor(a.from + s + e.length)
  })), { userEvent: "input.complete" });
}
const Xg = /* @__PURE__ */ new WeakMap();
function NQ(i) {
  if (!Array.isArray(i))
    return i;
  let e = Xg.get(i);
  return e || Xg.set(i, e = SO(i)), e;
}
const RO = /* @__PURE__ */ fe.define(), $a = /* @__PURE__ */ fe.define();
class IQ {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [];
    for (let t = 0; t < e.length; ) {
      let r = mt(e, t), o = mi(r);
      this.chars.push(r);
      let s = e.slice(t, t + o), n = s.toUpperCase();
      this.folded.push(mt(n == s ? s.toLowerCase() : n, 0)), t += o;
    }
    this.astral = e.length != this.chars.length;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return null for no match, and otherwise an array that starts
  // with the match score, followed by any number of `from, to` pairs
  // indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return [
        -100
        /* NotFull */
      ];
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: r, any: o, precise: s, byWord: n } = this;
    if (t.length == 1) {
      let g = mt(e, 0), A = mi(g), S = A == e.length ? 0 : -100;
      if (g != t[0])
        if (g == r[0])
          S += -200;
        else
          return null;
      return [S, 0, A];
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return [e.length == this.pattern.length ? 0 : -100, 0, this.pattern.length];
    let l = t.length, u = 0;
    if (a < 0) {
      for (let g = 0, A = Math.min(e.length, 200); g < A && u < l; ) {
        let S = mt(e, g);
        (S == t[u] || S == r[u]) && (o[u++] = g), g += mi(S);
      }
      if (u < l)
        return null;
    }
    let h = 0, c = 0, d = !1, f = 0, p = -1, O = -1, m = /[a-z]/.test(e), E = !0;
    for (let g = 0, A = Math.min(e.length, 200), S = 0; g < A && c < l; ) {
      let R = mt(e, g);
      a < 0 && (h < l && R == t[h] && (s[h++] = g), f < l && (R == t[f] || R == r[f] ? (f == 0 && (p = g), O = g + 1, f++) : f = 0));
      let v, I = R < 255 ? R >= 48 && R <= 57 || R >= 97 && R <= 122 ? 2 : R >= 65 && R <= 90 ? 1 : 0 : (v = Zp(R)) != v.toLowerCase() ? 1 : v != v.toUpperCase() ? 2 : 0;
      (!g || I == 1 && m || S == 0 && I != 0) && (t[c] == R || r[c] == R && (d = !0) ? n[c++] = g : n.length && (E = !1)), S = I, g += mi(R);
    }
    return c == l && n[0] == 0 && E ? this.result(-100 + (d ? -200 : 0), n, e) : f == l && p == 0 ? [-200 - e.length + (O == e.length ? 0 : -100), 0, O] : a > -1 ? [-700 - e.length, a, a + this.pattern.length] : f == l ? [-200 + -700 - e.length, p, O] : c == l ? this.result(-100 + (d ? -200 : 0) + -700 + (E ? 0 : -1100), n, e) : t.length == 2 ? null : this.result((o[0] ? -700 : 0) + -200 + -1100, o, e);
  }
  result(e, t, r) {
    let o = [e - r.length], s = 1;
    for (let n of t) {
      let a = n + (this.astral ? mi(mt(r, n)) : 1);
      s > 1 && o[s - 1] == n ? o[s - 1] = a : (o[s++] = n, o[s++] = a);
    }
    return o;
  }
}
const zt = /* @__PURE__ */ K.define({
  combine(i) {
    return cr(i, {
      activateOnTyping: !0,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: vQ,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (r) => Yg(e(r), t(r)),
      optionClass: (e, t) => (r) => Yg(e(r), t(r)),
      addToOptions: (e, t) => e.concat(t)
    });
  }
});
function Yg(i, e) {
  return i ? e ? i + " " + e : i : e;
}
function vQ(i, e, t, r, o) {
  let s = i.textDirection == He.RTL, n = s, a = !1, l = "top", u, h, c = e.left - o.left, d = o.right - e.right, f = r.right - r.left, p = r.bottom - r.top;
  if (n && c < Math.min(f, d) ? n = !1 : !n && d < Math.min(f, c) && (n = !0), f <= (n ? c : d))
    u = Math.max(o.top, Math.min(t.top, o.bottom - p)) - e.top, h = Math.min(400, n ? c : d);
  else {
    a = !0, h = Math.min(
      400,
      (s ? e.right : o.right - e.left) - 30
      /* Margin */
    );
    let O = o.bottom - e.bottom;
    O >= p || O > e.top ? u = t.bottom - e.top : (l = "bottom", u = e.bottom - t.top);
  }
  return {
    style: `${l}: ${u}px; max-width: ${h}px`,
    class: "cm-completionInfo-" + (a ? s ? "left-narrow" : "right-narrow" : n ? "left" : "right")
  };
}
function _Q(i) {
  let e = i.addToOptions.slice();
  return i.icons && e.push({
    render(t) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), t.type && r.classList.add(...t.type.split(/\s+/g).map((o) => "cm-completionIcon-" + o)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(t, r, o) {
      let s = document.createElement("span");
      s.className = "cm-completionLabel";
      let { label: n } = t, a = 0;
      for (let l = 1; l < o.length; ) {
        let u = o[l++], h = o[l++];
        u > a && s.appendChild(document.createTextNode(n.slice(a, u)));
        let c = s.appendChild(document.createElement("span"));
        c.appendChild(document.createTextNode(n.slice(u, h))), c.className = "cm-completionMatchedText", a = h;
      }
      return a < n.length && s.appendChild(document.createTextNode(n.slice(a))), s;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = t.detail, r;
    },
    position: 80
  }), e.sort((t, r) => t.position - r.position).map((t) => t.render);
}
function Bg(i, e, t) {
  if (i <= t)
    return { from: 0, to: i };
  if (e < 0 && (e = 0), e <= i >> 1) {
    let o = Math.floor(e / t);
    return { from: o * t, to: (o + 1) * t };
  }
  let r = Math.floor((i - e) / t);
  return { from: i - (r + 1) * t, to: i - r * t };
}
class PQ {
  constructor(e, t, r) {
    this.view = e, this.stateField = t, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let o = e.state.field(t), { options: s, selected: n } = o.open, a = e.state.facet(zt);
    this.optionContent = _Q(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Bg(s.length, n, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < s.length) {
          this.applyCompletion(e, s[+h[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let u = e.state.field(this.stateField, !1);
      u && u.tooltip && e.state.facet(zt).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: $a.of(null) });
    }), this.list = this.dom.appendChild(this.createListBox(s, o.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  mount() {
    this.updateSel();
  }
  update(e) {
    var t, r, o;
    let s = e.state.field(this.stateField), n = e.startState.field(this.stateField);
    this.updateTooltipClass(e.state), s != n && (this.updateSel(), ((t = s.open) === null || t === void 0 ? void 0 : t.disabled) != ((r = n.open) === null || r === void 0 ? void 0 : r.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!(!((o = s.open) === null || o === void 0) && o.disabled)));
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of t.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = Bg(t.options.length, t.selected, this.view.state.facet(zt).maxRenderedOptions), this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t.options, e.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    })), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: r } = t.options[t.selected], { info: o } = r;
      if (!o)
        return;
      let s = typeof o == "string" ? document.createTextNode(o) : o(r);
      if (!s)
        return;
      "then" in s ? s.then((n) => {
        n && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(n, r);
      }).catch((n) => Ri(this.view.state, n, "completion info")) : this.addInfoPane(s, r);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: o, destroy: s } = e;
      r.appendChild(o), this.infoDestroy = s || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let r = this.list.firstChild, o = this.range.from; r; r = r.nextSibling, o++)
      r.nodeName != "LI" || !r.id ? o-- : o == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), t = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return t && wQ(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), o = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let n = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: n.innerWidth, bottom: n.innerHeight };
    }
    return o.top > Math.min(s.bottom, t.bottom) - 10 || o.bottom < Math.max(s.top, t.top) + 10 ? null : this.view.state.facet(zt).positionInfo(this.view, t, o, r, s);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, r) {
    const o = document.createElement("ul");
    o.id = t, o.setAttribute("role", "listbox"), o.setAttribute("aria-expanded", "true"), o.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let n = r.from; n < r.to; n++) {
      let { completion: a, match: l } = e[n], { section: u } = a;
      if (u) {
        let d = typeof u == "string" ? u : u.name;
        if (d != s && (n > r.from || r.from == 0))
          if (s = d, typeof u != "string" && u.header)
            o.appendChild(u.header(u));
          else {
            let f = o.appendChild(document.createElement("completion-section"));
            f.textContent = d;
          }
      }
      const h = o.appendChild(document.createElement("li"));
      h.id = t + "-" + n, h.setAttribute("role", "option");
      let c = this.optionClass(a);
      c && (h.className = c);
      for (let d of this.optionContent) {
        let f = d(a, this.view.state, l);
        f && h.appendChild(f);
      }
    }
    return r.from && o.classList.add("cm-completionListIncompleteTop"), r.to < e.length && o.classList.add("cm-completionListIncompleteBottom"), o;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function LQ(i, e) {
  return (t) => new PQ(t, i, e);
}
function wQ(i, e) {
  let t = i.getBoundingClientRect(), r = e.getBoundingClientRect();
  r.top < t.top ? i.scrollTop -= t.top - r.top : r.bottom > t.bottom && (i.scrollTop += r.bottom - t.bottom);
}
function Fg(i) {
  return (i.boost || 0) * 100 + (i.apply ? 10 : 0) + (i.info ? 5 : 0) + (i.type ? 1 : 0);
}
function yQ(i, e) {
  let t = [], r = null, o = (l) => {
    t.push(l);
    let { section: u } = l.completion;
    if (u) {
      r || (r = []);
      let h = typeof u == "string" ? u : u.name;
      r.some((c) => c.name == h) || r.push(typeof u == "string" ? { name: h } : u);
    }
  };
  for (let l of i)
    if (l.hasResult())
      if (l.result.filter === !1) {
        let u = l.result.getMatch;
        for (let h of l.result.options) {
          let c = [1e9 - t.length];
          if (u)
            for (let d of u(h))
              c.push(d);
          o(new Hg(h, l.source, c, c[0]));
        }
      } else {
        let u = new IQ(e.sliceDoc(l.from, l.to)), h;
        for (let c of l.result.options)
          (h = u.match(c.label)) && o(new Hg(c, l.source, h, h[0] + (c.boost || 0)));
      }
  if (r) {
    let l = /* @__PURE__ */ Object.create(null), u = 0, h = (c, d) => {
      var f, p;
      return ((f = c.rank) !== null && f !== void 0 ? f : 1e9) - ((p = d.rank) !== null && p !== void 0 ? p : 1e9) || (c.name < d.name ? -1 : 1);
    };
    for (let c of r.sort(h))
      u -= 1e5, l[c.name] = u;
    for (let c of t) {
      let { section: d } = c.completion;
      d && (c.score += l[typeof d == "string" ? d : d.name]);
    }
  }
  let s = [], n = null, a = e.facet(zt).compareCompletions;
  for (let l of t.sort((u, h) => h.score - u.score || a(u.completion, h.completion))) {
    let u = l.completion;
    !n || n.label != u.label || n.detail != u.detail || n.type != null && u.type != null && n.type != u.type || n.apply != u.apply || n.boost != u.boost ? s.push(l) : Fg(l.completion) > Fg(n) && (s[s.length - 1] = l), n = l.completion;
  }
  return s;
}
class Ms {
  constructor(e, t, r, o, s, n) {
    this.options = e, this.attrs = t, this.tooltip = r, this.timestamp = o, this.selected = s, this.disabled = n;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Ms(this.options, Wg(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, r, o, s) {
    let n = yQ(e, t);
    if (!n.length)
      return o && e.some(
        (l) => l.state == 1
        /* Pending */
      ) ? new Ms(o.options, o.attrs, o.tooltip, o.timestamp, o.selected, !0) : null;
    let a = t.facet(zt).selectOnOpen ? 0 : -1;
    if (o && o.selected != a && o.selected != -1) {
      let l = o.options[o.selected].completion;
      for (let u = 0; u < n.length; u++)
        if (n[u].completion == l) {
          a = u;
          break;
        }
    }
    return new Ms(n, Wg(r, a), {
      pos: e.reduce((l, u) => u.hasResult() ? Math.min(l, u.from) : l, 1e8),
      create: LQ(si, qN),
      above: s.aboveCursor
    }, o ? o.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new Ms(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class ih {
  constructor(e, t, r) {
    this.active = e, this.id = t, this.open = r;
  }
  static start() {
    return new ih(MQ, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, r = t.facet(zt), s = (r.override || t.languageDataAt("autocomplete", no(t)).map(NQ)).map((a) => (this.active.find((u) => u.source == a) || new Xt(
      a,
      this.active.some(
        (u) => u.state != 0
        /* Inactive */
      ) ? 1 : 0
      /* Inactive */
    )).update(e, r));
    s.length == this.active.length && s.every((a, l) => a == this.active[l]) && (s = this.active);
    let n = this.open;
    n && e.docChanged && (n = n.map(e.changes)), e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !DQ(s, this.active) ? n = Ms.build(s, t, this.id, n, r) : n && n.disabled && !s.some(
      (a) => a.state == 1
      /* Pending */
    ) && (n = null), !n && s.every(
      (a) => a.state != 1
      /* Pending */
    ) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new Xt(
      a.source,
      0
      /* Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(ZN) && (n = n && n.setSelected(a.value, this.id));
    return s == this.active && n == this.open ? this : new ih(s, this.id, n);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : xQ;
  }
}
function DQ(i, e) {
  if (i == e)
    return !0;
  for (let t = 0, r = 0; ; ) {
    for (; t < i.length && !i[t].hasResult; )
      t++;
    for (; r < e.length && !e[r].hasResult; )
      r++;
    let o = t == i.length, s = r == e.length;
    if (o || s)
      return o == s;
    if (i[t++].result != e[r++].result)
      return !1;
  }
}
const xQ = {
  "aria-autocomplete": "list"
};
function Wg(i, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": i
  };
  return e > -1 && (t["aria-activedescendant"] = i + "-" + e), t;
}
const MQ = [];
function xf(i) {
  return i.isUserEvent("input.type") ? "input" : i.isUserEvent("delete.backward") ? "delete" : null;
}
class Xt {
  constructor(e, t, r = -1) {
    this.source = e, this.state = t, this.explicitPos = r;
  }
  hasResult() {
    return !1;
  }
  update(e, t) {
    let r = xf(e), o = this;
    r ? o = o.handleUserEvent(e, r, t) : e.docChanged ? o = o.handleChange(e) : e.selection && o.state != 0 && (o = new Xt(
      o.source,
      0
      /* Inactive */
    ));
    for (let s of e.effects)
      if (s.is(RO))
        o = new Xt(o.source, 1, s.value ? no(e.state) : -1);
      else if (s.is($a))
        o = new Xt(
          o.source,
          0
          /* Inactive */
        );
      else if (s.is(zN))
        for (let n of s.value)
          n.source == o.source && (o = n);
    return o;
  }
  handleUserEvent(e, t, r) {
    return t == "delete" || !r.activateOnTyping ? this.map(e.changes) : new Xt(
      this.source,
      1
      /* Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(no(e.startState)) ? new Xt(
      this.source,
      0
      /* Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new Xt(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class Fs extends Xt {
  constructor(e, t, r, o, s) {
    super(e, 2, t), this.result = r, this.from = o, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, t, r) {
    var o;
    let s = e.changes.mapPos(this.from), n = e.changes.mapPos(this.to, 1), a = no(e.state);
    if ((this.explicitPos < 0 ? a <= s : a < this.from) || a > n || t == "delete" && no(e.startState) == this.from)
      return new Xt(
        this.source,
        t == "input" && r.activateOnTyping ? 1 : 0
        /* Inactive */
      );
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), u;
    return UQ(this.result.validFor, e.state, s, n) ? new Fs(this.source, l, this.result, s, n) : this.result.update && (u = this.result.update(this.result, s, n, new YN(e.state, a, l >= 0))) ? new Fs(this.source, l, u, u.from, (o = u.to) !== null && o !== void 0 ? o : no(e.state)) : new Xt(this.source, 1, l);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new Xt(
      this.source,
      0
      /* Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new Fs(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function UQ(i, e, t, r) {
  if (!i)
    return !1;
  let o = e.sliceDoc(t, r);
  return typeof i == "function" ? i(o, t, r, e) : FN(i, !0).test(o);
}
const zN = /* @__PURE__ */ fe.define({
  map(i, e) {
    return i.map((t) => t.map(e));
  }
}), ZN = /* @__PURE__ */ fe.define(), si = /* @__PURE__ */ ct.define({
  create() {
    return ih.start();
  },
  update(i, e) {
    return i.update(e);
  },
  provide: (i) => [
    nO.from(i, (e) => e.tooltip),
    q.contentAttributes.from(i, (e) => e.attrs)
  ]
});
function qN(i, e) {
  const t = e.completion.apply || e.completion.label;
  let r = i.state.field(si).active.find((o) => o.source == e.source);
  return r instanceof Fs ? (typeof t == "string" ? i.dispatch(Object.assign(Object.assign({}, CQ(i.state, t, r.from, r.to)), { annotations: WN.of(e.completion) })) : t(i, e.completion, r.from, r.to), !0) : !1;
}
function Gl(i, e = "option") {
  return (t) => {
    let r = t.state.field(si, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < t.state.facet(zt).interactionDelay)
      return !1;
    let o = 1, s;
    e == "page" && (s = _C(t, r.open.tooltip)) && (o = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: n } = r.open.options, a = r.open.selected > -1 ? r.open.selected + o * (i ? 1 : -1) : i ? 0 : n - 1;
    return a < 0 ? a = e == "page" ? 0 : n - 1 : a >= n && (a = e == "page" ? n - 1 : 0), t.dispatch({ effects: ZN.of(a) }), !0;
  };
}
const QQ = (i) => {
  let e = i.state.field(si, !1);
  return i.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < i.state.facet(zt).interactionDelay ? !1 : qN(i, e.open.options[e.open.selected]);
}, kQ = (i) => i.state.field(si, !1) ? (i.dispatch({ effects: RO.of(!0) }), !0) : !1, $Q = (i) => {
  let e = i.state.field(si, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* Inactive */
  ) ? !1 : (i.dispatch({ effects: $a.of(null) }), !0);
};
class GQ {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const zg = 50, VQ = 50, HQ = 1e3, XQ = /* @__PURE__ */ lt.fromClass(class {
  constructor(i) {
    this.view = i, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0;
    for (let e of i.state.field(si).active)
      e.state == 1 && this.startQuery(e);
  }
  update(i) {
    let e = i.state.field(si);
    if (!i.selectionSet && !i.docChanged && i.startState.field(si) == e)
      return;
    let t = i.transactions.some((r) => (r.selection || r.docChanged) && !xf(r));
    for (let r = 0; r < this.running.length; r++) {
      let o = this.running[r];
      if (t || o.updates.length + i.transactions.length > VQ && Date.now() - o.time > HQ) {
        for (let s of o.context.abortListeners)
          try {
            s();
          } catch (n) {
            Ri(this.view.state, n);
          }
        o.context.abortListeners = null, this.running.splice(r--, 1);
      } else
        o.updates.push(...i.transactions);
    }
    if (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), this.debounceUpdate = e.active.some((r) => r.state == 1 && !this.running.some((o) => o.active.source == r.source)) ? setTimeout(() => this.startUpdate(), zg) : -1, this.composing != 0)
      for (let r of i.transactions)
        xf(r) == "input" ? this.composing = 2 : this.composing == 2 && r.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state: i } = this.view, e = i.field(si);
    for (let t of e.active)
      t.state == 1 && !this.running.some((r) => r.active.source == t.source) && this.startQuery(t);
  }
  startQuery(i) {
    let { state: e } = this.view, t = no(e), r = new YN(e, t, i.explicitPos == t), o = new GQ(i, r);
    this.running.push(o), Promise.resolve(i.source(r)).then((s) => {
      o.context.aborted || (o.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: $a.of(null) }), Ri(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((i) => i.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), zg));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var i;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(zt);
    for (let r = 0; r < this.running.length; r++) {
      let o = this.running[r];
      if (o.done === void 0)
        continue;
      if (this.running.splice(r--, 1), o.done) {
        let n = new Fs(o.active.source, o.active.explicitPos, o.done, o.done.from, (i = o.done.to) !== null && i !== void 0 ? i : no(o.updates.length ? o.updates[0].startState : this.view.state));
        for (let a of o.updates)
          n = n.update(a, t);
        if (n.hasResult()) {
          e.push(n);
          continue;
        }
      }
      let s = this.view.state.field(si).active.find((n) => n.source == o.active.source);
      if (s && s.state == 1)
        if (o.done == null) {
          let n = new Xt(
            o.active.source,
            0
            /* Inactive */
          );
          for (let a of o.updates)
            n = n.update(a, t);
          n.state != 1 && e.push(n);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: zN.of(e) });
  }
}, {
  eventHandlers: {
    blur(i) {
      let e = this.view.state.field(si, !1);
      if (e && e.tooltip && this.view.state.facet(zt).closeOnBlur) {
        let t = e.open && _C(this.view, e.open.tooltip);
        (!t || !t.dom.contains(i.relatedTarget)) && this.view.dispatch({ effects: $a.of(null) });
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: RO.of(!1) }), 20), this.composing = 0;
    }
  }
}), jN = /* @__PURE__ */ q.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class YQ {
  constructor(e, t, r, o) {
    this.field = e, this.line = t, this.from = r, this.to = o;
  }
}
class AO {
  constructor(e, t, r) {
    this.field = e, this.from = t, this.to = r;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, bt.TrackDel), r = e.mapPos(this.to, 1, bt.TrackDel);
    return t == null || r == null ? null : new AO(this.field, t, r);
  }
}
class CO {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let r = [], o = [t], s = e.doc.lineAt(t), n = /^\s*/.exec(s.text)[0];
    for (let l of this.lines) {
      if (r.length) {
        let u = n, h = /^\t*/.exec(l)[0].length;
        for (let c = 0; c < h; c++)
          u += e.facet(Vh);
        o.push(t + u.length - h), l = u + l.slice(h);
      }
      r.push(l), t += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new AO(l.field, o[l.line] + l.from, o[l.line] + l.to));
    return { text: r, ranges: a };
  }
  static parse(e) {
    let t = [], r = [], o = [], s;
    for (let n of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(n); ) {
        let a = s[1] ? +s[1] : null, l = s[2] || s[3] || "", u = -1;
        for (let h = 0; h < t.length; h++)
          (a != null ? t[h].seq == a : l && t[h].name == l) && (u = h);
        if (u < 0) {
          let h = 0;
          for (; h < t.length && (a == null || t[h].seq != null && t[h].seq < a); )
            h++;
          t.splice(h, 0, { seq: a, name: l }), u = h;
          for (let c of o)
            c.field >= u && c.field++;
        }
        o.push(new YQ(u, r.length, s.index, s.index + l.length)), n = n.slice(0, s.index) + l + n.slice(s.index + s[0].length);
      }
      for (let a; a = /\\([{}])/.exec(n); ) {
        n = n.slice(0, a.index) + a[1] + n.slice(a.index + a[0].length);
        for (let l of o)
          l.line == r.length && l.from > a.index && (l.from--, l.to--);
      }
      r.push(n);
    }
    return new CO(r, o);
  }
}
let BQ = /* @__PURE__ */ ie.widget({ widget: /* @__PURE__ */ new class extends Ur {
  toDOM() {
    let i = document.createElement("span");
    return i.className = "cm-snippetFieldPosition", i;
  }
  ignoreEvent() {
    return !1;
  }
}() }), FQ = /* @__PURE__ */ ie.mark({ class: "cm-snippetField" });
class Tn {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = ie.set(e.map((r) => (r.from == r.to ? BQ : FQ).range(r.from, r.to)));
  }
  map(e) {
    let t = [];
    for (let r of this.ranges) {
      let o = r.map(e);
      if (!o)
        return null;
      t.push(o);
    }
    return new Tn(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((r) => r.field == this.active && r.from <= t.from && r.to >= t.to));
  }
}
const rl = /* @__PURE__ */ fe.define({
  map(i, e) {
    return i && i.map(e);
  }
}), WQ = /* @__PURE__ */ fe.define(), Ga = /* @__PURE__ */ ct.define({
  create() {
    return null;
  },
  update(i, e) {
    for (let t of e.effects) {
      if (t.is(rl))
        return t.value;
      if (t.is(WQ) && i)
        return new Tn(i.ranges, t.value);
    }
    return i && e.docChanged && (i = i.map(e.changes)), i && e.selection && !i.selectionInsideField(e.selection) && (i = null), i;
  },
  provide: (i) => q.decorations.from(i, (e) => e ? e.deco : ie.none)
});
function NO(i, e) {
  return D.create(i.filter((t) => t.field == e).map((t) => D.range(t.from, t.to)));
}
function zQ(i) {
  let e = CO.parse(i);
  return (t, r, o, s) => {
    let { text: n, ranges: a } = e.instantiate(t.state, o), l = {
      changes: { from: o, to: s, insert: Ce.of(n) },
      scrollIntoView: !0,
      annotations: r ? WN.of(r) : void 0
    };
    if (a.length && (l.selection = NO(a, 0)), a.length > 1) {
      let u = new Tn(a, 0), h = l.effects = [rl.of(u)];
      t.state.field(Ga, !1) === void 0 && h.push(fe.appendConfig.of([Ga, JQ, ek, jN]));
    }
    t.dispatch(t.state.update(l));
  };
}
function KN(i) {
  return ({ state: e, dispatch: t }) => {
    let r = e.field(Ga, !1);
    if (!r || i < 0 && r.active == 0)
      return !1;
    let o = r.active + i, s = i > 0 && !r.ranges.some((n) => n.field == o + i);
    return t(e.update({
      selection: NO(r.ranges, o),
      effects: rl.of(s ? null : new Tn(r.ranges, o))
    })), !0;
  };
}
const ZQ = ({ state: i, dispatch: e }) => i.field(Ga, !1) ? (e(i.update({ effects: rl.of(null) })), !0) : !1, qQ = /* @__PURE__ */ KN(1), jQ = /* @__PURE__ */ KN(-1), KQ = [
  { key: "Tab", run: qQ, shift: jQ },
  { key: "Escape", run: ZQ }
], Zg = /* @__PURE__ */ K.define({
  combine(i) {
    return i.length ? i[0] : KQ;
  }
}), JQ = /* @__PURE__ */ ds.highest(/* @__PURE__ */ Ka.compute([Zg], (i) => i.facet(Zg)));
function vi(i, e) {
  return Object.assign(Object.assign({}, e), { apply: zQ(i) });
}
const ek = /* @__PURE__ */ q.domEventHandlers({
  mousedown(i, e) {
    let t = e.state.field(Ga, !1), r;
    if (!t || (r = e.posAtCoords({ x: i.clientX, y: i.clientY })) == null)
      return !1;
    let o = t.ranges.find((s) => s.from <= r && s.to >= r);
    return !o || o.field == t.active ? !1 : (e.dispatch({
      selection: NO(t.ranges, o.field),
      effects: rl.of(t.ranges.some((s) => s.field > o.field) ? new Tn(t.ranges, o.field) : null)
    }), !0);
  }
}), Va = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Go = /* @__PURE__ */ fe.define({
  map(i, e) {
    let t = e.mapPos(i, -1, bt.TrackAfter);
    return t ?? void 0;
  }
}), IO = /* @__PURE__ */ new class extends es {
}();
IO.startSide = 1;
IO.endSide = -1;
const JN = /* @__PURE__ */ ct.define({
  create() {
    return Le.empty;
  },
  update(i, e) {
    if (e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head).from, r = e.startState.doc.lineAt(e.startState.selection.main.head).from;
      t != e.changes.mapPos(r, -1) && (i = Le.empty);
    }
    i = i.map(e.changes);
    for (let t of e.effects)
      t.is(Go) && (i = i.update({ add: [IO.range(t.value, t.value + 1)] }));
    return i;
  }
});
function tk() {
  return [rk, JN];
}
const Bc = "()[]{}<>";
function eI(i) {
  for (let e = 0; e < Bc.length; e += 2)
    if (Bc.charCodeAt(e) == i)
      return Bc.charAt(e + 1);
  return Zp(i < 128 ? i : i + 1);
}
function tI(i, e) {
  return i.languageDataAt("closeBrackets", e)[0] || Va;
}
const ik = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), rk = /* @__PURE__ */ q.inputHandler.of((i, e, t, r) => {
  if ((ik ? i.composing : i.compositionStarted) || i.state.readOnly)
    return !1;
  let o = i.state.selection.main;
  if (r.length > 2 || r.length == 2 && mi(mt(r, 0)) == 1 || e != o.from || t != o.to)
    return !1;
  let s = nk(i.state, r);
  return s ? (i.dispatch(s), !0) : !1;
}), ok = ({ state: i, dispatch: e }) => {
  if (i.readOnly)
    return !1;
  let r = tI(i, i.selection.main.head).brackets || Va.brackets, o = null, s = i.changeByRange((n) => {
    if (n.empty) {
      let a = ak(i.doc, n.head);
      for (let l of r)
        if (l == a && qh(i.doc, n.head) == eI(mt(l, 0)))
          return {
            changes: { from: n.head - l.length, to: n.head + l.length },
            range: D.cursor(n.head - l.length)
          };
    }
    return { range: o = n };
  });
  return o || e(i.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !o;
}, sk = [
  { key: "Backspace", run: ok }
];
function nk(i, e) {
  let t = tI(i, i.selection.main.head), r = t.brackets || Va.brackets;
  for (let o of r) {
    let s = eI(mt(o, 0));
    if (e == o)
      return s == o ? hk(i, o, r.indexOf(o + o + o) > -1, t) : lk(i, o, s, t.before || Va.before);
    if (e == s && iI(i, i.selection.main.from))
      return uk(i, o, s);
  }
  return null;
}
function iI(i, e) {
  let t = !1;
  return i.field(JN).between(0, i.doc.length, (r) => {
    r == e && (t = !0);
  }), t;
}
function qh(i, e) {
  let t = i.sliceString(e, e + 2);
  return t.slice(0, mi(mt(t, 0)));
}
function ak(i, e) {
  let t = i.sliceString(e - 2, e);
  return mi(mt(t, 0)) == t.length ? t : t.slice(1);
}
function lk(i, e, t, r) {
  let o = null, s = i.changeByRange((n) => {
    if (!n.empty)
      return {
        changes: [{ insert: e, from: n.from }, { insert: t, from: n.to }],
        effects: Go.of(n.to + e.length),
        range: D.range(n.anchor + e.length, n.head + e.length)
      };
    let a = qh(i.doc, n.head);
    return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
      changes: { insert: e + t, from: n.head },
      effects: Go.of(n.head + e.length),
      range: D.cursor(n.head + e.length)
    } : { range: o = n };
  });
  return o ? null : i.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function uk(i, e, t) {
  let r = null, o = i.changeByRange((s) => s.empty && qh(i.doc, s.head) == t ? {
    changes: { from: s.head, to: s.head + t.length, insert: t },
    range: D.cursor(s.head + t.length)
  } : r = { range: s });
  return r ? null : i.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function hk(i, e, t, r) {
  let o = r.stringPrefixes || Va.stringPrefixes, s = null, n = i.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: Go.of(a.to + e.length),
        range: D.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, u = qh(i.doc, l), h;
    if (u == e) {
      if (qg(i, l))
        return {
          changes: { insert: e + e, from: l },
          effects: Go.of(l + e.length),
          range: D.cursor(l + e.length)
        };
      if (iI(i, l)) {
        let d = t && i.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + d.length, insert: d },
          range: D.cursor(l + d.length)
        };
      }
    } else {
      if (t && i.sliceDoc(l - 2 * e.length, l) == e + e && (h = jg(i, l - 2 * e.length, o)) > -1 && qg(i, h))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: Go.of(l + e.length),
          range: D.cursor(l + e.length)
        };
      if (i.charCategorizer(l)(u) != $e.Word && jg(i, l, o) > -1 && !ck(i, l, e, o))
        return {
          changes: { insert: e + e, from: l },
          effects: Go.of(l + e.length),
          range: D.cursor(l + e.length)
        };
    }
    return { range: s = a };
  });
  return s ? null : i.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function qg(i, e) {
  let t = Be(i).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function ck(i, e, t, r) {
  let o = Be(i).resolveInner(e, -1), s = r.reduce((n, a) => Math.max(n, a.length), 0);
  for (let n = 0; n < 5; n++) {
    let a = i.sliceDoc(o.from, Math.min(o.to, o.from + t.length + s)), l = a.indexOf(t);
    if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
      let h = o.firstChild;
      for (; h && h.from == o.from && h.to - h.from > t.length + l; ) {
        if (i.sliceDoc(h.to - t.length, h.to) == t)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let u = o.to == e && o.parent;
    if (!u)
      break;
    o = u;
  }
  return !1;
}
function jg(i, e, t) {
  let r = i.charCategorizer(e);
  if (r(i.sliceDoc(e - 1, e)) != $e.Word)
    return e;
  for (let o of t) {
    let s = e - o.length;
    if (i.sliceDoc(s, e) == o && r(i.sliceDoc(s - 1, s)) != $e.Word)
      return s;
  }
  return -1;
}
function rI(i = {}) {
  return [
    si,
    zt.of(i),
    XQ,
    dk,
    jN
  ];
}
const oI = [
  { key: "Ctrl-Space", run: kQ },
  { key: "Escape", run: $Q },
  { key: "ArrowDown", run: /* @__PURE__ */ Gl(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Gl(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Gl(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Gl(!1, "page") },
  { key: "Enter", run: QQ }
], dk = /* @__PURE__ */ ds.highest(/* @__PURE__ */ Ka.computeN([zt], (i) => i.facet(zt).defaultKeymap ? [oI] : []));
class fk {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.diagnostic = r;
  }
}
class xo {
  constructor(e, t, r) {
    this.diagnostics = e, this.panel = t, this.selected = r;
  }
  static init(e, t, r) {
    let o = e, s = r.facet(aI).markerFilter;
    s && (o = s(o));
    let n = ie.set(o.map((a) => a.from == a.to || a.from == a.to - 1 && r.doc.lineAt(a.from).to == a.from ? ie.widget({
      widget: new Rk(a),
      diagnostic: a
    }).range(a.from) : ie.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + a.severity },
      diagnostic: a
    }).range(a.from, a.to)), !0);
    return new xo(n, t, cn(n));
  }
}
function cn(i, e = null, t = 0) {
  let r = null;
  return i.between(t, 1e9, (o, s, { spec: n }) => {
    if (!(e && n.diagnostic != e))
      return r = new fk(o, s, n.diagnostic), !1;
  }), r;
}
function pk(i, e) {
  let t = i.startState.doc.lineAt(e.pos);
  return !!(i.effects.some((r) => r.is(sI)) || i.changes.touchesRange(t.from, t.to));
}
function Ok(i, e) {
  return i.field(ai, !1) ? e : e.concat(fe.appendConfig.of(Nk));
}
const sI = /* @__PURE__ */ fe.define(), vO = /* @__PURE__ */ fe.define(), nI = /* @__PURE__ */ fe.define(), ai = /* @__PURE__ */ ct.define({
  create() {
    return new xo(ie.none, null, null);
  },
  update(i, e) {
    if (e.docChanged) {
      let t = i.diagnostics.map(e.changes), r = null;
      if (i.selected) {
        let o = e.changes.mapPos(i.selected.from, 1);
        r = cn(t, i.selected.diagnostic, o) || cn(t, null, o);
      }
      i = new xo(t, i.panel, r);
    }
    for (let t of e.effects)
      t.is(sI) ? i = xo.init(t.value, i.panel, e.state) : t.is(vO) ? i = new xo(i.diagnostics, t.value ? jh.open : null, i.selected) : t.is(nI) && (i = new xo(i.diagnostics, i.panel, t.value));
    return i;
  },
  provide: (i) => [
    Ma.from(i, (e) => e.panel),
    q.decorations.from(i, (e) => e.diagnostics)
  ]
}), Ek = /* @__PURE__ */ ie.mark({ class: "cm-lintRange cm-lintRange-active" });
function mk(i, e, t) {
  let { diagnostics: r } = i.state.field(ai), o = [], s = 2e8, n = 0;
  r.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, u, { spec: h }) => {
    e >= l && e <= u && (l == u || (e > l || t > 0) && (e < u || t < 0)) && (o.push(h.diagnostic), s = Math.min(l, s), n = Math.max(u, n));
  });
  let a = i.state.facet(aI).tooltipFilter;
  return a && (o = a(o)), o.length ? {
    pos: s,
    end: n,
    above: i.state.doc.lineAt(s).to < n,
    create() {
      return { dom: gk(i, o) };
    }
  } : null;
}
function gk(i, e) {
  return De("ul", { class: "cm-tooltip-lint" }, e.map((t) => uI(i, t, !1)));
}
const bk = (i) => {
  let e = i.state.field(ai, !1);
  (!e || !e.panel) && i.dispatch({ effects: Ok(i.state, [vO.of(!0)]) });
  let t = xa(i, jh.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, Kg = (i) => {
  let e = i.state.field(ai, !1);
  return !e || !e.panel ? !1 : (i.dispatch({ effects: vO.of(!1) }), !0);
}, Tk = (i) => {
  let e = i.state.field(ai, !1);
  if (!e)
    return !1;
  let t = i.state.selection.main, r = e.diagnostics.iter(t.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == t.from && r.to == t.to) ? !1 : (i.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, Sk = [
  { key: "Mod-Shift-m", run: bk, preventDefault: !0 },
  { key: "F8", run: Tk }
], aI = /* @__PURE__ */ K.define({
  combine(i) {
    return Object.assign({ sources: i.map((e) => e.source) }, cr(i.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, t) => e ? t ? (r) => e(r) || t(r) : e : t
    }));
  }
});
function lI(i) {
  let e = [];
  if (i)
    e:
      for (let { name: t } of i) {
        for (let r = 0; r < t.length; r++) {
          let o = t[r];
          if (/[a-zA-Z]/.test(o) && !e.some((s) => s.toLowerCase() == o.toLowerCase())) {
            e.push(o);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function uI(i, e, t) {
  var r;
  let o = t ? lI(e.actions) : [];
  return De("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, De("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((s, n) => {
    let a = !1, l = (d) => {
      if (d.preventDefault(), a)
        return;
      a = !0;
      let f = cn(i.state.field(ai).diagnostics, e);
      f && s.apply(i, f.from, f.to);
    }, { name: u } = s, h = o[n] ? u.indexOf(o[n]) : -1, c = h < 0 ? u : [
      u.slice(0, h),
      De("u", u.slice(h, h + 1)),
      u.slice(h + 1)
    ];
    return De("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${u}${h < 0 ? "" : ` (access key "${o[n]})"`}.`
    }, c);
  }), e.source && De("div", { class: "cm-diagnosticSource" }, e.source));
}
class Rk extends Ur {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return De("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class Jg {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = uI(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class jh {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (o) => {
      if (o.keyCode == 27)
        Kg(this.view), this.view.focus();
      else if (o.keyCode == 38 || o.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (o.keyCode == 40 || o.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (o.keyCode == 36)
        this.moveSelection(0);
      else if (o.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (o.keyCode == 13)
        this.view.focus();
      else if (o.keyCode >= 65 && o.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], n = lI(s.actions);
        for (let a = 0; a < n.length; a++)
          if (n[a].toUpperCase().charCodeAt(0) == o.keyCode) {
            let l = cn(this.view.state.field(ai).diagnostics, s);
            l && s.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      o.preventDefault();
    }, r = (o) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(o.target) && this.moveSelection(s);
    };
    this.list = De("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: r
    }), this.dom = De("div", { class: "cm-panel-lint" }, this.list, De("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => Kg(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(ai).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(ai), r = 0, o = !1, s = null;
    for (e.between(0, this.view.state.doc.length, (n, a, { spec: l }) => {
      let u = -1, h;
      for (let c = r; c < this.items.length; c++)
        if (this.items[c].diagnostic == l.diagnostic) {
          u = c;
          break;
        }
      u < 0 ? (h = new Jg(this.view, l.diagnostic), this.items.splice(r, 0, h), o = !0) : (h = this.items[u], u > r && (this.items.splice(r, u - r), o = !0)), t && h.diagnostic == t.diagnostic ? h.dom.hasAttribute("aria-selected") || (h.dom.setAttribute("aria-selected", "true"), s = h) : h.dom.hasAttribute("aria-selected") && h.dom.removeAttribute("aria-selected"), r++;
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      o = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new Jg(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), o = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: n, panel: a }) => {
        n.top < a.top ? this.list.scrollTop -= a.top - n.top : n.bottom > a.bottom && (this.list.scrollTop += n.bottom - a.bottom);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), o && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          t();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(ai), r = cn(t.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: nI.of(r)
    });
  }
  static open(e) {
    return new jh(e);
  }
}
function Ak(i, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(i)}</svg>')`;
}
function Fc(i) {
  return Ak(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${i}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const Ck = /* @__PURE__ */ q.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Fc("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Fc("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Fc("#999") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), Nk = [
  ai,
  /* @__PURE__ */ q.decorations.compute([ai], (i) => {
    let { selected: e, panel: t } = i.field(ai);
    return !e || !t || e.from == e.to ? ie.none : ie.set([
      Ek.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ mx(mk, { hideOn: pk }),
  Ck
], Ik = /* @__PURE__ */ (() => [
  Ix(),
  Px(),
  ZD(),
  qM(),
  RM(),
  kD(),
  XD(),
  Re.allowMultipleSelections.of(!0),
  hM(),
  jC(IM, { fallback: !0 }),
  DM(),
  tk(),
  rI(),
  ax(),
  hx(),
  tx(),
  eQ(),
  Ka.of([
    ...sk,
    ...yN,
    ...bQ,
    ...sU,
    ...bM,
    ...oI,
    ...Sk
  ])
])(), vk = "#e5c07b", eb = "#e06c75", _k = "#56b6c2", Pk = "#ffffff", iu = "#abb2bf", Mf = "#7d8799", Lk = "#61afef", wk = "#98c379", tb = "#d19a66", yk = "#c678dd", Dk = "#21252b", ib = "#2c313a", rb = "#282c34", Wc = "#353a42", xk = "#3E4451", ob = "#528bff", Mk = /* @__PURE__ */ q.theme({
  "&": {
    color: iu,
    backgroundColor: rb
  },
  ".cm-content": {
    caretColor: ob
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: ob },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: xk },
  ".cm-panels": { backgroundColor: Dk, color: iu },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847",
    outline: "1px solid #515a6b"
  },
  ".cm-gutters": {
    backgroundColor: rb,
    color: Mf,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: ib
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: Wc
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Wc,
    borderBottomColor: Wc
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: ib,
      color: iu
    }
  }
}, { dark: !0 }), Uk = /* @__PURE__ */ tl.define([
  {
    tag: b.keyword,
    color: yk
  },
  {
    tag: [b.name, b.deleted, b.character, b.propertyName, b.macroName],
    color: eb
  },
  {
    tag: [/* @__PURE__ */ b.function(b.variableName), b.labelName],
    color: Lk
  },
  {
    tag: [b.color, /* @__PURE__ */ b.constant(b.name), /* @__PURE__ */ b.standard(b.name)],
    color: tb
  },
  {
    tag: [/* @__PURE__ */ b.definition(b.name), b.separator],
    color: iu
  },
  {
    tag: [b.typeName, b.className, b.number, b.changed, b.annotation, b.modifier, b.self, b.namespace],
    color: vk
  },
  {
    tag: [b.operator, b.operatorKeyword, b.url, b.escape, b.regexp, b.link, /* @__PURE__ */ b.special(b.string)],
    color: _k
  },
  {
    tag: [b.meta, b.comment],
    color: Mf
  },
  {
    tag: b.strong,
    fontWeight: "bold"
  },
  {
    tag: b.emphasis,
    fontStyle: "italic"
  },
  {
    tag: b.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: b.link,
    color: Mf,
    textDecoration: "underline"
  },
  {
    tag: b.heading,
    fontWeight: "bold",
    color: eb
  },
  {
    tag: [b.atom, b.bool, /* @__PURE__ */ b.special(b.variableName)],
    color: tb
  },
  {
    tag: [b.processingInstruction, b.string, b.inserted],
    color: wk
  },
  {
    tag: b.invalid,
    color: Pk
  }
]), Qk = [Mk, /* @__PURE__ */ jC(Uk)];
class rh {
  /// @internal
  constructor(e, t, r, o, s, n, a, l, u, h = 0, c) {
    this.p = e, this.stack = t, this.state = r, this.reducePos = o, this.pos = s, this.score = n, this.buffer = a, this.bufferBase = l, this.curContext = u, this.lookAhead = h, this.parent = c;
  }
  /// @internal
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /// @internal
  static start(e, t, r = 0) {
    let o = e.parser.context;
    return new rh(e, [], t, r, r, 0, [], 0, o ? new sb(o, o.start) : null, 0, null);
  }
  /// The stack's current [context](#lr.ContextTracker) value, if
  /// any. Its type will depend on the context tracker's type
  /// parameter, or it will be `null` if there is no context
  /// tracker.
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /// @internal
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /// @internal
  reduce(e) {
    var t;
    let r = e >> 19, o = e & 65535, { parser: s } = this.p, n = s.dynamicPrecedence(o);
    if (n && (this.score += n), r == 0) {
      this.pushState(s.getGoto(this.state, o, !0), this.reducePos), o < s.minRepeatTerm && this.storeNode(o, this.reducePos, this.reducePos, 4, !0), this.reduceContext(o, this.reducePos);
      return;
    }
    let a = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0), l = a ? this.stack[a - 2] : this.p.ranges[0].from, u = this.reducePos - l;
    u >= 2e3 && !(!((t = this.p.parser.nodeSet.types[o]) === null || t === void 0) && t.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = u));
    let h = a ? this.stack[a - 1] : 0, c = this.bufferBase + this.buffer.length - h;
    if (o < s.minRepeatTerm || e & 131072) {
      let d = s.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(o, l, d, c + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[a];
    else {
      let d = this.stack[a - 3];
      this.state = s.getGoto(d, o, !0);
    }
    for (; this.stack.length > a; )
      this.stack.pop();
    this.reduceContext(o, l);
  }
  // Shift a value into the buffer
  /// @internal
  storeNode(e, t, r, o = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let n = this, a = this.buffer.length;
      if (a == 0 && n.parent && (a = n.bufferBase - n.parent.bufferBase, n = n.parent), a > 0 && n.buffer[a - 4] == 0 && n.buffer[a - 1] > -1) {
        if (t == r)
          return;
        if (n.buffer[a - 2] >= t) {
          n.buffer[a - 2] = r;
          return;
        }
      }
    }
    if (!s || this.pos == r)
      this.buffer.push(e, t, r, o);
    else {
      let n = this.buffer.length;
      if (n > 0 && this.buffer[n - 4] != 0)
        for (; n > 0 && this.buffer[n - 2] > r; )
          this.buffer[n] = this.buffer[n - 4], this.buffer[n + 1] = this.buffer[n - 3], this.buffer[n + 2] = this.buffer[n - 2], this.buffer[n + 3] = this.buffer[n - 1], n -= 4, o > 4 && (o -= 4);
      this.buffer[n] = e, this.buffer[n + 1] = t, this.buffer[n + 2] = r, this.buffer[n + 3] = o;
    }
  }
  // Apply a shift action
  /// @internal
  shift(e, t, r) {
    let o = this.pos;
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = r, this.shiftContext(t, o), t <= this.p.parser.maxNode && this.buffer.push(t, o, r, 4);
    else {
      let s = e, { parser: n } = this.p;
      (r > this.pos || t <= n.maxNode) && (this.pos = r, n.stateFlag(
        s,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = r)), this.pushState(s, o), this.shiftContext(t, o), t <= n.maxNode && this.buffer.push(t, o, r, 4);
    }
  }
  // Apply an action
  /// @internal
  apply(e, t, r) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, r);
  }
  // Add a prebuilt (reused) node into the buffer.
  /// @internal
  useNode(e, t) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++);
    let o = this.pos;
    this.reducePos = this.pos = o + e.length, this.pushState(t, o), this.buffer.push(
      r,
      o,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /// @internal
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let r = e.buffer.slice(t), o = e.bufferBase + t;
    for (; e && o == e.bufferBase; )
      e = e.parent;
    return new rh(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, o, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /// @internal
  recoverByDelete(e, t) {
    let r = e <= this.p.parser.maxNode;
    r && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, r ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /// Check if the given term would be able to be shifted (optionally
  /// after some reductions) on this stack. This can be useful for
  /// external tokenizers that want to make sure they only provide a
  /// given token when it applies.
  canShift(e) {
    for (let t = new kk(this); ; ) {
      let r = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (r == 0)
        return !1;
      if (!(r & 65536))
        return !0;
      t.reduce(r);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /// @internal
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let o = [];
      for (let s = 0, n; s < t.length; s += 2)
        (n = t[s + 1]) != this.state && this.p.parser.hasAction(n, e) && o.push(t[s], n);
      if (this.stack.length < 120)
        for (let s = 0; o.length < 8 && s < t.length; s += 2) {
          let n = t[s + 1];
          o.some((a, l) => l & 1 && a == n) || o.push(t[s], n);
        }
      t = o;
    }
    let r = [];
    for (let o = 0; o < t.length && r.length < 4; o += 2) {
      let s = t[o + 1];
      if (s == this.state)
        continue;
      let n = this.split();
      n.pushState(s, this.pos), n.storeNode(0, n.pos, n.pos, 4, !0), n.shiftContext(t[o], this.pos), n.score -= 200, r.push(n);
    }
    return r;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /// @internal
  forceReduce() {
    let { parser: e } = this.p, t = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(t & 65536))
      return !1;
    if (!e.validAction(this.state, t)) {
      let r = t >> 19, o = t & 65535, s = this.stack.length - r * 3;
      if (s < 0 || e.getGoto(this.stack[s], o, !1) < 0) {
        let n = this.findForcedReduction();
        if (n == null)
          return !1;
        t = n;
      }
      this.storeNode(0, this.reducePos, this.reducePos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  /// Try to scan through the automaton to find some kind of reduction
  /// that can be applied. Used when the regular ForcedReduce field
  /// isn't a valid action. @internal
  findForcedReduction() {
    let { parser: e } = this.p, t = [], r = (o, s) => {
      if (!t.includes(o))
        return t.push(o), e.allActions(o, (n) => {
          if (!(n & 393216))
            if (n & 65536) {
              let a = (n >> 19) - s;
              if (a > 1) {
                let l = n & 65535, u = this.stack.length - a * 3;
                if (u >= 0 && e.getGoto(this.stack[u], l, !1) >= 0)
                  return a << 19 | 65536 | l;
              }
            } else {
              let a = r(n, s + 1);
              if (a != null)
                return a;
            }
        });
    };
    return r(this.state, 0);
  }
  /// @internal
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /// Check whether this state has no further actions (assumed to be a direct descendant of the
  /// top state, since any other states must be able to continue
  /// somehow). @internal
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /// Restart the stack (put it back in its start state). Only safe
  /// when this.stack.length == 3 (state is directly below the top
  /// state). @internal
  restart() {
    this.state = this.stack[0], this.stack.length = 0;
  }
  /// @internal
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /// Get the parser used by this stack.
  get parser() {
    return this.p.parser;
  }
  /// Test whether a given dialect (by numeric ID, as exported from
  /// the terms file) is enabled.
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /// @internal
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /// @internal
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new sb(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /// @internal
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /// @internal
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class sb {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
var nb;
(function(i) {
  i[i.Insert = 200] = "Insert", i[i.Delete = 190] = "Delete", i[i.Reduce = 100] = "Reduce", i[i.MaxNext = 4] = "MaxNext", i[i.MaxInsertStackDepth = 300] = "MaxInsertStackDepth", i[i.DampenInsertStackDepth = 120] = "DampenInsertStackDepth", i[i.MinBigReduction = 2e3] = "MinBigReduction";
})(nb || (nb = {}));
class kk {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, r = e >> 19;
    r == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (r - 1) * 3;
    let o = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = o;
  }
}
class oh {
  constructor(e, t, r) {
    this.stack = e, this.pos = t, this.index = r, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new oh(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new oh(this.stack, this.pos, this.index);
  }
}
function zn(i, e = Uint16Array) {
  if (typeof i != "string")
    return i;
  let t = null;
  for (let r = 0, o = 0; r < i.length; ) {
    let s = 0;
    for (; ; ) {
      let n = i.charCodeAt(r++), a = !1;
      if (n == 126) {
        s = 65535;
        break;
      }
      n >= 92 && n--, n >= 34 && n--;
      let l = n - 32;
      if (l >= 46 && (l -= 46, a = !0), s += l, a)
        break;
      s *= 46;
    }
    t ? t[o++] = s : t = new e(s);
  }
  return t;
}
class ru {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const ab = new ru();
class $k {
  /// @internal
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = ab, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /// @internal
  resolveOffset(e, t) {
    let r = this.range, o = this.rangeIndex, s = this.pos + e;
    for (; s < r.from; ) {
      if (!o)
        return null;
      let n = this.ranges[--o];
      s -= r.from - n.to, r = n;
    }
    for (; t < 0 ? s > r.to : s >= r.to; ) {
      if (o == this.ranges.length - 1)
        return null;
      let n = this.ranges[++o];
      s += n.from - r.to, r = n;
    }
    return s;
  }
  /// @internal
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /// Look at a code unit near the stream position. `.peek(0)` equals
  /// `.next`, `.peek(-1)` gives you the previous character, and so
  /// on.
  ///
  /// Note that looking around during tokenizing creates dependencies
  /// on potentially far-away content, which may reduce the
  /// effectiveness incremental parsing—when looking forward—or even
  /// cause invalid reparses when looking backward more than 25 code
  /// units, since the library does not track lookbehind.
  peek(e) {
    let t = this.chunkOff + e, r, o;
    if (t >= 0 && t < this.chunk.length)
      r = this.pos + e, o = this.chunk.charCodeAt(t);
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null)
        return -1;
      if (r = s, r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)
        o = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let n = this.rangeIndex, a = this.range;
        for (; a.to <= r; )
          a = this.ranges[++n];
        this.chunk2 = this.input.chunk(this.chunk2Pos = r), r + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - r)), o = this.chunk2.charCodeAt(0);
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), o;
  }
  /// Accept a token. By default, the end of the token is set to the
  /// current stream position, but you can pass an offset (relative to
  /// the stream position) to change that.
  acceptToken(e, t = 0) {
    let r = t ? this.resolveOffset(t, -1) : this.pos;
    if (r == null || r < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = r;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /// Move the stream forward N (defaults to 1) code units. Returns
  /// the new value of [`next`](#lr.InputStream.next).
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /// @internal
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = ab, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /// @internal
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let r = "";
    for (let o of this.ranges) {
      if (o.from >= t)
        break;
      o.to > e && (r += this.input.read(Math.max(o.from, e), Math.min(o.to, t)));
    }
    return r;
  }
}
class Ws {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: r } = t.p;
    hI(this.data, e, t, this.id, r.data, r.tokenPrecTable);
  }
}
Ws.prototype.contextual = Ws.prototype.fallback = Ws.prototype.extend = !1;
class Uf {
  constructor(e, t, r) {
    this.precTable = t, this.elseToken = r, this.data = typeof e == "string" ? zn(e) : e;
  }
  token(e, t) {
    let r = e.pos, o = 0;
    for (; ; ) {
      let s = e.resolveOffset(1, -1);
      if (hI(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s == null)
        break;
      e.reset(s, e.token), o++;
    }
    o && (e.reset(r, e.token), e.acceptToken(this.elseToken, o));
  }
}
Uf.prototype.contextual = Ws.prototype.fallback = Ws.prototype.extend = !1;
class Gi {
  /// Create a tokenizer. The first argument is the function that,
  /// given an input stream, scans for the types of tokens it
  /// recognizes at the stream's position, and calls
  /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  /// one.
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function hI(i, e, t, r, o, s) {
  let n = 0, a = 1 << r, { dialect: l } = t.p.parser;
  e:
    for (; a & i[n]; ) {
      let u = i[n + 1];
      for (let f = n + 3; f < u; f += 2)
        if ((i[f + 1] & a) > 0) {
          let p = i[f];
          if (l.allows(p) && (e.token.value == -1 || e.token.value == p || Gk(p, e.token.value, o, s))) {
            e.acceptToken(p);
            break;
          }
        }
      let h = e.next, c = 0, d = i[n + 2];
      if (e.next < 0 && d > c && i[u + d * 3 - 3] == 65535 && i[u + d * 3 - 3] == 65535) {
        n = i[u + d * 3 - 1];
        continue e;
      }
      for (; c < d; ) {
        let f = c + d >> 1, p = u + f + (f << 1), O = i[p], m = i[p + 1] || 65536;
        if (h < O)
          d = f;
        else if (h >= m)
          c = f + 1;
        else {
          n = i[p + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function lb(i, e, t) {
  for (let r = e, o; (o = i[r]) != 65535; r++)
    if (o == t)
      return r - e;
  return -1;
}
function Gk(i, e, t, r) {
  let o = lb(t, r, e);
  return o < 0 || lb(t, r, i) < o;
}
const _i = typeof process < "u" && {} && /\bparse\b/.test({}.LOG);
let zc = null;
var ub;
(function(i) {
  i[i.Margin = 25] = "Margin";
})(ub || (ub = {}));
function hb(i, e, t) {
  let r = i.cursor(Qe.IncludeAnonymous);
  for (r.moveTo(e); ; )
    if (!(t < 0 ? r.childBefore(e) : r.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? r.to < e : r.from > e) && !r.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            r.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(i.length, Math.max(
            r.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (t < 0 ? r.prevSibling() : r.nextSibling())
          break;
        if (!r.parent())
          return t < 0 ? 0 : i.length;
      }
}
class Vk {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? hb(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? hb(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let r = this.trees[t], o = this.index[t];
      if (o == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = r.children[o], n = this.start[t] + r.positions[o];
      if (n > e)
        return this.nextStart = n, null;
      if (s instanceof Xe) {
        if (n == e) {
          if (n < this.safeFrom)
            return null;
          let a = n + s.length;
          if (a <= this.safeTo) {
            let l = s.prop(Oe.lookAhead);
            if (!l || a + l < this.fragment.to)
              return s;
          }
        }
        this.index[t]++, n + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(n), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = n + s.length;
    }
  }
}
class Hk {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((r) => new ru());
  }
  getActions(e) {
    let t = 0, r = null, { parser: o } = e.p, { tokenizers: s } = o, n = o.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let u = 0; u < s.length; u++) {
      if (!(1 << u & n))
        continue;
      let h = s[u], c = this.tokens[u];
      if (!(r && !h.fallback) && ((h.contextual || c.start != e.pos || c.mask != n || c.context != a) && (this.updateCachedToken(c, h, e), c.mask = n, c.context = a), c.lookAhead > c.end + 25 && (l = Math.max(c.lookAhead, l)), c.value != 0)) {
        let d = t;
        if (c.extended > -1 && (t = this.addActions(e, c.extended, c.end, t)), t = this.addActions(e, c.value, c.end, t), !h.extend && (r = c, t > d))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return l && e.setLookAhead(l), !r && e.pos == this.stream.end && (r = new ru(), r.value = e.p.parser.eofTerm, r.start = r.end = e.pos, t = this.addActions(e, r.value, r.end, t)), this.mainToken = r, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new ru(), { pos: r, p: o } = e;
    return t.start = r, t.end = Math.min(r + 1, o.stream.end), t.value = r == o.stream.end ? o.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, r) {
    let o = this.stream.clipPos(r.pos);
    if (t.token(this.stream.reset(o, e), r), e.value > -1) {
      let { parser: s } = r.p;
      for (let n = 0; n < s.specialized.length; n++)
        if (s.specialized[n] == e.value) {
          let a = s.specializers[n](this.stream.read(e.start, e.end), r);
          if (a >= 0 && r.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? e.extended = a >> 1 : e.value = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(o + 1);
  }
  putAction(e, t, r, o) {
    for (let s = 0; s < o; s += 3)
      if (this.actions[s] == e)
        return o;
    return this.actions[o++] = e, this.actions[o++] = t, this.actions[o++] = r, o;
  }
  addActions(e, t, r, o) {
    let { state: s } = e, { parser: n } = e.p, { data: a } = n;
    for (let l = 0; l < 2; l++)
      for (let u = n.stateSlot(
        s,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (a[u] == 65535)
          if (a[u + 1] == 1)
            u = mr(a, u + 2);
          else {
            o == 0 && a[u + 1] == 2 && (o = this.putAction(mr(a, u + 2), t, r, o));
            break;
          }
        a[u] == t && (o = this.putAction(mr(a, u + 1), t, r, o));
      }
    return o;
  }
}
var cb;
(function(i) {
  i[i.Distance = 5] = "Distance", i[i.MaxRemainingPerStep = 3] = "MaxRemainingPerStep", i[i.MinBufferLengthPrune = 500] = "MinBufferLengthPrune", i[i.ForceReduceLimit = 10] = "ForceReduceLimit", i[i.CutDepth = 15e3] = "CutDepth", i[i.CutTo = 9e3] = "CutTo", i[i.MaxLeftAssociativeReductionCount = 300] = "MaxLeftAssociativeReductionCount", i[i.MaxStackCount = 12] = "MaxStackCount";
})(cb || (cb = {}));
class Xk {
  constructor(e, t, r, o) {
    this.parser = e, this.input = t, this.ranges = o, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new $k(t, o), this.tokens = new Hk(e, this.stream), this.topTerm = e.top[1];
    let { from: s } = o[0];
    this.stacks = [rh.start(this, e.top[0], s)], this.fragments = r.length && this.stream.end - s > e.bufferLength * 4 ? new Vk(r, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, r = this.stacks = [], o, s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [n] = e;
      for (; n.forceReduce() && n.stack.length && n.stack[n.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let n = 0; n < e.length; n++) {
      let a = e[n];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > t)
          r.push(a);
        else {
          if (this.advanceStack(a, r, e))
            continue;
          {
            o || (o = [], s = []), o.push(a);
            let l = this.tokens.getMainToken(a);
            s.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let n = o && Bk(o);
      if (n)
        return this.stackToTree(n);
      if (this.parser.strict)
        throw _i && o && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && o) {
      let n = this.stoppedAt != null && o[0].pos > this.stoppedAt ? o[0] : this.runRecovery(o, s, r);
      if (n)
        return this.stackToTree(n.forceAll());
    }
    if (this.recovering) {
      let n = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > n)
        for (r.sort((a, l) => l.score - a.score); r.length > n; )
          r.pop();
      r.some((a) => a.reducePos > t) && this.recovering--;
    } else if (r.length > 1) {
      e:
        for (let n = 0; n < r.length - 1; n++) {
          let a = r[n];
          for (let l = n + 1; l < r.length; l++) {
            let u = r[l];
            if (a.sameState(u) || a.buffer.length > 500 && u.buffer.length > 500)
              if ((a.score - u.score || a.buffer.length - u.buffer.length) > 0)
                r.splice(l--, 1);
              else {
                r.splice(n--, 1);
                continue e;
              }
          }
        }
      r.length > 12 && r.splice(
        12,
        r.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = r[0].pos;
    for (let n = 1; n < r.length; n++)
      r[n].pos < this.minStackPos && (this.minStackPos = r[n].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, r) {
    let o = e.pos, { parser: s } = this, n = _i ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && o > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let u = e.curContext && e.curContext.tracker.strict, h = u ? e.curContext.hash : 0;
      for (let c = this.fragments.nodeAt(o); c; ) {
        let d = this.parser.nodeSet.types[c.type.id] == c.type ? s.getGoto(e.state, c.type.id) : -1;
        if (d > -1 && c.length && (!u || (c.prop(Oe.contextHash) || 0) == h))
          return e.useNode(c, d), _i && console.log(n + this.stackID(e) + ` (via reuse of ${s.getName(c.type.id)})`), !0;
        if (!(c instanceof Xe) || c.children.length == 0 || c.positions[0] > 0)
          break;
        let f = c.children[0];
        if (f instanceof Xe && c.positions[0] == 0)
          c = f;
        else
          break;
      }
    }
    let a = s.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), _i && console.log(n + this.stackID(e) + ` (via always-reduce ${s.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 15e3)
      for (; e.stack.length > 9e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let u = 0; u < l.length; ) {
      let h = l[u++], c = l[u++], d = l[u++], f = u == l.length || !r, p = f ? e : e.split();
      if (p.apply(h, c, d), _i && console.log(n + this.stackID(p) + ` (via ${h & 65536 ? `reduce of ${s.getName(
        h & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${s.getName(c)} @ ${o}${p == e ? "" : ", split"})`), f)
        return !0;
      p.pos > o ? t.push(p) : r.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let r = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > r)
        return db(e, t), !0;
    }
  }
  runRecovery(e, t, r) {
    let o = null, s = !1;
    for (let n = 0; n < e.length; n++) {
      let a = e[n], l = t[n << 1], u = t[(n << 1) + 1], h = _i ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (s || (s = !0, a.restart(), _i && console.log(h + this.stackID(a) + " (restarted)"), this.advanceFully(a, r))))
        continue;
      let c = a.split(), d = h;
      for (let f = 0; c.forceReduce() && f < 10 && (_i && console.log(d + this.stackID(c) + " (via force-reduce)"), !this.advanceFully(c, r)); f++)
        _i && (d = this.stackID(c) + " -> ");
      for (let f of a.recoverByInsert(l))
        _i && console.log(h + this.stackID(f) + " (via recover-insert)"), this.advanceFully(f, r);
      this.stream.end > a.pos ? (u == a.pos && (u++, l = 0), a.recoverByDelete(l, u), _i && console.log(h + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), db(a, r)) : (!o || o.score < a.score) && (o = a);
    }
    return o;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), Xe.build({
      buffer: oh.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (zc || (zc = /* @__PURE__ */ new WeakMap())).get(e);
    return t || zc.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function db(i, e) {
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    if (r.pos == i.pos && r.sameState(i)) {
      e[t].score < i.score && (e[t] = i);
      return;
    }
  }
  e.push(i);
}
class Yk {
  constructor(e, t, r) {
    this.source = e, this.flags = t, this.disabled = r;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const Zc = (i) => i;
class cI {
  /// Define a context tracker.
  constructor(e) {
    this.start = e.start, this.shift = e.shift || Zc, this.reduce = e.reduce || Zc, this.reuse = e.reuse || Zc, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class Pr extends UC {
  /// @internal
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      t.push("");
    let r = Object.keys(e.topRules).map((a) => e.topRules[a][1]), o = [];
    for (let a = 0; a < t.length; a++)
      o.push([]);
    function s(a, l, u) {
      o[a].push([l, l.deserialize(String(u))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = Oe[l]);
        for (let u = 1; u < a.length; ) {
          let h = a[u++];
          if (h >= 0)
            s(h, l, a[u++]);
          else {
            let c = a[u + -h];
            for (let d = -h; d > 0; d--)
              s(a[u++], l, c);
            u++;
          }
        }
      }
    this.nodeSet = new lO(t.map((a, l) => di.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: o[l],
      top: r.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = yC;
    let n = zn(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(fb), this.states = zn(e.states, Uint32Array), this.data = zn(e.stateData), this.goto = zn(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new Ws(n, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, r) {
    let o = new Xk(this, e, t, r);
    for (let s of this.wrappers)
      o = s(o, e, t, r);
    return o;
  }
  /// Get a goto table entry @internal
  getGoto(e, t, r = !1) {
    let o = this.goto;
    if (t >= o[0])
      return -1;
    for (let s = o[t + 1]; ; ) {
      let n = o[s++], a = n & 1, l = o[s++];
      if (a && r)
        return l;
      for (let u = s + (n >> 1); s < u; s++)
        if (o[s] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /// Check if this state has an action for a given terminal @internal
  hasAction(e, t) {
    let r = this.data;
    for (let o = 0; o < 2; o++)
      for (let s = this.stateSlot(
        e,
        o ? 2 : 1
        /* ParseState.Actions */
      ), n; ; s += 3) {
        if ((n = r[s]) == 65535)
          if (r[s + 1] == 1)
            n = r[s = mr(r, s + 2)];
          else {
            if (r[s + 1] == 2)
              return mr(r, s + 2);
            break;
          }
        if (n == t || n == 0)
          return mr(r, s + 1);
      }
    return 0;
  }
  /// @internal
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /// @internal
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /// @internal
  validAction(e, t) {
    return !!this.allActions(e, (r) => r == t ? !0 : null);
  }
  /// @internal
  allActions(e, t) {
    let r = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), o = r ? t(r) : void 0;
    for (let s = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); o == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = mr(this.data, s + 2);
        else
          break;
      o = t(mr(this.data, s + 1));
    }
    return o;
  }
  /// Get the states that can follow this one through shift actions or
  /// goto jumps. @internal
  nextStates(e) {
    let t = [];
    for (let r = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = mr(this.data, r + 2);
        else
          break;
      if (!(this.data[r + 2] & 1)) {
        let o = this.data[r + 1];
        t.some((s, n) => n & 1 && s == o) || t.push(this.data[r], o);
      }
    }
    return t;
  }
  /// Configure the parser. Returns a new parser instance that has the
  /// given settings modified. Settings not provided in `config` are
  /// kept from the original parser.
  configure(e) {
    let t = Object.assign(Object.create(Pr.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let r = this.topRules[e.top];
      if (!r)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = r;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((r) => {
      let o = e.tokenizers.find((s) => s.from == r);
      return o ? o.to : r;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((r, o) => {
      let s = e.specializers.find((a) => a.from == r.external);
      if (!s)
        return r;
      let n = Object.assign(Object.assign({}, r), { external: s.to });
      return t.specializers[o] = fb(n), n;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /// Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  /// are registered for this parser.
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /// Returns the name associated with a given term. This will only
  /// work for all terms when the parser was generated with the
  /// `--names` option. By default, only the names of tagged terms are
  /// stored.
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /// The eof term id is always allocated directly after the node
  /// types. @internal
  get eofTerm() {
    return this.maxNode + 1;
  }
  /// The type of top node produced by the parser.
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /// @internal
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /// @internal
  parseDialect(e) {
    let t = Object.keys(this.dialects), r = t.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let n = t.indexOf(s);
        n >= 0 && (r[n] = !0);
      }
    let o = null;
    for (let s = 0; s < t.length; s++)
      if (!r[s])
        for (let n = this.dialects[t[s]], a; (a = this.data[n++]) != 65535; )
          (o || (o = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new Yk(e, r, o);
  }
  /// Used by the output of the parser generator. Not available to
  /// user code. @hide
  static deserialize(e) {
    return new Pr(e);
  }
}
function mr(i, e) {
  return i[e] | i[e + 1] << 16;
}
function Bk(i) {
  let e = null;
  for (let t of i) {
    let r = t.p.stoppedAt;
    (t.pos == t.p.stream.end || r != null && t.pos > r) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function fb(i) {
  if (i.external) {
    let e = i.extend ? 1 : 0;
    return (t, r) => i.external(t, r) << 1 | e;
  }
  return i.get;
}
const Fk = ps({
  null: b.null,
  instanceof: b.operatorKeyword,
  this: b.self,
  "new super assert open to with void": b.keyword,
  "class interface extends implements enum var": b.definitionKeyword,
  "module package import": b.moduleKeyword,
  "switch while for if else case default do break continue return try catch finally throw": b.controlKeyword,
  ["requires exports opens uses provides public private protected static transitive abstract final strictfp synchronized native transient volatile throws"]: b.modifier,
  IntegerLiteral: b.integer,
  FloatingPointLiteral: b.float,
  "StringLiteral TextBlock": b.string,
  CharacterLiteral: b.character,
  LineComment: b.lineComment,
  BlockComment: b.blockComment,
  BooleanLiteral: b.bool,
  PrimitiveType: b.standard(b.typeName),
  TypeName: b.typeName,
  Identifier: b.variableName,
  "MethodName/Identifier": b.function(b.variableName),
  Definition: b.definition(b.variableName),
  ArithOp: b.arithmeticOperator,
  LogicOp: b.logicOperator,
  BitOp: b.bitwiseOperator,
  CompareOp: b.compareOperator,
  AssignOp: b.definitionOperator,
  UpdateOp: b.updateOperator,
  Asterisk: b.punctuation,
  Label: b.labelName,
  "( )": b.paren,
  "[ ]": b.squareBracket,
  "{ }": b.brace,
  ".": b.derefOperator,
  ", ;": b.separator
}), Wk = { __proto__: null, true: 34, false: 34, null: 42, void: 46, byte: 48, short: 48, int: 48, long: 48, char: 48, float: 48, double: 48, boolean: 48, extends: 62, super: 64, class: 76, this: 78, new: 84, public: 100, protected: 102, private: 104, abstract: 106, static: 108, final: 110, strictfp: 112, default: 114, synchronized: 116, native: 118, transient: 120, volatile: 122, throws: 150, implements: 160, interface: 166, enum: 176, instanceof: 236, open: 265, module: 267, requires: 272, transitive: 274, exports: 276, to: 278, opens: 280, uses: 282, provides: 284, with: 286, package: 290, import: 294, if: 306, else: 308, while: 312, for: 316, var: 323, assert: 330, switch: 334, case: 340, do: 344, break: 348, continue: 352, return: 356, throw: 362, try: 366, catch: 370, finally: 378 }, zk = Pr.deserialize({
  version: 14,
  states: "#!hQ]QPOOO&tQQO'#H[O(xQQO'#CbOOQO'#Cb'#CbO)PQPO'#CaO)XOSO'#CpOOQO'#Ha'#HaOOQO'#Cu'#CuO*tQPO'#D_O+_QQO'#HkOOQO'#Hk'#HkO-sQQO'#HfO-zQQO'#HfOOQO'#Hf'#HfOOQO'#He'#HeO0OQPO'#DUO0]QPO'#GlO3TQPO'#D_O3[QPO'#DzO)PQPO'#E[O3}QPO'#E[OOQO'#DV'#DVO5]QQO'#H_O7dQQO'#EeO7kQPO'#EdO7pQPO'#EfOOQO'#H`'#H`O5sQQO'#H`O8sQQO'#FgO8zQPO'#EwO9PQPO'#E|O9PQPO'#FOOOQO'#H_'#H_OOQO'#HW'#HWOOQO'#Gf'#GfOOQO'#HV'#HVO:aQPO'#FhOOQO'#HU'#HUOOQO'#Ge'#GeQ]QPOOOOQO'#Hq'#HqO:fQPO'#HqO:kQPO'#D{O:kQPO'#EVO:kQPO'#EQO:sQPO'#HnO;UQQO'#EfO)PQPO'#C`O;^QPO'#C`O)PQPO'#FbO;cQPO'#FdO;nQPO'#FjO;nQPO'#FmO:kQPO'#FrO;sQPO'#FoO9PQPO'#FvO;nQPO'#FxO]QPO'#F}O;xQPO'#GPO<TQPO'#GRO<`QPO'#GTO;nQPO'#GVO9PQPO'#GWO<gQPO'#GYOOQO'#H['#H[O=WQQO,58{OOQO'#HY'#HYOOOO'#Gg'#GgO>yOSO,59[OOQO,59[,59[OOQO'#Hg'#HgO?jQPO,59eO@lQPO,59yOOQO-E:d-E:dO)PQPO,58zOA`QPO,58zO)PQPO,5;|OAeQPO'#DQOAjQPO'#DQOOQO'#Gi'#GiOBjQQO,59jOOQO'#Dm'#DmODRQPO'#HsOD]QPO'#DlODkQPO'#HrODsQPO,5<^ODxQPO,59^OEcQPO'#CxOOQO,59c,59cOEjQPO,59bOGrQQO'#H[OJVQQO'#CbOJmQPO'#D_OKrQQO'#HkOLSQQO,59pOLZQPO'#DvOLiQPO'#HzOLqQPO,5:`OLvQPO,5:`OM^QPO,5;mOMiQPO'#IROMtQPO,5;dOMyQPO,5=WOOQO-E:j-E:jOOQO,5:f,5:fO! aQPO,5:fO! hQPO,5:vO! mQPO,5<^O)PQPO,5:vO:kQPO,5:gO:kQPO,5:qO:kQPO,5:lO:kQPO,5<^O!!^QPO,59qO9PQPO,5:}O!!eQPO,5;QO9PQPO,59TO!!sQPO'#DXOOQO,5;O,5;OOOQO'#El'#ElOOQO'#En'#EnO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;eOOQO,5;h,5;hOOQO,5<R,5<RO!!zQPO,5;aO!#]QPO,5;cO!!zQPO'#CyO!#dQQO'#HkO!#rQQO,5;jO]QPO,5<SOOQO-E:c-E:cOOQO,5>],5>]O!%SQPO,5:gO!%bQPO,5:qO!%jQPO,5:lO!%uQPO,5>YOLZQPO,5>YO! {QPO,59UO!&QQQO,58zO!&YQQO,5;|O!&bQQO,5<OO)PQPO,5<OO9PQPO'#DUO]QPO,5<UO]QPO,5<XO!&jQPO'#FqO]QPO,5<ZO]QPO,5<`O!&zQQO,5<bO!'UQPO,5<dO!'ZQPO,5<iOOQO'#Fi'#FiOOQO,5<k,5<kO!'`QPO,5<kOOQO,5<m,5<mO!'eQPO,5<mO!'jQQO,5<oOOQO,5<o,5<oO<jQPO,5<qO!'qQQO,5<rO!'xQPO'#GcO!)OQPO,5<tO<jQPO,5<|O)PQPO,58}O!,|QPO'#ChOOQO1G.k1G.kOOOO-E:e-E:eOOQO1G.v1G.vO!-WQPO,59jO!&QQQO1G.fO)PQPO1G.fO!-eQQO1G1hOOQO,59l,59lO!-mQPO,59lOOQO-E:g-E:gO!-rQPO,5>_O!.ZQPO,5:WO:kQPO'#GnO!.bQPO,5>^OOQO1G1x1G1xOOQO1G.x1G.xO!.{QPO'#CyO!/kQPO'#HkO!/uQPO'#CzO!0TQPO'#HjO!0]QPO,59dOOQO1G.|1G.|OEjQPO1G.|O!0sQPO,59eO!1QQQO'#H[O!1cQQO'#CbOOQO,5:b,5:bO:kQPO,5:cOOQO,5:a,5:aO!1tQQO,5:aOOQO1G/[1G/[O!1yQPO,5:bO!2[QPO'#GqO!2oQPO,5>fOOQO1G/z1G/zO!2wQPO'#DvO!3YQPO'#D_O!3aQPO1G/zO!!zQPO'#GoO!3fQPO1G1XO9PQPO1G1XO:kQPO'#GwO!3nQPO,5>mOOQO1G1O1G1OOOQO1G0Q1G0QO!3vQPO'#E]OOQO1G0b1G0bO!4gQPO1G1xO! hQPO1G0bO!%SQPO1G0RO!%bQPO1G0]O!%jQPO1G0WOOQO1G/]1G/]O!4lQQO1G.pO7kQPO1G0jO)PQPO1G0jO:sQPO'#HnO!6`QQO1G.pOOQO1G.p1G.pO!6eQQO1G0iOOQO1G0l1G0lO!6lQPO1G0lO!6wQQO1G.oO!7_QQO'#HoO!7lQPO,59sO!8{QQO1G0pO!:dQQO1G0pO!;rQQO1G0pO!<PQQO1G0pO!=UQQO1G0pO!=lQQO1G0pO!=vQQO1G1PO!=}QQO'#HkOOQO1G0{1G0{O!?QQQO1G0}OOQO1G0}1G0}OOQO1G1n1G1nO! pQPO'#DqO!ARQPO'#D[O!!zQPO'#D|O!!zQPO'#D}OOQO1G0R1G0RO!AYQPO1G0RO!A_QPO1G0RO!AgQPO1G0RO!ArQPO'#EXOOQO1G0]1G0]O!BVQPO1G0]O!B[QPO'#ETO!!zQPO'#ESOOQO1G0W1G0WO!CUQPO1G0WO!CZQPO1G0WO!CcQPO'#EhO!CjQPO'#EhOOQO'#Gv'#GvO!CrQQO1G0mO!EcQQO1G3tO7kQPO1G3tO!GbQPO'#FWOOQO1G.f1G.fOOQO1G1h1G1hO!GiQPO1G1jOOQO1G1j1G1jO!GtQQO1G1jO!G|QPO1G1pOOQO1G1s1G1sO)aQPO'#D_O+_QQO,5<aO!KtQPO,5<aO!LVQPO,5<]O!L^QPO,5<]OOQO1G1u1G1uOOQO1G1z1G1zOOQO1G1|1G1|O9PQPO1G1|O#!QQPO'#FzOOQO1G2O1G2OO;nQPO1G2TOOQO1G2V1G2VOOQO1G2X1G2XOOQO1G2Z1G2ZOOQO1G2]1G2]OOQO1G2^1G2^O#!XQQO'#H[O##SQQO'#CbO+_QQO'#HkO##}QQOOO#$kQQO'#EeO#$YQQO'#H`OLZQPO'#GdO#$rQPO,5<}OOQO'#HO'#HOO#$zQPO1G2`O#(xQPO'#G[O<jQPO'#G`OOQO1G2`1G2`O#(}QPO1G2hOOQO1G.i1G.iO#.SQQO'#EeO#.dQQO'#H^O#.tQPO'#FSOOQO'#H^'#H^O#/OQPO'#H^O#/mQPO'#IUO#/uQPO,59SOOQO7+$Q7+$QO!&QQQO7+$QOOQO7+'S7+'SOOQO1G/W1G/WO#/zQPO'#DoO#0UQQO'#HtOOQO'#Ht'#HtOOQO1G/r1G/rOOQO,5=Y,5=YOOQO-E:l-E:lO#0fQWO,58{O#0mQPO,59fOOQO,59f,59fO!!zQPO'#HmOD}QPO'#GhO#0{QPO,5>UOOQO1G/O1G/OOOQO7+$h7+$hOOQO1G/{1G/{O#1TQQO1G/{OOQO1G/}1G/}O#1YQPO1G/{OOQO1G/|1G/|O:kQPO1G/}OOQO,5=],5=]OOQO-E:o-E:oOOQO7+%f7+%fOOQO,5=Z,5=ZOOQO-E:m-E:mO9PQPO7+&sOOQO7+&s7+&sOOQO,5=c,5=cOOQO-E:u-E:uO#1_QPO'#EUO#1mQPO'#EUOOQO'#Gu'#GuO#2UQPO,5:wOOQO,5:w,5:wOOQO7+'d7+'dOOQO7+%|7+%|OOQO7+%m7+%mO!AYQPO7+%mO!A_QPO7+%mO!AgQPO7+%mOOQO7+%w7+%wO!BVQPO7+%wOOQO7+%r7+%rO!CUQPO7+%rO!CZQPO7+%rOOQO7+&U7+&UOOQO'#Ee'#EeO7kQPO7+&UO7kQPO,5>YO#2uQPO7+$[OOQO7+&T7+&TOOQO7+&W7+&WO9PQPO'#GjO#3TQPO,5>ZOOQO1G/_1G/_O9PQPO7+&kO#3`QQO,59eO#4cQPO'#DrO! pQPO'#DrO#4nQPO'#HwO#4vQPO,5:]O#5aQQO'#HgO#5|QQO'#CuO! mQPO'#HvO#6lQPO'#DpO#6vQPO'#HvO#7XQPO'#DpO#7aQPO'#IPO#7fQPO'#E`OOQO'#Hp'#HpOOQO'#Gk'#GkO#7nQPO,59vOOQO,59v,59vO#7uQPO'#HqOOQO,5:h,5:hO#9]QPO'#H|OOQO'#EP'#EPOOQO,5:i,5:iO#9hQPO'#EYO:kQPO'#EYO#9yQPO'#H}O#:UQPO,5:sO! mQPO'#HvO!!zQPO'#HvO#:^QPO'#DpOOQO'#Gs'#GsO#:eQPO,5:oOOQO,5:o,5:oOOQO,5:n,5:nOOQO,5;S,5;SO#;_QQO,5;SO#;fQPO,5;SOOQO-E:t-E:tOOQO7+&X7+&XOOQO7+)`7+)`O#;mQQO7+)`OOQO'#Gz'#GzO#=ZQPO,5;rOOQO,5;r,5;rO#=bQPO'#FXO)PQPO'#FXO)PQPO'#FXO)PQPO'#FXO#=pQPO7+'UO#=uQPO7+'UOOQO7+'U7+'UO]QPO7+'[O#>QQPO1G1{O! mQPO1G1{O#>`QQO1G1wO!!sQPO1G1wO#>gQPO1G1wO#>nQQO7+'hOOQO'#G}'#G}O#>uQPO,5<fOOQO,5<f,5<fO#>|QPO'#HqO9PQPO'#F{O#?UQPO7+'oO#?ZQPO,5=OO! mQPO,5=OO#?`QPO1G2iO#@iQPO1G2iOOQO1G2i1G2iOOQO-E:|-E:|OOQO7+'z7+'zO!2[QPO'#G^O<jQPO,5<vOOQO,5<z,5<zO#@qQPO7+(SOOQO7+(S7+(SO#DoQPO,59TO#DvQPO'#ITO#EOQPO,5;nO)PQPO'#GyO#ETQPO,5>pOOQO1G.n1G.nOOQO<<Gl<<GlO#E]QPO'#HuO#EeQPO,5:ZOOQO1G/Q1G/QOOQO,5>X,5>XOOQO,5=S,5=SOOQO-E:f-E:fO#EjQPO7+%gOOQO7+%g7+%gOOQO7+%i7+%iOOQO<<J_<<J_O#FQQPO'#H[O#FXQPO'#CbO#F`QPO,5:pO#FeQPO,5:xO#1_QPO,5:pOOQO-E:s-E:sOOQO1G0c1G0cOOQO<<IX<<IXO!AYQPO<<IXO!A_QPO<<IXOOQO<<Ic<<IcOOQO<<I^<<I^O!CUQPO<<I^OOQO<<Ip<<IpO#FjQQO<<GvO7kQPO<<IpO)PQPO<<IpOOQO<<Gv<<GvO#H^QQO,5=UOOQO-E:h-E:hO#HkQQO<<JVOOQO,5:^,5:^O!!zQPO'#DsO#IRQPO,5:^O! pQPO'#GpO#I^QPO,5>cOOQO1G/w1G/wO#IfQPO'#HsO#ImQPO,59xO#IrQPO,5>bO! mQPO,59xO#I}QPO,5:[O#7fQPO,5:zO! mQPO,5>bO!!zQPO,5>bO#7aQPO,5>kOOQO,5:[,5:[OLvQPO'#DtOOQO,5>k,5>kO#JVQPO'#EaOOQO,5:z,5:zO#MWQPO,5:zO!!zQPO'#DxOOQO-E:i-E:iOOQO1G/b1G/bOOQO,5:y,5:yO!!zQPO'#GrO#M]QPO,5>hOOQO,5:t,5:tO#MhQPO,5:tO#MvQPO,5:tO#NXQPO'#GtO#NoQPO,5>iO#NzQPO'#EZOOQO1G0_1G0_O$ RQPO1G0_O! mQPO,5:pOOQO-E:q-E:qOOQO1G0Z1G0ZOOQO1G0n1G0nO$ WQQO1G0nOOQO<<Lz<<LzOOQO-E:x-E:xOOQO1G1^1G1^O$ _QQO,5;sOOQO'#G{'#G{O#=bQPO,5;sOOQO'#IV'#IVO$ gQQO,5;sO$ xQQO,5;sOOQO<<Jp<<JpO$!QQPO<<JpOOQO<<Jv<<JvO9PQPO7+'gO$!VQPO7+'gO!!sQPO7+'cO$!eQPO7+'cO$!jQQO7+'cOOQO<<KS<<KSOOQO-E:{-E:{OOQO1G2Q1G2QOOQO,5<g,5<gO$!qQQO,5<gOOQO<<KZ<<KZO9PQPO1G2jO$!xQPO1G2jOOQO,5=l,5=lOOQO7+(T7+(TO$!}QPO7+(TOOQO-E;O-E;OO$$lQWO'#HfO$$WQWO'#HfO$$sQPO'#G_O:kQPO,5<xOLZQPO,5<xOOQO1G2b1G2bOOQO<<Kn<<KnO$%UQQO1G.oOOQO1G1Z1G1ZO$%`QPO'#GxO$%mQPO,5>oOOQO1G1Y1G1YO$%uQPO'#FTOOQO,5=e,5=eOOQO-E:w-E:wO$%zQPO'#GmO$&XQPO,5>aOOQO1G/u1G/uOOQO<<IR<<IROOQO1G0[1G0[O$&aQPO1G0dO$&fQPO1G0[O$&kQPO1G0dOOQOAN>sAN>sO!AYQPOAN>sOOQOAN>xAN>xOOQOAN?[AN?[O7kQPOAN?[O$&pQPO,5:_OOQO1G/x1G/xOOQO,5=[,5=[OOQO-E:n-E:nO$&{QPO,5>eOOQO1G/d1G/dOOQO1G3|1G3|O$'^QPO1G/dOOQO1G/v1G/vOOQO1G0f1G0fO#MWQPO1G0fO#7aQPO'#HyO$'cQPO1G3|O! mQPO1G3|OOQO1G4V1G4VOK^QPO'#DvOJmQPO'#D_OOQO,5:{,5:{O$'nQPO,5:{O$'nQPO,5:{O$'uQQO'#H_O$'|QQO'#H`O$(WQQO'#EbO$(cQPO'#EbOOQO,5:d,5:dOOQO,5=^,5=^OOQO-E:p-E:pOOQO1G0`1G0`O$(kQPO1G0`OOQO,5=`,5=`OOQO-E:r-E:rO$(yQPO,5:uOOQO7+%y7+%yOOQO7+&Y7+&YOOQO1G1_1G1_O$)QQQO1G1_OOQO-E:y-E:yO$)YQQO'#IWO$)TQPO1G1_O$ mQPO1G1_O)PQPO1G1_OOQOAN@[AN@[O$)eQQO<<KRO9PQPO<<KRO$)lQPO<<J}OOQO<<J}<<J}O!!sQPO<<J}OOQO1G2R1G2RO$)qQQO7+(UO9PQPO7+(UOOQO<<Ko<<KoP!'xQPO'#HQOLZQPO'#HPO$){QPO,5<yO$*WQPO1G2dO:kQPO1G2dOOQO,5=d,5=dOOQO-E:v-E:vO#DoQPO,5;oOOQO,5=X,5=XOOQO-E:k-E:kO$*]QPO7+&OOOQO7+%v7+%vO$*kQPO7+&OOOQOG24_G24_OOQOG24vG24vO$*pQPO1G/yO$*{QPO1G4POOQO7+%O7+%OOOQO7+&Q7+&QOOQO7+)h7+)hO$+^QPO7+)hO!0bQPO,5:aOOQO1G0g1G0gO$+iQPO1G0gO$+pQPO,59qO$,UQPO,5:|O7kQPO,5:|OOQO7+%z7+%zOOQO7+&y7+&yO)PQPO'#G|O$,ZQPO,5>rO$,cQPO7+&yO$,hQQO'#IXOOQOAN@mAN@mO$,sQQOAN@mOOQOAN@iAN@iO$,zQPOAN@iO$-PQQO<<KpO$-ZQPO,5=kOOQO-E:}-E:}OOQO7+(O7+(OO$-lQPO7+(OO$-qQPO<<IjOOQO<<Ij<<IjO#DoQPO<<IjO$-qQPO<<IjOOQO<<MS<<MSOOQO7+&R7+&RO$.PQPO1G0jO$.[QQO1G0hOOQO1G0h1G0hO$.dQPO1G0hO$.iQQO,5=hOOQO-E:z-E:zOOQO<<Je<<JeO$.tQPO,5>sOOQOG26XG26XOOQOG26TG26TOOQO<<Kj<<KjOOQOAN?UAN?UO#DoQPOAN?UO$.|QPOAN?UO$/RQPOAN?UO7kQPO7+&SO$/aQPO7+&SOOQO7+&S7+&SO$/fQPOG24pOOQOG24pG24pO#DoQPOG24pO$/kQPO<<InOOQO<<In<<InOOQOLD*[LD*[O$/pQPOLD*[OOQOAN?YAN?YOOQO!$'Mv!$'MvO)PQPO'#CaO$/uQQO'#H[O$0YQQO'#CbO!!zQPO'#Cy",
  stateData: "$0u~OPOSQOS%wOS~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~OWiXW&OXZ&OXuiXu&OX!P&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~O#o$]X~P$wOWUXW&ZXZUXuUXu&ZX!PUX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~O#o$]X~P&{O%}RO&P!bO~O&U!gO&W!eO~Og]Oh]O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO%{SO%}!hO&PVOg!RXh!RX$g!RX%}!RX&P!RX~O#x!mO#y!lO$V!nOv!RX!u!RX!z!RX&r!RX~P)aOW!xOu!oO%{SO%}!sO&P!sO&t&_X~OW!{Ou&YX%{&YX%}&YX&P&YX&t&YXY&YXw&YX&l&YX&o&YXZ&YXq&YX&[&YX!P&YX#_&YX#a&YX#c&YX#d&YX#e&YX#f&YX#g&YX#h&YX#j&YX#n&YX#q&YX}&YX!r&YX#o&YXs&YX|&YX~O&]!yO~P+sO&]&YX~P+sOZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO#eoO#qnO#soO#toO%{SO&VTO~O%}!}O&P!|OY&nP~P.RO%{SOg%`Xh%`Xv%`X!S%`X!T%`X!U%`X!V%`X!W%`X!X%`X!Y%`X!Z%`X!]%`X!^%`X!_%`X!u%`X!z%`X$g%`X%}%`X&P%`X&r%`X&]%`X~O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xOg!RXh!RXv!RX!u!RX!z!RX%}!RX&P!RX&r!RX&]!RX~O$g!RX~P1sO|#[O~P]Og]Oh]Ov#aO!u#cO!z#bO%}!hO&PVO&r#`O~O$g#dO~P3cOu#fO&t#gO!P&RX#_&RX#a&RX#c&RX#d&RX#e&RX#f&RX#g&RX#h&RX#j&RX#n&RX#q&RX&[&RX&]&RX&l&RX~OW#eOY&RX#o&RXs&RXq&RX|&RX~P4UO!b#hO#]#hOW&SXu&SX!P&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SXY&SX#o&SXs&SXq&SX|&SX~OZ#XX~P5sOZ#iO~O&t#gO~O#_#mO#a#nO#c#oO#d#oO#e#pO#f#qO#g#rO#h#rO#j#vO#n#sO#q#tO&[#kO&]#kO&l#lO~O!P#uO~P7uO&v#wO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O#eoO#qnO#soO#toO%{SO%}0iO&P0hO&VTO~O#o#{O~O![#}O~O%}!sO&P!sO~Og]Oh]O%}!hO&PVO&]!yO~OW$TO&t#gO~O#y!lO~O!W$XO%}RO&P!bO~OZ$YO~OZ$]O~O!P$dO%}$cO&P$cO~O!P$fO%}$cO&P$cO~O!P$iO~P9POZ$lO}bO~OW$oOZ$pOgTahTa%{Ta%}Ta&PTa~OvTa!STa!TTa!UTa!VTa!WTa!XTa!YTa!ZTa!]Ta!^Ta!_Ta!uTa!zTa#xTa#yTa$VTa$gTa&rTauTaYTa&]TaqTa|Ta!PTa~P<oO&U$sO&W!eO~Ou!oO%{SOqma&[maYma&lma!Pma~O&tma}ma!rma~P?RO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO~Og!Rah!Rav!Ra!u!Ra!z!Ra$g!Ra%}!Ra&P!Ra&r!Ra&]!Ra~P?wO#y$vO~Os$xO~Ou$yO%{SO~Ou!oO%{ra%}ra&Pra&traYrawra&lra&ora!Pra&[raqra~OWra#_ra#ara#cra#dra#era#fra#gra#hra#jra#nra#qra&]ra#orasra|ra~PArOu!oO%{SOq&gX!P&gX!b&gX~OY&gX#o&gX~PCpO!b$|Oq!`X!P!`XY!`X~Oq$}O!P&fX~O!P%PO~Ov%QO~Og]Oh]O%{0gO%}!hO&PVO&`%TO~O&[&^P~PD}O%{SO%}!hO&PVO~OWiXW&OXY&OXZ&OXuiXu&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~OYiXY!aXq!aXwiX&liX&oiX~PEuOWUXW&ZXYUXZUXuUXu&ZX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~OY!aXY&ZXq!aXw&ZX&l&ZX&o&ZX~PHYOg]Oh]O%{SO%}!hO&PVOg!RXh!RX%}!RX&P!RX~P?wOu!oOw%_O%{SO%}%[O&P%ZO&o%^O~OW!xOY&_X&l&_X&t&_X~PK^OY%aO~P7uOg]Oh]O%}!hO&PVO~Oq%cOY&nX~OY%eO~Og]Oh]O%{SO%}!hO&PVOY&nP~P?wOY%kO&l%iO&t#gO~Oq%lO&v#wOY&uX~OY%nO~O%{SOg%`ah%`av%`a!S%`a!T%`a!U%`a!V%`a!W%`a!X%`a!Y%`a!Z%`a!]%`a!^%`a!_%`a!u%`a!z%`a$g%`a%}%`a&P%`a&r%`a&]%`a~O|%oO~P]O}%pO~Ou!oO%{SO%}!sO&P!sO~Op%|Ow%}O%}RO&P!bO&]!yO~Oz%{O~P! {Oz&PO%}RO&P!bO&]!yO~OY&cP~P9POg]Oh]O%{SO%}!hO&PVO~O}bO~P9POW!xOu!oO%{SO&t&_X~O#q#tO!P#ra#_#ra#a#ra#c#ra#d#ra#e#ra#f#ra#g#ra#h#ra#j#ra#n#ra&[#ra&]#ra&l#raY#ra#o#ras#raq#ra|#ra~Oo&dO}&cO!r&eO&]&bO~O}&jO!r&eO~Oo&nO}&mO&]&bO~OZ#iOu&rO%{SO~OW$oO}&xO~OW$oO!P&zO~OW&{O!P&|O~O$g!VO%}0iO&P0hO!P&cP~P.RO!P'XO#o'YO~P7uO}'ZO~O$b']O~O!P'^O~O!P'_O~O!P'`O~P7uO!P'bO~P7uOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wO%P'mO%T'nOZ$|a_$|a`$|aa$|ab$|ac$|ae$|ag$|ah$|ap$|av$|aw$|az$|a}$|a!P$|a!S$|a!T$|a!U$|a!V$|a!W$|a!X$|a!Y$|a!Z$|a![$|a!]$|a!^$|a!_$|a!u$|a!z$|a#e$|a#q$|a#s$|a#t$|a#x$|a#y$|a$V$|a$X$|a$_$|a$b$|a$d$|a$g$|a$k$|a$m$|a$r$|a$t$|a$v$|a$x$|a${$|a$}$|a%u$|a%{$|a%}$|a&P$|a&V$|a&r$|a|$|a$`$|a$p$|a~O}'tOY&xP~P9PO}ra!rra&|ra~PArOW$oO!P'{O~Os'|O~Ou!oO%{SOq&ga!P&ga!b&gaY&ga#o&ga~O}'}O~P9POq$}O!P&fa~Og]Oh]O%{0gO%}!hO&PVO~O&`(UO~P!.jOu!oO%{SOq&_X&[&_XY&_X&l&_X!P&_X~O}&_X!r&_X~P!/SOo(WOp(WOqnX&[nX~Oq(XO&[&^X~O&[(ZO~Ou!oOw(]O%{SO%}RO&P!bO~OYma&lma&tma~P!0bOW&OXY!aXq!aXu!aX%{!aX~OWUXY!aXq!aXu!aX%{!aX~OW(`O~Ou!oO%{SO%}!sO&P!sO&o(bO~Og]Oh]O%{SO%}!hO&PVO~P?wOq%cOY&na~Ou!oO%{SO%}!sO&P!sO&o%^O~O%{SO~P1sOY(eO~OY(hO&l%iO~Oq%lOY&ua~Og]Oh]OvzO|(pO!u|O%{SO%}!hO&PVO&rcO~P?wO!P(qO~OW^iZ#XXu^i!P^i!b^i#]^i#_^i#a^i#c^i#d^i#e^i#f^i#g^i#h^i#j^i#n^i#q^i&[^i&]^i&l^i&t^iY^i#o^is^iq^i|^i~OW)QO~Os)RO~P7uOz)SO%}RO&P!bO~O!P]iY]i#o]is]iq]i|]i~P7uOq)TOY&cX!P&cX~P7uOY)VO~O#q#tO!P#^i#_#^i#a#^i#c#^i#d#^i#e#^i#f#^i#j#^i#n#^i&[#^i&]#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#g#rO#h#rO~P!7qO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#a#^i#c#^i#d#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#e#pO~P!9VO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#c#^i#d#^i#n#^iY#^i#o#^is#^iq#^i|#^i~O#a#nO#e#pO&l#lO~P!:kO#e#^i~P!9VO#q#tO!P#^i#a#^i#c#^i#d#^i#e#^i#f#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#_#mO#g#rO#h#rO#j#vO&[#kO&]#kO~P!<WO#g#^i#h#^i~P!7qO#o)WO~P7uO#_&_X#a&_X#c&_X#d&_X#e&_X#f&_X#g&_X#h&_X#j&_X#n&_X#q&_X&]&_X#o&_Xs&_X|&_X~P!/SO!P#kiY#ki#o#kis#kiq#ki|#ki~P7uOg]Oh]OvzO}bO!P)fO!SxO!TxO!UxO!VxO!W)jO!XxO!YxO!ZyO!]xO!^xO!_xO!u|O!z{O%{SO%})^O&P)_O&]&bO&rcO~O|)iO~P!?hO}&cO~O}&cO!r&eO~Oo&dO}&cO!r&eO~O%{SO%}!sO&P!sO|&qP!P&qP~P?wO}&jO~Og]Oh]OvzO|)xO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wO}&mO~Oo&nO}&mO~Os)zO~P9POu)|O%{SO~Ou&rO}'}O%{SOW#Zi!P#Zi#_#Zi#a#Zi#c#Zi#d#Zi#e#Zi#f#Zi#g#Zi#h#Zi#j#Zi#n#Zi#q#Zi&[#Zi&]#Zi&l#Zi&t#ZiY#Zi#o#Zis#Ziq#Zi|#Zi~O}&cOW&biu&bi!P&bi#_&bi#a&bi#c&bi#d&bi#e&bi#f&bi#g&bi#h&bi#j&bi#n&bi#q&bi&[&bi&]&bi&l&bi&t&biY&bi#o&bis&biq&bi|&bi~O#|*UO$O*VO$Q*VO$R*WO$S*XO~O|*TO~P!GPO$Y*YO%}RO&P!bO~OW*ZO!P*[O~O$`*]OZ$^i_$^i`$^ia$^ib$^ic$^ie$^ig$^ih$^ip$^iv$^iw$^iz$^i}$^i!P$^i!S$^i!T$^i!U$^i!V$^i!W$^i!X$^i!Y$^i!Z$^i![$^i!]$^i!^$^i!_$^i!u$^i!z$^i#e$^i#q$^i#s$^i#t$^i#x$^i#y$^i$V$^i$X$^i$_$^i$b$^i$d$^i$g$^i$k$^i$m$^i$r$^i$t$^i$v$^i$x$^i${$^i$}$^i%u$^i%{$^i%}$^i&P$^i&V$^i&r$^i|$^i$p$^i~Og]Oh]O$g#dO%}!hO&PVO~O!P*aO~P9PO!P*bO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!Z*gO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$p*hO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~O|*fO~P!LcOWiXW&OXY&OXZ&OXuiXu&OX!P&OX%{iX%}iX&PiX&]iX&tiX&t&OX~OWUXW&ZXYUXZUXuUXu&ZX!PUX%{&ZX%}&ZX&P&ZX&]&ZX&tUX&t&ZX~OW#eOu#fO&t#gO~OW&SXY%WXu&SX!P%WX&t&SX~OZ#XX~P#$YOY*nO!P*lO~O%P'mO%T'nOZ$|i_$|i`$|ia$|ib$|ic$|ie$|ig$|ih$|ip$|iv$|iw$|iz$|i}$|i!P$|i!S$|i!T$|i!U$|i!V$|i!W$|i!X$|i!Y$|i!Z$|i![$|i!]$|i!^$|i!_$|i!u$|i!z$|i#e$|i#q$|i#s$|i#t$|i#x$|i#y$|i$V$|i$X$|i$_$|i$b$|i$d$|i$g$|i$k$|i$m$|i$r$|i$t$|i$v$|i$x$|i${$|i$}$|i%u$|i%{$|i%}$|i&P$|i&V$|i&r$|i|$|i$`$|i$p$|i~OZ*qO~O%P'mO%T'nOZ%Ui_%Ui`%Uia%Uib%Uic%Uie%Uig%Uih%Uip%Uiv%Uiw%Uiz%Ui}%Ui!P%Ui!S%Ui!T%Ui!U%Ui!V%Ui!W%Ui!X%Ui!Y%Ui!Z%Ui![%Ui!]%Ui!^%Ui!_%Ui!u%Ui!z%Ui#e%Ui#q%Ui#s%Ui#t%Ui#x%Ui#y%Ui$V%Ui$X%Ui$_%Ui$b%Ui$d%Ui$g%Ui$k%Ui$m%Ui$r%Ui$t%Ui$v%Ui$x%Ui${%Ui$}%Ui%u%Ui%{%Ui%}%Ui&P%Ui&V%Ui&r%Ui|%Ui$`%Ui$p%Ui~OW&SXu&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SX~O!b*vO#]#hOY&SXZ#XX~P#,{OY&QXq&QX|&QX!P&QX~P7uO}'tO|&wP~P9POY&QXg%YXh%YX%{%YX%}%YX&P%YXq&QX|&QX!P&QX~Oq*yOY&xX~OY*{O~O}'}O|&iP~P9POq&hX!P&hX|&hXY&hX~P7uO&`Ta~P<oOo(WOp(WOqna&[na~Oq(XO&[&^a~OW+TO~Ow+UO~Ou!oO%{SO%}+YO&P+XO~Og]Oh]Ov#aO!u#cO%}!hO&PVO&r#`O~Og]Oh]OvzO|+_O!u|O%{SO%}!hO&PVO&rcO~P?wOw+jO%}RO&P!bO&]!yO~Oq)TOY&ca!P&ca~O#_ma#ama#cma#dma#ema#fma#gma#hma#jma#nma#qma&]ma#omasma|ma~P?ROo+oOq!fX&[!fX~Oq+qO&[&kX~O&[+sO~OW&ZXu&ZX%{&ZX%}&ZX&P&ZX&]&ZX~OZ!aX~P#4{OWiXuiX%{iX%}iX&PiX&]iX~OZ!aX~P#5hOg]Oh]Ov#aO!u#cO!z#bO&]&bO&r#`O~O%})^O&P)_O~P#6TOg]Oh]O%{SO%})^O&P)_O~O}bO!P+}O~OZ,OO~O},QO!m,TO~O|,VO~P!?hO}bOg&eXh&eXv&eX!S&eX!T&eX!U&eX!V&eX!W&eX!X&eX!Y&eX!Z&eX!]&eX!^&eX!_&eX!u&eX!z&eX%{&eX%}&eX&P&eX&]&eX&r&eX~Oq,XO}&pX!P&pX~OZ#iO}&cOq!|X|!|X!P!|X~Oq,^O|&qX!P&qX~O|,aO!P,`O~O&]&bO~P3cOg]Oh]OvzO|,eO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wOs,fO~P7uOs,fO~P9PO}&cOW&bqu&bq!P&bq#_&bq#a&bq#c&bq#d&bq#e&bq#f&bq#g&bq#h&bq#j&bq#n&bq#q&bq&[&bq&]&bq&l&bq&t&bqY&bq#o&bqs&bqq&bq|&bq~O|,jO~P!GPO!W,nO#},nO%}RO&P!bO~O!P,qO~O$Y,rO%}RO&P!bO~O!b$|O#o,tOq!`X!P!`X~O!P,vO~P7uO!P,vO~P9PO!P,yO~P7uO|,{O~P!LcO![#}O#o,|O~O!P-OO~O!b-PO~OY-SOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOY-SO!P-TO~O%P'mO%T'nOZ%Uq_%Uq`%Uqa%Uqb%Uqc%Uqe%Uqg%Uqh%Uqp%Uqv%Uqw%Uqz%Uq}%Uq!P%Uq!S%Uq!T%Uq!U%Uq!V%Uq!W%Uq!X%Uq!Y%Uq!Z%Uq![%Uq!]%Uq!^%Uq!_%Uq!u%Uq!z%Uq#e%Uq#q%Uq#s%Uq#t%Uq#x%Uq#y%Uq$V%Uq$X%Uq$_%Uq$b%Uq$d%Uq$g%Uq$k%Uq$m%Uq$r%Uq$t%Uq$v%Uq$x%Uq${%Uq$}%Uq%u%Uq%{%Uq%}%Uq&P%Uq&V%Uq&r%Uq|%Uq$`%Uq$p%Uq~O}'tO~P9POq-`O|&wX~O|-bO~Oq*yOY&xa~Oq-fO|&iX~O|-hO~Ow-iO~Oq!aXu!aX!P!aX!b!aX%{!aX~OZ&OX~P#EoOZUX~P#EoO!P-jO~OZ-kO~OW^yZ#XXu^y!P^y!b^y#]^y#_^y#a^y#c^y#d^y#e^y#f^y#g^y#h^y#j^y#n^y#q^y&[^y&]^y&l^y&t^yY^y#o^ys^yq^y|^y~OY%^aq%^a!P%^a~P7uO!P#myY#my#o#mys#myq#my|#my~P7uOo+oOq!fa&[!fa~Oq+qO&[&ka~OZ,OO~PCpO!P-xO~O!m,TO}&ja!P&ja~O}bO!P-{O~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op.ZOvzOw.YOz}O|.UO}bO!PuO![!_O!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&]!yO&rcO~P?wO},QO~Oq,XO}&pa!P&pa~O}&cOq!|a|!|a!P!|a~OZ#iO}&cOq!|a|!|a!P!|a~O%{SO%}!sO&P!sOq%hX|%hX!P%hX~P?wOq,^O|&qa!P&qa~O|!}X~P!?hO|.eO~Os.fO~P7uOW$oO!P.gO~OW$oO$P.lO%}RO&P!bO!P&zP~OW$oO$T.mO~O!P.nO~O!b$|O#o.pOq!`X!P!`X~OY.rO~O!P.sO~P7uO#o.tO~P7uO!b.vO~OY.wOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOW!{Ou&YX%{&YX%}&YX&P&YX&|&YX~O&]!yO~P$$WOu!oO%{SO&|.yO%}%RX&P%RX~OY&QXq&QX~P7uO}'tOq%lX|%lX~P9POq-`O|&wa~O!b/PO~O}'}Oq%aX|%aX~P9POq-fO|&ia~OY/SO~O!P/TO~OZ/UO~O&l%iOq!ga&[!ga~Ou!oO%{SO}&ma!P&ma!m&ma~O!P/ZO~O!m,TO}&ji!P&ji~O|/`O~P]OW/bO~P4UOZ#iO!P&SX~P#,{OW$TOZ#iO&t#gO~Op/dOw/dO~O}&cOq!|i|!|i!P!|i~O|!}a~P!?hOW$oO!P/fO~OW$oOq/gO!P&zX~OY/kO~P7uOY/mO~OY%Wq!P%Wq~P7uO&|.yO%}%Ra&P%Ra~OY/rO~Ou!oO!P/uO!Z/vO%{SO~OY/wO~O&l%iOq!gi&[!gi~Ou!oO%{SO}&mi!P&mi!m&mi~O!m,TO}&jq!P&jq~O|/yO~P]Op/{Ow%}Oz%{O%}RO&P!bO&]!yO~O!P/|O~Oq/gO!P&za~O!P0QO~OW$oOq/gO!P&{X~OY0SO~P7uOY0TO~OY%Wy!P%Wy~P7uOu!oO%{SO%}%sa&P%sa&|%sa~OY0UO~Ou!oO!P0VO!Z0WO%{SO~Op0ZO%}RO&P!bO~OW)QOZ#iO~O!P0]O~OW$oOq%pa!P%pa~Oq/gO!P&{a~O!P0_O~Ou!oO!P0_O!Z0`O%{SO~O!P0bO~O!P0cO~O!P0eO~O!P0fO~O#o&OXY&OXs&OXq&OX|&OX~P$wO#oUXYUXsUXqUX|UX~P&{O`Q_P#f&Vc~",
  goto: "#(V&|PPPP&}'b*q-tP'bPP.Y.^/rPPPPP1^P2vPP4`7P9j<T<m>bPPP>hP@|PPPAv2vPCoPPDjPEaEgPPPPPPPPPPPPFpGXPJ_JgJqKZKaKgMVMZMZMcPMrNx! k! uP!![NxP!!b!!l!!{!#TP!#r!#|!$SNx!$V!$]EaEa!$a!$k!$n2v!&Y2v2v!(RP.^P!(VP!(vPPPPPP.^P.^!)d.^PP.^P.^PP.^!*x!+SPP!+Y!+cPPPPPPPP&}P&}PP!+g!+g!+z!+gPP!+gP!+gP!,e!,hP!+g!-O!+gP!+gP!-R!-UP!+gP!+gP!+gP!+gP!+g!+gP!+gP!-YP!-`!-c!-iP!+g!-u!-x!.Q!.d!2a!2g!2m!3s!3y!4T!5X!5_!5e!5o!5u!5{!6R!6X!6_!6e!6k!6q!6w!6}!7T!7Z!7e!7k!7u!7{PPP!8R!+g!8vP!<XP!=]P!?n!@U!CQ2vPPP!Dn!HY!JwPP!Mb!MeP# n# t##b##q##w#$w#%a#&[#&e#&h#&tP#&w#'TP#'[#'cP#'fP#'oP#'r#'u#'x#'|#(SssObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/a'kqOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l$p${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e't'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q*v+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-`-f-w.Q.S.T.V.W.d.p.s.v.x/P/S/Y/_/a/p/t/v/w0W0Y0`0j#rgO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`t!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gQ#^cS%`#P.SQ%s#`U%x#e$T/bQ&P#gW'g$l*l-T.xU'q$o&{*ZQ'r$pS(^%Y/_U(}%z+i/zQ)S&QQ+[(lQ+g)QQ-c*yR-m+]u!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gT$q!c(T#upO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#tkO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`X'h$l*l-T.x#}UO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`#}jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jQ%W!{Q([%XV-V*q-Z.y%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-V*q-Z.y%t[OW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-W*q-Z.yS!zZ-VS$S}%{S%z#e$TQ&Q#gQ+i)QQ.[,QR/z/b$eYO_bnow!X!Z!^!`!y#]#f#h#i#m#n#o#p#q#r#s#v#w#{$Y$Z$[$]$^$_$l$p$|%i%k&d&e&n&r'T'Y'Z't'}(W(X(h)T)W)|*]*a*b*e*h*l*v+o,Q,T,X,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q%U!yR+R(X%u^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0j!o!qX!i!r!t#P#_#y$t${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0Y#|jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q$Z!TQ$[!UQ$a!YQ$j!_R*i']Q#jhS&v$R)PQ(|%yQ*Q&wQ+f)OQ,[)oQ-q+hQ.a,]Q/W-rS/c.Y.ZQ/}/dQ0[/{R0a0ZQ&f$OW(s%t&g&h&iQ*P&vU+`(t(u(vQ,Z)oQ,h*QS-n+a+bS.`,[,]Q/V-oR/e.aX)f&c)h,`.drdObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW#R_#U%c,OQ'S$]W'i$l*l-T.xS(m%p(oW)a&c)h,`.dS)p&j,^S)u&m)wR-Z*qh!vX!V#_#d'R(l)`)s*_+]+w,cQ(R$}Q(_%^R+V(b#rmObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`v!tX!V#P#_#d$}%^%b%f'R'e(b(l*_*k+]-Y.S.|Q#W_Q$OzQ$P{Q$Q|Q%t#aQ%u#bQ%v#cQ(j%lS)Y&b+qY)d&c)a)h,`.dS)o&j,^Q+p)ZW+t)`)s+w,cQ+|)bQ,])pT.O+z.QU(P$|'}-fR*O&uW)f&c)h,`.dT)v&m)wQ&i$OQ&q$QQ(v%tQ({%vY)b&c)a)h,`.dV)t&m)u)wQ)[&bR-u+qQ+n)YR-t+p#tmO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`Q,P)dS-w+t.OR.R+|T#U_,OU#S_#U,OR(c%cQ,S)eQ-y+vQ-}+yQ/].PR/x/^ruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$m!aQ&`#wQ'a$jQ'p$nW)f&c)h,`.dQ*s'nQ+})cQ,W)jQ-[*rR-{+xrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS(n%p(oW)f&c)h,`.dT)v&m)wQ&h$OS(u%t&iR+b(vQ&g$OQ&l$PU(t%t&h&iQ(x%uS+a(u(vR-o+bQ)n&eR)y&nQ&p$QS(z%v&qR+e({Q&o$QU(y%v&p&qS+d(z({R-p+eS(n%p(oT)v&m)wrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW)f&c)h,`.dT)v&m)wQ&k$PS(w%u&lR+c(xQ)q&jR.b,^R,b)rQ%q#^R(r%sT(n%p(oQ,R)eS-|+y,SR/[-}R.W,QWj$l*l-T.x#ukO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#|hO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`U%y#e$T/bS)O%z/zQ+h)QR-r+iT&t$R&u!]#ml#Q$`$h$k&O&R&S&V&W&X&Y&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o!V#nl#Q$`$h$k&O&R&S&W&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o#umO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`a'u$p't*v-`/P/v0W0`Q'w$pR-d*yQ&y$UQ'y$uR*|'zT*R&x*SsuObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/artObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$e![R$g!]R$^!WruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aR'T$]R$_!WR'[$aT*d'Z*eX'k$m'l'p*tR*r'mQ-Y*qR.|-ZQ'o$mQ*p'lQ*u'pR-]*tR$n!aQ'j$lV-R*l-T.xQwOQ#]bW#|w#].V/aQ.V,QR/a.WrWObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/al!kW!p#O#Y#x%R%X%g&s'Q)Z+{.T0j!j!pX!i!t#P#_#y${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0YQ#O_Q#Y`#^#xno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%i%k&d&e&n&r'T'Y't'}(W(h)T)W)|*a*b*h*v+o,T,X,t,v-P-`-f.p.s.v/P/v0W0`S%R!y(XQ%X!{j%g#U%c%p&c&j&m(o)h)w*q,^,`.dS&s$R&uY'Q$]$l*l-T.xS)Z&b+qS+{)b)tQ.T,OR0j#vQ!fTR$r!fQ(Y%UR+S(Y^!rX#P#y&]'R'e)Xx$t!i#_%S%Y%b%f(l)`)s*_*k+]+w+z,c-X.Q.S/_/p[$z!r$t${/Y/t0YS${!t+tQ/Y-wQ/t/SR0Y/wQ)U&SR+l)UQ)h&cS,U)h.dR.d,`!laO_bw!Z#U#]#{$Z$[$]$^$_$l%c%p&c&j&m'Z(o)h)w*]*e*l*q,O,Q,^,`-T.V.W.d.x/aY!jW#O%g'Q.TT#Za!jQ-g*}R/R-gQ%O!vR(S%OQ%j#VS(g%j/XR/X-sQ+r)[R-v+rQ%d#SR(d%dQ,Y)lR._,YQ)w&mR,d)wQ,_)qR.c,_Q(o%pR+^(oQ&u$RR)}&uQ%m#WR(k%mQ-a*wR/O-aQ*z'wR-e*zQ*S&xR,i*SQ,m*UR.i,mQ/h.jS0P/h0RR0R/jQ*e'ZR,z*eQ'l$mS*o'l*tR*t'pQ.z-XR/q.zQ*m'jR-U*m`vObw#],Q.V.W/aQ$b!ZQ&a#{Q'O$ZQ'P$[Q'V$^Q'W$_S*d'Z*eR,s*]'YrOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-f-w.Q.S.T.V.W.d.p.s.v.x/S/Y/_/a/p/t/w0Y0ja'v$p't*v-`/P/v0W0`Q!cSQ$U!PQ$V!RQ$W!SQ$u!lQ$w!nQ&}$XQ'z$vQ(T0gS,k*U*WQ,o*VQ,p*XQ.h,mS.j,o.lQ/j.mR0O/g%oROS_bcnow!P!R!S!X!Z!^!`!l!n#P#]#`#e#f#g#h#i#m#n#o#p#q#r#s#w#{$T$X$Y$Z$[$]$^$_$l$o$p$v$|%Y%k%z&Q&r&{'T'Y'Z't'}(h(l)Q)T)W)|*U*V*W*X*Z*]*a*b*e*h*l*v*y+]+i,Q,m,o,t,v-P-T-`-f.S.V.W.l.m.p.s.v.x/P/_/a/b/g/v/z0W0`0gQ'x$pQ*w'tS-_*v/PQ.}-`Q0X/vQ0^0WR0d0`rlObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS#Q_$YQ#tnQ#zoQ$`!XQ$h!^Q$k!`Q&O#fQ&R#hY&S#i$]*a,v.sQ&U#mQ&V#nQ&W#oQ&X#pQ&Y#qQ&Z#rQ&[#sQ&_#w^'s$p't-`/P/v0W0`U(O$|'}-fQ(i%kQ){&rQ*`'TQ*c'YQ+W(hQ+k)TQ+m)WQ,g)|Q,x*bQ,}*hQ-^*vQ.o,tQ.u-PQ/l.pR/o.v#rfO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`W'f$l*l-T.xR.X,QrXObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW!iW#x%R'QQ#P_Q#_d!|#yno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%k&r'T'Y't'}(h)T)W)|*a*b*h*v,t,v-P-`-f.p.s.v/P/v0W0`d%S!y%i&d&e&n(W(X+o,T,XQ%Y#OQ%b#RS%f#U%cQ&]#vQ'R$]W'e$l*l-T.xS(l%p(oQ)X0jW)`&c)h,`.dS)s&m)wQ*_'SQ*k'iQ+](mQ+w)aS+z)b)tQ,c)uS-X*q-ZQ.Q+{Q.S,OQ/_.TR/p.y%t^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jQ$R}Q&w$SR)P%{&PVOW_bdnow}!X!Z!^!`!y!{#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%X%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jR%V!y#ziObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q#V_Q%U!yQ&^#vQ(f%iQ)k&dU)l&e&n,TQ+Q(WQ+R(XQ-s+oR.^,XQ(V%TR+P(U#|eO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`T%w#e/bQ&T#iQ'U$]Q,w*aQ.q,vR/n.sX)g&c)h,`.d!{`OW_abw!Z!j#O#U#]#{$Z$[$]$^$_$l%c%g%p&c&j&m'Q'Z(o)h)w*]*e*l*q,O,Q,^,`-T.T.V.W.d.x/aU!wX!V'RU%r#_#d*_S+Z(l)sQ+u)`S-l+],cR-z+wj!uX!V#_#d$}%^(b(l)`)s+]+w,cU%]#P%f.SQ(a%bQ*^'RQ*j'eQ,u*_Q-Q*kQ.{-YR/s.|Q(Q$|Q*}'}R/Q-fR+O'}[)c&c&m)h)w,`.dT+x)a)uR)]&bW+v)`)s+w,cQ.P+zR/^.QS#T_,OR%h#US)m&e&nR.],TR)r&jW)e&c)h,`.dR+y)aR#X_R*x'tR'x$pT,l*U,mQ.k,oR/i.lR/i.m",
  nodeNames: "⚠ LineComment BlockComment Program ModuleDeclaration MarkerAnnotation Identifier ScopedIdentifier . Annotation ) ( AnnotationArgumentList AssignmentExpression FieldAccess IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock null ClassLiteral void PrimitiveType TypeName ScopedTypeName GenericType TypeArguments AnnotatedType Wildcard extends super , ArrayType ] Dimension [ class this ParenthesizedExpression ObjectCreationExpression new ArgumentList } { ClassBody ; FieldDeclaration Modifiers public protected private abstract static final strictfp default synchronized native transient volatile VariableDeclarator Definition AssignOp ArrayInitializer MethodDeclaration TypeParameters TypeParameter TypeBound FormalParameters ReceiverParameter FormalParameter SpreadParameter Throws throws Block ClassDeclaration Superclass SuperInterfaces implements InterfaceTypeList InterfaceDeclaration interface ExtendsInterfaces InterfaceBody ConstantDeclaration EnumDeclaration enum EnumBody EnumConstant EnumBodyDeclarations AnnotationTypeDeclaration AnnotationTypeBody AnnotationTypeElementDeclaration StaticInitializer ConstructorDeclaration ConstructorBody ExplicitConstructorInvocation ArrayAccess MethodInvocation MethodName MethodReference ArrayCreationExpression Dimension AssignOp BinaryExpression CompareOp CompareOp LogicOp BitOp BitOp LogicOp ArithOp ArithOp ArithOp BitOp InstanceofExpression instanceof LambdaExpression InferredParameters TernaryExpression LogicOp : UpdateExpression UpdateOp UnaryExpression LogicOp BitOp CastExpression ElementValueArrayInitializer ElementValuePair open module ModuleBody ModuleDirective requires transitive exports to opens uses provides with PackageDeclaration package ImportDeclaration import Asterisk ExpressionStatement LabeledStatement Label IfStatement if else WhileStatement while ForStatement for ForSpec LocalVariableDeclaration var EnhancedForStatement ForSpec AssertStatement assert SwitchStatement switch SwitchBlock SwitchLabel case DoStatement do BreakStatement break ContinueStatement continue ReturnStatement return SynchronizedStatement ThrowStatement throw TryStatement try CatchClause catch CatchFormalParameter CatchType FinallyClause finally TryWithResourcesStatement ResourceSpecification Resource",
  maxTerm: 274,
  nodeProps: [
    ["group", -26, 4, 47, 76, 77, 82, 87, 92, 144, 146, 149, 150, 152, 155, 157, 160, 162, 164, 166, 171, 173, 175, 177, 179, 180, 182, 190, "Statement", -25, 6, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 39, 40, 41, 99, 100, 102, 103, 106, 117, 119, 121, 124, 126, 129, "Expression", -7, 23, 24, 25, 26, 27, 29, 34, "Type"],
    ["openedBy", 10, "(", 44, "{"],
    ["closedBy", 11, ")", 45, "}"]
  ],
  propSources: [Fk],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 28,
  tokenData: "#$`_R!_OX%QXY'fYZ)bZ^'f^p%Qpq'fqr*|rs,^st%Qtu4euv5qvw7Rwx8ixy@zyzAhz{BU{|Bz|}Db}!OEO!O!PFi!P!Q! c!Q!R!,X!R![!0P![!]!>a!]!^!?q!^!_!@_!_!`!Ax!`!a!Bl!a!b!DY!b!c!Dx!c!}!Kt!}#O!MQ#O#P%Q#P#Q!Mn#Q#R!N[#R#S4e#S#T%Q#T#o4e#o#p# O#p#q# l#q#r##U#r#s##r#s#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%QS%VV&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS%qO&WSS%tVOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZS&^VOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS&vP;=`<%l%QS&|UOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZS'cP;=`<%l&Z_'mk&WS%wZOX%QXY'fYZ)bZ^'f^p%Qpq'fqr%Qrs%qs#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%Q_)iY&WS%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XZ*^Y%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XV+TX#sP&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QU+wV#_Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT,aXOY,|YZ%lZr,|rs3Ys#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T-PXOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT-qX&WSOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT.cVcPOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZT.}V&WSOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT/iW&WSOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0UWOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0sOcPP0vTOY0RYZ0RZ;'S0R;'S;=`1V<%lO0RP1YP;=`<%l0RT1`XOY,|YZ%lZr,|rs1{s#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T2QUcPOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZT2gVOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT3PP;=`<%l-lT3VP;=`<%l,|T3_VcPOY&ZYZ%lZr&Zrs3ts;'S&Z;'S;=`'`<%lO&ZT3yR&USXY4SYZ4`pq4SP4VRXY4SYZ4`pq4SP4eO&VP_4la%}Z&WSOY%QYZ%lZr%Qrs%qst%Qtu4eu!Q%Q!Q![4e![!c%Q!c!}4e!}#R%Q#R#S4e#S#T%Q#T#o4e#o;'S%Q;'S;=`&s<%lO%QU5xX#gQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU6lV#]Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV7YZ&lR&WSOY%QYZ%lZr%Qrs%qsv%Qvw7{w!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU8SV#aQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT8nZ&WSOY9aYZ%lZr9ars:Xsw9awx%Qx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT9fZ&WSOY9aYZ%lZr9ars:Xsw9awx;sx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT:[ZOY:}YZ%lZr:}rs>zsw:}wx?px#O:}#O#P@[#P;'S:};'S;=`@t<%lO:}T;QZOY9aYZ%lZr9ars:Xsw9awx;sx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT;zVbP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT<fV&WSOY9aYZ<{Zr9ars:Xs;'S9a;'S;=`>t<%lO9aT=QW&WSOY=jZw=jwx>Vx#O=j#O#P>[#P;'S=j;'S;=`>n<%lO=jP=mWOY=jZw=jwx>Vx#O=j#O#P>[#P;'S=j;'S;=`>n<%lO=jP>[ObPP>_TOY=jYZ=jZ;'S=j;'S;=`>n<%lO=jP>qP;=`<%l=jT>wP;=`<%l9aT>}ZOY:}YZ%lZr:}rs=jsw:}wx?px#O:}#O#P@[#P;'S:};'S;=`@t<%lO:}T?uVbPOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT@_VOY9aYZ<{Zr9ars:Xs;'S9a;'S;=`>t<%lO9aT@wP;=`<%l:}_ARVZZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVAoVYR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVB_X$YP&WS#fQOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVCRZ#eR&WSOY%QYZ%lZr%Qrs%qs{%Q{|Ct|!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVC{V#qR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVDiVqR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVEV[#eR&WSOY%QYZ%lZr%Qrs%qs}%Q}!OCt!O!_%Q!_!`6e!`!aE{!a;'S%Q;'S;=`&s<%lO%QVFSV&vR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_FpZWY&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PGc!P!Q%Q!Q![Hq![;'S%Q;'S;=`&s<%lO%QVGhX&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PHT!P;'S%Q;'S;=`&s<%lO%QVH[V&oR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTHxc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![!f%Q!f!gJT!g!hJq!h!iJT!i#R%Q#R#SNk#S#W%Q#W#XJT#X#YJq#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QTJ[V&WS`POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTJv]&WSOY%QYZ%lZr%Qrs%qs{%Q{|Ko|}%Q}!OKo!O!Q%Q!Q![La![;'S%Q;'S;=`&s<%lO%QTKtX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![La![;'S%Q;'S;=`&s<%lO%QTLhc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![La![!f%Q!f!gJT!g!h%Q!h!iJT!i#R%Q#R#SMs#S#W%Q#W#XJT#X#Y%Q#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QTMxZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![La![#R%Q#R#SMs#S;'S%Q;'S;=`&s<%lO%QTNpZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![#R%Q#R#SNk#S;'S%Q;'S;=`&s<%lO%Q_! j]&WS#fQOY%QYZ%lZr%Qrs%qsz%Qz{!!c{!P%Q!P!Q!)U!Q!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%Q_!!hX&WSOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{;'S!!c;'S;=`!'d<%lO!!c_!#YT&WSOz!#iz{!#{{;'S!#i;'S;=`!$j<%lO!#iZ!#lTOz!#iz{!#{{;'S!#i;'S;=`!$j<%lO!#iZ!$OVOz!#iz{!#{{!P!#i!P!Q!$e!Q;'S!#i;'S;=`!$j<%lO!#iZ!$jOQZZ!$mP;=`<%l!#i_!$sXOY!%`YZ!#TZr!%`rs!'jsz!%`z{!(Y{;'S!%`;'S;=`!)O<%lO!%`_!%cXOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{;'S!!c;'S;=`!'d<%lO!!c_!&TZ&WSOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{!P!!c!P!Q!&v!Q;'S!!c;'S;=`!'d<%lO!!c_!&}V&WSQZOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!'gP;=`<%l!!c_!'mXOY!%`YZ!#TZr!%`rs!#isz!%`z{!(Y{;'S!%`;'S;=`!)O<%lO!%`_!(]ZOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{!P!!c!P!Q!&v!Q;'S!!c;'S;=`!'d<%lO!!c_!)RP;=`<%l!%`_!)]V&WSPZOY!)UYZ%lZr!)Urs!)rs;'S!)U;'S;=`!*x<%lO!)U_!)wVPZOY!*^YZ%lZr!*^rs!+Os;'S!*^;'S;=`!,R<%lO!*^_!*cVPZOY!)UYZ%lZr!)Urs!)rs;'S!)U;'S;=`!*x<%lO!)U_!*{P;=`<%l!)U_!+TVPZOY!*^YZ%lZr!*^rs!+js;'S!*^;'S;=`!,R<%lO!*^Z!+oSPZOY!+jZ;'S!+j;'S;=`!+{<%lO!+jZ!,OP;=`<%l!+j_!,UP;=`<%l!*^T!,`u&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.s!P!Q%Q!Q![!0P![!d%Q!d!e!3Z!e!f%Q!f!gJT!g!hJq!h!iJT!i!n%Q!n!o!1u!o!q%Q!q!r!5X!r!z%Q!z!{!7P!{#R%Q#R#S!2c#S#U%Q#U#V!3Z#V#W%Q#W#XJT#X#YJq#Y#ZJT#Z#`%Q#`#a!1u#a#c%Q#c#d!5X#d#l%Q#l#m!7P#m;'S%Q;'S;=`&s<%lO%QT!.za&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![!f%Q!f!gJT!g!hJq!h!iJT!i#W%Q#W#XJT#X#YJq#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QT!0Wi&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.s!P!Q%Q!Q![!0P![!f%Q!f!gJT!g!hJq!h!iJT!i!n%Q!n!o!1u!o#R%Q#R#S!2c#S#W%Q#W#XJT#X#YJq#Y#ZJT#Z#`%Q#`#a!1u#a;'S%Q;'S;=`&s<%lO%QT!1|V&WS_POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT!2hZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!0P![#R%Q#R#S!2c#S;'S%Q;'S;=`&s<%lO%QT!3`Y&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4O!R!S!4O!S;'S%Q;'S;=`&s<%lO%QT!4V`&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4O!R!S!4O!S!n%Q!n!o!1u!o#R%Q#R#S!3Z#S#`%Q#`#a!1u#a;'S%Q;'S;=`&s<%lO%QT!5^X&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!5y!Y;'S%Q;'S;=`&s<%lO%QT!6Q_&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!5y!Y!n%Q!n!o!1u!o#R%Q#R#S!5X#S#`%Q#`#a!1u#a;'S%Q;'S;=`&s<%lO%QT!7U_&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!P!8T!P!Q%Q!Q![!:c![!c%Q!c!i!:c!i#T%Q#T#Z!:c#Z;'S%Q;'S;=`&s<%lO%QT!8Y]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9R![!c%Q!c!i!9R!i#T%Q#T#Z!9R#Z;'S%Q;'S;=`&s<%lO%QT!9Wc&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9R![!c%Q!c!i!9R!i!r%Q!r!sJq!s#R%Q#R#S!8T#S#T%Q#T#Z!9R#Z#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!:ji&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!<X!P!Q%Q!Q![!:c![!c%Q!c!i!:c!i!n%Q!n!o!1u!o!r%Q!r!sJq!s#R%Q#R#S!=c#S#T%Q#T#Z!:c#Z#`%Q#`#a!1u#a#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!<^a&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9R![!c%Q!c!i!9R!i!r%Q!r!sJq!s#T%Q#T#Z!9R#Z#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!=h]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!:c![!c%Q!c!i!:c!i#T%Q#T#Z!:c#Z;'S%Q;'S;=`&s<%lO%QV!>hX#oR&WSOY%QYZ%lZr%Qrs%qs![%Q![!]!?T!];'S%Q;'S;=`&s<%lO%QV!?[V&tR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!?xV!PR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!@fY&]Z&WSOY%QYZ%lZr%Qrs%qs!^%Q!^!_!AU!_!`+p!`;'S%Q;'S;=`&s<%lO%QU!A]X#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV!BPX!bR&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QV!BsY&[R&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`!a!Cc!a;'S%Q;'S;=`&s<%lO%QU!CjY#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`!a!AU!a;'S%Q;'S;=`&s<%lO%Q_!DcV&`X#nQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!EPX%{Z&WSOY%QYZ%lZr%Qrs%qs#]%Q#]#^!El#^;'S%Q;'S;=`&s<%lO%QV!EqX&WSOY%QYZ%lZr%Qrs%qs#b%Q#b#c!F^#c;'S%Q;'S;=`&s<%lO%QV!FcX&WSOY%QYZ%lZr%Qrs%qs#h%Q#h#i!GO#i;'S%Q;'S;=`&s<%lO%QV!GTX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!Gp#Y;'S%Q;'S;=`&s<%lO%QV!GuX&WSOY%QYZ%lZr%Qrs%qs#f%Q#f#g!Hb#g;'S%Q;'S;=`&s<%lO%QV!HgX&WSOY%QYZ%lZr%Qrs%qs#Y%Q#Y#Z!IS#Z;'S%Q;'S;=`&s<%lO%QV!IXX&WSOY%QYZ%lZr%Qrs%qs#T%Q#T#U!It#U;'S%Q;'S;=`&s<%lO%QV!IyX&WSOY%QYZ%lZr%Qrs%qs#V%Q#V#W!Jf#W;'S%Q;'S;=`&s<%lO%QV!JkX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!KW#Y;'S%Q;'S;=`&s<%lO%QV!K_V&rR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!K{a&PZ&WSOY%QYZ%lZr%Qrs%qst%Qtu!Ktu!Q%Q!Q![!Kt![!c%Q!c!}!Kt!}#R%Q#R#S!Kt#S#T%Q#T#o!Kt#o;'S%Q;'S;=`&s<%lO%Q_!MXVuZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!MuVsR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QU!NcX#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV# VV}R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_# uZ&|X#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`#p%Q#p#q#!h#q;'S%Q;'S;=`&s<%lO%QU#!oV#dQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV##]V|R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT##yV#tP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q",
  tokenizers: [0, 1, 2, 3],
  topRules: { Program: [0, 3] },
  dynamicPrecedences: { 27: 1, 230: -1, 241: -1 },
  specialized: [{ term: 229, get: (i) => Wk[i] || -1 }],
  tokenPrec: 7067
}), Zk = /* @__PURE__ */ _r.define({
  parser: /* @__PURE__ */ zk.configure({
    props: [
      /* @__PURE__ */ Os.add({
        IfStatement: /* @__PURE__ */ ar({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ ar({ except: /^\s*({|catch|finally)\b/ }),
        LabeledStatement: XC,
        SwitchBlock: (i) => {
          let e = i.textAfter, t = /^\s*\}/.test(e), r = /^\s*(case|default)\b/.test(e);
          return i.baseIndent + (t ? 0 : r ? 1 : 2) * i.unit;
        },
        Block: /* @__PURE__ */ VC({ closing: "}" }),
        BlockComment: () => -1,
        Statement: /* @__PURE__ */ ar({ except: /^{/ })
      }),
      /* @__PURE__ */ Es.add({
        ["Block SwitchBlock ClassBody ElementValueArrayInitializer ModuleBody EnumBody ConstructorBody InterfaceBody ArrayInitializer"]: Xh,
        BlockComment(i) {
          return { from: i.from + 2, to: i.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\})$/
  }
});
function qk() {
  return new mn(Zk);
}
const pb = 302, Ob = 1, jk = 2, Eb = 303, Kk = 305, Jk = 306, e$ = 3, t$ = 4, i$ = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], dI = 125, r$ = 59, mb = 47, o$ = 42, s$ = 43, n$ = 45, a$ = new cI({
  start: !1,
  shift(i, e) {
    return e == e$ || e == t$ || e == Kk ? i : e == Jk;
  },
  strict: !1
}), l$ = new Gi((i, e) => {
  let { next: t } = i;
  (t == dI || t == -1 || e.context) && e.canShift(Eb) && i.acceptToken(Eb);
}, { contextual: !0, fallback: !0 }), u$ = new Gi((i, e) => {
  let { next: t } = i, r;
  i$.indexOf(t) > -1 || t == mb && ((r = i.peek(1)) == mb || r == o$) || t != dI && t != r$ && t != -1 && !e.context && e.canShift(pb) && i.acceptToken(pb);
}, { contextual: !0 }), h$ = new Gi((i, e) => {
  let { next: t } = i;
  if ((t == s$ || t == n$) && (i.advance(), t == i.next)) {
    i.advance();
    let r = !e.context && e.canShift(Ob);
    i.acceptToken(r ? Ob : jk);
  }
}, { contextual: !0 }), c$ = ps({
  "get set async static": b.modifier,
  "for while do if else switch try catch finally return throw break continue default case": b.controlKeyword,
  "in of await yield void typeof delete instanceof": b.operatorKeyword,
  "let var const function class extends": b.definitionKeyword,
  "import export from": b.moduleKeyword,
  "with debugger as new": b.keyword,
  TemplateString: b.special(b.string),
  super: b.atom,
  BooleanLiteral: b.bool,
  this: b.self,
  null: b.null,
  Star: b.modifier,
  VariableName: b.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": b.function(b.variableName),
  VariableDefinition: b.definition(b.variableName),
  Label: b.labelName,
  PropertyName: b.propertyName,
  PrivatePropertyName: b.special(b.propertyName),
  "CallExpression/MemberExpression/PropertyName": b.function(b.propertyName),
  "FunctionDeclaration/VariableDefinition": b.function(b.definition(b.variableName)),
  "ClassDeclaration/VariableDefinition": b.definition(b.className),
  PropertyDefinition: b.definition(b.propertyName),
  PrivatePropertyDefinition: b.definition(b.special(b.propertyName)),
  UpdateOp: b.updateOperator,
  LineComment: b.lineComment,
  BlockComment: b.blockComment,
  Number: b.number,
  String: b.string,
  Escape: b.escape,
  ArithOp: b.arithmeticOperator,
  LogicOp: b.logicOperator,
  BitOp: b.bitwiseOperator,
  CompareOp: b.compareOperator,
  RegExp: b.regexp,
  Equals: b.definitionOperator,
  Arrow: b.function(b.punctuation),
  ": Spread": b.punctuation,
  "( )": b.paren,
  "[ ]": b.squareBracket,
  "{ }": b.brace,
  "InterpolationStart InterpolationEnd": b.special(b.brace),
  ".": b.derefOperator,
  ", ;": b.separator,
  "@": b.meta,
  TypeName: b.typeName,
  TypeDefinition: b.definition(b.typeName),
  "type enum interface implements namespace module declare": b.definitionKeyword,
  "abstract global Privacy readonly override": b.modifier,
  "is keyof unique infer": b.operatorKeyword,
  JSXAttributeValue: b.attributeValue,
  JSXText: b.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": b.angleBracket,
  "JSXIdentifier JSXNameSpacedName": b.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": b.attributeName,
  "JSXBuiltin/JSXIdentifier": b.standard(b.tagName)
}), d$ = { __proto__: null, export: 14, as: 19, from: 27, default: 30, async: 35, function: 36, extends: 46, this: 50, true: 58, false: 58, null: 70, void: 74, typeof: 78, super: 96, new: 130, delete: 146, yield: 155, await: 159, class: 164, public: 221, private: 221, protected: 221, readonly: 223, instanceof: 242, satisfies: 245, in: 246, const: 248, import: 280, keyof: 335, unique: 339, infer: 345, is: 381, abstract: 401, implements: 403, type: 405, let: 408, var: 410, interface: 417, enum: 421, namespace: 427, module: 429, declare: 433, global: 437, for: 456, of: 465, while: 468, with: 472, do: 476, if: 480, else: 482, switch: 486, case: 492, try: 498, catch: 502, finally: 506, return: 510, throw: 514, break: 518, continue: 522, debugger: 526 }, f$ = { __proto__: null, async: 117, get: 119, set: 121, declare: 181, public: 183, private: 183, protected: 183, static: 185, abstract: 187, override: 189, readonly: 195, accessor: 197, new: 385 }, p$ = { __proto__: null, "<": 137 }, O$ = Pr.deserialize({
  version: 14,
  states: "$6[O`QUOOO%QQUOOO'TQWOOP(bOSOOO*pQ(CjO'#CfO*wOpO'#CgO+VO!bO'#CgO+eO07`O'#DZO-vQUO'#DaO.WQUO'#DlO%QQUO'#DvO0[QUO'#EOOOQ(CY'#EW'#EWO0uQSO'#ETOOQO'#Ei'#EiOOQO'#Ib'#IbO0}QSO'#GkO1YQSO'#EhO1_QSO'#EhO3aQ(CjO'#JcO6QQ(CjO'#JdO6nQSO'#FWO6sQ#tO'#FoOOQ(CY'#F`'#F`O7OO&jO'#F`O7^Q,UO'#FvO8tQSO'#FuOOQ(CY'#Jd'#JdOOQ(CW'#Jc'#JcOOQQ'#KO'#KOO8yQSO'#IOO9OQ(C[O'#IPOOQQ'#JP'#JPOOQQ'#IT'#ITQ`QUOOO%QQUO'#DnO9WQUO'#DzO%QQUO'#D|O9_QSO'#GkO9dQ,UO'#ClO9rQSO'#EgO9}QSO'#ErO:SQ,UO'#F_O:qQSO'#GkO:vQSO'#GoO;RQSO'#GoO;aQSO'#GrO;aQSO'#GsO;aQSO'#GuO9_QSO'#GxO<QQSO'#G{O=cQSO'#CbO=sQSO'#HXO={QSO'#H_O={QSO'#HaO`QUO'#HcO={QSO'#HeO={QSO'#HhO>QQSO'#HnO>VQ(C]O'#HtO%QQUO'#HvO>bQ(C]O'#HxO>mQ(C]O'#HzO9OQ(C[O'#H|O>xQ(CjO'#CfO?zQWO'#DfQOQSOOO@bQSO'#EPO9dQ,UO'#EgO@mQSO'#EgO@xQ`O'#F_OOQQ'#Cd'#CdOOQ(CW'#Dk'#DkOOQ(CW'#Jg'#JgO%QQUO'#JgOOQO'#Jk'#JkOOQO'#I_'#I_OAxQWO'#E`OOQ(CW'#E_'#E_OBtQ(C`O'#E`OCOQWO'#ESOOQO'#Jj'#JjOCdQWO'#JkODqQWO'#ESOCOQWO'#E`PEOO?MpO'#C`POOO)CDn)CDnOOOO'#IU'#IUOEZOpO,59ROOQ(CY,59R,59ROOOO'#IV'#IVOEiO!bO,59RO%QQUO'#D]OOOO'#IX'#IXOEwO07`O,59uOOQ(CY,59u,59uOFVQUO'#IYOFjQSO'#JeOHlQbO'#JeO+sQUO'#JeOHsQSO,59{OIZQSO'#EiOIhQSO'#JsOIsQSO'#JrOIsQSO'#JrOI{QSO,5;VOJQQSO'#JqOOQ(CY,5:W,5:WOJXQUO,5:WOLYQ(CjO,5:bOLyQSO,5:jOMdQ(C[O'#JpOMkQSO'#JoO:vQSO'#JoONPQSO'#JoONXQSO,5;UON^QSO'#JoO!!fQbO'#JdOOQ(CY'#Cf'#CfO%QQUO'#EOO!#UQ`O,5:oOOQO'#Jl'#JlOOQO-E<`-E<`O9_QSO,5=VO!#lQSO,5=VO!#qQUO,5;SO!%tQ,UO'#EdO!'XQSO,5;SO!(qQ,UO'#DpO!(xQUO'#DuO!)SQWO,5;]O!)[QWO,5;]O%QQUO,5;]OOQQ'#FO'#FOOOQQ'#FQ'#FQO%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^OOQQ'#FU'#FUO!)jQUO,5;oOOQ(CY,5;t,5;tOOQ(CY,5;u,5;uO!+mQSO,5;uOOQ(CY,5;v,5;vO%QQUO'#IfO!+uQ(C[O,5<cO!%tQ,UO,5;^O!,dQ,UO,5;^O%QQUO,5;rO!,kQ#tO'#FeO!-hQ#tO'#JwO!-SQ#tO'#JwO!-oQ#tO'#JwOOQO'#Jw'#JwO!.TQ#tO,5;}OOOO,5<Z,5<ZO!.fQUO'#FqOOOO'#Ie'#IeO7OO&jO,5;zO!.mQ#tO'#FsOOQ(CY,5;z,5;zO!/^Q7[O'#CrOOQ(CY'#Cv'#CvO!/qQSO'#CvO!/vO07`O'#CzO!0dQ,UO,5<`O!0kQSO,5<bO!2QQMhO'#GQO!2_QSO'#GRO!2dQSO'#GRO!2iQMhO'#GVO!3hQWO'#GZO!4ZQ7[O'#J^OOQ(CY'#J^'#J^O!4eQSO'#J]O!4sQSO'#J[O!4{QSO'#CqOOQ(CY'#Ct'#CtOOQ(CY'#DO'#DOOOQ(CY'#DQ'#DQO0xQSO'#DSO!'^Q,UO'#FxO!'^Q,UO'#FzO!5TQSO'#F|O!5YQSO'#F}O!2dQSO'#GTO!'^Q,UO'#GYO!5_QSO'#EjO!5|QSO,5<aO`QUO,5>jOOQQ'#JX'#JXOOQQ,5>k,5>kOOQQ-E<R-E<RO!7{Q(CjO,5:YO!:iQ(CjO,5:fO%QQUO,5:fO!=SQ(CjO,5:hOOQ(CW'#Co'#CoO!=sQ,UO,5=VO!>RQ(C[O'#JYO8tQSO'#JYO!>dQ(C[O,59WO!>oQWO,59WO!>wQ,UO,59WO9dQ,UO,59WO!?SQSO,5;SO!?[QSO'#HWO!?mQSO'#KSO%QQUO,5;wO!?uQWO,5;yO!?zQSO,5=qO!@PQSO,5=qO!@UQSO,5=qO9OQ(C[O,5=qO!@dQSO'#EkO!A^QWO'#ElOOQ(CW'#Jq'#JqO!AeQ(C[O'#KPO9OQ(C[O,5=ZO;aQSO,5=aOOQO'#Cr'#CrO!ApQWO,5=^O!AxQ,UO,5=_O!BTQSO,5=aO!BYQ`O,5=dO>QQSO'#G}O9_QSO'#HPO!BbQSO'#HPO9dQ,UO'#HRO!BgQSO'#HROOQQ,5=g,5=gO!BlQSO'#HSO!BtQSO'#ClO!ByQSO,58|O!CTQSO,58|O!E]QUO,58|OOQQ,58|,58|O!EjQ(C[O,58|O%QQUO,58|O!EuQUO'#HZOOQQ'#H['#H[OOQQ'#H]'#H]O`QUO,5=sO!FVQSO,5=sO`QUO,5=yO`QUO,5={O!F[QSO,5=}O`QUO,5>PO!FaQSO,5>SO!FfQUO,5>YOOQQ,5>`,5>`O%QQUO,5>`O9OQ(C[O,5>bOOQQ,5>d,5>dO!JmQSO,5>dOOQQ,5>f,5>fO!JmQSO,5>fOOQQ,5>h,5>hO!JrQWO'#DXO%QQUO'#JgO!KaQWO'#JgO!LOQWO'#DgO!LaQWO'#DgO!NrQUO'#DgO!NyQSO'#JfO# RQSO,5:QO# WQSO'#EmO# fQSO'#JtO# nQSO,5;WO# sQWO'#DgO#!QQWO'#EROOQ(CY,5:k,5:kO%QQUO,5:kO#!XQSO,5:kO>QQSO,5;RO!>oQWO,5;RO!>wQ,UO,5;RO9dQ,UO,5;RO#!aQSO,5@RO#!fQ!LQO,5:oOOQO-E<]-E<]O##lQ(C`O,5:zOCOQWO,5:nO##vQWO,5:nOCOQWO,5:zO!>dQ(C[O,5:nOOQ(CW'#Ec'#EcOOQO,5:z,5:zO%QQUO,5:zO#$TQ(C[O,5:zO#$`Q(C[O,5:zO!>oQWO,5:nOOQO,5;Q,5;QO#$nQ(C[O,5:zPOOO'#IS'#ISP#%SO?MpO,58zPOOO,58z,58zOOOO-E<S-E<SOOQ(CY1G.m1G.mOOOO-E<T-E<TO#%_Q`O,59wOOOO-E<V-E<VOOQ(CY1G/a1G/aO#%dQbO,5>tO+sQUO,5>tOOQO,5>z,5>zO#%nQUO'#IYOOQO-E<W-E<WO#%{QSO,5@PO#&TQbO,5@PO#&[QSO,5@^OOQ(CY1G/g1G/gO%QQUO,5@_O#&dQSO'#I`OOQO-E<^-E<^O#&[QSO,5@^OOQ(CW1G0q1G0qOOQ(CY1G/r1G/rOOQ(CY1G0U1G0UO%QQUO,5@[O#&xQ(C[O,5@[O#'ZQ(C[O,5@[O#'bQSO,5@ZO:vQSO,5@ZO#'jQSO,5@ZO#'xQSO'#IcO#'bQSO,5@ZOOQ(CW1G0p1G0pO!)SQWO,5:qO!)_QWO,5:qOOQO,5:s,5:sO#(jQSO,5:sO#(rQ,UO1G2qO9_QSO1G2qOOQ(CY1G0n1G0nO#)QQ(CjO1G0nO#*VQ(ChO,5;OOOQ(CY'#GP'#GPO#*sQ(CjO'#J^O!#qQUO1G0nO#,{Q,UO'#JhO#-VQSO,5:[O#-[QbO'#JiO%QQUO'#JiO#-fQSO,5:aOOQ(CY'#DX'#DXOOQ(CY1G0w1G0wO%QQUO1G0wOOQ(CY1G1a1G1aO#-kQSO1G0wO#0SQ(CjO1G0xO#0ZQ(CjO1G0xO#2tQ(CjO1G0xO#2{Q(CjO1G0xO#5VQ(CjO1G0xO#5mQ(CjO1G0xO#8gQ(CjO1G0xO#8nQ(CjO1G0xO#;XQ(CjO1G0xO#;`Q(CjO1G0xO#=WQ(CjO1G0xO#@WQ$IUO'#CfO#BUQ$IUO1G1ZO#B]Q$IUO'#JdO!+pQSO1G1aO#BmQ(CjO,5?QOOQ(CW-E<d-E<dO#CaQ(CjO1G0xOOQ(CY1G0x1G0xO#ElQ(CjO1G1^O#F`Q#tO,5<RO#FhQ#tO,5<SO#FpQ#tO'#FjO#GXQSO'#FiOOQO'#Jx'#JxOOQO'#Id'#IdO#G^Q#tO1G1iOOQ(CY1G1i1G1iOOOO1G1t1G1tO#GoQ$IUO'#JcO#GyQSO,5<]O!)jQUO,5<]OOOO-E<c-E<cOOQ(CY1G1f1G1fO#HOQWO'#JwOOQ(CY,5<_,5<_O#HWQWO,5<_OOQ(CY,59b,59bO!%tQ,UO'#C|OOOO'#IW'#IWO#H]O07`O,59fOOQ(CY,59f,59fO%QQUO1G1zO!5YQSO'#IhO#HhQSO,5<sOOQ(CY,5<p,5<pOOQO'#Gf'#GfO!'^Q,UO,5=POOQO'#Gh'#GhO!'^Q,UO,5=RO!%tQ,UO,5=TOOQO1G1|1G1|O#HvQ`O'#CoO#IZQ`O,5<lO#IbQSO'#J{O9_QSO'#J{O#IpQSO,5<nO!'^Q,UO,5<mO#IuQSO'#GSO#JQQSO,5<mO#JVQ`O'#GPO#JdQ`O'#J|O#JnQSO'#J|O!%tQ,UO'#J|O#JsQSO,5<qO#JxQWO'#G[O!3cQWO'#G[O#KZQSO'#G^O#K`QSO'#G`O!2dQSO'#GcO#KeQ(C[O'#IjO#KpQWO,5<uOOQ(CY,5<u,5<uO#KwQWO'#G[O#LVQWO'#G]O#L_QWO'#G]OOQ(CY,5=U,5=UO!'^Q,UO,5?wO!'^Q,UO,5?wO#LdQSO'#IkO#LoQSO,5?vO#LwQSO,59]O#MhQ,UO,59nOOQ(CY,59n,59nO#NZQ,UO,5<dO#N|Q,UO,5<fO?rQSO,5<hOOQ(CY,5<i,5<iO$ WQSO,5<oO$ ]Q,UO,5<tO$ mQSO'#JoO!#qQUO1G1{O$ rQSO1G1{OOQQ1G4U1G4UOOQ(CY1G/t1G/tO!+mQSO1G/tO$#qQ(CjO1G0QOOQQ1G2q1G2qO!%tQ,UO1G2qO%QQUO1G2qO$$bQSO1G2qO$$mQ,UO'#EdOOQ(CW,5?t,5?tO$$wQ(C[O,5?tOOQQ1G.r1G.rO!>dQ(C[O1G.rO!>oQWO1G.rO!>wQ,UO1G.rO$%YQSO1G0nO$%_QSO'#CfO$%jQSO'#KTO$%rQSO,5=rO$%wQSO'#KTO$%|QSO'#KTO$&XQSO'#IsO$&gQSO,5@nO$&oQbO1G1cOOQ(CY1G1e1G1eO9_QSO1G3]O?rQSO1G3]O$&vQSO1G3]O$&{QSO1G3]OOQQ1G3]1G3]O:vQSO'#JrO:vQSO'#EmO%QQUO'#EmO:vQSO'#ImO$'QQ(C[O,5@kOOQQ1G2u1G2uO!BTQSO1G2{O!%tQ,UO1G2xO$']QSO1G2xOOQQ1G2y1G2yO!%tQ,UO1G2yO$'bQSO1G2yO$'jQWO'#GwOOQQ1G2{1G2{O!3cQWO'#IoO!BYQ`O1G3OOOQQ1G3O1G3OOOQQ,5=i,5=iO$'rQ,UO,5=kO9_QSO,5=kO#K`QSO,5=mO8tQSO,5=mO!>oQWO,5=mO!>wQ,UO,5=mO9dQ,UO,5=mO$(QQSO'#KRO$(]QSO,5=nOOQQ1G.h1G.hO$(bQ(C[O1G.hO?rQSO1G.hO$(mQSO1G.hO9OQ(C[O1G.hO$*rQbO,5@pO$+SQSO,5@pO$+_QUO,5=uO$+fQSO,5=uO:vQSO,5@pOOQQ1G3_1G3_O`QUO1G3_OOQQ1G3e1G3eOOQQ1G3g1G3gO={QSO1G3iO$+kQUO1G3kO$/lQUO'#HjOOQQ1G3n1G3nO$/yQSO'#HpO>QQSO'#HrOOQQ1G3t1G3tO$0RQUO1G3tO9OQ(C[O1G3zOOQQ1G3|1G3|OOQ(CW'#GW'#GWO9OQ(C[O1G4OO9OQ(C[O1G4QO$4VQSO,5@RO!)jQUO,5;XO:vQSO,5;XO>QQSO,5:RO!)jQUO,5:RO!>oQWO,5:RO$4[Q$IUO,5:ROOQO,5;X,5;XO$4fQWO'#IZO$4|QSO,5@QOOQ(CY1G/l1G/lO$5UQWO'#IaO$5`QSO,5@`OOQ(CW1G0r1G0rO!LaQWO,5:ROOQO'#I^'#I^O$5hQWO,5:mOOQ(CY,5:m,5:mO#![QSO1G0VOOQ(CY1G0V1G0VO%QQUO1G0VOOQ(CY1G0m1G0mO>QQSO1G0mO!>oQWO1G0mO!>wQ,UO1G0mOOQ(CW1G5m1G5mO!>dQ(C[O1G0YOOQO1G0f1G0fO%QQUO1G0fO$5oQ(C[O1G0fO$5zQ(C[O1G0fO!>oQWO1G0YOCOQWO1G0YO$6YQ(C[O1G0fOOQO1G0Y1G0YO$6nQ(CjO1G0fPOOO-E<Q-E<QPOOO1G.f1G.fOOOO1G/c1G/cO$6xQ`O,5<cO$7QQbO1G4`OOQO1G4f1G4fO%QQUO,5>tO$7[QSO1G5kO$7dQSO1G5xO$7lQbO1G5yO:vQSO,5>zO$7vQ(CjO1G5vO%QQUO1G5vO$8WQ(C[O1G5vO$8iQSO1G5uO$8iQSO1G5uO:vQSO1G5uO$8qQSO,5>}O:vQSO,5>}OOQO,5>},5>}O$9VQSO,5>}O$ mQSO,5>}OOQO-E<a-E<aOOQO1G0]1G0]OOQO1G0_1G0_O!+pQSO1G0_OOQQ7+(]7+(]O!%tQ,UO7+(]O%QQUO7+(]O$9eQSO7+(]O$9pQ,UO7+(]O$:OQ(CjO,59nO$<WQ(CjO,5<dO$>cQ(CjO,5<fO$@nQ(CjO,5<tOOQ(CY7+&Y7+&YO$CPQ(CjO7+&YO$CsQ,UO'#I[O$C}QSO,5@SOOQ(CY1G/v1G/vO$DVQUO'#I]O$DdQSO,5@TO$DlQbO,5@TOOQ(CY1G/{1G/{O$DvQSO7+&cOOQ(CY7+&c7+&cO$D{Q$IUO,5:bO%QQUO7+&uO$EVQ$IUO,5:YO$EdQ$IUO,5:fO$EnQ$IUO,5:hOOQ(CY7+&{7+&{OOQO1G1m1G1mOOQO1G1n1G1nO$ExQ#tO,5<UO!)jQUO,5<TOOQO-E<b-E<bOOQ(CY7+'T7+'TOOOO7+'`7+'`OOOO1G1w1G1wO$FTQSO1G1wOOQ(CY1G1y1G1yO$FYQ`O,59hOOOO-E<U-E<UOOQ(CY1G/Q1G/QO$FaQ(CjO7+'fOOQ(CY,5?S,5?SO$GTQSO,5?SOOQ(CY1G2_1G2_P$GYQSO'#IhPOQ(CY-E<f-E<fO$G|Q,UO1G2kO$HoQ,UO1G2mO$HyQ`O1G2oOOQ(CY1G2W1G2WO$IQQSO'#IgO$I`QSO,5@gO$I`QSO,5@gO$IhQSO,5@gO$IsQSO,5@gOOQO1G2Y1G2YO$JRQ,UO1G2XO!'^Q,UO1G2XO$JcQMhO'#IiO$JsQSO,5@hO!%tQ,UO,5@hO$J{Q`O,5@hOOQ(CY1G2]1G2]OOQ(CW,5<v,5<vOOQ(CW,5<w,5<wO$ mQSO,5<wOBoQSO,5<wO!>oQWO,5<vOOQO'#G_'#G_O$KVQSO,5<xOOQ(CW,5<z,5<zO$ mQSO,5<}OOQO,5?U,5?UOOQO-E<h-E<hOOQ(CY1G2a1G2aO!3cQWO,5<vO$K_QSO,5<wO#KZQSO,5<xO!3cQWO,5<wO$KjQ,UO1G5cO$KtQ,UO1G5cOOQO,5?V,5?VOOQO-E<i-E<iOOQO1G.w1G.wO!?uQWO,59pO%QQUO,59pO$LRQSO1G2SO!'^Q,UO1G2ZO$LWQ(CjO7+'gOOQ(CY7+'g7+'gO!#qQUO7+'gOOQ(CY7+%`7+%`O$LzQ`O'#J}O#![QSO7+(]O$MUQbO7+(]O$9hQSO7+(]O$M]Q(ChO'#CfO$MpQ(ChO,5<{O$NbQSO,5<{OOQ(CW1G5`1G5`OOQQ7+$^7+$^O!>dQ(C[O7+$^O!>oQWO7+$^O!#qQUO7+&YO$NgQSO'#IrO$N{QSO,5@oOOQO1G3^1G3^O9_QSO,5@oO$N{QSO,5@oO% TQSO,5@oOOQO,5?_,5?_OOQO-E<q-E<qOOQ(CY7+&}7+&}O% YQSO7+(wO9OQ(C[O7+(wO9_QSO7+(wO?rQSO7+(wO% _QSO,5;XOOQ(CW,5?X,5?XOOQ(CW-E<k-E<kOOQQ7+(g7+(gO% dQ(ChO7+(dO!%tQ,UO7+(dO% nQ`O7+(eOOQQ7+(e7+(eO!%tQ,UO7+(eO% uQSO'#KQO%!QQSO,5=cOOQO,5?Z,5?ZOOQO-E<m-E<mOOQQ7+(j7+(jO%#aQWO'#HQOOQQ1G3V1G3VO!%tQ,UO1G3VO%QQUO1G3VO%#hQSO1G3VO%#sQ,UO1G3VO9OQ(C[O1G3XO#K`QSO1G3XO8tQSO1G3XO!>oQWO1G3XO!>wQ,UO1G3XO%$RQSO'#IqO%$^QSO,5@mO%$fQWO,5@mOOQ(CW1G3Y1G3YOOQQ7+$S7+$SO?rQSO7+$SO9OQ(C[O7+$SO%$qQSO7+$SO%QQUO1G6[O%QQUO1G6]O%$vQUO1G3aO%$}QSO1G3aO%%SQUO1G3aO%%ZQ(C[O1G6[OOQQ7+(y7+(yO9OQ(C[O7+)TO`QUO7+)VOOQQ'#KW'#KWOOQQ'#It'#ItO%%eQUO,5>UOOQQ,5>U,5>UO%QQUO'#HkO%%rQSO'#HmOOQQ,5>[,5>[O:vQSO,5>[OOQQ,5>^,5>^OOQQ7+)`7+)`OOQQ7+)f7+)fOOQQ7+)j7+)jOOQQ7+)l7+)lO%%wQWO1G5mO%&]Q$IUO1G0sO%&gQSO1G0sOOQO1G/m1G/mO%&rQ$IUO1G/mO>QQSO1G/mO!)jQUO'#DgOOQO,5>u,5>uOOQO-E<X-E<XOOQO,5>{,5>{OOQO-E<_-E<_O!>oQWO1G/mOOQO-E<[-E<[OOQ(CY1G0X1G0XOOQ(CY7+%q7+%qO#![QSO7+%qOOQ(CY7+&X7+&XO>QQSO7+&XO!>oQWO7+&XOOQO7+%t7+%tO$6nQ(CjO7+&QOOQO7+&Q7+&QO%QQUO7+&QO%&|Q(C[O7+&QO!>dQ(C[O7+%tO!>oQWO7+%tO%'XQ(C[O7+&QO%'gQ(CjO7++bO%QQUO7++bO%'wQSO7++aO%'wQSO7++aOOQO1G4i1G4iO:vQSO1G4iO%(PQSO1G4iOOQO7+%y7+%yO#![QSO<<KwO$MUQbO<<KwO%(_QSO<<KwOOQQ<<Kw<<KwO!%tQ,UO<<KwO%QQUO<<KwO%(gQSO<<KwO%(rQ(CjO1G2kO%*}Q(CjO1G2mO%-YQ(CjO1G2XO%/kQ,UO,5>vOOQO-E<Y-E<YO%/uQbO,5>wO%QQUO,5>wOOQO-E<Z-E<ZO%0PQSO1G5oOOQ(CY<<I}<<I}O%0XQ$IUO1G0nO%2cQ$IUO1G0xO%2jQ$IUO1G0xO%4nQ$IUO1G0xO%4uQ$IUO1G0xO%6jQ$IUO1G0xO%7QQ$IUO1G0xO%9eQ$IUO1G0xO%9lQ$IUO1G0xO%;pQ$IUO1G0xO%;wQ$IUO1G0xO%=oQ$IUO1G0xO%>SQ(CjO<<JaO%?XQ$IUO1G0xO%@}Q$IUO'#J^O%CQQ$IUO1G1^O%C_Q$IUO1G0QO!)jQUO'#FlOOQO'#Jy'#JyOOQO1G1p1G1pO%CiQSO1G1oO%CnQ$IUO,5?QOOOO7+'c7+'cOOOO1G/S1G/SOOQ(CY1G4n1G4nO!'^Q,UO7+(ZO%CxQSO,5?RO9_QSO,5?ROOQO-E<e-E<eO%DWQSO1G6RO%DWQSO1G6RO%D`QSO1G6RO%DkQ,UO7+'sO%D{Q`O,5?TO%EVQSO,5?TO!%tQ,UO,5?TOOQO-E<g-E<gO%E[Q`O1G6SO%EfQSO1G6SOOQ(CW1G2c1G2cO$ mQSO1G2cOOQ(CW1G2b1G2bO%EnQSO1G2dO!%tQ,UO1G2dOOQ(CW1G2i1G2iO!>oQWO1G2bOBoQSO1G2cO%EsQSO1G2dO%E{QSO1G2cO!'^Q,UO7+*}OOQ(CY1G/[1G/[O%FWQSO1G/[OOQ(CY7+'n7+'nO%F]Q,UO7+'uO%FmQ(CjO<<KROOQ(CY<<KR<<KRO!%tQ,UO'#IlO%GaQSO,5@iO!%tQ,UO1G2gOOQQ<<Gx<<GxO!>dQ(C[O<<GxO%GiQ(CjO<<ItOOQ(CY<<It<<ItOOQO,5?^,5?^O%H]QSO,5?^O$%|QSO,5?^OOQO-E<p-E<pO%HbQSO1G6ZO%HbQSO1G6ZO9_QSO1G6ZO?rQSO<<LcOOQQ<<Lc<<LcO%HjQSO<<LcO9OQ(C[O<<LcO%HoQSO1G0sOOQQ<<LO<<LOO% dQ(ChO<<LOOOQQ<<LP<<LPO% nQ`O<<LPO%HtQWO'#InO%IPQSO,5@lO!)jQUO,5@lOOQQ1G2}1G2}O%IXQUO'#JgOOQO'#Ip'#IpO9OQ(C[O'#IpO%IcQWO,5=lOOQQ,5=l,5=lO%IjQWO'#E`O%JOQSO7+(qO%JTQSO7+(qOOQQ7+(q7+(qO!%tQ,UO7+(qO%QQUO7+(qO%J]QSO7+(qOOQQ7+(s7+(sO9OQ(C[O7+(sO#K`QSO7+(sO8tQSO7+(sO!>oQWO7+(sO%JhQSO,5?]OOQO-E<o-E<oOOQO'#HT'#HTO%JsQSO1G6XO9OQ(C[O<<GnOOQQ<<Gn<<GnO?rQSO<<GnO%J{QSO7++vO%KQQSO7++wOOQQ7+({7+({O%KVQSO7+({O%K[QUO7+({O%KcQSO7+({O%QQUO7++vO%QQUO7++wOOQQ<<Lo<<LoOOQQ<<Lq<<LqOOQQ-E<r-E<rOOQQ1G3p1G3pO%KhQSO,5>VOOQQ,5>X,5>XO%KmQSO1G3vO:vQSO7+&_O!)jQUO7+&_OOQO7+%X7+%XO%KrQ$IUO1G5yO>QQSO7+%XOOQ(CY<<I]<<I]OOQ(CY<<Is<<IsO>QQSO<<IsOOQO<<Il<<IlO$6nQ(CjO<<IlO%QQUO<<IlOOQO<<I`<<I`O!>dQ(C[O<<I`O%K|Q(C[O<<IlO%LXQ(CjO<<N|O%LiQSO<<N{OOQO7+*T7+*TO:vQSO7+*TOOQQANAcANAcO%LqQSOANAcO!%tQ,UOANAcO#![QSOANAcO$MUQbOANAcO%QQUOANAcO%LyQ(CjO7+'sO& [Q(CjO7+'uO&#mQbO1G4cO&#wQ$IUO7+&YO&$UQ$IUO,59nO&&XQ$IUO,5<dO&([Q$IUO,5<fO&*_Q$IUO,5<tO&,TQ$IUO7+'fO&,bQ$IUO7+'gO&,oQSO,5<WOOQO7+'Z7+'ZO&,tQ,UO<<KuOOQO1G4m1G4mO&,{QSO1G4mO&-WQSO1G4mO&-fQSO7++mO&-fQSO7++mO!%tQ,UO1G4oO&-nQ`O1G4oO&-xQSO7++nOOQ(CW7+'}7+'}O$ mQSO7+(OO&.QQ`O7+(OOOQ(CW7+'|7+'|O$ mQSO7+'}O&.XQSO7+(OO!%tQ,UO7+(OOBoQSO7+'}O&.^Q,UO<<NiOOQ(CY7+$v7+$vO&.hQ`O,5?WOOQO-E<j-E<jO&.rQ(ChO7+(ROOQQAN=dAN=dO9_QSO1G4xOOQO1G4x1G4xO&/SQSO1G4xO&/XQSO7++uO&/XQSO7++uO9OQ(C[OANA}O?rQSOANA}OOQQANA}ANA}OOQQANAjANAjOOQQANAkANAkO&/aQSO,5?YOOQO-E<l-E<lO&/lQ$IUO1G6WO&1|QbO'#CfOOQO,5?[,5?[OOQO-E<n-E<nOOQQ1G3W1G3WO%IXQUO,5<xOOQQ<<L]<<L]O!%tQ,UO<<L]O%JOQSO<<L]O&2WQSO<<L]O%QQUO<<L]OOQQ<<L_<<L_O9OQ(C[O<<L_O#K`QSO<<L_O8tQSO<<L_O&2`QWO1G4wO&2kQSO7++sOOQQAN=YAN=YO9OQ(C[OAN=YOOQQ<= b<= bOOQQ<= c<= cOOQQ<<Lg<<LgO&2sQSO<<LgO&2xQUO<<LgO&3PQSO<= bO&3UQSO<= cOOQQ1G3q1G3qO>QQSO7+)bO&3ZQSO<<IyO&3fQ$IUO<<IyOOQO<<Hs<<HsOOQ(CYAN?_AN?_OOQOAN?WAN?WO$6nQ(CjOAN?WOOQOAN>zAN>zO%QQUOAN?WOOQO<<Mo<<MoOOQQG26}G26}O!%tQ,UOG26}O#![QSOG26}O&3pQSOG26}O$MUQbOG26}O&3xQ$IUO<<JaO&4VQ$IUO1G2XO&5{Q$IUO1G2kO&8OQ$IUO1G2mO&:RQ$IUO<<KRO&:`Q$IUO<<ItOOQO1G1r1G1rO!'^Q,UOANAaOOQO7+*X7+*XO&:mQSO7+*XO&:xQSO<= XO&;QQ`O7+*ZOOQ(CW<<Kj<<KjO$ mQSO<<KjOOQ(CW<<Ki<<KiO&;[Q`O<<KjO$ mQSO<<KiOOQO7+*d7+*dO9_QSO7+*dO&;cQSO<= aOOQQG27iG27iO9OQ(C[OG27iO!)jQUO1G4tO&;kQSO7++rO%JOQSOANAwOOQQANAwANAwO!%tQ,UOANAwO&;sQSOANAwOOQQANAyANAyO9OQ(C[OANAyO#K`QSOANAyOOQO'#HU'#HUOOQO7+*c7+*cOOQQG22tG22tOOQQANBRANBRO&;{QSOANBROOQQAND|AND|OOQQAND}AND}OOQQ<<L|<<L|O!)jQUOAN?eOOQOG24rG24rO$6nQ(CjOG24rO#![QSOLD,iOOQQLD,iLD,iO!%tQ,UOLD,iO&<QQSOLD,iO&<YQ$IUO7+'sO&>OQ$IUO7+'uO&?tQ,UOG26{OOQO<<Ms<<MsOOQ(CWANAUANAUO$ mQSOANAUOOQ(CWANATANATOOQO<<NO<<NOOOQQLD-TLD-TO&@UQ$IUO7+*`OOQQG27cG27cO%JOQSOG27cO!%tQ,UOG27cOOQQG27eG27eO9OQ(C[OG27eOOQQG27mG27mO&@`Q$IUOG25POOQOLD*^LD*^OOQQ!$(!T!$(!TO#![QSO!$(!TO!%tQ,UO!$(!TO&@jQ(CjOG26{OOQ(CWG26pG26pOOQQLD,}LD,}O%JOQSOLD,}OOQQLD-PLD-POOQQ!)9Eo!)9EoO#![QSO!)9EoOOQQ!$(!i!$(!iOOQQ!.K;Z!.K;ZO&B{Q$IUOG26{O!)jQUO'#DvO0uQSO'#ETO&DqQbO'#JcO!)jQUO'#DnO&DxQUO'#DzO!)jQUO'#D|O&EPQbO'#CfO&GgQbO'#CfO&GwQUO,5;SO!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO'#IfO&IzQSO,5<cO&JSQ,UO,5;^O&KgQ,UO,5;^O!)jQUO,5;rO0xQSO'#DSO0xQSO'#DSO!%tQ,UO'#FxO&JSQ,UO'#FxO!%tQ,UO'#FzO&JSQ,UO'#FzO!%tQ,UO'#GYO&JSQ,UO'#GYO!)jQUO,5:fO!)jQUO,5@_O&GwQUO1G0nO&KnQ$IUO'#CfO!)jQUO1G1zO!%tQ,UO,5=PO&JSQ,UO,5=PO!%tQ,UO,5=RO&JSQ,UO,5=RO!%tQ,UO,5<mO&JSQ,UO,5<mO&GwQUO1G1{O!)jQUO7+&uO!%tQ,UO1G2XO&JSQ,UO1G2XO!%tQ,UO1G2ZO&JSQ,UO1G2ZO&GwQUO7+'gO&GwQUO7+&YO!%tQ,UOANAaO&JSQ,UOANAaO&KxQSO'#EhO&K}QSO'#EhO&LVQSO'#FWO&L[QSO'#ErO&LaQSO'#JsO&LlQSO'#JqO&LwQSO,5;SO&L|Q,UO,5<`O&MTQSO'#GRO&MYQSO'#GRO&M_QSO,5<aO&MgQSO,5;SO&MoQ$IUO1G1ZO&MvQSO,5<mO&M{QSO,5<mO&NQQSO,5<oO&NVQSO,5<oO&N[QSO1G1{O&NaQSO1G0nO&NfQ,UO<<KuO&NmQ,UO<<KuO7^Q,UO'#FvO8tQSO'#FuO@mQSO'#EgO!)jQUO,5;oO!2dQSO'#GRO!2dQSO'#GRO!2dQSO'#GTO!2dQSO'#GTO!'^Q,UO7+(ZO!'^Q,UO7+(ZO$HyQ`O1G2oO$HyQ`O1G2oO!%tQ,UO,5=TO!%tQ,UO,5=T",
  stateData: "' v~O'mOS'nOSROS'oRQ~OPYOQYOV!TO^pOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O#p}O$QzO$UfO%`{O%b!OO%d|O%e|O%h!PO%j!QO%m!RO%n!RO%p!SO%|!UO&S!VO&U!WO&W!XO&Y!YO&]!ZO&c![O&i!]O&k!^O&m!_O&o!`O&q!aO'tSO'vTO'yUO(RVO(a[O(niO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO't!bO'vTO'yUO(RVO(a[O(niO~O^!sOl!kO|!lO![!uO!]!rO!^!rO!x9mO!|!mO!}!mO#O!tO#P!mO#Q!mO#T!vO#U!vO'u!iO'vTO'yUO(U!jO(a!pO~O'o!wO~OPYXXYX^YXkYXyYXzYX|YX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX'kYX(RYX(bYX(iYX(jYX~O!a$zX~P(gO[!yO'v!{O'w!yO'x!{O~O[!|O'x!{O'y!{O'z!|O~Oq#OO!O#PO(S#PO(T#RO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO't9rO'vTO'yUO(RVO(a[O(niO~O!U#VO!V#SO!S(XP!S(fP~P+sO!W#_O~P`OPYOQYOa!gOb!fOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO'vTO'yUO(RVO(a[O(niO~Oi#iO!U#eO!x]O#b#hO#c#eO't9sO!g(cP~P._O!h#kO't#jO~O!t#oO!x]O%`#pO~O#d#qO~O!a#rO#d#qO~OP$YOX$aOk#}Oy#vOz#wO|#xO!V$^O!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO#v$VO(RVO(b$WO(i#yO(j#zO~O^(VX'k(VX'i(VX!g(VX!S(VX!X(VX%a(VX!a(VX~P1gO#X$bO#{$bOP(WXX(WXk(WXy(WXz(WX|(WX!V(WX!e(WX!h(WX!l(WX#g(WX#h(WX#i(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#q(WX#s(WX#u(WX#v(WX(R(WX(b(WX(i(WX(j(WX!X(WX%a(WX~O^(WX!f(WX'k(WX'i(WX!S(WX!g(WXo(WX!a(WX~P3}O#X$bO~O$W$dO$Y$cO$a$iO~O!X$jO$UfO$d$kO$f$mO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#c%YO$Q%VO$m%TO$o%UO$r%WO't$oO'vTO'yUO'}%OO(R$rOd(OP~O!h%ZO~O!a%]O~O^%^O'k%^O~O'u!iO~P%QO't%eO~O!h%ZO't%eO'u!iO'}%OO~Ob%lO!h%ZO't%eO~O#o$PO~Oy%qO!X%nO!h%pO%b%tO't%eO'u!iO'vTO'yUO](vP~O!t#oO~O|%vO!X%wO't%eO~O|%vO!X%wO%j%{O't%eO~O't%|O~O#p}O%b!OO%d|O%e|O%h!PO%j!QO%m!RO%n!RO~Oa&VOb&UO!t&SO%`&TO%r&RO~P;fOa&YObwO!X&XO!tvO!x]O#p}O%`{O%d|O%e|O%h!PO%j!QO%m!RO%n!RO%p!SO~O_&]O#X&`O%b&ZO'u!iO~P<eO!h&aO!q&eO~O!h#kO~O!XXO~O^%^O'j&mO'k%^O~O^%^O'j&pO'k%^O~O^%^O'j&rO'k%^O~O'iYX!SYXoYX!gYX&QYX!XYX%aYX!aYX~P(gO!['PO!]&xO!^&xO'u!iO'vTO'yUO~Ol&vO|&uO!U&yO(U&tO!W(YP!W(hP~P?fOg'SO!X'QO't%eO~Ob'XO!h%ZO't%eO~Oy%qO!h%pO~Ol!kO|!lO!x9mO!|!mO!}!mO#P!mO#Q!mO'u!iO'vTO'yUO(U!jO(a!pO~O!['_O!]'^O!^'^O#O!mO#T'`O#U'`O~PAQO^%^O!a#rO!h%ZO'k%^O'}%OO(b'bO~O!l'fO#X'dO~PB`Ol!kO|!lO'vTO'yUO(U!jO(a!pO~O!XXOl(_X|(_X![(_X!](_X!^(_X!x(_X!|(_X!}(_X#O(_X#P(_X#Q(_X#T(_X#U(_X'u(_X'v(_X'y(_X(U(_X(a(_X~O!]'^O!^'^O'u!iO~PCOO'p'jO'q'jO'r'lO~O[!yO'v'nO'w!yO'x'nO~O[!|O'x'nO'y'nO'z!|O~Oq#OO!O#PO(S#PO(T'rO~O!U'tO!S&|X!S'SX!V&|X!V'SX~P+sO!V'vO!S(XX~OP$YOX$aOk#}Oy#vOz#wO|#xO!V'vO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO#v$VO(RVO(b$WO(i#yO(j#zO~O!S(XX~PFrO!S'{O~O!S(eX!V(eX!a(eX!g(eX(b(eX~O#X(eX#d#]X!W(eX~PHxO#X'|O!S(gX!V(gX~O!V'}O!S(fX~O!S(QO~O#X$bO~PHxO!W(RO~P`Oy#vOz#wO|#xO!f#tO!h#uO(RVOP!jaX!jak!ja!V!ja!e!ja!l!ja#g!ja#h!ja#i!ja#j!ja#k!ja#l!ja#m!ja#n!ja#o!ja#q!ja#s!ja#u!ja#v!ja(b!ja(i!ja(j!ja~O^!ja'k!ja'i!ja!S!ja!g!jao!ja!X!ja%a!ja!a!ja~PJ`O!g(SO~O!a#rO#X(TO(b'bO!V(dX^(dX'k(dX~O!g(dX~PMOO|%vO!X%wO!x]O#b(YO#c(XO't%eO~O!V(ZO!g(cX~O!g(]O~O|%vO!X%wO#c(XO't%eO~OP(WXX(WXk(WXy(WXz(WX|(WX!V(WX!e(WX!f(WX!h(WX!l(WX#g(WX#h(WX#i(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#q(WX#s(WX#u(WX#v(WX(R(WX(b(WX(i(WX(j(WX~O!a#rO!g(WX~PNlOy(^Oz(_O!f#tO!h#uO!x!wa|!wa~O!t!wa%`!wa!X!wa#b!wa#c!wa't!wa~P!!pO!t(cO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO't!bO'vTO'yUO(RVO(a[O(niO~Oi%POk$qOl$pOm$pOs%QOu%ROw:VO|$xO!X$yO!c;aO!h$uO#c:]O$Q%VO$m:XO$o:ZO$r%WO't(gO'vTO'yUO'}%OO(R$rO~O#d(iO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#c%YO$Q%VO$m%TO$o%UO$r%WO't(gO'vTO'yUO'}%OO(R$rO~Od([P~P!'^O!U(mO!g(]P~P%QO(U(oO(a[O~O|(qO!h#uO(U(oO(a[O~OP9lOQ9lOa;]Ob!fOikOk9lOlkOmkOskOu9lOw9lO|WO!QkO!RkO!X!cO!c9oO!hZO!k9lO!l9lO!m9lO!o9pO!q9qO!t!eO$Q!hO$UfO't)PO'vTO'yUO(RVO(a[O(n;ZO~Oz)SO!h#uO~O!V$^O^$ka'k$ka'i$ka!g$ka!S$ka!X$ka%a$ka!a$ka~O#p)WO~P!%tOy)ZO!a)YO!X$XX$T$XX$W$XX$Y$XX$a$XX~O!a)YO!X(kX$T(kX$W(kX$Y(kX$a(kX~Oy)ZO~P!-SOy)ZO!X(kX$T(kX$W(kX$Y(kX$a(kX~O!X)]O$T)aO$W)[O$Y)[O$a)bO~O!U)eO~P!)jO$W$dO$Y$cO$a)iO~Og$sXy$sX|$sX!f$sX(i$sX(j$sX~OdfXd$sXgfX!VfX#XfX~P!.xOl)kO~Oq)lO(S)mO(T)oO~Og)xOy)qO|)rO(i)tO(j)vO~Od)pO~P!0ROd)yO~Oi%POk$qOl$pOm$pOs%QOu%ROw:VO|$xO!X$yO!c;aO!h$uO#c:]O$Q%VO$m:XO$o:ZO$r%WO'vTO'yUO'}%OO(R$rO~O!U)}O't)zO!g(oP~P!0pO#d*PO~O!h*QO~O!U*VO't*SO!S(pP~P!0pOk*cO|*ZO![*aO!]*YO!^*YO!h*QO#T*bO%W*]O'u!iO(U!jO~O!W*`O~P!2vO!f#tOg(QXy(QX|(QX(i(QX(j(QX!V(QX#X(QX~Od(QX#y(QX~P!3oOg*fO#X*eOd(PX!V(PX~O!V*gOd(OX~O't%|Od(OP~O!h*nO~O't(gO~Oi*rO|%vO!U#eO!X%wO!x]O#b#hO#c#eO't%eO!g(cP~O!a#rO#d*sO~OP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO#v$VO(RVO(b$WO(i#yO(j#zO~O^!ba!V!ba'k!ba'i!ba!S!ba!g!bao!ba!X!ba%a!ba!a!ba~P!6UOy#vOz#wO|#xO!f#tO!h#uO(RVOP!naX!nak!na!V!na!e!na!l!na#g!na#h!na#i!na#j!na#k!na#l!na#m!na#n!na#o!na#q!na#s!na#u!na#v!na(b!na(i!na(j!na~O^!na'k!na'i!na!S!na!g!nao!na!X!na%a!na!a!na~P!8oOy#vOz#wO|#xO!f#tO!h#uO(RVOP!paX!pak!pa!V!pa!e!pa!l!pa#g!pa#h!pa#i!pa#j!pa#k!pa#l!pa#m!pa#n!pa#o!pa#q!pa#s!pa#u!pa#v!pa(b!pa(i!pa(j!pa~O^!pa'k!pa'i!pa!S!pa!g!pao!pa!X!pa%a!pa!a!pa~P!;YOg*{O!X'QO%a*zO'}%OO~O!a*}O^'|X!X'|X'k'|X!V'|X~O^%^O!XXO'k%^O~O!h%ZO'}%OO~O!h%ZO't%eO'}%OO~O!a#rO#d(iO~O%b+ZO't+VO'vTO'yUO!W(wP~O!V+[O](vX~O(U(oO~OX+`O~O]+aO~O!X%nO't%eO'u!iO](vP~O|%vO!U+eO!V'}O!X%wO't%eO!S(fP~Ol&|O|+gO!U+fO'vTO'yUO(U(oO~O!W(hP~P!@xO!V+hO^(sX'k(sX~O#X+lO'}%OO~Og+oO!X$yO'}%OO~O!X+qO~Oy+sO!XXO~O!t+xO~Ob+}O~O't#jO!W(uP~Ob%lO~O%b!OO't%|O~P<eOX,TO],SO~OPYOQYOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O$UfO%`{O'vTO'yUO(RVO(a[O(niO~O!X!cO$Q!hO't!bO~P!C]O],SO^%^O'k%^O~O^,XO#p,ZO%d,ZO%e,ZO~P%QO!h&aO~O&S,`O~O!X,bO~O&e,dO&g,eOP&baQ&baV&ba^&baa&bab&bai&bak&bal&bam&bas&bau&baw&ba|&ba!Q&ba!R&ba!X&ba!c&ba!h&ba!k&ba!l&ba!m&ba!o&ba!q&ba!t&ba!x&ba#p&ba$Q&ba$U&ba%`&ba%b&ba%d&ba%e&ba%h&ba%j&ba%m&ba%n&ba%p&ba%|&ba&S&ba&U&ba&W&ba&Y&ba&]&ba&c&ba&i&ba&k&ba&m&ba&o&ba&q&ba'i&ba't&ba'v&ba'y&ba(R&ba(a&ba(n&ba!W&ba&Z&ba_&ba&`&ba~O't,jO~O!V{X!V!_X!W{X!W!_X!a{X!a!_X!h!_X#X{X'}!_X~O!a,oO#X,nO!V#aX!V(ZX!W#aX!W(ZX!a(ZX!h(ZX'}(ZX~O!a,qO!h%ZO'}%OO!V!ZX!W!ZX~Ol!kO|!lO'vTO'yUO(U!jO~OP9lOQ9lOa;]Ob!fOikOk9lOlkOmkOskOu9lOw9lO|WO!QkO!RkO!X!cO!c9oO!hZO!k9lO!l9lO!m9lO!o9pO!q9qO!t!eO$Q!hO$UfO'vTO'yUO(RVO(a[O(n;ZO~O't:bO~P!LrO!V,uO!W(YX~O!W,wO~O!a,oO#X,nO!V#aX!W#aX~O!V,xO!W(hX~O!W,zO~O!],{O!^,{O'u!iO~P!LaO!W-OO~P'TOg-RO!X'QO~O!S-WO~Ol!wa![!wa!]!wa!^!wa!|!wa!}!wa#O!wa#P!wa#Q!wa#T!wa#U!wa'u!wa'v!wa'y!wa(U!wa(a!wa~P!!pO!l-]O#X-ZO~PB`O!]-_O!^-_O'u!iO~PCOO^%^O#X-ZO'k%^O~O^%^O!a#rO#X-ZO'k%^O~O^%^O!a#rO!l-]O#X-ZO'k%^O(b'bO~O'p'jO'q'jO'r-dO~Oo-eO~O!S&|a!V&|a~P!6UO!U-iO!S&|X!V&|X~P%QO!V'vO!S(Xa~O!S(Xa~PFrO!V'}O!S(fa~O|%vO!U-mO!X%wO't%eO!S'SX!V'SX~O#X-oO!V(da!g(da^(da'k(da~O!a#rO~P#&xO!V(ZO!g(ca~O|%vO!X%wO#c-sO't%eO~Oi-xO|%vO!U-uO!X%wO!x]O#b-wO#c-uO't%eO!V'VX!g'VX~Oz-|O!h#uO~Og.PO!X'QO%a.OO'}%OO~O^#[i!V#[i'k#[i'i#[i!S#[i!g#[io#[i!X#[i%a#[i!a#[i~P!6UOg;gOy)qO|)rO(i)tO(j)vO~O#d#Wa^#Wa#X#Wa'k#Wa!V#Wa!g#Wa!X#Wa!S#Wa~P#)tO#d(QXP(QXX(QX^(QXk(QXz(QX!e(QX!h(QX!l(QX#g(QX#h(QX#i(QX#j(QX#k(QX#l(QX#m(QX#n(QX#o(QX#q(QX#s(QX#u(QX#v(QX'k(QX(R(QX(b(QX!g(QX!S(QX'i(QXo(QX!X(QX%a(QX!a(QX~P!3oO!V.YOd([X~P!0ROd.[O~O!V.]O!g(]X~P!6UO!g.`O~O!S.bO~OP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(RVOX#fi^#fik#fi!V#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'k#fi(b#fi(i#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O#g#fi~P#-pO#g#{O~P#-pOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O(RVOX#fi^#fi!V#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'k#fi(b#fi(i#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~Ok#fi~P#0bOk#}O~P#0bOP$YOk#}Oy#vOz#wO|#xO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO(RVO^#fi!V#fi#q#fi#s#fi#u#fi#v#fi'k#fi(b#fi(i#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P#3SOX$aO!e$PO#l$PO#m$PO#n$`O#o$PO~P#3SOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO(RVO^#fi!V#fi#s#fi#u#fi#v#fi'k#fi(b#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(i#fi~P#6TO(i#yO~P#6TOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO(RVO(i#yO^#fi!V#fi#u#fi#v#fi'k#fi(b#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(j#fi~P#8uO(j#zO~P#8uOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO(RVO(i#yO(j#zO~O^#fi!V#fi#v#fi'k#fi(b#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#;gOPYXXYXkYXyYXzYX|YX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(RYX(bYX(iYX(jYX!VYX!WYX~O#yYX~P#>QOP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO#s9|O#u:OO#v:PO(RVO(b$WO(i#yO(j#zO~O#y.dO~P#@_O#X:UO#{:UO#y(WX!W(WX~PNlO^'Ya!V'Ya'k'Ya'i'Ya!g'Ya!S'Yao'Ya!X'Ya%a'Ya!a'Ya~P!6UOP#fiX#fi^#fik#fiz#fi!V#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'k#fi(R#fi(b#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#)tO^#zi!V#zi'k#zi'i#zi!S#zi!g#zio#zi!X#zi%a#zi!a#zi~P!6UO$W.iO$Y.iO~O$W.jO$Y.jO~O!a)YO#X.kO!X$^X$T$^X$W$^X$Y$^X$a$^X~O!U.lO~O!X)]O$T.nO$W)[O$Y)[O$a.oO~O!V:QO!W(VX~P#@_O!W.pO~O!a)YO$a(kX~O$a.rO~Oq)lO(S)mO(T.uO~Ol.xO!S.yO'vTO'yUO~O!VcX!acX!gcX!g$sX(bcX~P!.xO!g/PO~P#)tO!V/QO!a#rO(b'bO!g(oX~O!g/VO~O!U)}O't%eO!g(oP~O#d/XO~O!S$sX!V$sX!a$zX~P!.xO!V/YO!S(pX~P#)tO!a/[O~O!S/^O~Ok/bO!a#rO!h%ZO'}%OO(b'bO~O't/dO~O!a*}O~O^%^O!V/hO'k%^O~O!W/jO~P!2vO!]/kO!^/kO'u!iO(U!jO~O|/mO(U!jO~O#T/nO~O't%|Od'_X!V'_X~O!V*gOd(Oa~Od/sO~Oy/tOz/tO|/uOgva(iva(jva!Vva#Xva~Odva#yva~P#L|Oy)qO|)rOg$la(i$la(j$la!V$la#X$la~Od$la#y$la~P#MrOy)qO|)rOg$na(i$na(j$na!V$na#X$na~Od$na#y$na~P#NeO#d/wO~Od$|a!V$|a#X$|a#y$|a~P!0RO!a#rO~O#d/zO~Oy#vOz#wO|#xO!f#tO!h#uO(RVOP!niX!nik!ni!V!ni!e!ni!l!ni#g!ni#h!ni#i!ni#j!ni#k!ni#l!ni#m!ni#n!ni#o!ni#q!ni#s!ni#u!ni#v!ni(b!ni(i!ni(j!ni~O^!ni'k!ni'i!ni!S!ni!g!nio!ni!X!ni%a!ni!a!ni~P$ wOg.PO!X'QO%a.OO~Oi0RO't0QO~P!0sO!a*}O^'|a!X'|a'k'|a!V'|a~O#d0XO~OXYX!VcX!WcX~O!V0YO!W(wX~O!W0[O~OX0]O~O't+VO'vTO'yUO~O!X%nO't%eO]'gX!V'gX~O!V+[O](va~O!g0bO~P!6UOX0eO~O]0fO~O!V+hO^(sa'k(sa~O#X0lO~Og0oO!X$yO~O(U(oO!W(tP~Og0xO!X0uO%a0wO'}%OO~OX1SO!V1QO!W(uX~O!W1TO~O]1VO^%^O'k%^O~O't#jO'vTO'yUO~O#X$bO#{$bOP(WXX(WXk(WXy(WXz(WX|(WX!V(WX!e(WX!h(WX!l(WX#g(WX#h(WX#i(WX#j(WX#k(WX#l(WX#m(WX#n(WX#q(WX#s(WX#u(WX#v(WX(R(WX(b(WX(i(WX(j(WX~O#o1YO&Q1ZO^(WX!f(WX~P$(xO#X$bO#o1YO&Q1ZO~O^1[O~P%QO^1^O~O&Z1bOP&XiQ&XiV&Xi^&Xia&Xib&Xii&Xik&Xil&Xim&Xis&Xiu&Xiw&Xi|&Xi!Q&Xi!R&Xi!X&Xi!c&Xi!h&Xi!k&Xi!l&Xi!m&Xi!o&Xi!q&Xi!t&Xi!x&Xi#p&Xi$Q&Xi$U&Xi%`&Xi%b&Xi%d&Xi%e&Xi%h&Xi%j&Xi%m&Xi%n&Xi%p&Xi%|&Xi&S&Xi&U&Xi&W&Xi&Y&Xi&]&Xi&c&Xi&i&Xi&k&Xi&m&Xi&o&Xi&q&Xi'i&Xi't&Xi'v&Xi'y&Xi(R&Xi(a&Xi(n&Xi!W&Xi_&Xi&`&Xi~O_1hO!W1fO&`1gO~P`O!XXO!h1jO~O&g,eOP&biQ&biV&bi^&bia&bib&bii&bik&bil&bim&bis&biu&biw&bi|&bi!Q&bi!R&bi!X&bi!c&bi!h&bi!k&bi!l&bi!m&bi!o&bi!q&bi!t&bi!x&bi#p&bi$Q&bi$U&bi%`&bi%b&bi%d&bi%e&bi%h&bi%j&bi%m&bi%n&bi%p&bi%|&bi&S&bi&U&bi&W&bi&Y&bi&]&bi&c&bi&i&bi&k&bi&m&bi&o&bi&q&bi'i&bi't&bi'v&bi'y&bi(R&bi(a&bi(n&bi!W&bi&Z&bi_&bi&`&bi~O!S1pO~O!V!Za!W!Za~P#@_Ol!kO|!lO!U1vO(U!jO!V&}X!W&}X~P?fO!V,uO!W(Ya~O!V'TX!W'TX~P!@xO!V,xO!W(ha~O!W1}O~P'TO^%^O#X2WO'k%^O~O^%^O!a#rO#X2WO'k%^O~O^%^O!a#rO!l2[O#X2WO'k%^O(b'bO~O^%^O'k%^O~P!6UO!V$^Oo$ka~O!S&|i!V&|i~P!6UO!V'vO!S(Xi~O!V'}O!S(fi~O!S(gi!V(gi~P!6UO!V(di!g(di^(di'k(di~P!6UO#X2^O!V(di!g(di^(di'k(di~O!V(ZO!g(ci~O|%vO!X%wO!x]O#b2cO#c2bO't%eO~O|%vO!X%wO#c2bO't%eO~Og2jO!X'QO%a2iO~Og2jO!X'QO%a2iO'}%OO~O#dvaPvaXva^vakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva'kva(Rva(bva!gva!Sva'ivaova!Xva%ava!ava~P#L|O#d$laP$laX$la^$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la'k$la(R$la(b$la!g$la!S$la'i$lao$la!X$la%a$la!a$la~P#MrO#d$naP$naX$na^$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na'k$na(R$na(b$na!g$na!S$na'i$nao$na!X$na%a$na!a$na~P#NeO#d$|aP$|aX$|a^$|ak$|az$|a!V$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a'k$|a(R$|a(b$|a!g$|a!S$|a'i$|a#X$|ao$|a!X$|a%a$|a!a$|a~P#)tO^#[q!V#[q'k#[q'i#[q!S#[q!g#[qo#[q!X#[q%a#[q!a#[q~P!6UOd'OX!V'OX~P!'^O!V.YOd([a~O!U2rO!V'PX!g'PX~P%QO!V.]O!g(]a~O!V.]O!g(]a~P!6UO!S2uO~O#y!ja!W!ja~PJ`O#y!ba!V!ba!W!ba~P#@_O#y!na!W!na~P!8oO#y!pa!W!pa~P!;YO!X3XO$UfO$_3YO~O!W3^O~Oo3_O~P#)tO^$hq!V$hq'k$hq'i$hq!S$hq!g$hqo$hq!X$hq%a$hq!a$hq~P!6UO!S3`O~Ol.xO'vTO'yUO~Oy)qO|)rO(j)vOg%Xi(i%Xi!V%Xi#X%Xi~Od%Xi#y%Xi~P$GeOy)qO|)rOg%Zi(i%Zi(j%Zi!V%Zi#X%Zi~Od%Zi#y%Zi~P$HWO(b$WO~P#)tO!U3cO't%eO!V'ZX!g'ZX~O!V/QO!g(oa~O!V/QO!a#rO!g(oa~O!V/QO!a#rO(b'bO!g(oa~Od$ui!V$ui#X$ui#y$ui~P!0RO!U3kO't*SO!S']X!V']X~P!0pO!V/YO!S(pa~O!V/YO!S(pa~P#)tO!a#rO#o3sO~Ok3vO!a#rO(b'bO~Od(Pi!V(Pi~P!0RO#X3yOd(Pi!V(Pi~P!0RO!g3|O~O^$iq!V$iq'k$iq'i$iq!S$iq!g$iqo$iq!X$iq%a$iq!a$iq~P!6UO!V4QO!X(qX~P#)tO!f#tO~P3}O^$sX!X$sX%UYX'k$sX!V$sX~P!.xO%U4SO^hXghXyhX|hX!XhX'khX(ihX(jhX!VhX~O%U4SO~O%b4ZO't+VO'vTO'yUO!V'fX!W'fX~O!V0YO!W(wa~OX4_O~O]4`O~O!S4dO~O^%^O'k%^O~P#)tO!X$yO~P#)tO!V4iO#X4kO!W(tX~O!W4lO~Ol!kO|4mO![!uO!]!rO!^!rO!x9mO!|!mO!}!mO#O!mO#P!mO#Q!mO#T4rO#U!vO'u!iO'vTO'yUO(U!jO(a!pO~O!W4qO~P%!VOg4wO!X0uO%a4vO~Og4wO!X0uO%a4vO'}%OO~O't#jO!V'eX!W'eX~O!V1QO!W(ua~O'vTO'yUO(U5QO~O]5UO~O!g5XO~P%QO^5ZO~O^5ZO~P%QO#o5]O&Q5^O~PMOO_1hO!W5bO&`1gO~P`O!a5dO~O!a5fO!V(Zi!W(Zi!a(Zi!h(Zi'}(Zi~O!V#ai!W#ai~P#@_O#X5gO!V#ai!W#ai~O!V!Zi!W!Zi~P#@_O^%^O#X5pO'k%^O~O^%^O!a#rO#X5pO'k%^O~O!V(dq!g(dq^(dq'k(dq~P!6UO!V(ZO!g(cq~O|%vO!X%wO#c5wO't%eO~O!X'QO%a5zO~Og5}O!X'QO%a5zO~O#d%XiP%XiX%Xi^%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi'k%Xi(R%Xi(b%Xi!g%Xi!S%Xi'i%Xio%Xi!X%Xi%a%Xi!a%Xi~P$GeO#d%ZiP%ZiX%Zi^%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi'k%Zi(R%Zi(b%Zi!g%Zi!S%Zi'i%Zio%Zi!X%Zi%a%Zi!a%Zi~P$HWO#d$uiP$uiX$ui^$uik$uiz$ui!V$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui'k$ui(R$ui(b$ui!g$ui!S$ui'i$ui#X$uio$ui!X$ui%a$ui!a$ui~P#)tOd'Oa!V'Oa~P!0RO!V'Pa!g'Pa~P!6UO!V.]O!g(]i~O#y#[i!V#[i!W#[i~P#@_OP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(RVOX#fik#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(b#fi(i#fi(j#fi!V#fi!W#fi~O#g#fi~P%0fO#g9uO~P%0fOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO(RVOX#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(b#fi(i#fi(j#fi!V#fi!W#fi~Ok#fi~P%2qOk9wO~P%2qOP$YOk9wOy#vOz#wO|#xO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO(RVO#q#fi#s#fi#u#fi#v#fi#y#fi(b#fi(i#fi(j#fi!V#fi!W#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P%4|OX:TO!e9yO#l9yO#m9yO#n:SO#o9yO~P%4|OP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO(RVO#s#fi#u#fi#v#fi#y#fi(b#fi(j#fi!V#fi!W#fi~O(i#fi~P%7hO(i#yO~P%7hOP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO#s9|O(RVO(i#yO#u#fi#v#fi#y#fi(b#fi!V#fi!W#fi~O(j#fi~P%9sO(j#zO~P%9sOP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO#s9|O#u:OO(RVO(i#yO(j#zO~O#v#fi#y#fi(b#fi!V#fi!W#fi~P%<OO^#wy!V#wy'k#wy'i#wy!S#wy!g#wyo#wy!X#wy%a#wy!a#wy~P!6UOg;hOy)qO|)rO(i)tO(j)vO~OP#fiX#fik#fiz#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(R#fi(b#fi!V#fi!W#fi~P%>vO!f#tOP(QXX(QXg(QXk(QXy(QXz(QX|(QX!e(QX!h(QX!l(QX#g(QX#h(QX#i(QX#j(QX#k(QX#l(QX#m(QX#n(QX#o(QX#q(QX#s(QX#u(QX#v(QX#y(QX(R(QX(b(QX(i(QX(j(QX!V(QX!W(QX~O#y#zi!V#zi!W#zi~P#@_O#y!ni!W!ni~P$ wO!W6ZO~O!V'Ya!W'Ya~P#@_O!a#rO(b'bO!V'Za!g'Za~O!V/QO!g(oi~O!V/QO!a#rO!g(oi~Od$uq!V$uq#X$uq#y$uq~P!0RO!S']a!V']a~P#)tO!a6bO~O!V/YO!S(pi~P#)tO!V/YO!S(pi~O!S6fO~O!a#rO#o6kO~Ok6lO!a#rO(b'bO~O!S6nO~Od$wq!V$wq#X$wq#y$wq~P!0RO^$iy!V$iy'k$iy'i$iy!S$iy!g$iyo$iy!X$iy%a$iy!a$iy~P!6UO!V4QO!X(qa~O^#[y!V#[y'k#[y'i#[y!S#[y!g#[yo#[y!X#[y%a#[y!a#[y~P!6UOX6sO~O!V0YO!W(wi~O]6yO~O!a5fO~O(U(oO!V'bX!W'bX~O!V4iO!W(ta~OikO't7QO~P._O!W7TO~P%!VOl!kO|7UO'vTO'yUO(U!jO(a!pO~O!X0uO~O!X0uO%a7WO~Og7ZO!X0uO%a7WO~OX7`O!V'ea!W'ea~O!V1QO!W(ui~O!g7dO~O!g7eO~O!g7fO~O!g7fO~P%QO^7hO~O!a7kO~O!g7lO~O!V(gi!W(gi~P#@_O^%^O#X7tO'k%^O~O!V(dy!g(dy^(dy'k(dy~P!6UO!V(ZO!g(cy~O!X'QO%a7wO~O#d$uqP$uqX$uq^$uqk$uqz$uq!V$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq'k$uq(R$uq(b$uq!g$uq!S$uq'i$uq#X$uqo$uq!X$uq%a$uq!a$uq~P#)tO#d$wqP$wqX$wq^$wqk$wqz$wq!V$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq'k$wq(R$wq(b$wq!g$wq!S$wq'i$wq#X$wqo$wq!X$wq%a$wq!a$wq~P#)tO!V'Pi!g'Pi~P!6UO#y#[q!V#[q!W#[q~P#@_Oy/tOz/tO|/uOPvaXvagvakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva#yva(Rva(bva(iva(jva!Vva!Wva~Oy)qO|)rOP$laX$lag$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la#y$la(R$la(b$la(i$la(j$la!V$la!W$la~Oy)qO|)rOP$naX$nag$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na#y$na(R$na(b$na(i$na(j$na!V$na!W$na~OP$|aX$|ak$|az$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a#y$|a(R$|a(b$|a!V$|a!W$|a~P%>vO#y$hq!V$hq!W$hq~P#@_O#y$iq!V$iq!W$iq~P#@_O!W8RO~O#y8SO~P!0RO!a#rO!V'Zi!g'Zi~O!a#rO(b'bO!V'Zi!g'Zi~O!V/QO!g(oq~O!S']i!V']i~P#)tO!V/YO!S(pq~O!S8YO~P#)tO!S8YO~Od(Py!V(Py~P!0RO!V'`a!X'`a~P#)tO^%Tq!X%Tq'k%Tq!V%Tq~P#)tOX8_O~O!V0YO!W(wq~O#X8cO!V'ba!W'ba~O!V4iO!W(ti~P#@_OPYXXYXkYXyYXzYX|YX!SYX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(RYX(bYX(iYX(jYX~O!a%RX#o%RX~P&/vO!X0uO%a8gO~O'vTO'yUO(U8lO~O!V1QO!W(uq~O!g8oO~O!g8oO~P%QO!g8qO~O!g8rO~O#X8tO!V#ay!W#ay~O!V#ay!W#ay~P#@_O!X'QO%a8yO~O#y#wy!V#wy!W#wy~P#@_OP$uiX$uik$uiz$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui#y$ui(R$ui(b$ui!V$ui!W$ui~P%>vOy)qO|)rO(j)vOP%XiX%Xig%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi#y%Xi(R%Xi(b%Xi(i%Xi!V%Xi!W%Xi~Oy)qO|)rOP%ZiX%Zig%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi#y%Zi(R%Zi(b%Zi(i%Zi(j%Zi!V%Zi!W%Zi~O#y$iy!V$iy!W$iy~P#@_O#y#[y!V#[y!W#[y~P#@_O!a#rO!V'Zq!g'Zq~O!V/QO!g(oy~O!S']q!V']q~P#)tO!S9QO~P#)tO!V0YO!W(wy~O!V4iO!W(tq~O!X0uO%a9XO~O!g9[O~O!X'QO%a9aO~OP$uqX$uqk$uqz$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq#y$uq(R$uq(b$uq!V$uq!W$uq~P%>vOP$wqX$wqk$wqz$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq#y$wq(R$wq(b$wq!V$wq!W$wq~P%>vOd%]!Z!V%]!Z#X%]!Z#y%]!Z~P!0RO!V'bq!W'bq~P#@_O!V#a!Z!W#a!Z~P#@_O#d%]!ZP%]!ZX%]!Z^%]!Zk%]!Zz%]!Z!V%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z'k%]!Z(R%]!Z(b%]!Z!g%]!Z!S%]!Z'i%]!Z#X%]!Zo%]!Z!X%]!Z%a%]!Z!a%]!Z~P#)tOP%]!ZX%]!Zk%]!Zz%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z#y%]!Z(R%]!Z(b%]!Z!V%]!Z!W%]!Z~P%>vOo(VX~P1gO'u!iO~P!)jO!ScX!VcX#XcX~P&/vOPYXXYXkYXyYXzYX|YX!VYX!VcX!eYX!fYX!hYX!lYX#XYX#XcX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(RYX(bYX(iYX(jYX~O!acX!gYX!gcX(bcX~P&E^OP9lOQ9lOa;]Ob!fOikOk9lOlkOmkOskOu9lOw9lO|WO!QkO!RkO!XXO!c9oO!hZO!k9lO!l9lO!m9lO!o9pO!q9qO!t!eO$Q!hO$UfO't)PO'vTO'yUO(RVO(a[O(n;ZO~O!V:QO!W$ka~Oi%POk$qOl$pOm$pOs%QOu%ROw:WO|$xO!X$yO!c;bO!h$uO#c:^O$Q%VO$m:YO$o:[O$r%WO't(gO'vTO'yUO'}%OO(R$rO~O#p)WO~P&JSO!WYX!WcX~P&E^O#d9tO~O!a#rO#d9tO~O#X:UO~O#o9yO~O#X:`O!V(gX!W(gX~O#X:UO!V(eX!W(eX~O#d:aO~Od:cO~P!0RO#d:hO~O#d:iO~O!a#rO#d:jO~O!a#rO#d:aO~O#y:kO~P#@_O#d:lO~O#d:mO~O#d:nO~O#d:oO~O#d:pO~O#d:qO~O#y:rO~P!0RO#y:sO~P!0RO$U~!f!|!}#P#Q#T#b#c#n(n$m$o$r%U%`%a%b%h%j%m%n%p%r~'oR$U(n#h!R'm'u#il#g#jky'n(U'n't$W$Y$W~",
  goto: "$%Z({PPPP(|P)PP)aP*p.rPPPP5SPP5iP;d>iP>|P>|PPP>|P@lP>|P>|P>|P@pPP@uPA`PFUPPPFYPPPPFYIXPPPI_JYPFYPLgPPPPNuFYPPPFYPFYP!#TFYP!&g!'i!'rP!(e!(i!(ePPPPP!+r!'iPP!,`!-YP!/|FYFY!0R!3Z!7n!7n!;cPPP!;jFYPPPPPPPPPPP!>uP!@WPPFY!AePFYPFYFYFYFYPFY!BwPP!E}P!IPP!IT!I_!Ic!IcP!EzP!Ig!IgP!LiP!LmFYFY!Ls# t>|P>|P>|>|P##O>|>|#$x>|#'V>|#(y>|>|#)g#+c#+c#+g#+o#+c#+wP#+cP>|#,a>|#-i>|>|5SPPP#.tPP#/^#/^P#/^P#/s#/^PP#/yP#/pP#/p#0]#/p#0w#0}5P)P#1Q)PP#1X#1X#1XP)PP)PP)PP)PPP)PP#1_#1bP#1b)PP#1fP#1iP)PP)PP)PP)PP)PP)P)PPP#1o#1u#2P#2V#2]#2c#2i#2w#2}#3T#3_#3e#3o#4O#4U#4u#5X#5_#5e#5s#6Y#7j#7x#8O#8U#8[#8b#8l#8r#8x#9S#9f#9lPPPPPPPPPP#9rPPPPPPP#:f#=mP#>|#?T#?]PPPP#Cg#F]#Lr#Lu#Lx#Mq#Mt#Mw#NO#NWPP#N^#Nb$ Z$!Z$!_$!sPP$!w$!}$#RP$#U$#Y$#]$$R$$i$$n$$q$$t$$z$$}$%R$%VR!xRmpOXr!X#`%]&d&f&g&i,],b1b1eY!rQ'Q,}0u4pQ%ctQ%kwQ%rzQ&[!TS&x!c,uQ'W!fS'^!o!uS*Y$y*_Q+T%lQ+b%tQ+|&UQ,{'PQ-V'XQ-_'_Q/k*aQ1P+}R:_9p$zdOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s+g,X,],b-R-Z-i-o.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2r4m4w5Z5]5^5p7U7Z7h7tS#m]9m!r)R$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q*j%SQ+Y%nQ,O&XQ,V&aQ.S:VQ0O*{Q0S*}Q0_+ZQ1X,TQ2f.PQ4Y0YQ5O1QQ5|2jQ6S:WQ6u4ZR7z5}&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^t!kQ!o!r!u!v&x'P'Q'^'_'`,u,{,}-_0u4p4r$Y$pi#r#t$`$a$u$x%T%U%Y)l)u)w)x*P*V*e*f*z*}+l+o.O.Y/X/Y/[/w0l0o0w2i3a3k3s3y4Q4S4v5z6b6k7W7w8S8g8y9X9a:S:T:X:Y:Z:[:]:^:d:e:f:g:h:i:l:m:n:o:r:s;Z;c;d;g;hQ%uzQ&v!cS&|%w,xQ+Y%nS.x)r.zQ/v*nQ0_+ZQ0d+aQ1W,SQ1X,TQ4Y0YQ4c0fQ5R1SQ5S1VQ6u4ZQ6x4`Q7c5UQ8b6yR8m7`pmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eR,Q&]&r^OPXYrstux!X!^!g!l#O#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u'S'd'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;];^[#XWZ#S#V&y'tQ%fvQ%jwS%oz%t!U%x|}#d#e#h%Z%v'}(X(Y(Z+e+f+h,Z,o-m-s-t-u-w1j2b2c5f5wQ&Q!RQ'T!eQ'V!fQ(b#oS)|$u*QS+S%k%lQ+W%nQ+w&SQ+{&US-U'W'XQ.R(cQ/U)}Q0W+TQ0^+ZQ0`+[Q0c+`Q0z+xS1O+|+}Q2S-VQ3b/QQ4X0YQ4]0]Q4b0eQ4}1PQ6_3cQ6t4ZQ6w4_Q8^6sR9S8_v$wi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;d!S%hw!f!q%j%k%l&w'V'W'X']'g*X+S+T,r-U-V-^/c0W1{2S2Z3uQ*|%fQ+m%}Q+p&OQ+z&UQ.Q(bQ0y+wU0}+{+|+}Q2k.RQ4x0zS4|1O1PQ7_4}!z;_#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hg;`:S:T:Y:[:^:e:g:i:m:o:sW$|i%O*g;ZS%}!O&ZQ&O!PQ&P!QR+k%{$Z${i#r#t$`$a$u$x%T%U%Y)l)u)w)x*P*V*e*f*z*}+l+o.O.Y/X/Y/[/w0l0o0w2i3a3k3s3y4Q4S4v5z6b6k7W7w8S8g8y9X9a:S:T:X:Y:Z:[:]:^:d:e:f:g:h:i:l:m:n:o:r:s;Z;c;d;g;hT)m$r)nV*k%S:V:WU&|!c%w,xS(p#v#wQ+_%qS-z(^(_Q0p+qQ3z/tR6}4i&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^$i$]c#U#a%a%b%d's'y(e(l(t(u(v(w(x(y(z({(|(})O)Q)T)X)c*x+^,s-b-g-l-n.X._.c.e.f.g.v/x1q1t2U2]2q2v2w2x2y2z2{2|2}3O3P3Q3R3S3V3W3]4O4V5i5o5t6Q6R6W6X7P7n7r7{8P8Q8v9U9]9n;QT#PV#Q&ykOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q&z!cR1w,uv!kQ!c!o!r!u!v&x'P'Q'^'_'`,u,{,}-_0u4p4rS*X$y*_S/c*Y*aQ/l*bQ0r+sQ3u/kR3x/nlpOXr!X#`%]&d&f&g&i,],b1b1eQ&k![Q'h!tS(d#q9tQ+Q%iQ+u&QQ+v&RQ-S'UQ-a'aS.W(i:aS/y*s:jQ0U+RQ0t+tQ1i,dQ1k,eQ1s,pQ2Q-TQ2T-XS4P/z:pQ4T0VS4W0X:qQ5h1uQ5l2RQ5q2YQ6r4UQ7o5jQ7p5mQ7s5rR8s7l$d$[c#U#a%b%d's'y(e(l(t(u(v(w(x(y(z({(|(})O)Q)T)X)c*x+^,s-b-g-l-n.X._.c.f.g.v/x1q1t2U2]2q2v2w2x2y2z2{2|2}3O3P3Q3R3S3V3W3]4O4V5i5o5t6Q6R6W6X7P7n7r7{8P8Q8v9U9]9n;QS(a#l'ZU*d$z(h3US*w%a.eQ2g0OQ5y2fQ7y5|R8z7z$d$Zc#U#a%b%d's'y(e(l(t(u(v(w(x(y(z({(|(})O)Q)T)X)c*x+^,s-b-g-l-n.X._.c.f.g.v/x1q1t2U2]2q2v2w2x2y2z2{2|2}3O3P3Q3R3S3V3W3]4O4V5i5o5t6Q6R6W6X7P7n7r7{8P8Q8v9U9]9n;QS(`#l'ZS(r#w$[S*v%a.eS-{(_(aQ.h)SQ/{*wR2d-|&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^S#m]9mQ&f!VQ&g!WQ&i!YQ&j!ZR1a,`Q'R!eQ*y%fQ-Q'TS-}(b*|Q2O-PW2h.Q.R/}0PQ5k2PU5x2e2g2kS7v5y5{S8x7x7yS9_8w8zQ9g9`R9j9hU!sQ'Q,}T4n0u4p!O_OXZ`r!T!X#`#d%Z%]&Z&]&d&f&g&i(Z,],b-t1b1e]!mQ!o'Q,}0u4pT#m]9m%UyOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tS(p#v#wS-z(^(_!s:w$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Y!qQ'Q,}0u4pQ']!oS'g!r!uS'i!v4rS-^'^'_Q-`'`R2Z-_Q'f!qS(V#c1_S-]']'iQ/T)|Q/a*XQ2[-`Q3g/US3p/b/lQ6^3bS6i3v3xQ8U6_R8]6lQ#sbQ'e!qS(U#c1_S(W#i*rQ*t%[Q+O%gQ+U%mU-[']'f'iQ-p(VQ/S)|Q/`*XQ/f*[Q0T+PQ0{+yS2X-]-`Q2a-xS3f/T/US3o/a/lQ3r/eQ3t/gQ4z0|Q5s2[Q6]3bQ6a3gS6e3p3xQ6j3wQ7]4{S8T6^6_Q8X6fQ8Z6iQ8j7^Q9O8UQ9P8YQ9R8]Q9Z8kQ9c9QQ:z:uQ;V;OR;W;PV!sQ'Q,}%UaOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tS#sx!g!r:t$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^R:z;]%UbOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tQ%[j!S%gw!f!q%j%k%l&w'V'W'X']'g*X+S+T,r-U-V-^/c0W1{2S2Z3uS%mx!gQ+P%hQ+y&UW0|+z+{+|+}U4{0}1O1PS7^4|4}Q8k7_!r:u$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q;O;[R;P;]$xeOPXYrstu!X!^!l#O#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'd'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tY#^WZ#S#V't!U%x|}#d#e#h%Z%v'}(X(Y(Z+e+f+h,Z,o-m-s-t-u-w1j2b2c5f5wQ,W&a!p:v$X$j)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^R:y&yS&}!c%wR1y,x$zdOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s+g,X,],b-R-Z-i-o.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2r4m4w5Z5]5^5p7U7Z7h7t!r)R$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q,V&aQ0O*{Q2f.PQ5|2jR7z5}!f$Rc#U%a's'y(e(l({(|(})O)T)X+^-b-g-l-n.X._.v/x2U2]2q3S4O4V5o5t6Q7r8v9n!T9{)Q)c,s.e1q1t2v3O3P3Q3R3V3]5i6R6W6X7P7n7{8P8Q9U9];Q!b$Tc#U%a's'y(e(l(})O)T)X+^-b-g-l-n.X._.v/x2U2]2q3S4O4V5o5t6Q7r8v9n!P9})Q)c,s.e1q1t2v3Q3R3V3]5i6R6W6X7P7n7{8P8Q9U9];Q!^$Xc#U%a's'y(e(l)T)X+^-b-g-l-n.X._.v/x2U2]2q3S4O4V5o5t6Q7r8v9nQ3a/Oz;^)Q)c,s.e1q1t2v3V3]5i6R6W6X7P7n7{8P8Q9U9];QQ;c;eR;d;f&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^S$kh$lR3Y.k'PgOPWXYZhrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.k.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^T$gf$mQ$efS)[$h)`R)h$mT$ff$mT)^$h)`'PhOPWXYZhrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.k.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^T$kh$lQ$nhR)g$l%UjOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7t!s;[$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^#alOPXZr!X!^!l#O#`#k#x$j%]&]&`&a&d&f&g&i&m&u'S(q)e*{+g,X,],b-R.P.l/u0x1Y1Z1[1^1b1e1g2j3X4m4w5Z5]5^5}7U7Z7hv$zi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;d!z(h#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hQ*o%WQ.w)qg3U:S:T:Y:[:^:e:g:i:m:o:sv$vi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;dQ*R$wS*[$y*_Q*p%XQ/g*]!z:|#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hf:}:S:T:Y:[:^:e:g:i:m:o:sQ;R;_Q;S;`Q;T;aR;U;bv$zi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;d!z(h#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hg3U:S:T:Y:[:^:e:g:i:m:o:slnOXr!X#`%]&d&f&g&i,],b1b1eQ*U$xQ,k&pQ,l&rR3j/Y$Y${i#r#t$`$a$u$x%T%U%Y)l)u)w)x*P*V*e*f*z*}+l+o.O.Y/X/Y/[/w0l0o0w2i3a3k3s3y4Q4S4v5z6b6k7W7w8S8g8y9X9a:S:T:X:Y:Z:[:]:^:d:e:f:g:h:i:l:m:n:o:r:s;Z;c;d;g;hQ+n&OQ0n+pQ4g0mR6|4hT*^$y*_S*^$y*_T4o0u4pS/e*Z4mT3w/m7UQ+O%gQ/f*[Q0T+PQ0{+yQ4z0|Q7]4{Q8j7^R9Z8kn)u$s(j*q/W/o/p2o3h3}6[6m8}:{;X;Y!W:d(f)V){*T.V.s/O/]/|0k0m2n3i3m4f4h6O6P6c6g6o6q8W8[9b;e;f]:e3T6V7|8{8|9kp)w$s(j*q.|/W/o/p2o3h3}6[6m8}:{;X;Y!Y:f(f)V){*T.V.s/O/]/|0k0m2l2n3i3m4f4h6O6P6c6g6o6q8W8[9b;e;f_:g3T6V7|7}8{8|9kpmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eQ&W!SR,X&apmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eR&W!SQ+r&PR0j+kqmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eQ0v+wS4u0y0zU7V4s4t4xS8f7X7YS9V8e8hQ9d9WR9i9eQ&_!TR,R&ZR5R1SS%oz%tR0`+[Q&d!UR,]&eR,c&jT1c,b1eR,g&kQ,f&kR1l,gQ'k!wR-c'kQrOQ#`XT%`r#`Q!zTR'm!zQ!}UR'o!}Q)n$rR.t)nQ#QVR'q#QQ#TWU'w#T'x-jQ'x#UR-j'yQ,v&zR1x,vQ.Z(jR2p.ZQ.^(lS2s.^2tR2t._Q,}'QR1|,}Y!oQ'Q,}0u4pR'[!oS#ZW%vU(O#Z(P-kQ(P#[R-k'zQ,y&}R1z,yr`OXr!T!X#`%]&Z&]&d&f&g&i,],b1b1eS#dZ%ZU#n`#d-tR-t(ZQ([#fQ-q(WW-y([-q2_5uQ2_-rR5u2`Q)`$hR.m)`Q$lhR)f$lQ$_cU)U$_-f:RQ-f9nR:R)cQ/R)|W3d/R3e6`8VU3e/S/T/US6`3f3gR8V6a#m)s$s(f(j)V){*T*l*m*q.T.U.V.s.|.}/O/W/]/o/p/|0k0m2l2m2n2o3T3h3i3m3}4f4h6O6P6T6U6V6[6c6g6m6o6q7|7}8O8W8[8{8|8}9b9k:{;X;Y;e;fQ/Z*TU3l/Z3n6dQ3n/]R6d3mQ*_$yR/i*_Q*h$}R/r*hQ4R/|R6p4RQ+i%yR0i+iQ4j0pS7O4j8dR8d7PQ+t&QR0s+tQ4p0uR7S4pQ1R,OS5P1R7aR7a5RQ0Z+WW4[0Z4^6v8`Q4^0^Q6v4]R8`6wQ+]%oR0a+]Q1e,bR5a1eWqOXr#`Q&h!XQ*u%]Q,[&dQ,^&fQ,_&gQ,a&iQ1`,]S1c,b1eR5`1bQ%_oQ&l!]Q&o!_Q&q!`Q&s!aQ'c!qQ+Q%iQ+d%uQ+j%zQ,Q&_Q,i&nW-Y']'e'f'iQ-a'aQ/h*^Q0U+RS1U,R,UQ1m,hQ1n,kQ1o,lQ2T-XW2V-[-]-`-bQ4T0VQ4a0dQ4e0kQ4y0{Q5T1WQ5_1aU5n2U2X2[Q5q2YQ6r4UQ6z4cQ6{4fQ7R4oQ7[4zQ7b5SS7q5o5sQ7s5rQ8a6xQ8i7]Q8n7cQ8u7rQ9T8bQ9Y8jQ9^8vR9f9ZQ%iwQ'U!fQ'a!qU+R%j%k%lQ,p&wU-T'V'W'XS-X']'gQ/_*XS0V+S+TQ1u,rS2R-U-VQ2Y-^Q3q/cQ4U0WQ5j1{Q5m2SQ5r2ZR6h3uS$ti;ZR*i%OU$}i%O;ZR/q*gQ$siS(f#r*}Q(j#tS)V$`$aQ){$uQ*T$xQ*l%TQ*m%UQ*q%YQ.T:XQ.U:ZQ.V:]Q.s)lQ.|)uQ.})wQ/O)xQ/W*PQ/]*VQ/o*eQ/p*fh/|*z.O0w2i4v5z7W7w8g8y9X9aQ0k+lQ0m+oQ2l:dQ2m:fQ2n:hQ2o.YS3T:S:TQ3h/XQ3i/YQ3m/[Q3}/wQ4f0lQ4h0oQ6O:lQ6P:nQ6T:YQ6U:[Q6V:^Q6[3aQ6c3kQ6g3sQ6m3yQ6o4QQ6q4SQ7|:iQ7}:eQ8O:gQ8W6bQ8[6kQ8{:mQ8|:oQ8}8SQ9b:rQ9k:sQ:{;ZQ;X;cQ;Y;dQ;e;gR;f;hloOXr!X#`%]&d&f&g&i,],b1b1eQ!dPS#bZ#kQ&n!^U'Y!l4m7UQ'p#OQ(s#xQ)d$jS,U&]&`Q,Y&aQ,h&mQ,m&uQ-P'SQ.a(qQ.q)eQ0P*{Q0g+gQ1],XQ2P-RQ2g.PQ3[.lQ3{/uQ4t0xQ5V1YQ5W1ZQ5Y1[Q5[1^Q5c1gQ5y2jQ6Y3XQ7Y4wQ7g5ZQ7i5]Q7j5^Q7y5}Q8h7ZR8p7h#UcOPXZr!X!^!l#`#k#x%]&]&`&a&d&f&g&i&m&u'S(q*{+g,X,],b-R.P/u0x1Y1Z1[1^1b1e1g2j4m4w5Z5]5^5}7U7Z7hQ#UWQ#aYQ%asQ%btQ%duS's#S'vQ'y#VQ(e#qQ(l#uQ(t#{Q(u#|Q(v#}Q(w$OQ(x$PQ(y$QQ(z$RQ({$SQ(|$TQ(}$UQ)O$VQ)Q$XQ)T$^Q)X$bW)c$j)e.l3XQ*x%cQ+^%pS,s&y1vQ-b'dS-g't-iQ-l'|Q-n(TQ.X(iQ._(mQ.c9lQ.e9oQ.f9pQ.g9qQ.v)pQ/x*sQ1q,nQ1t,qQ2U-ZQ2]-oQ2q.]Q2v9tQ2w9uQ2x9vQ2y9wQ2z9xQ2{9yQ2|9zQ2}9{Q3O9|Q3P9}Q3Q:OQ3R:PQ3S.dQ3V:UQ3W:_Q3]:QQ4O/zQ4V0XQ5i:`Q5o2WQ5t2^Q6Q2rQ6R:aQ6W:cQ6X:jQ7P4kQ7n5gQ7r5pQ7{:kQ8P:pQ8Q:qQ8v7tQ9U8cQ9]8tQ9n#OR;Q;^R#WWR&{!cY!qQ'Q,}0u4pS&w!c,uQ']!oS'g!r!uS'i!v4rS,r&x'PS-^'^'_Q-`'`Q1{,{R2Z-_R(k#tR(n#uQ!dQT,|'Q,}]!nQ!o'Q,}0u4pQ#l]R'Z9mT#gZ%ZS#fZ%ZU%y|},ZU(W#d#e#hS-r(X(YQ-v(ZQ0h+hQ2`-sU2a-t-u-wS5v2b2cR7u5w`#YW#S#V%v't'}+e-mt#cZ|}#d#e#h%Z(X(Y(Z+h-s-t-u-w2b2c5wQ1_,ZQ1r,oQ5e1jQ7m5fT:x&y+fT#]W%vS#[W%vS'u#S'}S'z#V+eS,t&y+fT-h't-mT'O!c%wQ$hfR)j$mT)_$h)`R3Z.kT*O$u*QR*W$xQ/}*zQ2e.OQ4s0wQ5{2iQ7X4vQ7x5zQ8e7WQ8w7wQ9W8gQ9`8yQ9e9XR9h9alpOXr!X#`%]&d&f&g&i,],b1b1eQ&^!TR,Q&ZV%z|},ZR0q+qR,P&XQ%szR+c%tR+X%nT&b!U&eT&c!U&eT1d,b1e",
  nodeNames: "⚠ ArithOp ArithOp LineComment BlockComment Script ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 364,
  context: a$,
  nodeProps: [
    ["group", -26, 6, 14, 16, 62, 199, 203, 206, 207, 209, 212, 215, 225, 227, 233, 235, 237, 239, 242, 248, 254, 256, 258, 260, 262, 264, 265, "Statement", -32, 10, 11, 25, 28, 29, 35, 45, 48, 49, 51, 56, 64, 72, 76, 78, 80, 81, 103, 104, 113, 114, 131, 134, 136, 137, 138, 139, 141, 142, 162, 163, 165, "Expression", -23, 24, 26, 30, 34, 36, 38, 166, 168, 170, 171, 173, 174, 175, 177, 178, 179, 181, 182, 183, 193, 195, 197, 198, "Type", -3, 84, 96, 102, "ClassItem"],
    ["openedBy", 31, "InterpolationStart", 50, "[", 54, "{", 69, "(", 143, "JSXStartTag", 155, "JSXStartTag JSXStartCloseTag"],
    ["closedBy", 33, "InterpolationEnd", 44, "]", 55, "}", 70, ")", 144, "JSXSelfCloseEndTag JSXEndTag", 160, "JSXEndTag"]
  ],
  propSources: [c$],
  skippedNodes: [0, 3, 4, 268],
  repeatNodeCount: 33,
  tokenData: "$>y(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tu>PuvBavwDxwxGgxyMvyz! Qz{!![{|!%O|}!&]}!O!%O!O!P!'g!P!Q!1w!Q!R#0t!R![#3T![!]#@T!]!^#Aa!^!_#Bk!_!`#GS!`!a#In!a!b#N{!b!c$$z!c!}>P!}#O$&U#O#P$'`#P#Q$,w#Q#R$.R#R#S>P#S#T$/`#T#o$0j#o#p$4z#p#q$5p#q#r$7Q#r#s$8^#s$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$I|>P$I|$I}$<s$I}$JO$<s$JO$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(n%d_$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$d&j'z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU'z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$d&j'wpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'wpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$d&j'wp'z!b'm(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST'x#S$d&j'n(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$d&j'wp'z!b'n(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$d&j!l$Ip'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#q$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#q$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'v$(n$d&j'z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$d&j'z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$d&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$_#t$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$_#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$_#t$d&j'z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ'z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$_#t'z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hg$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|<[i$d&j(a!L^'wp'z!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!Q%Z!Q![<P![!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|=|P;=`<%l<P(CS>`k$d&j'wp'z!b(U!LY't&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P+d@`k$d&j'wp'z!b$W#tOY%ZYZ&cZr%Zrs&}st%Ztu@Tuw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![@T![!^%Z!^!_*g!_!c%Z!c!}@T!}#O%Z#O#P&c#P#R%Z#R#S@T#S#T%Z#T#o@T#o#p*g#p$g%Z$g;'S@T;'S;=`BT<%lO@T+dBWP;=`<%l@T(CSB^P;=`<%l>P%#SBl`$d&j'wp'z!b#i$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SCy_$d&j#{$Id'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%DfETa(j%<v$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sv%ZvwFYwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SFe`$d&j#u$Id'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2bGp_'y$)`$d&j'wpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo*QHv_$d&j'wpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo)`IzX$d&jOwIuwx6cx!^Iu!^!_Jg!_#oIu#o#pJg#p;'SIu;'S;=`KP<%lOIu#tJjTOwJgwx7]x;'SJg;'S;=`Jy<%lOJg#tJ|P;=`<%lJg)`KSP;=`<%lIu*QK`]$_#t$d&j'wpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$fL^Z'wpOYLXYZJgZrLXrsJgswLXwxMPx#OLX#O#PJg#P;'SLX;'S;=`Mj<%lOLX$fMWU$_#t'wpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$fMmP;=`<%lLX*QMsP;=`<%lHo(*QNR_!h(!b$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l! ]_!gM|$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!!ib$d&j'wp'z!b'u#)d#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!#q{!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!#|`$d&j'wp'z!b#g$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!%Z`$d&j'wp'z!bk&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!&h_!V&;l$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!'rc$d&j'wp'z!by'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!(}!P!Q%Z!Q![!+g![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!)Wa$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!*]!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!*h_!UMt$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!+rg$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!+g![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S!+g#S#X%Z#X#Y!-Z#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!-dg$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!.{|}%Z}!O!.{!O!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!/Uc$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!0lc$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!2Sf$d&j'wp'z!b#h$IdOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}xz!3hz{#$s{!P!3h!P!Q#&Y!Q!^!3h!^!_!Mh!_!`#-x!`!a#/_!a!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(r!3sb$d&j'wp'z!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(Q!5U`$d&j'z!b!RSOY!4{YZ&cZw!4{wx!6Wx!P!4{!P!Q!=o!Q!^!4{!^!_!?g!_!}!4{!}#O!Bn#O#P!<w#P#o!4{#o#p!?g#p;'S!4{;'S;=`!Cw<%lO!4{&n!6_^$d&j!RSOY!6WYZ&cZ!P!6W!P!Q!7Z!Q!^!6W!^!_!8g!_!}!6W!}#O!;U#O#P!<w#P#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!7ba$d&j!RSO!^&c!_#Z&c#Z#[!7Z#[#]&c#]#^!7Z#^#a&c#a#b!7Z#b#g&c#g#h!7Z#h#i&c#i#j!7Z#j#m&c#m#n!7Z#n#o&c#p;'S&c;'S;=`&w<%lO&cS!8lX!RSOY!8gZ!P!8g!P!Q!9X!Q!}!8g!}#O!9p#O#P!:o#P;'S!8g;'S;=`!;O<%lO!8gS!9^U!RS#Z#[!9X#]#^!9X#a#b!9X#g#h!9X#i#j!9X#m#n!9XS!9sVOY!9pZ#O!9p#O#P!:Y#P#Q!8g#Q;'S!9p;'S;=`!:i<%lO!9pS!:]SOY!9pZ;'S!9p;'S;=`!:i<%lO!9pS!:lP;=`<%l!9pS!:rSOY!8gZ;'S!8g;'S;=`!;O<%lO!8gS!;RP;=`<%l!8g&n!;Z[$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#O!;U#O#P!<P#P#Q!6W#Q#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<UX$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<tP;=`<%l!;U&n!<|X$d&jOY!6WYZ&cZ!^!6W!^!_!8g!_#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!=lP;=`<%l!6W(Q!=xi$d&j'z!b!RSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!=o#[#]&}#]#^!=o#^#a&}#a#b!=o#b#g&}#g#h!=o#h#i&}#i#j!=o#j#m&}#m#n!=o#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!?nZ'z!b!RSOY!?gZw!?gwx!8gx!P!?g!P!Q!@a!Q!}!?g!}#O!Ap#O#P!:o#P;'S!?g;'S;=`!Bh<%lO!?g!f!@hb'z!b!RSOY'}Zw'}x#O'}#P#Z'}#Z#[!@a#[#]'}#]#^!@a#^#a'}#a#b!@a#b#g'}#g#h!@a#h#i'}#i#j!@a#j#m'}#m#n!@a#n;'S'};'S;=`(f<%lO'}!f!AuX'z!bOY!ApZw!Apwx!9px#O!Ap#O#P!:Y#P#Q!?g#Q;'S!Ap;'S;=`!Bb<%lO!Ap!f!BeP;=`<%l!Ap!f!BkP;=`<%l!?g(Q!Bu^$d&j'z!bOY!BnYZ&cZw!Bnwx!;Ux!^!Bn!^!_!Ap!_#O!Bn#O#P!<P#P#Q!4{#Q#o!Bn#o#p!Ap#p;'S!Bn;'S;=`!Cq<%lO!Bn(Q!CtP;=`<%l!Bn(Q!CzP;=`<%l!4{'`!DW`$d&j'wp!RSOY!C}YZ&cZr!C}rs!6Ws!P!C}!P!Q!EY!Q!^!C}!^!_!GQ!_!}!C}!}#O!JX#O#P!<w#P#o!C}#o#p!GQ#p;'S!C};'S;=`!Kb<%lO!C}'`!Eci$d&j'wp!RSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!EY#[#](r#]#^!EY#^#a(r#a#b!EY#b#g(r#g#h!EY#h#i(r#i#j!EY#j#m(r#m#n!EY#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!GXZ'wp!RSOY!GQZr!GQrs!8gs!P!GQ!P!Q!Gz!Q!}!GQ!}#O!IZ#O#P!:o#P;'S!GQ;'S;=`!JR<%lO!GQt!HRb'wp!RSOY)rZr)rs#O)r#P#Z)r#Z#[!Gz#[#])r#]#^!Gz#^#a)r#a#b!Gz#b#g)r#g#h!Gz#h#i)r#i#j!Gz#j#m)r#m#n!Gz#n;'S)r;'S;=`*Z<%lO)rt!I`X'wpOY!IZZr!IZrs!9ps#O!IZ#O#P!:Y#P#Q!GQ#Q;'S!IZ;'S;=`!I{<%lO!IZt!JOP;=`<%l!IZt!JUP;=`<%l!GQ'`!J`^$d&j'wpOY!JXYZ&cZr!JXrs!;Us!^!JX!^!_!IZ!_#O!JX#O#P!<P#P#Q!C}#Q#o!JX#o#p!IZ#p;'S!JX;'S;=`!K[<%lO!JX'`!K_P;=`<%l!JX'`!KeP;=`<%l!C}(r!Ksk$d&j'wp'z!b!RSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[!Kh#[#]%Z#]#^!Kh#^#a%Z#a#b!Kh#b#g%Z#g#h!Kh#h#i%Z#i#j!Kh#j#m%Z#m#n!Kh#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W!Mq]'wp'z!b!RSOY!MhZr!Mhrs!?gsw!Mhwx!GQx!P!Mh!P!Q!Nj!Q!}!Mh!}#O#!U#O#P!:o#P;'S!Mh;'S;=`##U<%lO!Mh#W!Nse'wp'z!b!RSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[!Nj#[#]*g#]#^!Nj#^#a*g#a#b!Nj#b#g*g#g#h!Nj#h#i*g#i#j!Nj#j#m*g#m#n!Nj#n;'S*g;'S;=`+Z<%lO*g#W#!]Z'wp'z!bOY#!UZr#!Urs!Apsw#!Uwx!IZx#O#!U#O#P!:Y#P#Q!Mh#Q;'S#!U;'S;=`##O<%lO#!U#W##RP;=`<%l#!U#W##XP;=`<%l!Mh(r##e`$d&j'wp'z!bOY##[YZ&cZr##[rs!Bnsw##[wx!JXx!^##[!^!_#!U!_#O##[#O#P!<P#P#Q!3h#Q#o##[#o#p#!U#p;'S##[;'S;=`#$g<%lO##[(r#$jP;=`<%l##[(r#$pP;=`<%l!3h(CS#%Qb$d&j'wp'z!b'o(;d!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(CS#&e_$d&j'wp'z!bR(;dOY#&YYZ&cZr#&Yrs#'dsw#&Ywx#*tx!^#&Y!^!_#,s!_#O#&Y#O#P#(f#P#o#&Y#o#p#,s#p;'S#&Y;'S;=`#-r<%lO#&Y(Bb#'m]$d&j'z!bR(;dOY#'dYZ&cZw#'dwx#(fx!^#'d!^!_#)w!_#O#'d#O#P#(f#P#o#'d#o#p#)w#p;'S#'d;'S;=`#*n<%lO#'d(AO#(mX$d&jR(;dOY#(fYZ&cZ!^#(f!^!_#)Y!_#o#(f#o#p#)Y#p;'S#(f;'S;=`#)q<%lO#(f(;d#)_SR(;dOY#)YZ;'S#)Y;'S;=`#)k<%lO#)Y(;d#)nP;=`<%l#)Y(AO#)tP;=`<%l#(f(<v#*OW'z!bR(;dOY#)wZw#)wwx#)Yx#O#)w#O#P#)Y#P;'S#)w;'S;=`#*h<%lO#)w(<v#*kP;=`<%l#)w(Bb#*qP;=`<%l#'d(Ap#*}]$d&j'wpR(;dOY#*tYZ&cZr#*trs#(fs!^#*t!^!_#+v!_#O#*t#O#P#(f#P#o#*t#o#p#+v#p;'S#*t;'S;=`#,m<%lO#*t(<U#+}W'wpR(;dOY#+vZr#+vrs#)Ys#O#+v#O#P#)Y#P;'S#+v;'S;=`#,g<%lO#+v(<U#,jP;=`<%l#+v(Ap#,pP;=`<%l#*t(=h#,|Y'wp'z!bR(;dOY#,sZr#,srs#)wsw#,swx#+vx#O#,s#O#P#)Y#P;'S#,s;'S;=`#-l<%lO#,s(=h#-oP;=`<%l#,s(CS#-uP;=`<%l#&Y%#W#.Vb$d&j#{$Id'wp'z!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h+h#/lb$T#t$d&j'wp'z!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h$/l#1Pp$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#U%Z#U#V#6_#V#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#d#9g#d#l%Z#l#m#<i#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#3`k$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#5`_$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#6hd$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#8Rf$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#9pc$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;We$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#<rg$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>fi$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#@b_!a$b$d&j#y%<f'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Al_^l$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Bz^'}!*v!e'.r'wp'z!b$U)d(nSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Cv!Q!^*g!^!_#Dl!_!`#F^!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#DPX$f&j'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#DuZ#k$Id'wp'z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Eh!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#EqX#{$Id'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#FgX#l$Id'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh#G_a#X%?x$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a#Hd!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W#Ho_#d$Ih$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#I}adBf#l$Id$a#|$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`#KS!`!a#L^!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#K__#l$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#Lia#k$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`!a#Mn!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#My`#k$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$ Wc(b$Ip$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$!c!P!^%Z!^!_*g!_!a%Z!a!b$#m!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$!n_z'#p$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$#x`$d&j#v$Id'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$%V_!x!Ln$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$&a_|(8n$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$'eZ$d&jO!^$(W!^!_$(n!_#i$(W#i#j$(s#j#l$(W#l#m$*f#m#o$(W#o#p$(n#p;'S$(W;'S;=`$,q<%lO$(W(n$(_T[#S$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$(sO[#S(n$(x[$d&jO!Q&c!Q![$)n![!^&c!_!c&c!c!i$)n!i#T&c#T#Z$)n#Z#o&c#o#p$,U#p;'S&c;'S;=`&w<%lO&c(n$)sZ$d&jO!Q&c!Q![$*f![!^&c!_!c&c!c!i$*f!i#T&c#T#Z$*f#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$*kZ$d&jO!Q&c!Q![$+^![!^&c!_!c&c!c!i$+^!i#T&c#T#Z$+^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$+cZ$d&jO!Q&c!Q![$(W![!^&c!_!c&c!c!i$(W!i#T&c#T#Z$(W#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$,XR!Q![$,b!c!i$,b#T#Z$,b#S$,eS!Q![$,b!c!i$,b#T#Z$,b#q#r$(n(n$,tP;=`<%l$(W!'l$-S_!SM|$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$.^`#s$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$/k_$d&j'wp'z!b(R&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$0yk$d&j'wp'z!b(U!LY't&;d$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$0juw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$0j![!^%Z!^!_*g!_!c%Z!c!}$0j!}#O%Z#O#P&c#P#R%Z#R#S$0j#S#T%Z#T#o$0j#o#p*g#p$g%Z$g;'S$0j;'S;=`$4t<%lO$0j+d$2yk$d&j'wp'z!b$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$2nuw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$2n![!^%Z!^!_*g!_!c%Z!c!}$2n!}#O%Z#O#P&c#P#R%Z#R#S$2n#S#T%Z#T#o$2n#o#p*g#p$g%Z$g;'S$2n;'S;=`$4n<%lO$2n+d$4qP;=`<%l$2n(CS$4wP;=`<%l$0j!5p$5TX!X!3l'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Df$5{a(i%<v$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$#m#q;'S%Z;'S;=`+a<%lO%Z%#`$7__!W$I`o`$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$8i_!mS$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$9y|$d&j'wp'z!b'm(;d(U!LY't&;d$W#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(CS$=Uk$d&j'wp'z!b'n(;d(U!LY't&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P",
  tokenizers: [u$, h$, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, l$, new Uf("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOq~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!O~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(T~~", 141, 326), new Uf("j~RQYZXz{^~^O'q~~aP!P!Qd~iO'r~~", 25, 308)],
  topRules: { Script: [0, 5], SingleExpression: [1, 266], SingleClassItem: [2, 267] },
  dialects: { jsx: 12686, ts: 12688 },
  dynamicPrecedences: { 76: 1, 78: 1, 163: 1, 191: 1 },
  specialized: [{ term: 312, get: (i) => d$[i] || -1 }, { term: 328, get: (i) => f$[i] || -1 }, { term: 67, get: (i) => p$[i] || -1 }],
  tokenPrec: 12712
}), E$ = [
  /* @__PURE__ */ vi("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ vi("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ vi("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ vi("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ vi("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ vi(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ vi("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ vi(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ vi(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ vi('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ vi('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], gb = /* @__PURE__ */ new Mx(), fI = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Un(i) {
  return (e, t) => {
    let r = e.node.getChild("VariableDefinition");
    return r && t(r, i), !0;
  };
}
const m$ = ["FunctionDeclaration"], g$ = {
  FunctionDeclaration: /* @__PURE__ */ Un("function"),
  ClassDeclaration: /* @__PURE__ */ Un("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ Un("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Un("type"),
  NamespaceDeclaration: /* @__PURE__ */ Un("namespace"),
  VariableDefinition(i, e) {
    i.matchContext(m$) || e(i, "variable");
  },
  TypeDefinition(i, e) {
    e(i, "type");
  },
  __proto__: null
};
function pI(i, e) {
  let t = gb.get(e);
  if (t)
    return t;
  let r = [], o = !0;
  function s(n, a) {
    let l = i.sliceString(n.from, n.to);
    r.push({ label: l, type: a });
  }
  return e.cursor(Qe.IncludeAnonymous).iterate((n) => {
    if (o)
      o = !1;
    else if (n.name) {
      let a = g$[n.name];
      if (a && a(n, s) || fI.has(n.name))
        return !1;
    } else if (n.to - n.from > 8192) {
      for (let a of pI(i, n.node))
        r.push(a);
      return !1;
    }
  }), gb.set(e, r), r;
}
const bb = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, OI = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName"
];
function b$(i) {
  let e = Be(i.state).resolveInner(i.pos, -1);
  if (OI.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && bb.test(i.state.sliceDoc(e.from, e.to));
  if (!t && !i.explicit)
    return null;
  let r = [];
  for (let o = e; o; o = o.parent)
    fI.has(o.name) && (r = r.concat(pI(i.state.doc, o)));
  return {
    options: r,
    from: t ? e.from : i.pos,
    validFor: bb
  };
}
const ao = /* @__PURE__ */ _r.define({
  name: "javascript",
  parser: /* @__PURE__ */ O$.configure({
    props: [
      /* @__PURE__ */ Os.add({
        IfStatement: /* @__PURE__ */ ar({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ ar({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: XC,
        SwitchBody: (i) => {
          let e = i.textAfter, t = /^\s*\}/.test(e), r = /^\s*(case|default)\b/.test(e);
          return i.baseIndent + (t ? 0 : r ? 1 : 2) * i.unit;
        },
        Block: /* @__PURE__ */ VC({ closing: "}" }),
        ArrowFunction: (i) => i.baseIndent + i.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ ar({ except: /^{/ }),
        JSXElement(i) {
          let e = /^\s*<\//.test(i.textAfter);
          return i.lineIndent(i.node.from) + (e ? 0 : i.unit);
        },
        JSXEscape(i) {
          let e = /\s*\}/.test(i.textAfter);
          return i.lineIndent(i.node.from) + (e ? 0 : i.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(i) {
          return i.column(i.node.from) + i.unit;
        }
      }),
      /* @__PURE__ */ Es.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": Xh,
        BlockComment(i) {
          return { from: i.from + 2, to: i.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), T$ = /* @__PURE__ */ ao.configure({ dialect: "ts" }, "typescript"), S$ = /* @__PURE__ */ ao.configure({ dialect: "jsx" }), R$ = /* @__PURE__ */ ao.configure({ dialect: "jsx ts" }, "typescript"), A$ = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map((i) => ({ label: i, type: "keyword" }));
function ou(i = {}) {
  let e = i.jsx ? i.typescript ? R$ : S$ : i.typescript ? T$ : ao;
  return new mn(e, [
    ao.data.of({
      autocomplete: BN(OI, SO(E$.concat(A$)))
    }),
    ao.data.of({
      autocomplete: b$
    }),
    i.jsx ? N$ : []
  ]);
}
function Tb(i, e, t = i.length) {
  if (!e)
    return "";
  let r = e.getChild("JSXIdentifier");
  return r ? i.sliceString(r.from, Math.min(r.to, t)) : "";
}
const C$ = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), N$ = /* @__PURE__ */ q.inputHandler.of((i, e, t, r) => {
  if ((C$ ? i.composing : i.compositionStarted) || i.state.readOnly || e != t || r != ">" && r != "/" || !ao.isActiveAt(i.state, e, -1))
    return !1;
  let { state: o } = i, s = o.changeByRange((n) => {
    var a, l, u;
    let { head: h } = n, c = Be(o).resolveInner(h, -1), d;
    if (c.name == "JSXStartTag" && (c = c.parent), r == ">" && c.name == "JSXFragmentTag")
      return { range: D.cursor(h + 1), changes: { from: h, insert: "><>" } };
    if (r == ">" && c.name == "JSXIdentifier") {
      if (((l = (a = c.parent) === null || a === void 0 ? void 0 : a.lastChild) === null || l === void 0 ? void 0 : l.name) != "JSXEndTag" && (d = Tb(o.doc, c.parent, h)))
        return { range: D.cursor(h + 1), changes: { from: h, insert: `></${d}>` } };
    } else if (r == "/" && c.name == "JSXFragmentTag") {
      let f = c.parent, p = f == null ? void 0 : f.parent;
      if (f.from == h - 1 && ((u = p.lastChild) === null || u === void 0 ? void 0 : u.name) != "JSXEndTag" && (d = Tb(o.doc, p == null ? void 0 : p.firstChild, h))) {
        let O = `/${d}>`;
        return { range: D.cursor(h + O.length), changes: { from: h, insert: O } };
      }
    }
    return { range: n };
  });
  return s.changes.empty ? !1 : (i.dispatch(s, { userEvent: "input.type", scrollIntoView: !0 }), !0);
}), I$ = 95, Sb = 1, v$ = 96, _$ = 97, Rb = 2, EI = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], P$ = 58, L$ = 40, mI = 95, w$ = 91, su = 45, y$ = 46, D$ = 35, x$ = 37;
function sh(i) {
  return i >= 65 && i <= 90 || i >= 97 && i <= 122 || i >= 161;
}
function M$(i) {
  return i >= 48 && i <= 57;
}
const U$ = new Gi((i, e) => {
  for (let t = !1, r = 0, o = 0; ; o++) {
    let { next: s } = i;
    if (sh(s) || s == su || s == mI || t && M$(s))
      !t && (s != su || o > 0) && (t = !0), r === o && s == su && r++, i.advance();
    else {
      t && i.acceptToken(s == L$ ? v$ : r == 2 && e.canShift(Rb) ? Rb : _$);
      break;
    }
  }
}), Q$ = new Gi((i) => {
  if (EI.includes(i.peek(-1))) {
    let { next: e } = i;
    (sh(e) || e == mI || e == D$ || e == y$ || e == w$ || e == P$ || e == su) && i.acceptToken(I$);
  }
}), k$ = new Gi((i) => {
  if (!EI.includes(i.peek(-1))) {
    let { next: e } = i;
    if (e == x$ && (i.advance(), i.acceptToken(Sb)), sh(e)) {
      do
        i.advance();
      while (sh(i.next));
      i.acceptToken(Sb);
    }
  }
}), $$ = ps({
  "AtKeyword import charset namespace keyframes media supports": b.definitionKeyword,
  "from to selector": b.keyword,
  NamespaceName: b.namespace,
  KeyframeName: b.labelName,
  KeyframeRangeName: b.operatorKeyword,
  TagName: b.tagName,
  ClassName: b.className,
  PseudoClassName: b.constant(b.className),
  IdName: b.labelName,
  "FeatureName PropertyName": b.propertyName,
  AttributeName: b.attributeName,
  NumberLiteral: b.number,
  KeywordQuery: b.keyword,
  UnaryQueryOp: b.operatorKeyword,
  "CallTag ValueName": b.atom,
  VariableName: b.variableName,
  Callee: b.operatorKeyword,
  Unit: b.unit,
  "UniversalSelector NestingSelector": b.definitionOperator,
  MatchOp: b.compareOperator,
  "ChildOp SiblingOp, LogicOp": b.logicOperator,
  BinOp: b.arithmeticOperator,
  Important: b.modifier,
  Comment: b.blockComment,
  ColorLiteral: b.color,
  "ParenthesizedContent StringLiteral": b.string,
  ":": b.punctuation,
  "PseudoOp #": b.derefOperator,
  "; ,": b.separator,
  "( )": b.paren,
  "[ ]": b.squareBracket,
  "{ }": b.brace
}), G$ = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 }, V$ = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 }, H$ = { __proto__: null, not: 128, only: 128 }, X$ = Pr.deserialize({
  version: 14,
  states: "8`QYQ[OOO#_Q[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO#fQ[O'#CfO$YQXO'#CaO$aQ[O'#ChO$lQ[O'#DPO$qQ[O'#DTOOQP'#Ee'#EeO$vQdO'#DeO%bQ[O'#DrO$vQdO'#DtO%sQ[O'#DvO&OQ[O'#DyO&WQ[O'#EPO&fQ[O'#EROOQS'#Ed'#EdOOQS'#ET'#ETQYQ[OOO&mQXO'#CdO'bQWO'#DaO'gQWO'#EkO'rQ[O'#EkQOQWOOOOQP'#Cg'#CgOOQP,59Q,59QO#fQ[O,59QO'|Q[O'#EWO(hQWO,58{O(pQ[O,59SO$lQ[O,59kO$qQ[O,59oO'|Q[O,59sO'|Q[O,59uO'|Q[O,59vO({Q[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)SQWO,59SO)XQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)^Q`O,59oOOQS'#Cp'#CpO$vQdO'#CqO)fQvO'#CsO*sQtO,5:POOQO'#Cx'#CxO)XQWO'#CwO+XQWO'#CyOOQS'#Eh'#EhOOQO'#Dh'#DhO+^Q[O'#DoO+lQWO'#ElO&WQ[O'#DmO+zQWO'#DpOOQO'#Em'#EmO(kQWO,5:^O,PQpO,5:`OOQS'#Dx'#DxO,XQWO,5:bO,^Q[O,5:bOOQO'#D{'#D{O,fQWO,5:eO,kQWO,5:kO,sQWO,5:mOOQS-E8R-E8RO$vQdO,59{O,{Q[O'#EYO-YQWO,5;VO-YQWO,5;VOOQP1G.l1G.lO.PQXO,5:rOOQO-E8U-E8UOOQS1G.g1G.gOOQP1G.n1G.nO)SQWO1G.nO)XQWO1G.nOOQP1G/V1G/VO.^Q`O1G/ZO.wQXO1G/_O/_QXO1G/aO/uQXO1G/bO0]QWO,59zO0bQ[O'#DOO0iQdO'#CoOOQP1G/Z1G/ZO$vQdO1G/ZO0pQpO,59]OOQS,59_,59_O$vQdO,59aO0xQWO1G/kOOQS,59c,59cO0}Q!bO,59eO1VQWO'#DhO1bQWO,5:TO1gQWO,5:ZO&WQ[O,5:VO&WQ[O'#EZO1oQWO,5;WO1zQWO,5:XO'|Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2]QWO1G/|O2bQdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO2mQtO1G/gOOQO,5:t,5:tO3TQ[O,5:tOOQO-E8W-E8WO3bQWO1G0qOOQP7+$Y7+$YOOQP7+$u7+$uO$vQdO7+$uOOQS1G/f1G/fO3mQXO'#EjO3tQWO,59jO3yQtO'#EUO4nQdO'#EgO4xQWO,59ZO4}QpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5VQWO1G/PO$vQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5[QWO,5:uOOQO-E8X-E8XO5jQXO1G/vOOQS7+%h7+%hO5qQYO'#CsOOQO'#EO'#EOO5|Q`O'#D}OOQO'#D}'#D}O6XQWO'#E[O6aQdO,5:hOOQS,5:h,5:hO6lQtO'#EXO$vQdO'#EXO7jQdO7+%ROOQO7+%R7+%ROOQO1G0`1G0`O7}QpO<<HaO8VQWO,5;UOOQP1G/U1G/UOOQS-E8S-E8SO$vQdO'#EVO8_QWO,5;ROOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO8gQdO7+%ZOOQO7+%b7+%bOOQO,5:i,5:iO2eQdO'#E]O6XQWO,5:vOOQS,5:v,5:vOOQS-E8Y-E8YOOQS1G0S1G0SO8nQtO,5:sOOQS-E8V-E8VOOQO<<Hm<<HmOOQPAN={AN={O9lQdO,5:qOOQO-E8T-E8TOOQO<<Hu<<HuOOQO,5:w,5:wOOQO-E8Z-E8ZOOQS1G0b1G0b",
  stateData: ":O~O#VOSROS~OUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#TQO#YSO~OQeOUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#TdO#YSO~O#Q#_P~P!ZO#TiO~O]nO^nOplOtoOxpO|qO!PsO#RrO#YkO~O!RtO~P#kO`zO#SwO#TvO~O#T{O~O#T}O~OQ!WOb!QOf!WOh!WOn!VO#S!TO#T!PO#]!RO~Ob!YO!b![O!e!]O#T!XO!R#`P~Oh!bOn!VO#T!aO~Oh!dO#T!dO~Ob!YO!b![O!e!]O#T!XO~O!W#`P~P%bO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#RWX#YWX~O]!iO~O!W!jO#Q#_X!Q#_X~O#Q#_X!Q#_X~P!ZOUXOXXO]UO^UOtVOxWO#TQO#YSO~OplO!RtO~O`!sO#SwO#TvO~O!Q#_P~P!ZOb!zO~Ob!{O~Ov!|Oz!}O~OP#PObgXjgX!WgX!bgX!egX#TgXagXQgXfgXhgXngXpgX!VgX#QgX#SgX#]gXvgX!QgX~Ob!YOj#QO!b![O!e!]O#T!XO!W#`P~Ob#TO~Ob!YO!b![O!e!]O#T#UO~Op#YO!`#XO!R#`X!W#`X~Ob#]O~Oj#QO!W#_O~O!W#`O~Oh#aOn!VO~O!R#bO~O!RtO!`#XO~O!RtO!W#eO~O!W!|X#Q!|X!Q!|X~P!ZO!W!jO#Q#_a!Q#_a~O]nO^nOtoOxpO|qO!PsO#RrO#YkO~Op!za!R!zaa!za~P-eOv#lOz#mO~O]nO^nOtoOxpO#YkO~Op{i|{i!P{i!R{i#R{ia{i~P.fOp}i|}i!P}i!R}i#R}ia}i~P.fOp!Oi|!Oi!P!Oi!R!Oi#R!Oia!Oi~P.fO!Q#nO~Oa#^P~P'|Oa#ZP~P$vOa#uOj#QO~O!W#wO~Oh#xOo#xO~O]!^Xa![X!`![X~O]#yO~Oa#zO!`#XO~Op#YO!R#`a!W#`a~O!`#XOp!aa!R!aa!W!aaa!aa~O!W$PO~O!Q$WO#T$RO#]$QO~Oj#QOp$YO!V$[O!W!Ti#Q!Ti!Q!Ti~P$vO!W!|a#Q!|a!Q!|a~P!ZO!W!jO#Q#_i!Q#_i~Oa#^X~P#kOa$`O~Oj#QOQ!xXa!xXb!xXf!xXh!xXn!xXp!xX#S!xX#T!xX#]!xX~Op$bOa#ZX~P$vOa$dO~Oj#QOv$eO~Oa$fO~O!`#XOp!}a!R!}a!W!}a~Oa$hO~P-eOP#POpgX!RgX~O#]$QOp!qX!R!qX~Op$jO!RtO~O!Q$nO#T$RO#]$QO~Oj#QOQ!{Xb!{Xf!{Xh!{Xn!{Xp!{X!V!{X!W!{X#Q!{X#S!{X#T!{X#]!{X!Q!{X~Op$YO!V$qO!W!Tq#Q!Tq!Q!Tq~P$vOj#QOv$rO~OplOa#^a~Op$bOa#Za~Oa$uO~P$vOj#QOQ!{ab!{af!{ah!{an!{ap!{a!V!{a!W!{a#Q!{a#S!{a#T!{a#]!{a!Q!{a~Oa!yap!ya~P$vO#VoR#]j!Pj~",
  goto: ",z#bPPPPP#cP#l#{P#l$[#lPP$bPPP$h$q$qP%TP$qP$q%o&RPPP&k&q#lP&wP#lP&}P#lP#l#lPPP'T'j'wPP#cPP(O(O(Y(OP(OP(O(OP#cP#cP#cP(]#cP(`(c(f(m#cP#cP(r)R)a)g)q)w*R*X*_PPPPPP*e*nP+Z+^P,S,V,],f_aOPcgt!j#hkXOPcglqrst!j!z#]#hkROPcglqrst!j!z#]#hQjSR!mkQxUR!qnQ!qzQ#S!UR#k!sq!WY[!Q!i!{!}#Q#f#m#r#y$Y$Z$b$g$sp!WY[!Q!i!{!}#Q#f#m#r#y$Y$Z$b$g$sU$T#b$V$jR$i$Sq!UY[!Q!i!{!}#Q#f#m#r#y$Y$Z$b$g$sp!WY[!Q!i!{!}#Q#f#m#r#y$Y$Z$b$g$sQ!b]R#a!cQyUR!rnQ!qyR#k!rQ|VR!toQ!OWR!upQuTQ!pmQ#^!_Q#d!fQ#e!gQ$l$UR$x$kSfPtQ!lgQ#g!jR$]#hZePgt!j#ha!^Z_`!S!Y![#X#YR#V!YR!c]R!e^R#c!eS$U#b$VR$v$jV$S#b$V$jQcOSgPtU!hcg#hR#h!jQ#r!{U$a#r$g$sQ$g#yR$s$bQ$c#rR$t$cQmTS!om$_R$_#oQ$Z#fR$p$ZQ!kfS#i!k#jR#j!lQ#Z!ZR#}#ZQ$V#bR$m$VQ$k$UR$w$k_bOPcgt!j#h^TOPcgt!j#hQ!nlQ!vqQ!wrQ!xsQ#o!zR$O#]R#s!{Q!SYQ!`[Q#O!QQ#f!i[#q!{#r#y$b$g$sQ#t!}Q#v#QS$X#f$ZQ$^#mR$o$YR#p!zQhPR!ytQ!_ZQ!g`R#R!SU!ZZ`!SQ!f_Q#W!YQ#[![Q#{#XR#|#Y",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 109,
  nodeProps: [
    ["openedBy", 17, "(", 48, "{"],
    ["closedBy", 18, ")", 49, "}"]
  ],
  propSources: [$$],
  skippedNodes: [0, 3],
  repeatNodeCount: 9,
  tokenData: "Lq~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Cu![!]Dp!]!^El!^!_$}!_!`E}!`!aF`!a!b$}!b!cG[!c!}$}!}#OHt#O#P$}#P#QIV#Q#R6d#R#T$}#T#UIh#U#c$}#c#dJy#d#o$}#o#pK`#p#q6d#q#rKq#r#sLS#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`Lk<%lO$}W%QSOy%^z;'S%^;'S;=`%o<%lO%^W%cSoWOy%^z;'S%^;'S;=`%o<%lO%^W%rP;=`<%l%^~%zh#V~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#V~oWOX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^^)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^^)sUoWOy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^^*[UoWOy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^^*sUoWOy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^^+[UoWOy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^^+sUoWOy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^^,[UoWOy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^^,sUoWOy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^^-[UoWOy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^^-uS!VUoWOy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.R_/zYtPOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^^0oYoWOy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^^1dYoWOy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^^2ZYfUoWOy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^^3QYfUoWOy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^^3uYoWOy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^^4lYfUoWOy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^^5aYoWOy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^^6WSfUoWOy%^z;'S%^;'S;=`%o<%lO%^Y6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^Y7QSzQoWOy%^z;'S%^;'S;=`%o<%lO%^X7cSXPOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7o_9cSbVOy%^z;'S%^;'S;=`%o<%lO%^~9tOa~_9{UUPjSOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^_:fWjS!PPOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^^;TUoWOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^^;nYoW#]UOy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^^<cYoWOy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=WUoWOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=qUoW#]UOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^>[[oW#]UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^_?VSpVOy%^z;'S%^;'S;=`%o<%lO%^^?hWjSOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^_@VU#YPOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjSOy%^z{@}{;'S%^;'S;=`%o<%lO%^~ASUoWOy@}yzAfz{Bm{;'S@};'S;=`Co<%lO@}~AiTOzAfz{Ax{;'SAf;'S;=`Bg<%lOAf~A{VOzAfz{Ax{!PAf!P!QBb!Q;'SAf;'S;=`Bg<%lOAf~BgOR~~BjP;=`<%lAf~BrWoWOy@}yzAfz{Bm{!P@}!P!QC[!Q;'S@};'S;=`Co<%lO@}~CcSoWR~Oy%^z;'S%^;'S;=`%o<%lO%^~CrP;=`<%l@}^Cz[#]UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^XDuU]POy%^z![%^![!]EX!];'S%^;'S;=`%o<%lO%^XE`S^PoWOy%^z;'S%^;'S;=`%o<%lO%^_EqS!WVOy%^z;'S%^;'S;=`%o<%lO%^YFSSzQOy%^z;'S%^;'S;=`%o<%lO%^XFeU|POy%^z!`%^!`!aFw!a;'S%^;'S;=`%o<%lO%^XGOS|PoWOy%^z;'S%^;'S;=`%o<%lO%^XG_WOy%^z!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHO[!YPoWOy%^z}%^}!OGw!O!Q%^!Q![Gw![!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHySxPOy%^z;'S%^;'S;=`%o<%lO%^^I[SvUOy%^z;'S%^;'S;=`%o<%lO%^XIkUOy%^z#b%^#b#cI}#c;'S%^;'S;=`%o<%lO%^XJSUoWOy%^z#W%^#W#XJf#X;'S%^;'S;=`%o<%lO%^XJmS!`PoWOy%^z;'S%^;'S;=`%o<%lO%^XJ|UOy%^z#f%^#f#gJf#g;'S%^;'S;=`%o<%lO%^ZKeS!RROy%^z;'S%^;'S;=`%o<%lO%^_KvS!QVOy%^z;'S%^;'S;=`%o<%lO%^ZLXU!PPOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^WLnP;=`<%l$}",
  tokenizers: [Q$, k$, U$, 0, 1, 2, 3],
  topRules: { StyleSheet: [0, 4], Styles: [1, 84] },
  specialized: [{ term: 96, get: (i) => G$[i] || -1 }, { term: 56, get: (i) => V$[i] || -1 }, { term: 97, get: (i) => H$[i] || -1 }],
  tokenPrec: 1142
});
let qc = null;
function jc() {
  if (!qc && typeof document == "object" && document.body) {
    let i = [];
    for (let e in document.body.style)
      /[A-Z]|^-|^(item|length)$/.test(e) || i.push(e);
    qc = i.sort().map((e) => ({ type: "property", label: e }));
  }
  return qc || [];
}
const Ab = /* @__PURE__ */ [
  "active",
  "after",
  "before",
  "checked",
  "default",
  "disabled",
  "empty",
  "enabled",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "lang",
  "last-child",
  "last-of-type",
  "link",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-of-type",
  "only-child",
  "optional",
  "out-of-range",
  "placeholder",
  "read-only",
  "read-write",
  "required",
  "root",
  "selection",
  "target",
  "valid",
  "visited"
].map((i) => ({ type: "class", label: i })), Cb = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((i) => ({ type: "keyword", label: i })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((i) => ({ type: "constant", label: i }))), Y$ = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((i) => ({ type: "type", label: i })), Vr = /^[\w-]*/, B$ = (i) => {
  let { state: e, pos: t } = i, r = Be(e).resolveInner(t, -1);
  if (r.name == "PropertyName")
    return { from: r.from, options: jc(), validFor: Vr };
  if (r.name == "ValueName")
    return { from: r.from, options: Cb, validFor: Vr };
  if (r.name == "PseudoClassName")
    return { from: r.from, options: Ab, validFor: Vr };
  if (r.name == "TagName") {
    for (let { parent: n } = r; n; n = n.parent)
      if (n.name == "Block")
        return { from: r.from, options: jc(), validFor: Vr };
    return { from: r.from, options: Y$, validFor: Vr };
  }
  if (!i.explicit)
    return null;
  let o = r.resolve(t), s = o.childBefore(t);
  return s && s.name == ":" && o.name == "PseudoClassSelector" ? { from: t, options: Ab, validFor: Vr } : s && s.name == ":" && o.name == "Declaration" || o.name == "ArgList" ? { from: t, options: Cb, validFor: Vr } : o.name == "Block" ? { from: t, options: jc(), validFor: Vr } : null;
}, Qf = /* @__PURE__ */ _r.define({
  parser: /* @__PURE__ */ X$.configure({
    props: [
      /* @__PURE__ */ Os.add({
        Declaration: /* @__PURE__ */ ar()
      }),
      /* @__PURE__ */ Es.add({
        Block: Xh
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function kf() {
  return new mn(Qf, Qf.data.of({ autocomplete: B$ }));
}
const F$ = 54, W$ = 1, z$ = 55, Z$ = 2, q$ = 56, j$ = 3, Nb = 4, K$ = 5, nh = 6, gI = 7, bI = 8, TI = 9, SI = 10, J$ = 11, eG = 12, tG = 13, Kc = 57, iG = 14, Ib = 58, RI = 20, rG = 22, AI = 23, oG = 24, $f = 26, CI = 27, sG = 28, nG = 31, aG = 34, lG = 36, uG = 37, hG = 0, cG = 1, dG = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, fG = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, vb = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function pG(i) {
  return i == 45 || i == 46 || i == 58 || i >= 65 && i <= 90 || i == 95 || i >= 97 && i <= 122 || i >= 161;
}
function NI(i) {
  return i == 9 || i == 10 || i == 13 || i == 32;
}
let _b = null, Pb = null, Lb = 0;
function Gf(i, e) {
  let t = i.pos + e;
  if (Lb == t && Pb == i)
    return _b;
  let r = i.peek(e);
  for (; NI(r); )
    r = i.peek(++e);
  let o = "";
  for (; pG(r); )
    o += String.fromCharCode(r), r = i.peek(++e);
  return Pb = i, Lb = t, _b = o ? o.toLowerCase() : r == OG || r == EG ? void 0 : null;
}
const II = 60, ah = 62, _O = 47, OG = 63, EG = 33, mG = 45;
function wb(i, e) {
  this.name = i, this.parent = e, this.hash = e ? e.hash : 0;
  for (let t = 0; t < i.length; t++)
    this.hash += (this.hash << 4) + i.charCodeAt(t) + (i.charCodeAt(t) << 8);
}
const gG = [nh, SI, gI, bI, TI], bG = new cI({
  start: null,
  shift(i, e, t, r) {
    return gG.indexOf(e) > -1 ? new wb(Gf(r, 1) || "", i) : i;
  },
  reduce(i, e) {
    return e == RI && i ? i.parent : i;
  },
  reuse(i, e, t, r) {
    let o = e.type.id;
    return o == nh || o == lG ? new wb(Gf(r, 1) || "", i) : i;
  },
  hash(i) {
    return i ? i.hash : 0;
  },
  strict: !1
}), TG = new Gi((i, e) => {
  if (i.next != II) {
    i.next < 0 && e.context && i.acceptToken(Kc);
    return;
  }
  i.advance();
  let t = i.next == _O;
  t && i.advance();
  let r = Gf(i, 0);
  if (r === void 0)
    return;
  if (!r)
    return i.acceptToken(t ? iG : nh);
  let o = e.context ? e.context.name : null;
  if (t) {
    if (r == o)
      return i.acceptToken(J$);
    if (o && fG[o])
      return i.acceptToken(Kc, -2);
    if (e.dialectEnabled(hG))
      return i.acceptToken(eG);
    for (let s = e.context; s; s = s.parent)
      if (s.name == r)
        return;
    i.acceptToken(tG);
  } else {
    if (r == "script")
      return i.acceptToken(gI);
    if (r == "style")
      return i.acceptToken(bI);
    if (r == "textarea")
      return i.acceptToken(TI);
    if (dG.hasOwnProperty(r))
      return i.acceptToken(SI);
    o && vb[o] && vb[o][r] ? i.acceptToken(Kc, -1) : i.acceptToken(nh);
  }
}, { contextual: !0 }), SG = new Gi((i) => {
  for (let e = 0, t = 0; ; t++) {
    if (i.next < 0) {
      t && i.acceptToken(Ib);
      break;
    }
    if (i.next == mG)
      e++;
    else if (i.next == ah && e >= 2) {
      t > 3 && i.acceptToken(Ib, -2);
      break;
    } else
      e = 0;
    i.advance();
  }
});
function RG(i) {
  for (; i; i = i.parent)
    if (i.name == "svg" || i.name == "math")
      return !0;
  return !1;
}
const AG = new Gi((i, e) => {
  if (i.next == _O && i.peek(1) == ah) {
    let t = e.dialectEnabled(cG) || RG(e.context);
    i.acceptToken(t ? K$ : Nb, 2);
  } else
    i.next == ah && i.acceptToken(Nb, 1);
});
function PO(i, e, t) {
  let r = 2 + i.length;
  return new Gi((o) => {
    for (let s = 0, n = 0, a = 0; ; a++) {
      if (o.next < 0) {
        a && o.acceptToken(e);
        break;
      }
      if (s == 0 && o.next == II || s == 1 && o.next == _O || s >= 2 && s < r && o.next == i.charCodeAt(s - 2))
        s++, n++;
      else if ((s == 2 || s == r) && NI(o.next))
        n++;
      else if (s == r && o.next == ah) {
        a > n ? o.acceptToken(e, -n) : o.acceptToken(t, -(n - 2));
        break;
      } else if ((o.next == 10 || o.next == 13) && a) {
        o.acceptToken(e, 1);
        break;
      } else
        s = n = 0;
      o.advance();
    }
  });
}
const CG = PO("script", F$, W$), NG = PO("style", z$, Z$), IG = PO("textarea", q$, j$), vG = ps({
  "Text RawText": b.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": b.angleBracket,
  TagName: b.tagName,
  "MismatchedCloseTag/TagName": [b.tagName, b.invalid],
  AttributeName: b.attributeName,
  "AttributeValue UnquotedAttributeValue": b.attributeValue,
  Is: b.definitionOperator,
  "EntityReference CharacterReference": b.character,
  Comment: b.blockComment,
  ProcessingInst: b.processingInstruction,
  DoctypeDecl: b.documentMeta
}), _G = Pr.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: bG,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"]
  ],
  propSources: [vG],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "#%g!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs4ysv-_vw5iwxJ^x}-_}!OKP!O!P-_!P!Q$q!Q![-_![!]!!O!]!^-_!^!_!&W!_!`#$o!`!a&X!a!c-_!c!}!!O!}#R-_#R#S!!O#S#T3V#T#o!!O#o#s-_#s$f$q$f%W-_%W%o!!O%o%p-_%p&a!!O&a&b-_&b1p!!O1p4U-_4U4d!!O4d4e-_4e$IS!!O$IS$I`-_$I`$Ib!!O$Ib$Kh-_$Kh%#t!!O%#t&/x-_&/x&Et!!O&Et&FV-_&FV;'S!!O;'S;:j!&Q;:j;=`4s<%l?&r-_?&r?Ah!!O?Ah?BY$q?BY?Mn!!O?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/echSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0uXhSqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0pS1eP;=`<%l0p[1kP;=`<%l/^!U1wbhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!U3SP;=`<%l1n!V3bchS`P!a`!cpOq&Xqr3Vrs&}sv3Vvw0pwx(tx!P3V!P!Q&X!Q!^3V!^!_1n!_!a&X!a#s3V#s$f&X$f;'S3V;'S;=`4m<%l?Ah3V?Ah?BY&X?BY?Mn3V?MnO&X!V4pP;=`<%l3V!_4vP;=`<%l-_!Z5SV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_5rjhSkWc!ROX7dXZ8qZ[7d[^8q^p7dqr:crs8qst@Ttw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^/^!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!Z7ibkWOX7dXZ8qZ[7d[^8q^p7dqr7drs8qst+Ptw7dwx8qx!]7d!]!^9f!^!a8q!a#S7d#S#T8q#T;'S7d;'S;=`:]<%lO7d!R8tVOp8qqs8qt!]8q!]!^9Z!^;'S8q;'S;=`9`<%lO8q!R9`Oa!R!R9cP;=`<%l8q!Z9mYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z:`P;=`<%l7d!_:jjhSkWOX7dXZ8qZ[7d[^8q^p7dqr:crs8qst/^tw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^<[!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!_<echSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V=udhSOp8qqr=prs8qst0ptw=pwx8qx!P=p!P!Q8q!Q!]=p!]!^?T!^!_=p!_!a8q!a#s=p#s$f8q$f;'S=p;'S;=`?w<%l?Ah=p?Ah?BY8q?BY?Mn=p?MnO8q!V?[XhSa!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!V?zP;=`<%l=p!_@QP;=`<%l:c!_@[ihSkWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^/^!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!ZBOakWOXAyXZCTZ[Ay[^CT^pAyqrAyrsCTswAywxCTx!]Ay!]!^Cu!^!aCT!a#SAy#S#TCT#T;'SAy;'S;=`Dl<%lOAy!RCWUOpCTq!]CT!]!^Cj!^;'SCT;'S;=`Co<%lOCT!RCoOb!R!RCrP;=`<%lCT!ZC|YkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZDoP;=`<%lAy!_DyihSkWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^Fh!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!_FqchSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VHRchSOpCTqrG|rsCTswG|wxCTx!PG|!P!QCT!Q!]G|!]!^I^!^!_G|!_!aCT!a#sG|#s$fCT$f;'SG|;'S;=`JQ<%l?AhG|?Ah?BYCT?BY?MnG|?MnOCT!VIeXhSb!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!VJTP;=`<%lG|!_JZP;=`<%lDr!ZJgW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aK^lhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMU!O!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aMckhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!`&X!`!a! W!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!T! cX`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!a!!_!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!O!!O!O!P!!O!P!Q$q!Q![!!O![!]!!O!]!^-_!^!_1n!_!a&X!a!c-_!c!}!!O!}#R-_#R#S!!O#S#T3V#T#o!!O#o#s-_#s$f$q$f$}-_$}%O!!O%O%W-_%W%o!!O%o%p-_%p&a!!O&a&b-_&b1p!!O1p4U!!O4U4d!!O4d4e-_4e$IS!!O$IS$I`-_$I`$Ib!!O$Ib$Je-_$Je$Jg!!O$Jg$Kh-_$Kh%#t!!O%#t&/x-_&/x&Et!!O&Et&FV-_&FV;'S!!O;'S;:j!&Q;:j;=`4s<%l?&r-_?&r?Ah!!O?Ah?BY$q?BY?Mn!!O?MnO$q!a!&TP;=`<%l!!O!V!&achS!a`!cpOq*Vqr!'lrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!b!Ey!b#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!'uhhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!)a!O!P1n!P!Q*V!Q!_1n!_!a*V!a!f1n!f!g!,]!g#W1n#W#X!<y#X#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!)jdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!*x!O!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!+TbhS!a`!cp!dPOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!,fdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!q1n!q!r!-t!r#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!-}dhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!e1n!e!f!/]!f#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!/fdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!v1n!v!w!0t!w#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!0}dhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!{1n!{!|!2]!|#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!2fdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!r1n!r!s!3t!s#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!3}dhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!g1n!g!h!5]!h#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!5fchS!a`!cpOq!6qqr!5]rs!7hsv!5]vw!;`wx!9[x!P!5]!P!Q!6q!Q!_!5]!_!`!6q!`!a!:j!a#s!5]#s$f!6q$f;'S!5];'S;=`!<s<%l?Ah!5]?Ah?BY!6q?BY?Mn!5]?MnO!6q!R!6xY!a`!cpOr!6qrs!7hsv!6qvw!8Swx!9[x!`!6q!`!a!:j!a;'S!6q;'S;=`!;Y<%lO!6qq!7mV!cpOv!7hvx!8Sx!`!7h!`!a!8q!a;'S!7h;'S;=`!9U<%lO!7hP!8VTO!`!8S!`!a!8f!a;'S!8S;'S;=`!8k<%lO!8SP!8kO{PP!8nP;=`<%l!8Sq!8xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!9XP;=`<%l!7ha!9aX!a`Or!9[rs!8Ssv!9[vw!8Sw!`!9[!`!a!9|!a;'S!9[;'S;=`!:d<%lO!9[a!:TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!:gP;=`<%l!9[!R!:sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;]P;=`<%l!6qT!;ebhSOq!8Sqr!;`rs!8Ssw!;`wx!8Sx!P!;`!P!Q!8S!Q!_!;`!_!`!8S!`!a!8f!a#s!;`#s$f!8S$f;'S!;`;'S;=`!<m<%l?Ah!;`?Ah?BY!8S?BY?Mn!;`?MnO!8ST!<pP;=`<%l!;`!V!<vP;=`<%l!5]!V!=SdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#c1n#c#d!>b#d#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!>kdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#V1n#V#W!?y#W#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!@SdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#h1n#h#i!Ab#i#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!AkdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#m1n#m#n!By#n#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!CSdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#d1n#d#e!Db#e#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!DkdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#X1n#X#Y!5]#Y#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!FSchS!a`!cpOq!G_qr!Eyrs!HUsv!Eyvw!Ncwx!Jvx!P!Ey!P!Q!G_!Q!_!Ey!_!a!G_!a!b##T!b#s!Ey#s$f!G_$f;'S!Ey;'S;=`#$i<%l?Ah!Ey?Ah?BY!G_?BY?Mn!Ey?MnO!G_!R!GfY!a`!cpOr!G_rs!HUsv!G_vw!Hpwx!Jvx!a!G_!a!b!Lv!b;'S!G_;'S;=`!N]<%lO!G_q!HZV!cpOv!HUvx!Hpx!a!HU!a!b!Iq!b;'S!HU;'S;=`!Jp<%lO!HUP!HsTO!a!Hp!a!b!IS!b;'S!Hp;'S;=`!Ik<%lO!HpP!IVTO!`!Hp!`!a!If!a;'S!Hp;'S;=`!Ik<%lO!HpP!IkOxPP!InP;=`<%l!Hpq!IvV!cpOv!HUvx!Hpx!`!HU!`!a!J]!a;'S!HU;'S;=`!Jp<%lO!HUq!JdS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!JsP;=`<%l!HUa!J{X!a`Or!Jvrs!Hpsv!Jvvw!Hpw!a!Jv!a!b!Kh!b;'S!Jv;'S;=`!Lp<%lO!Jva!KmX!a`Or!Jvrs!Hpsv!Jvvw!Hpw!`!Jv!`!a!LY!a;'S!Jv;'S;=`!Lp<%lO!Jva!LaT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!LsP;=`<%l!Jv!R!L}Y!a`!cpOr!G_rs!HUsv!G_vw!Hpwx!Jvx!`!G_!`!a!Mm!a;'S!G_;'S;=`!N]<%lO!G_!R!MvV!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!N`P;=`<%l!G_T!NhbhSOq!Hpqr!Ncrs!Hpsw!Ncwx!Hpx!P!Nc!P!Q!Hp!Q!_!Nc!_!a!Hp!a!b# p!b#s!Nc#s$f!Hp$f;'S!Nc;'S;=`#!}<%l?Ah!Nc?Ah?BY!Hp?BY?Mn!Nc?MnO!HpT# ubhSOq!Hpqr!Ncrs!Hpsw!Ncwx!Hpx!P!Nc!P!Q!Hp!Q!_!Nc!_!`!Hp!`!a!If!a#s!Nc#s$f!Hp$f;'S!Nc;'S;=`#!}<%l?Ah!Nc?Ah?BY!Hp?BY?Mn!Nc?MnO!HpT##QP;=`<%l!Nc!V##^chS!a`!cpOq!G_qr!Eyrs!HUsv!Eyvw!Ncwx!Jvx!P!Ey!P!Q!G_!Q!_!Ey!_!`!G_!`!a!Mm!a#s!Ey#s$f!G_$f;'S!Ey;'S;=`#$i<%l?Ah!Ey?Ah?BY!G_?BY?Mn!Ey?MnO!G_!V#$lP;=`<%l!Ey!V#$zXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [CG, NG, IG, AG, TG, SG, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function vI(i, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r of i.getChildren(AI)) {
    let o = r.getChild(oG), s = r.getChild($f) || r.getChild(CI);
    o && (t[e.read(o.from, o.to)] = s ? s.type.id == $f ? e.read(s.from + 1, s.to - 1) : e.read(s.from, s.to) : "");
  }
  return t;
}
function yb(i, e) {
  let t = i.getChild(rG);
  return t ? e.read(t.from, t.to) : " ";
}
function Jc(i, e, t) {
  let r;
  for (let o of t)
    if (!o.attrs || o.attrs(r || (r = vI(i.node.parent.firstChild, e))))
      return { parser: o.parser };
  return null;
}
function PG(i = [], e = []) {
  let t = [], r = [], o = [], s = [];
  for (let a of i)
    (a.tag == "script" ? t : a.tag == "style" ? r : a.tag == "textarea" ? o : s).push(a);
  let n = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a of e)
    (n[a.name] || (n[a.name] = [])).push(a);
  return Qx((a, l) => {
    let u = a.type.id;
    if (u == sG)
      return Jc(a, l, t);
    if (u == nG)
      return Jc(a, l, r);
    if (u == aG)
      return Jc(a, l, o);
    if (u == RI && s.length) {
      let h = a.node, c = h.firstChild, d = c && yb(c, l), f;
      if (d) {
        for (let p of s)
          if (p.tag == d && (!p.attrs || p.attrs(f || (f = vI(h, l))))) {
            let O = h.lastChild;
            return { parser: p.parser, overlay: [{ from: c.to, to: O.type.id == uG ? O.from : h.to }] };
          }
      }
    }
    if (n && u == AI) {
      let h = a.node, c;
      if (c = h.firstChild) {
        let d = n[l.read(c.from, c.to)];
        if (d)
          for (let f of d) {
            if (f.tagName && f.tagName != yb(h.parent, l))
              continue;
            let p = h.lastChild;
            if (p.type.id == $f) {
              let O = p.from + 1, m = p.lastChild, E = p.to - (m && m.isError ? 0 : 1);
              if (E > O)
                return { parser: f.parser, overlay: [{ from: O, to: E }] };
            } else if (p.type.id == CI)
              return { parser: f.parser, overlay: [{ from: p.from, to: p.to }] };
          }
      }
    }
    return null;
  });
}
const Qn = ["_blank", "_self", "_top", "_parent"], ed = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], td = ["get", "post", "put", "delete"], id = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], ei = ["true", "false"], Z = {}, Kh = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Qn,
      hreflang: null
    }
  },
  abbr: Z,
  acronym: Z,
  address: Z,
  applet: Z,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: Z,
  aside: Z,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: Z,
  base: { attrs: { href: null, target: Qn } },
  basefont: Z,
  bdi: Z,
  bdo: Z,
  big: Z,
  blockquote: { attrs: { cite: null } },
  body: Z,
  br: Z,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: id,
      formmethod: td,
      formnovalidate: ["novalidate"],
      formtarget: Qn,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: Z,
  center: Z,
  cite: Z,
  code: Z,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: Z,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: Z,
  dir: Z,
  div: Z,
  dl: Z,
  dt: Z,
  em: Z,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: Z,
  figure: Z,
  font: Z,
  footer: Z,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": ed,
      autocomplete: ["on", "off"],
      enctype: id,
      method: td,
      novalidate: ["novalidate"],
      target: Qn
    }
  },
  frame: Z,
  frameset: Z,
  h1: Z,
  h2: Z,
  h3: Z,
  h4: Z,
  h5: Z,
  h6: Z,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: Z,
  hgroup: Z,
  hr: Z,
  html: {
    attrs: { manifest: null }
  },
  i: Z,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: id,
      formmethod: td,
      formnovalidate: ["novalidate"],
      formtarget: Qn,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: Z,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: Z,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: Z,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: ed,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: Z,
  noframes: Z,
  noscript: Z,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: Z,
  param: { attrs: { name: null, value: null } },
  pre: Z,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: Z,
  rt: Z,
  ruby: Z,
  s: Z,
  samp: Z,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: ed
    }
  },
  section: Z,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: Z,
  source: { attrs: { src: null, type: null, media: null } },
  span: Z,
  strike: Z,
  strong: Z,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: Z,
  summary: Z,
  sup: Z,
  table: Z,
  tbody: Z,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: Z,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: Z,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: Z,
  time: { attrs: { datetime: null } },
  title: Z,
  tr: Z,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  tt: Z,
  u: Z,
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: Z,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: Z
}, _I = {
  accesskey: null,
  class: null,
  contenteditable: ei,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: ei,
  autocorrect: ei,
  autocapitalize: ei,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  onclick: null,
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": ei,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": ei,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": ei,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": ei,
  "aria-hidden": ei,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": ei,
  "aria-multiselectable": ei,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": ei,
  "aria-relevant": null,
  "aria-required": ei,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, LG = /* @__PURE__ */ Object.keys(Kh), Db = /* @__PURE__ */ Object.keys(_I);
function dn(i, e, t = i.length) {
  if (!e)
    return "";
  let r = e.firstChild, o = r && r.getChild("TagName");
  return o ? i.sliceString(o.from, Math.min(o.to, t)) : "";
}
function Jh(i, e = !1) {
  for (let t = i.parent; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function PI(i, e) {
  let t = Kh[dn(i, Jh(e, !0))];
  return (t == null ? void 0 : t.children) || LG;
}
function LO(i, e) {
  let t = [];
  for (let r = e; r = Jh(r); ) {
    let o = dn(i, r);
    if (o && r.lastChild.name == "CloseTag")
      break;
    o && t.indexOf(o) < 0 && (e.name == "EndTag" || e.from >= r.firstChild.to) && t.push(o);
  }
  return t;
}
const LI = /^[:\-\.\w\u00b7-\uffff]*$/;
function xb(i, e, t, r) {
  let o = /\s*>/.test(i.sliceDoc(r, r + 5)) ? "" : ">";
  return {
    from: t,
    to: r,
    options: PI(i.doc, e).map((s) => ({ label: s, type: "type" })).concat(LO(i.doc, e).map((s, n) => ({ label: "/" + s, apply: "/" + s + o, type: "type", boost: 99 - n }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function Mb(i, e, t, r) {
  let o = /\s*>/.test(i.sliceDoc(r, r + 5)) ? "" : ">";
  return {
    from: t,
    to: r,
    options: LO(i.doc, e).map((s, n) => ({ label: s, apply: s + o, type: "type", boost: 99 - n })),
    validFor: LI
  };
}
function wG(i, e, t) {
  let r = [], o = 0;
  for (let s of PI(i.doc, e))
    r.push({ label: "<" + s, type: "type" });
  for (let s of LO(i.doc, e))
    r.push({ label: "</" + s + ">", type: "type", boost: 99 - o++ });
  return { from: t, to: t, options: r, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function yG(i, e, t, r) {
  let o = Jh(e), s = o ? Kh[dn(i.doc, o)] : null, n = s && s.attrs ? Object.keys(s.attrs).concat(Db) : Db;
  return {
    from: t,
    to: r,
    options: n.map((a) => ({ label: a, type: "property" })),
    validFor: LI
  };
}
function DG(i, e, t, r) {
  var o;
  let s = (o = e.parent) === null || o === void 0 ? void 0 : o.getChild("AttributeName"), n = [], a;
  if (s) {
    let l = i.sliceDoc(s.from, s.to), u = _I[l];
    if (!u) {
      let h = Jh(e), c = h ? Kh[dn(i.doc, h)] : null;
      u = (c == null ? void 0 : c.attrs) && c.attrs[l];
    }
    if (u) {
      let h = i.sliceDoc(t, r).toLowerCase(), c = '"', d = '"';
      /^['"]/.test(h) ? (a = h[0] == '"' ? /^[^"]*$/ : /^[^']*$/, c = "", d = i.sliceDoc(r, r + 1) == h[0] ? "" : h[0], h = h.slice(1), t++) : a = /^[^\s<>='"]*$/;
      for (let f of u)
        n.push({ label: f, apply: c + f + d, type: "constant" });
    }
  }
  return { from: t, to: r, options: n, validFor: a };
}
function xG(i) {
  let { state: e, pos: t } = i, r = Be(e).resolveInner(t), o = r.resolve(t, -1);
  for (let s = t, n; r == o && (n = o.childBefore(s)); ) {
    let a = n.lastChild;
    if (!a || !a.type.isError || a.from < a.to)
      break;
    r = o = n, s = a.from;
  }
  return o.name == "TagName" ? o.parent && /CloseTag$/.test(o.parent.name) ? Mb(e, o, o.from, t) : xb(e, o, o.from, t) : o.name == "StartTag" ? xb(e, o, t, t) : o.name == "StartCloseTag" || o.name == "IncompleteCloseTag" ? Mb(e, o, t, t) : i.explicit && (o.name == "OpenTag" || o.name == "SelfClosingTag") || o.name == "AttributeName" ? yG(e, o, o.name == "AttributeName" ? o.from : t, t) : o.name == "Is" || o.name == "AttributeValue" || o.name == "UnquotedAttributeValue" ? DG(e, o, o.name == "Is" ? t : o.from, t) : i.explicit && (r.name == "Element" || r.name == "Text" || r.name == "Document") ? wG(e, o, t) : null;
}
const Vf = /* @__PURE__ */ _r.define({
  parser: /* @__PURE__ */ _G.configure({
    props: [
      /* @__PURE__ */ Os.add({
        Element(i) {
          let e = /^(\s*)(<\/)?/.exec(i.textAfter);
          return i.node.to <= i.pos + e[0].length ? i.continue() : i.lineIndent(i.node.from) + (e[2] ? 0 : i.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(i) {
          return i.column(i.node.from) + i.unit;
        },
        Document(i) {
          if (i.pos + /\s*/.exec(i.textAfter)[0].length < i.node.to)
            return i.continue();
          let e = null, t;
          for (let r = i.node; ; ) {
            let o = r.lastChild;
            if (!o || o.name != "Element" || o.to != r.to)
              break;
            e = r = o;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? i.lineIndent(e.from) + i.unit : null;
        }
      }),
      /* @__PURE__ */ Es.add({
        Element(i) {
          let e = i.firstChild, t = i.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : i.to };
        }
      })
    ],
    wrap: /* @__PURE__ */ PG([
      {
        tag: "script",
        attrs(i) {
          return !i.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(i.type);
        },
        parser: ao.parser
      },
      {
        tag: "style",
        attrs(i) {
          return (!i.lang || i.lang == "css") && (!i.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(i.type));
        },
        parser: Qf.parser
      }
    ])
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
});
function MG(i = {}) {
  let e = Vf;
  return i.matchClosingTags === !1 && (e = e.configure({ dialect: "noMatch" })), new mn(e, [
    Vf.data.of({ autocomplete: xG }),
    i.autoCloseTags !== !1 ? UG : [],
    ou().support,
    kf().support
  ]);
}
const UG = /* @__PURE__ */ q.inputHandler.of((i, e, t, r) => {
  if (i.composing || i.state.readOnly || e != t || r != ">" && r != "/" || !Vf.isActiveAt(i.state, e, -1))
    return !1;
  let { state: o } = i, s = o.changeByRange((n) => {
    var a, l, u;
    let { head: h } = n, c = Be(o).resolveInner(h, -1), d;
    if ((c.name == "TagName" || c.name == "StartTag") && (c = c.parent), r == ">" && c.name == "OpenTag") {
      if (((l = (a = c.parent) === null || a === void 0 ? void 0 : a.lastChild) === null || l === void 0 ? void 0 : l.name) != "CloseTag" && (d = dn(o.doc, c.parent, h)))
        return { range: D.cursor(h + 1), changes: { from: h, insert: `></${d}>` } };
    } else if (r == "/" && c.name == "OpenTag") {
      let f = c.parent, p = f == null ? void 0 : f.parent;
      if (f.from == h - 1 && ((u = p.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (d = dn(o.doc, p, h))) {
        let O = `/${d}>`;
        return { range: D.cursor(h + O.length), changes: { from: h, insert: O } };
      }
    }
    return { range: n };
  });
  return s.changes.empty ? !1 : (i.dispatch(s, { userEvent: "input.type", scrollIntoView: !0 }), !0);
}), QG = ps({
  String: b.string,
  Number: b.number,
  "True False": b.bool,
  PropertyName: b.propertyName,
  Null: b.null,
  ",": b.separator,
  "[ ]": b.squareBracket,
  "{ }": b.brace
}), kG = Pr.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [QG],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), $G = /* @__PURE__ */ _r.define({
  parser: /* @__PURE__ */ kG.configure({
    props: [
      /* @__PURE__ */ Os.add({
        Object: /* @__PURE__ */ ar({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ ar({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ Es.add({
        "Object Array": Xh
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function GG() {
  return new mn($G);
}
const VG = 34, Ub = 1, HG = 2, rd = 3, Vl = 4, XG = 5, YG = 6, BG = 7, FG = 8, WG = 9, zG = 10, ZG = 11, qG = 12, jG = 13, KG = 14, JG = 15, eV = 16, tV = 17, iV = 18, rV = 19, wI = 20, yI = 21, oV = 22;
function Hf(i) {
  return i >= 65 && i <= 90 || i >= 97 && i <= 122 || i >= 48 && i <= 57;
}
function sV(i) {
  return i >= 48 && i <= 57 || i >= 97 && i <= 102 || i >= 65 && i <= 70;
}
function Ps(i, e, t) {
  for (let r = !1; ; ) {
    if (i.next < 0)
      return;
    if (i.next == e && !r) {
      i.advance();
      return;
    }
    r = t && !r && i.next == 92, i.advance();
  }
}
function DI(i, e) {
  for (; !(i.next != 95 && !Hf(i.next)); )
    e != null && (e += String.fromCharCode(i.next)), i.advance();
  return e;
}
function nV(i) {
  if (i.next == 39 || i.next == 34 || i.next == 96) {
    let e = i.next;
    i.advance(), Ps(i, e, !1);
  } else
    DI(i);
}
function Qb(i, e) {
  for (; ; ) {
    if (i.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (i.next < 48 || i.next > 57)
      break;
    i.advance();
  }
  if (i.next == 69 || i.next == 101)
    for (i.advance(), (i.next == 43 || i.next == 45) && i.advance(); i.next >= 48 && i.next <= 57; )
      i.advance();
}
function kb(i) {
  for (; !(i.next < 0 || i.next == 10); )
    i.advance();
}
function Cs(i, e) {
  for (let t = 0; t < e.length; t++)
    if (e.charCodeAt(t) == i)
      return !0;
  return !1;
}
const $b = ` 	\r
`;
function xI(i, e, t) {
  let r = /* @__PURE__ */ Object.create(null);
  r.true = r.false = XG, r.null = r.unknown = YG;
  for (let o of i.split(" "))
    o && (r[o] = wI);
  for (let o of e.split(" "))
    o && (r[o] = yI);
  for (let o of (t || "").split(" "))
    o && (r[o] = oV);
  return r;
}
const aV = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", lV = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", Xf = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  charSetCasts: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  words: /* @__PURE__ */ xI(lV, aV)
};
function uV(i, e, t, r) {
  let o = {};
  for (let s in Xf)
    o[s] = (i.hasOwnProperty(s) ? i : Xf)[s];
  return e && (o.words = xI(e, t || "", r)), o;
}
function MI(i) {
  return new Gi((e) => {
    var t;
    let { next: r } = e;
    if (e.advance(), Cs(r, $b)) {
      for (; Cs(e.next, $b); )
        e.advance();
      e.acceptToken(VG);
    } else if (r == 39 || r == 34 && i.doubleQuotedStrings)
      Ps(e, r, i.backslashEscapes), e.acceptToken(rd);
    else if (r == 35 && i.hashComments || r == 47 && e.next == 47 && i.slashComments)
      kb(e), e.acceptToken(Ub);
    else if (r == 45 && e.next == 45 && (!i.spaceAfterDashes || e.peek(2) == 32))
      kb(e), e.acceptToken(Ub);
    else if (r == 47 && e.next == 42) {
      e.advance();
      for (let o = -1, s = 1; !(e.next < 0); )
        if (e.advance(), o == 42 && e.next == 47) {
          if (s--, !s) {
            e.advance();
            break;
          }
          o = -1;
        } else
          o == 47 && e.next == 42 ? (s++, o = -1) : o = e.next;
      e.acceptToken(HG);
    } else if ((r == 101 || r == 69) && e.next == 39)
      e.advance(), Ps(e, 39, !0);
    else if ((r == 110 || r == 78) && e.next == 39 && i.charSetCasts)
      e.advance(), Ps(e, 39, i.backslashEscapes), e.acceptToken(rd);
    else if (r == 95 && i.charSetCasts)
      for (let o = 0; ; o++) {
        if (e.next == 39 && o > 1) {
          e.advance(), Ps(e, 39, i.backslashEscapes), e.acceptToken(rd);
          break;
        }
        if (!Hf(e.next))
          break;
        e.advance();
      }
    else if (r == 40)
      e.acceptToken(BG);
    else if (r == 41)
      e.acceptToken(FG);
    else if (r == 123)
      e.acceptToken(WG);
    else if (r == 125)
      e.acceptToken(zG);
    else if (r == 91)
      e.acceptToken(ZG);
    else if (r == 93)
      e.acceptToken(qG);
    else if (r == 59)
      e.acceptToken(jG);
    else if (r == 48 && (e.next == 98 || e.next == 66) || (r == 98 || r == 66) && e.next == 39) {
      let o = e.next == 39;
      for (e.advance(); e.next == 48 || e.next == 49; )
        e.advance();
      o && e.next == 39 && e.advance(), e.acceptToken(Vl);
    } else if (r == 48 && (e.next == 120 || e.next == 88) || (r == 120 || r == 88) && e.next == 39) {
      let o = e.next == 39;
      for (e.advance(); sV(e.next); )
        e.advance();
      o && e.next == 39 && e.advance(), e.acceptToken(Vl);
    } else if (r == 46 && e.next >= 48 && e.next <= 57)
      Qb(e, !0), e.acceptToken(Vl);
    else if (r == 46)
      e.acceptToken(KG);
    else if (r >= 48 && r <= 57)
      Qb(e, !1), e.acceptToken(Vl);
    else if (Cs(r, i.operatorChars)) {
      for (; Cs(e.next, i.operatorChars); )
        e.advance();
      e.acceptToken(JG);
    } else if (Cs(r, i.specialVar))
      e.next == r && e.advance(), nV(e), e.acceptToken(tV);
    else if (Cs(r, i.identifierQuotes))
      Ps(e, r, !1), e.acceptToken(rV);
    else if (r == 58 || r == 44)
      e.acceptToken(eV);
    else if (Hf(r)) {
      let o = DI(e, String.fromCharCode(r));
      e.acceptToken((t = i.words[o.toLowerCase()]) !== null && t !== void 0 ? t : iV);
    }
  });
}
const UI = /* @__PURE__ */ MI(Xf), hV = /* @__PURE__ */ Pr.deserialize({
  version: 14,
  states: "%dQ]QQOOO#kQRO'#DQO#rQQO'#CuO%RQQO'#CvO%YQQO'#CwO%aQQO'#CxOOQQ'#DQ'#DQOOQQ'#C{'#C{O&lQRO'#CyOOQQ'#Ct'#CtOOQQ'#Cz'#CzQ]QQOOQOQQOOO&vQQO,59aO'RQQO,59aO'WQQO'#DQOOQQ,59b,59bO'eQQO,59bOOQQ,59c,59cO'lQQO,59cOOQQ,59d,59dO'sQQO,59dOOQQ-E6y-E6yOOQQ,59`,59`OOQQ-E6x-E6xOOQQ'#C|'#C|OOQQ1G.{1G.{O&vQQO1G.{OOQQ1G.|1G.|OOQQ1G.}1G.}OOQQ1G/O1G/OP'zQQO'#C{POQQ-E6z-E6zOOQQ7+$g7+$g",
  stateData: "(R~OrOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUO~O^]ORtXStXTtXUtXVtXXtXZtX]tX_tX`tXatXbtXctXdtXetXftX~OqtX~P!dOa^Ob^Oc^O~ORUOSUOTUOUUOVROXSOZTO^QO_UO`UOa_Ob_Oc_OdUOeUOfUO~OW`O~P#}OYbO~P#}O[dO~P#}ORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUO~O]gOqmX~P%hOaiObiOciO~O^kO~OWtXYtX[tX~P!dOWlO~P#}OYmO~P#}O[nO~P#}O]gO~P#}O",
  goto: "#YuPPPPPPPPPPPPPPPPPPPPPPPPvzzzz!W![!b!vPPP!|TYOZeUORSTWZaceoT[OZQZORhZSWOZQaRQcSQeTZfWaceoQj]RqkeVORSTWZaceo",
  nodeNames: "⚠ LineComment BlockComment String Number Bool Null ( ) [ ] { } ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 36,
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, UI],
  topRules: { Script: [0, 23] },
  tokenPrec: 0
});
function Yf(i) {
  let e = i.cursor().moveTo(i.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function cV(i) {
  let e = /^[`'"](.*)[`'"]$/.exec(i);
  return e ? e[1] : i;
}
function dV(i, e) {
  return e.name == "Identifier" || e.name == "QuotedIdentifier" || e.name == "Keyword" && /^public$/i.test(i.sliceDoc(e.from, e.to));
}
function Gb(i, e) {
  for (let t = []; ; ) {
    if (!e || e.name != ".")
      return t;
    let r = Yf(e);
    if (!r || !dV(i, r))
      return t;
    t.unshift(cV(i.sliceDoc(r.from, r.to))), e = Yf(r);
  }
}
function fV(i, e) {
  let t = Be(i).resolveInner(e, -1);
  return t.name == "Identifier" || t.name == "QuotedIdentifier" ? {
    from: t.from,
    quoted: t.name == "QuotedIdentifier" ? i.sliceDoc(t.from, t.from + 1) : null,
    parents: Gb(i, Yf(t))
  } : t.name == "." ? {
    from: e,
    quoted: null,
    parents: Gb(i, t)
  } : { from: e, quoted: null, parents: [], empty: !0 };
}
function pV(i, e) {
  return i ? e.map((t) => Object.assign(Object.assign({}, t), { label: i + t.label + i, apply: void 0 })) : e;
}
const OV = /^\w*$/, EV = /^[`'"]?\w*[`'"]?$/;
class wO {
  constructor() {
    this.list = [], this.children = void 0;
  }
  child(e) {
    let t = this.children || (this.children = /* @__PURE__ */ Object.create(null));
    return t[e] || (t[e] = new wO());
  }
  childCompletions(e) {
    return this.children ? Object.keys(this.children).filter((t) => t).map((t) => ({ label: t, type: e })) : [];
  }
}
function mV(i, e, t, r) {
  let o = new wO(), s = o.child(r || "");
  for (let n in i) {
    let a = n.indexOf("."), u = (a > -1 ? o.child(n.slice(0, a)) : s).child(a > -1 ? n.slice(a + 1) : n);
    u.list = i[n].map((h) => typeof h == "string" ? { label: h, type: "property" } : h);
  }
  s.list = (e || s.childCompletions("type")).concat(t ? s.child(t).list : []);
  for (let n in o.children) {
    let a = o.child(n);
    a.list.length || (a.list = a.childCompletions("type"));
  }
  return o.list = s.list.concat(o.childCompletions("type")), (n) => {
    let { parents: a, from: l, quoted: u, empty: h } = fV(n.state, n.pos);
    if (h && !n.explicit)
      return null;
    let c = o;
    for (let f of a) {
      for (; !c.children || !c.children[f]; )
        if (c == o)
          c = s;
        else if (c == s && t)
          c = c.child(t);
        else
          return null;
      c = c.child(f);
    }
    let d = u && n.state.sliceDoc(n.pos, n.pos + 1) == u;
    return {
      from: l,
      to: d ? n.pos + 1 : void 0,
      options: pV(u, c.list),
      validFor: u ? EV : OV
    };
  };
}
function gV(i, e) {
  let t = Object.keys(i).map((r) => ({
    label: e ? r.toUpperCase() : r,
    type: i[r] == yI ? "type" : i[r] == wI ? "keyword" : "variable",
    boost: -1
  }));
  return BN(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], SO(t));
}
let bV = /* @__PURE__ */ hV.configure({
  props: [
    /* @__PURE__ */ Os.add({
      Statement: /* @__PURE__ */ ar()
    }),
    /* @__PURE__ */ Es.add({
      Statement(i) {
        return { from: i.firstChild.to, to: i.to };
      },
      BlockComment(i) {
        return { from: i.from + 2, to: i.to - 2 };
      }
    }),
    /* @__PURE__ */ ps({
      Keyword: b.keyword,
      Type: b.typeName,
      Builtin: /* @__PURE__ */ b.standard(b.name),
      Bool: b.bool,
      Null: b.null,
      Number: b.number,
      String: b.string,
      Identifier: b.name,
      QuotedIdentifier: /* @__PURE__ */ b.special(b.string),
      SpecialVar: /* @__PURE__ */ b.special(b.name),
      LineComment: b.lineComment,
      BlockComment: b.blockComment,
      Operator: b.operator,
      "Semi Punctuation": b.punctuation,
      "( )": b.paren,
      "{ }": b.brace,
      "[ ]": b.squareBracket
    })
  ]
});
class yO {
  constructor(e, t) {
    this.dialect = e, this.language = t;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let t = uV(e, e.keywords, e.types, e.builtin), r = _r.define({
      parser: bV.configure({
        tokenizers: [{ from: UI, to: MI(t) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new yO(t, r);
  }
}
function TV(i, e = !1) {
  return gV(i.dialect.words, e);
}
function SV(i, e = !1) {
  return i.language.data.of({
    autocomplete: TV(i, e)
  });
}
function RV(i) {
  return i.schema ? mV(i.schema, i.tables, i.defaultTable, i.defaultSchema) : () => null;
}
function AV(i) {
  return i.schema ? (i.dialect || QI).language.data.of({
    autocomplete: RV(i)
  }) : [];
}
function CV(i = {}) {
  let e = i.dialect || QI;
  return new mn(e.language, [AV(i), SV(e, !!i.upperCaseKeywords)]);
}
const QI = /* @__PURE__ */ yO.define({});
let k;
(function(i) {
  i.QUOTED_IDENTIFIER = "QUOTED_IDENTIFIER", i.IDENTIFIER = "IDENTIFIER", i.STRING = "STRING", i.VARIABLE = "VARIABLE", i.RESERVED_KEYWORD = "RESERVED_KEYWORD", i.RESERVED_FUNCTION_NAME = "RESERVED_FUNCTION_NAME", i.RESERVED_PHRASE = "RESERVED_PHRASE", i.RESERVED_SET_OPERATION = "RESERVED_SET_OPERATION", i.RESERVED_CLAUSE = "RESERVED_CLAUSE", i.RESERVED_SELECT = "RESERVED_SELECT", i.RESERVED_JOIN = "RESERVED_JOIN", i.ARRAY_IDENTIFIER = "ARRAY_IDENTIFIER", i.ARRAY_KEYWORD = "ARRAY_KEYWORD", i.CASE = "CASE", i.END = "END", i.WHEN = "WHEN", i.ELSE = "ELSE", i.THEN = "THEN", i.LIMIT = "LIMIT", i.BETWEEN = "BETWEEN", i.AND = "AND", i.OR = "OR", i.XOR = "XOR", i.OPERATOR = "OPERATOR", i.COMMA = "COMMA", i.ASTERISK = "ASTERISK", i.DOT = "DOT", i.OPEN_PAREN = "OPEN_PAREN", i.CLOSE_PAREN = "CLOSE_PAREN", i.LINE_COMMENT = "LINE_COMMENT", i.BLOCK_COMMENT = "BLOCK_COMMENT", i.NUMBER = "NUMBER", i.NAMED_PARAMETER = "NAMED_PARAMETER", i.QUOTED_PARAMETER = "QUOTED_PARAMETER", i.NUMBERED_PARAMETER = "NUMBERED_PARAMETER", i.POSITIONAL_PARAMETER = "POSITIONAL_PARAMETER", i.CUSTOM_PARAMETER = "CUSTOM_PARAMETER", i.DELIMITER = "DELIMITER", i.EOF = "EOF";
})(k || (k = {}));
const kI = (i) => ({
  type: k.EOF,
  raw: "«EOF»",
  text: "«EOF»",
  start: i
}), rs = kI(1 / 0), kn = (i) => (e) => e.type === i.type && e.text === i.text, Ro = {
  ARRAY: kn({
    text: "ARRAY",
    type: k.RESERVED_KEYWORD
  }),
  BY: kn({
    text: "BY",
    type: k.RESERVED_KEYWORD
  }),
  SET: kn({
    text: "SET",
    type: k.RESERVED_CLAUSE
  }),
  STRUCT: kn({
    text: "STRUCT",
    type: k.RESERVED_KEYWORD
  }),
  WINDOW: kn({
    text: "WINDOW",
    type: k.RESERVED_CLAUSE
  })
}, $I = (i) => i === k.RESERVED_KEYWORD || i === k.RESERVED_FUNCTION_NAME || i === k.RESERVED_PHRASE || i === k.RESERVED_CLAUSE || i === k.RESERVED_SELECT || i === k.RESERVED_SET_OPERATION || i === k.RESERVED_JOIN || i === k.ARRAY_KEYWORD || i === k.CASE || i === k.END || i === k.WHEN || i === k.ELSE || i === k.THEN || i === k.LIMIT || i === k.BETWEEN || i === k.AND || i === k.OR || i === k.XOR, NV = (i) => i === k.AND || i === k.OR || i === k.XOR, V = (i) => i.flatMap(IV), IV = (i) => GI(vV(i)).map((e) => e.trim()), Vb = /[^[\]{}]+/y, Hb = /\{.*?\}/y, Xb = /\[.*?\]/y, vV = (i) => {
  let e = 0;
  const t = [];
  for (; e < i.length; ) {
    Vb.lastIndex = e;
    const r = Vb.exec(i);
    r && (t.push([r[0].trim()]), e += r[0].length), Xb.lastIndex = e;
    const o = Xb.exec(i);
    if (o) {
      const n = o[0].slice(1, -1).split("|").map((a) => a.trim());
      t.push(["", ...n]), e += o[0].length;
    }
    Hb.lastIndex = e;
    const s = Hb.exec(i);
    if (s) {
      const n = s[0].slice(1, -1).split("|").map((a) => a.trim());
      t.push(n), e += s[0].length;
    }
    if (!r && !o && !s)
      throw new Error(`Unbalanced parenthesis in: ${i}`);
  }
  return t;
}, GI = ([i, ...e]) => i === void 0 ? [""] : GI(e).flatMap((t) => i.map((r) => r.trim() + " " + t.trim())), _V = (i) => [...new Set(i)], ha = (i) => i[i.length - 1], VI = (i) => i.sort((e, t) => t.length - e.length || e.localeCompare(t)), HI = (i) => i.reduce((e, t) => Math.max(e, t.length), 0), XI = (i) => i.replace(/\s+/gu, " "), Ne = (i) => _V(Object.values(i).flat()), od = (i) => /\n/.test(i), PV = Ne({
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#reserved_keywords
  keywords: ["ALL", "AND", "ANY", "ARRAY", "AS", "ASC", "ASSERT_ROWS_MODIFIED", "AT", "BETWEEN", "BY", "CASE", "CAST", "COLLATE", "CONTAINS", "CREATE", "CROSS", "CUBE", "CURRENT", "DEFAULT", "DEFINE", "DESC", "DISTINCT", "ELSE", "END", "ENUM", "ESCAPE", "EXCEPT", "EXCLUDE", "EXISTS", "EXTRACT", "FALSE", "FETCH", "FOLLOWING", "FOR", "FROM", "FULL", "GROUP", "GROUPING", "GROUPS", "HASH", "HAVING", "IF", "IGNORE", "IN", "INNER", "INTERSECT", "INTERVAL", "INTO", "IS", "JOIN", "LATERAL", "LEFT", "LIKE", "LIMIT", "LOOKUP", "MERGE", "NATURAL", "NEW", "NO", "NOT", "NULL", "NULLS", "OF", "ON", "OR", "ORDER", "OUTER", "OVER", "PARTITION", "PRECEDING", "PROTO", "RANGE", "RECURSIVE", "RESPECT", "RIGHT", "ROLLUP", "ROWS", "SELECT", "SET", "SOME", "STRUCT", "TABLE", "TABLESAMPLE", "THEN", "TO", "TREAT", "TRUE", "UNBOUNDED", "UNION", "UNNEST", "USING", "WHEN", "WHERE", "WINDOW", "WITH", "WITHIN"],
  datatypes: [
    "ARRAY",
    // parametric, ARRAY<T>
    "BOOL",
    "BYTES",
    // parameterised, BYTES(Length)
    "DATE",
    "DATETIME",
    "GEOGRAPHY",
    "INTERVAL",
    "INT64",
    "INT",
    "SMALLINT",
    "INTEGER",
    "BIGINT",
    "TINYINT",
    "BYTEINT",
    "NUMERIC",
    // parameterised, NUMERIC(Precision[, Scale])
    "DECIMAL",
    // parameterised, DECIMAL(Precision[, Scale])
    "BIGNUMERIC",
    // parameterised, BIGNUMERIC(Precision[, Scale])
    "BIGDECIMAL",
    // parameterised, BIGDECIMAL(Precision[, Scale])
    "FLOAT64",
    "STRING",
    // parameterised, STRING(Length)
    "STRUCT",
    // parametric, STRUCT<T>
    "TIME",
    "TIMEZONE"
  ],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/conversion_functions#formatting_syntax
  stringFormat: ["HEX", "BASEX", "BASE64M", "ASCII", "UTF-8", "UTF8"],
  misc: ["SAFE"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  ddl: [
    "LIKE",
    // CREATE TABLE LIKE
    "COPY",
    // CREATE TABLE COPY
    "CLONE",
    // CREATE TABLE CLONE
    "IN",
    "OUT",
    "INOUT",
    "RETURNS",
    "LANGUAGE",
    "CASCADE",
    "RESTRICT",
    "DETERMINISTIC"
  ]
}), LV = Ne({
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aead_encryption_functions
  aead: ["KEYS.NEW_KEYSET", "KEYS.ADD_KEY_FROM_RAW_BYTES", "AEAD.DECRYPT_BYTES", "AEAD.DECRYPT_STRING", "AEAD.ENCRYPT", "KEYS.KEYSET_CHAIN", "KEYS.KEYSET_FROM_JSON", "KEYS.KEYSET_TO_JSON", "KEYS.ROTATE_KEYSET", "KEYS.KEYSET_LENGTH"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_analytic_functions
  aggregateAnalytic: ["ANY_VALUE", "ARRAY_AGG", "AVG", "CORR", "COUNT", "COUNTIF", "COVAR_POP", "COVAR_SAMP", "MAX", "MIN", "ST_CLUSTERDBSCAN", "STDDEV_POP", "STDDEV_SAMP", "STRING_AGG", "SUM", "VAR_POP", "VAR_SAMP"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_functions
  aggregate: ["ANY_VALUE", "ARRAY_AGG", "ARRAY_CONCAT_AGG", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "COUNTIF", "LOGICAL_AND", "LOGICAL_OR", "MAX", "MIN", "STRING_AGG", "SUM"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/approximate_aggregate_functions
  approximateAggregate: ["APPROX_COUNT_DISTINCT", "APPROX_QUANTILES", "APPROX_TOP_COUNT", "APPROX_TOP_SUM"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/array_functions
  array: [
    // 'ARRAY',
    "ARRAY_CONCAT",
    "ARRAY_LENGTH",
    "ARRAY_TO_STRING",
    "GENERATE_ARRAY",
    "GENERATE_DATE_ARRAY",
    "GENERATE_TIMESTAMP_ARRAY",
    "ARRAY_REVERSE",
    "OFFSET",
    "SAFE_OFFSET",
    "ORDINAL",
    "SAFE_ORDINAL"
  ],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/bit_functions
  bitwise: ["BIT_COUNT"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/conversion_functions
  conversion: [
    // 'CASE',
    "PARSE_BIGNUMERIC",
    "PARSE_NUMERIC",
    "SAFE_CAST"
  ],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/date_functions
  date: ["CURRENT_DATE", "EXTRACT", "DATE", "DATE_ADD", "DATE_SUB", "DATE_DIFF", "DATE_TRUNC", "DATE_FROM_UNIX_DATE", "FORMAT_DATE", "LAST_DAY", "PARSE_DATE", "UNIX_DATE"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/datetime_functions
  datetime: ["CURRENT_DATETIME", "DATETIME", "EXTRACT", "DATETIME_ADD", "DATETIME_SUB", "DATETIME_DIFF", "DATETIME_TRUNC", "FORMAT_DATETIME", "LAST_DAY", "PARSE_DATETIME"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/debugging_functions
  debugging: ["ERROR"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/federated_query_functions
  federatedQuery: ["EXTERNAL_QUERY"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions
  geography: ["S2_CELLIDFROMPOINT", "S2_COVERINGCELLIDS", "ST_ANGLE", "ST_AREA", "ST_ASBINARY", "ST_ASGEOJSON", "ST_ASTEXT", "ST_AZIMUTH", "ST_BOUNDARY", "ST_BOUNDINGBOX", "ST_BUFFER", "ST_BUFFERWITHTOLERANCE", "ST_CENTROID", "ST_CENTROID_AGG", "ST_CLOSESTPOINT", "ST_CLUSTERDBSCAN", "ST_CONTAINS", "ST_CONVEXHULL", "ST_COVEREDBY", "ST_COVERS", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_DUMP", "ST_DWITHIN", "ST_ENDPOINT", "ST_EQUALS", "ST_EXTENT", "ST_EXTERIORRING", "ST_GEOGFROM", "ST_GEOGFROMGEOJSON", "ST_GEOGFROMTEXT", "ST_GEOGFROMWKB", "ST_GEOGPOINT", "ST_GEOGPOINTFROMGEOHASH", "ST_GEOHASH", "ST_GEOMETRYTYPE", "ST_INTERIORRINGS", "ST_INTERSECTION", "ST_INTERSECTS", "ST_INTERSECTSBOX", "ST_ISCOLLECTION", "ST_ISEMPTY", "ST_LENGTH", "ST_MAKELINE", "ST_MAKEPOLYGON", "ST_MAKEPOLYGONORIENTED", "ST_MAXDISTANCE", "ST_NPOINTS", "ST_NUMGEOMETRIES", "ST_NUMPOINTS", "ST_PERIMETER", "ST_POINTN", "ST_SIMPLIFY", "ST_SNAPTOGRID", "ST_STARTPOINT", "ST_TOUCHES", "ST_UNION", "ST_UNION_AGG", "ST_WITHIN", "ST_X", "ST_Y"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions
  hash: ["FARM_FINGERPRINT", "MD5", "SHA1", "SHA256", "SHA512"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/hll_functions
  hll: ["HLL_COUNT.INIT", "HLL_COUNT.MERGE", "HLL_COUNT.MERGE_PARTIAL", "HLL_COUNT.EXTRACT"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/interval_functions
  interval: ["MAKE_INTERVAL", "EXTRACT", "JUSTIFY_DAYS", "JUSTIFY_HOURS", "JUSTIFY_INTERVAL"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/json_functions
  json: ["JSON_EXTRACT", "JSON_QUERY", "JSON_EXTRACT_SCALAR", "JSON_VALUE", "JSON_EXTRACT_ARRAY", "JSON_QUERY_ARRAY", "JSON_EXTRACT_STRING_ARRAY", "JSON_VALUE_ARRAY", "TO_JSON_STRING"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/mathematical_functions
  math: ["ABS", "SIGN", "IS_INF", "IS_NAN", "IEEE_DIVIDE", "RAND", "SQRT", "POW", "POWER", "EXP", "LN", "LOG", "LOG10", "GREATEST", "LEAST", "DIV", "SAFE_DIVIDE", "SAFE_MULTIPLY", "SAFE_NEGATE", "SAFE_ADD", "SAFE_SUBTRACT", "MOD", "ROUND", "TRUNC", "CEIL", "CEILING", "FLOOR", "COS", "COSH", "ACOS", "ACOSH", "SIN", "SINH", "ASIN", "ASINH", "TAN", "TANH", "ATAN", "ATANH", "ATAN2", "RANGE_BUCKET"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions
  navigation: ["FIRST_VALUE", "LAST_VALUE", "NTH_VALUE", "LEAD", "LAG", "PERCENTILE_CONT", "PERCENTILE_DISC"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/net_functions
  net: ["NET.IP_FROM_STRING", "NET.SAFE_IP_FROM_STRING", "NET.IP_TO_STRING", "NET.IP_NET_MASK", "NET.IP_TRUNC", "NET.IPV4_FROM_INT64", "NET.IPV4_TO_INT64", "NET.HOST", "NET.PUBLIC_SUFFIX", "NET.REG_DOMAIN"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/numbering_functions
  numbering: ["RANK", "DENSE_RANK", "PERCENT_RANK", "CUME_DIST", "NTILE", "ROW_NUMBER"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/security_functions
  security: ["SESSION_USER"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/statistical_aggregate_functions
  statisticalAggregate: ["CORR", "COVAR_POP", "COVAR_SAMP", "STDDEV_POP", "STDDEV_SAMP", "STDDEV", "VAR_POP", "VAR_SAMP", "VARIANCE"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions
  string: ["ASCII", "BYTE_LENGTH", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHR", "CODE_POINTS_TO_BYTES", "CODE_POINTS_TO_STRING", "CONCAT", "CONTAINS_SUBSTR", "ENDS_WITH", "FORMAT", "FROM_BASE32", "FROM_BASE64", "FROM_HEX", "INITCAP", "INSTR", "LEFT", "LENGTH", "LPAD", "LOWER", "LTRIM", "NORMALIZE", "NORMALIZE_AND_CASEFOLD", "OCTET_LENGTH", "REGEXP_CONTAINS", "REGEXP_EXTRACT", "REGEXP_EXTRACT_ALL", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPLACE", "REPEAT", "REVERSE", "RIGHT", "RPAD", "RTRIM", "SAFE_CONVERT_BYTES_TO_STRING", "SOUNDEX", "SPLIT", "STARTS_WITH", "STRPOS", "SUBSTR", "SUBSTRING", "TO_BASE32", "TO_BASE64", "TO_CODE_POINTS", "TO_HEX", "TRANSLATE", "TRIM", "UNICODE", "UPPER"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/time_functions
  time: ["CURRENT_TIME", "TIME", "EXTRACT", "TIME_ADD", "TIME_SUB", "TIME_DIFF", "TIME_TRUNC", "FORMAT_TIME", "PARSE_TIME"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/timestamp_functions
  timestamp: ["CURRENT_TIMESTAMP", "EXTRACT", "STRING", "TIMESTAMP", "TIMESTAMP_ADD", "TIMESTAMP_SUB", "TIMESTAMP_DIFF", "TIMESTAMP_TRUNC", "FORMAT_TIMESTAMP", "PARSE_TIMESTAMP", "TIMESTAMP_SECONDS", "TIMESTAMP_MILLIS", "TIMESTAMP_MICROS", "UNIX_SECONDS", "UNIX_MILLIS", "UNIX_MICROS"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/uuid_functions
  uuid: ["GENERATE_UUID"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/conditional_expressions
  conditional: ["COALESCE", "IF", "IFNULL", "NULLIF"],
  // https://cloud.google.com/bigquery/docs/reference/legacy-sql
  legacyAggregate: ["AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "EXACT_COUNT_DISTINCT", "FIRST", "GROUP_CONCAT", "GROUP_CONCAT_UNQUOTED", "LAST", "MAX", "MIN", "NEST", "NTH", "QUANTILES", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "TOP", "UNIQUE", "VARIANCE", "VAR_POP", "VAR_SAMP"],
  legacyBitwise: ["BIT_COUNT"],
  legacyCasting: ["BOOLEAN", "BYTES", "CAST", "FLOAT", "HEX_STRING", "INTEGER", "STRING"],
  legacyComparison: [
    // expr 'IN',
    "COALESCE",
    "GREATEST",
    "IFNULL",
    "IS_INF",
    "IS_NAN",
    "IS_EXPLICITLY_DEFINED",
    "LEAST",
    "NVL"
  ],
  legacyDatetime: ["CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE", "DATE_ADD", "DATEDIFF", "DAY", "DAYOFWEEK", "DAYOFYEAR", "FORMAT_UTC_USEC", "HOUR", "MINUTE", "MONTH", "MSEC_TO_TIMESTAMP", "NOW", "PARSE_UTC_USEC", "QUARTER", "SEC_TO_TIMESTAMP", "SECOND", "STRFTIME_UTC_USEC", "TIME", "TIMESTAMP", "TIMESTAMP_TO_MSEC", "TIMESTAMP_TO_SEC", "TIMESTAMP_TO_USEC", "USEC_TO_TIMESTAMP", "UTC_USEC_TO_DAY", "UTC_USEC_TO_HOUR", "UTC_USEC_TO_MONTH", "UTC_USEC_TO_WEEK", "UTC_USEC_TO_YEAR", "WEEK", "YEAR"],
  legacyIp: ["FORMAT_IP", "PARSE_IP", "FORMAT_PACKED_IP", "PARSE_PACKED_IP"],
  legacyJson: ["JSON_EXTRACT", "JSON_EXTRACT_SCALAR"],
  legacyMath: ["ABS", "ACOS", "ACOSH", "ASIN", "ASINH", "ATAN", "ATANH", "ATAN2", "CEIL", "COS", "COSH", "DEGREES", "EXP", "FLOOR", "LN", "LOG", "LOG2", "LOG10", "PI", "POW", "RADIANS", "RAND", "ROUND", "SIN", "SINH", "SQRT", "TAN", "TANH"],
  legacyRegex: ["REGEXP_MATCH", "REGEXP_EXTRACT", "REGEXP_REPLACE"],
  legacyString: [
    "CONCAT",
    // expr CONTAINS 'str'
    "INSTR",
    "LEFT",
    "LENGTH",
    "LOWER",
    "LPAD",
    "LTRIM",
    "REPLACE",
    "RIGHT",
    "RPAD",
    "RTRIM",
    "SPLIT",
    "SUBSTR",
    "UPPER"
  ],
  legacyTableWildcard: ["TABLE_DATE_RANGE", "TABLE_DATE_RANGE_STRICT", "TABLE_QUERY"],
  legacyUrl: ["HOST", "DOMAIN", "TLD"],
  legacyWindow: ["AVG", "COUNT", "MAX", "MIN", "STDDEV", "SUM", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "RATIO_TO_REPORT", "ROW_NUMBER"],
  legacyMisc: ["CURRENT_USER", "EVERY", "FROM_BASE64", "HASH", "FARM_FINGERPRINT", "IF", "POSITION", "SHA1", "SOME", "TO_BASE64"],
  other: ["BQ.JOBS.CANCEL", "BQ.REFRESH_MATERIALIZED_VIEW"],
  ddl: ["OPTIONS"],
  pivot: ["PIVOT", "UNPIVOT"],
  // Data types with parameters like VARCHAR(100)
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#parameterized_data_types
  dataTypes: ["BYTES", "NUMERIC", "DECIMAL", "BIGNUMERIC", "BIGDECIMAL", "STRING"]
}), wV = V(["SELECT [ALL | DISTINCT] [AS STRUCT | AS VALUE]"]), yV = V([
  // Queries: https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "QUALIFY",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "OMIT RECORD IF",
  // legacy
  // Data modification: https://cloud.google.com/bigquery/docs/reference/standard-sql/dml-syntax
  // - insert:
  "INSERT [INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [BY SOURCE | BY TARGET] [THEN]",
  "UPDATE SET",
  // Data definition, https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  "CREATE [OR REPLACE] [MATERIALIZED] VIEW [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [TEMP|TEMPORARY|SNAPSHOT|EXTERNAL] TABLE [IF NOT EXISTS]",
  "CLUSTER BY",
  "FOR SYSTEM_TIME AS OF",
  // CREATE SNAPSHOT TABLE
  "WITH CONNECTION",
  "WITH PARTITION COLUMNS",
  "REMOTE WITH CONNECTION"
]), Yb = V([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP [SNAPSHOT | EXTERNAL] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "ADD COLUMN [IF NOT EXISTS]",
  "DROP COLUMN [IF EXISTS]",
  "RENAME TO",
  "ALTER COLUMN [IF EXISTS]",
  "SET DEFAULT COLLATE",
  // for alter column
  "SET OPTIONS",
  // for alter column
  "DROP NOT NULL",
  // for alter column
  "SET DATA TYPE",
  // for alter column
  // - alter schema
  "ALTER SCHEMA [IF EXISTS]",
  // - alter view
  "ALTER [MATERIALIZED] VIEW [IF EXISTS]",
  // - alter bi_capacity
  "ALTER BI_CAPACITY",
  // - truncate:
  "TRUNCATE TABLE",
  // - create schema
  "CREATE SCHEMA [IF NOT EXISTS]",
  "DEFAULT COLLATE",
  // stored procedures
  "CREATE [OR REPLACE] [TEMP|TEMPORARY|TABLE] FUNCTION [IF NOT EXISTS]",
  "CREATE [OR REPLACE] PROCEDURE [IF NOT EXISTS]",
  // row access policy
  "CREATE [OR REPLACE] ROW ACCESS POLICY [IF NOT EXISTS]",
  "GRANT TO",
  "FILTER USING",
  // capacity
  "CREATE CAPACITY",
  "AS JSON",
  // reservation
  "CREATE RESERVATION",
  // assignment
  "CREATE ASSIGNMENT",
  // search index
  "CREATE SEARCH INDEX [IF NOT EXISTS]",
  // drop
  "DROP SCHEMA [IF EXISTS]",
  "DROP [MATERIALIZED] VIEW [IF EXISTS]",
  "DROP [TABLE] FUNCTION [IF EXISTS]",
  "DROP PROCEDURE [IF EXISTS]",
  "DROP ROW ACCESS POLICY",
  "DROP ALL ROW ACCESS POLICIES",
  "DROP CAPACITY [IF EXISTS]",
  "DROP RESERVATION [IF EXISTS]",
  "DROP ASSIGNMENT [IF EXISTS]",
  "DROP SEARCH INDEX [IF EXISTS]",
  "DROP [IF EXISTS]",
  // DCL, https://cloud.google.com/bigquery/docs/reference/standard-sql/data-control-language
  "GRANT",
  "REVOKE",
  // Script, https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting
  "DECLARE",
  "EXECUTE IMMEDIATE",
  "LOOP",
  "END LOOP",
  "REPEAT",
  "END REPEAT",
  "WHILE",
  "END WHILE",
  "BREAK",
  "LEAVE",
  "CONTINUE",
  "ITERATE",
  "FOR",
  "END FOR",
  "BEGIN",
  "BEGIN TRANSACTION",
  "COMMIT TRANSACTION",
  "ROLLBACK TRANSACTION",
  "RAISE",
  "RETURN",
  "CALL",
  // Debug, https://cloud.google.com/bigquery/docs/reference/standard-sql/debugging-statements
  "ASSERT",
  // Other, https://cloud.google.com/bigquery/docs/reference/standard-sql/other-statements
  "EXPORT DATA"
]), DV = V(["UNION {ALL | DISTINCT}", "EXCEPT DISTINCT", "INTERSECT DISTINCT"]), xV = V(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN"]), MV = V([
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#tablesample_operator
  "TABLESAMPLE SYSTEM",
  // From DDL: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  "ANY TYPE",
  "ALL COLUMNS",
  "NOT DETERMINISTIC",
  // inside window definitions
  "{ROWS | RANGE} BETWEEN",
  // comparison operator
  "IS [NOT] DISTINCT FROM"
]), UV = {
  tokenizerOptions: {
    reservedSelect: wV,
    reservedClauses: [...yV, ...Yb],
    reservedSetOperations: DV,
    reservedJoins: xV,
    reservedPhrases: MV,
    reservedKeywords: PV,
    reservedFunctionNames: LV,
    extraParens: ["[]"],
    stringTypes: [
      // The triple-quoted strings are listed first, so they get matched first.
      // Otherwise the first two quotes of """ will get matched as an empty "" string.
      {
        quote: '""".."""',
        prefixes: ["R", "B", "RB", "BR"]
      },
      {
        quote: "'''..'''",
        prefixes: ["R", "B", "RB", "BR"]
      },
      '""-bs',
      "''-bs",
      {
        quote: '""-raw',
        prefixes: ["R", "B", "RB", "BR"],
        requirePrefix: !0
      },
      {
        quote: "''-raw",
        prefixes: ["R", "B", "RB", "BR"],
        requirePrefix: !0
      }
    ],
    identTypes: ["``"],
    identChars: {
      dashes: !0
    },
    paramTypes: {
      positional: !0,
      named: ["@"],
      quoted: ["@"]
    },
    variableTypes: [{
      regex: String.raw`@@\w+`
    }],
    lineCommentTypes: ["--", "#"],
    operators: ["&", "|", "^", "~", ">>", "<<", "||", "=>"],
    postProcess: QV
  },
  formatOptions: {
    onelineClauses: Yb
  }
};
function QV(i) {
  return kV($V(i));
}
function kV(i) {
  let e = rs;
  return i.map((t) => t.text === "OFFSET" && e.text === "[" ? (e = t, {
    ...t,
    type: k.RESERVED_FUNCTION_NAME
  }) : (e = t, t));
}
function $V(i) {
  const e = [];
  for (let r = 0; r < i.length; r++) {
    var t;
    const o = i[r];
    if ((Ro.ARRAY(o) || Ro.STRUCT(o)) && ((t = i[r + 1]) === null || t === void 0 ? void 0 : t.text) === "<") {
      const s = GV(i, r + 1), n = i.slice(r, s + 1);
      e.push({
        type: k.IDENTIFIER,
        raw: n.map(Bb("raw")).join(""),
        text: n.map(Bb("text")).join(""),
        start: o.start
      }), r = s;
    } else
      e.push(o);
  }
  return e;
}
const Bb = (i) => (e) => e.type === k.IDENTIFIER || e.type === k.COMMA ? e[i] + " " : e[i];
function GV(i, e) {
  let t = 0;
  for (let r = e; r < i.length; r++) {
    const o = i[r];
    if (o.text === "<" ? t++ : o.text === ">" ? t-- : o.text === ">>" && (t -= 2), t === 0)
      return r;
  }
  return i.length - 1;
}
const VV = Ne({
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-aggregate
  aggregate: ["ARRAY_AGG", "AVG", "CORR", "CORRELATION", "COUNT", "COUNT_BIG", "COVAR_POP", "COVARIANCE", "COVAR", "COVAR_SAMP", "COVARIANCE_SAMP", "CUME_DIST", "GROUPING", "LISTAGG", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_ICPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "STDDEV_POP", "STDDEV", "STDDEV_SAMP", "SUM", "VAR_POP", "VARIANCE", "VAR", "VAR_SAMP", "VARIANCE_SAMP", "XMLAGG"],
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-scalar
  scalar: ["ABS", "ABSVAL", "ACOS", "ADD_DAYS", "ADD_MONTHS", "ARRAY_DELETE", "ARRAY_FIRST", "ARRAY_LAST", "ARRAY_NEXT", "ARRAY_PRIOR", "ARRAY_TRIM", "ASCII", "ASCII_CHR", "ASCII_STR", "ASCIISTR", "ASIN", "ATAN", "ATANH", "ATAN2", "BIGINT", "BINARY", "BITAND", "BITANDNOT", "BITOR", "BITXOR", "BITNOT", "BLOB", "BTRIM", "CARDINALITY", "CCSID_ENCODING", "CEILING", "CEIL", "CHAR", "CHAR9", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHR", "CLOB", "COALESCE", "COLLATION_KEY", "COMPARE_DECFLOAT", "CONCAT", "CONTAINS", "COS", "COSH", "DATE", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFWEEK_ISO", "DAYOFYEAR", "DAYS", "DAYS_BETWEEN", "DBCLOB", "DECFLOAT", "DECFLOAT_FORMAT", "DECFLOAT_SORTKEY", "DECIMAL", "DEC", "DECODE", "DECRYPT_BINARY", "DECRYPT_BIT", "DECRYPT_CHAR", "DECRYPT_DB", "DECRYPT_DATAKEY_BIGINT", "DECRYPT_DATAKEY_BIT", "DECRYPT_DATAKEY_CLOB", "DECRYPT_DATAKEY_DBCLOB", "DECRYPT_DATAKEY_DECIMAL", "DECRYPT_DATAKEY_INTEGER", "DECRYPT_DATAKEY_VARCHAR", "DECRYPT_DATAKEY_VARGRAPHIC", "DEGREES", "DIFFERENCE", "DIGITS", "DOUBLE_PRECISION", "DOUBLE", "DSN_XMLVALIDATE", "EBCDIC_CHR", "EBCDIC_STR", "ENCRYPT_DATAKEY", "ENCRYPT_TDES", "EXP", "EXTRACT", "FLOAT", "FLOOR", "GENERATE_UNIQUE", "GENERATE_UNIQUE_BINARY", "GETHINT", "GETVARIABLE", "GRAPHIC", "GREATEST", "HASH", "HASH_CRC32", "HASH_MD5", "HASH_SHA1", "HASH_SHA256", "HEX", "HOUR", "IDENTITY_VAL_LOCAL", "IFNULL", "INSERT", "INSTR", "INTEGER", "INT", "JULIAN_DAY", "LAST_DAY", "LCASE", "LEAST", "LEFT", "LENGTH", "LN", "LOCATE", "LOCATE_IN_STRING", "LOG10", "LOWER", "LPAD", "LTRIM", "MAX", "MAX_CARDINALITY", "MICROSECOND", "MIDNIGHT_SECONDS", "MIN", "MINUTE", "MOD", "MONTH", "MONTHS_BETWEEN", "MQREAD", "MQREADCLOB", "MQRECEIVE", "MQRECEIVECLOB", "MQSEND", "MULTIPLY_ALT", "NEXT_DAY", "NEXT_MONTH", "NORMALIZE_DECFLOAT", "NORMALIZE_STRING", "NULLIF", "NVL", "OVERLAY", "PACK", "POSITION", "POSSTR", "POWER", "POW", "QUANTIZE", "QUARTER", "RADIANS", "RAISE_ERROR", "RANDOM", "RAND", "REAL", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_LIKE", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPEAT", "REPLACE", "RID", "RIGHT", "ROUND", "ROUND_TIMESTAMP", "ROWID", "RPAD", "RTRIM", "SCORE", "SECOND", "SIGN", "SIN", "SINH", "SMALLINT", "SOUNDEX", "SOAPHTTPC", "SOAPHTTPV", "SOAPHTTPNC", "SOAPHTTPNV", "SPACE", "SQRT", "STRIP", "STRLEFT", "STRPOS", "STRRIGHT", "SUBSTR", "SUBSTRING", "TAN", "TANH", "TIME", "TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIMESTAMP_FORMAT", "TIMESTAMP_ISO", "TIMESTAMP_TZ", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_NUMBER", "TOTALORDER", "TO_TIMESTAMP", "TRANSLATE", "TRIM", "TRIM_ARRAY", "TRUNCATE", "TRUNC", "TRUNC_TIMESTAMP", "UCASE", "UNICODE", "UNICODE_STR", "UNISTR", "UPPER", "VALUE", "VARBINARY", "VARCHAR", "VARCHAR9", "VARCHAR_BIT_FORMAT", "VARCHAR_FORMAT", "VARGRAPHIC", "VERIFY_GROUP_FOR_USER", "VERIFY_ROLE_FOR_USER", "VERIFY_TRUSTED_CONTEXT_ROLE_FOR_USER", "WEEK", "WEEK_ISO", "WRAP", "XMLATTRIBUTES", "XMLCOMMENT", "XMLCONCAT", "XMLDOCUMENT", "XMLELEMENT", "XMLFOREST", "XMLMODIFY", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLSERIALIZE", "XMLTEXT", "XMLXSROBJECTID", "XSLTRANSFORM", "YEAR"],
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-table
  table: ["ADMIN_TASK_LIST", "ADMIN_TASK_OUTPUT", "ADMIN_TASK_STATUS", "BLOCKING_THREADS", "MQREADALL", "MQREADALLCLOB", "MQRECEIVEALL", "MQRECEIVEALLCLOB", "XMLTABLE"],
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-row
  row: ["UNPACK"],
  // https://www.ibm.com/docs/en/db2-for-zos/12?topic=expressions-olap-specification
  olap: ["CUME_DIST", "PERCENT_RANK", "RANK", "DENSE_RANK", "NTILE", "LAG", "LEAD", "ROW_NUMBER", "FIRST_VALUE", "LAST_VALUE", "NTH_VALUE", "RATIO_TO_REPORT"],
  // Type casting
  cast: ["CAST"]
}), HV = Ne({
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=words-reserved#db2z_reservedwords__newresword
  standard: ["ALL", "ALLOCATE", "ALLOW", "ALTERAND", "ANY", "AS", "ARRAY", "ARRAY_EXISTS", "ASENSITIVE", "ASSOCIATE", "ASUTIME", "AT", "AUDIT", "AUX", "AUXILIARY", "BEFORE", "BEGIN", "BETWEEN", "BUFFERPOOL", "BY", "CAPTURE", "CASCADED", "CAST", "CCSID", "CHARACTER", "CHECK", "CLONE", "CLUSTER", "COLLECTION", "COLLID", "COLUMN", "CONDITION", "CONNECTION", "CONSTRAINT", "CONTENT", "CONTINUE", "CREATE", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_LC_CTYPE", "CURRENT_PATH", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRVAL", "CURSOR", "DATA", "DATABASE", "DBINFO", "DECLARE", "DEFAULT", "DESCRIPTOR", "DETERMINISTIC", "DISABLE", "DISALLOW", "DISTINCT", "DO", "DOCUMENT", "DSSIZE", "DYNAMIC", "EDITPROC", "ELSE", "ELSEIF", "ENCODING", "ENCRYPTION", "ENDING", "END-EXEC", "ERASE", "ESCAPE", "EXCEPTION", "EXISTS", "EXIT", "EXTERNAL", "FENCED", "FIELDPROC", "FINAL", "FIRST", "FOR", "FREE", "FULL", "FUNCTION", "GENERATED", "GET", "GLOBAL", "GOTO", "GROUP", "HANDLER", "HOLD", "HOURS", "IF", "IMMEDIATE", "IN", "INCLUSIVE", "INDEX", "INHERIT", "INNER", "INOUT", "INSENSITIVE", "INTO", "IS", "ISOBID", "ITERATE", "JAR", "KEEP", "KEY", "LANGUAGE", "LAST", "LC_CTYPE", "LEAVE", "LIKE", "LOCAL", "LOCALE", "LOCATOR", "LOCATORS", "LOCK", "LOCKMAX", "LOCKSIZE", "LONG", "LOOP", "MAINTAINED", "MATERIALIZED", "MICROSECONDS", "MINUTEMINUTES", "MODIFIES", "MONTHS", "NEXT", "NEXTVAL", "NO", "NONE", "NOT", "NULL", "NULLS", "NUMPARTS", "OBID", "OF", "OLD", "ON", "OPTIMIZATION", "OPTIMIZE", "ORDER", "ORGANIZATION", "OUT", "OUTER", "PACKAGE", "PARAMETER", "PART", "PADDED", "PARTITION", "PARTITIONED", "PARTITIONING", "PATH", "PIECESIZE", "PERIOD", "PLAN", "PRECISION", "PREVVAL", "PRIOR", "PRIQTY", "PRIVILEGES", "PROCEDURE", "PROGRAM", "PSID", "PUBLIC", "QUERY", "QUERYNO", "READS", "REFERENCES", "RESIGNAL", "RESTRICT", "RESULT", "RESULT_SET_LOCATOR", "RETURN", "RETURNS", "ROLE", "ROLLUP", "ROUND_CEILING", "ROUND_DOWN", "ROUND_FLOOR", "ROUND_HALF_DOWN", "ROUND_HALF_EVEN", "ROUND_HALF_UP", "ROUND_UP", "ROW", "ROWSET", "SCHEMA", "SCRATCHPAD", "SECONDS", "SECQTY", "SECURITY", "SEQUENCE", "SENSITIVE", "SESSION_USER", "SIMPLE", "SOME", "SOURCE", "SPECIFIC", "STANDARD", "STATIC", "STATEMENT", "STAY", "STOGROUP", "STORES", "STYLE", "SUMMARY", "SYNONYM", "SYSDATE", "SYSTEM", "SYSTIMESTAMP", "TABLE", "TABLESPACE", "THEN", "TO", "TRIGGER", "TYPE", "UNDO", "UNIQUE", "UNTIL", "USER", "USING", "VALIDPROC", "VARIABLE", "VARIANT", "VCAT", "VERSIONING", "VIEW", "VOLATILE", "VOLUMES", "WHILE", "WLM", "XMLEXISTS", "XMLCAST", "YEARS", "ZONE"]
}), XV = V(["SELECT [ALL | DISTINCT]"]), YV = V([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY [INPUT SEQUENCE]",
  "FETCH FIRST",
  // Data modification
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  "INSERT",
  // Data definition
  "CREATE [OR REPLACE] VIEW",
  "CREATE [GLOBAL TEMPORARY] TABLE"
]), Fb = V([
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  "WITH {RR | RS | CS | UR}",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [HIERARCHY]",
  // alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [COLUMN]",
  "ALTER [COLUMN]",
  "SET DATA TYPE",
  // for alter column
  "SET NOT NULL",
  // for alter column
  "DROP {IDENTITY | EXPRESSION | DEFAULT | NOT NULL}",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // other
  "SET [CURRENT] SCHEMA",
  "AFTER",
  "GO",
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=statements-list-supported
  "ALLOCATE CURSOR",
  "ALTER DATABASE",
  "ALTER FUNCTION",
  "ALTER INDEX",
  "ALTER MASK",
  "ALTER PERMISSION",
  "ALTER PROCEDURE",
  "ALTER SEQUENCE",
  "ALTER STOGROUP",
  "ALTER TABLESPACE",
  "ALTER TRIGGER",
  "ALTER TRUSTED CONTEXT",
  "ALTER VIEW",
  "ASSOCIATE LOCATORS",
  "BEGIN DECLARE SECTION",
  "CALL",
  "CLOSE",
  "COMMENT",
  "COMMIT",
  "CONNECT",
  "CREATE ALIAS",
  "CREATE AUXILIARY TABLE",
  "CREATE DATABASE",
  "CREATE FUNCTION",
  "CREATE GLOBAL TEMPORARY TABLE",
  "CREATE INDEX",
  "CREATE LOB TABLESPACE",
  "CREATE MASK",
  "CREATE PERMISSION",
  "CREATE PROCEDURE",
  "CREATE ROLE",
  "CREATE SEQUENCE",
  "CREATE STOGROUP",
  "CREATE SYNONYM",
  "CREATE TABLESPACE",
  "CREATE TRIGGER",
  "CREATE TRUSTED CONTEXT",
  "CREATE TYPE",
  "CREATE VARIABLE",
  "DECLARE CURSOR",
  "DECLARE GLOBAL TEMPORARY TABLE",
  "DECLARE STATEMENT",
  "DECLARE TABLE",
  "DECLARE VARIABLE",
  "DESCRIBE CURSOR",
  "DESCRIBE INPUT",
  "DESCRIBE OUTPUT",
  "DESCRIBE PROCEDURE",
  "DESCRIBE TABLE",
  "DROP",
  "END DECLARE SECTION",
  "EXCHANGE",
  "EXECUTE",
  "EXECUTE IMMEDIATE",
  "EXPLAIN",
  "FETCH",
  "FREE LOCATOR",
  "GET DIAGNOSTICS",
  "GRANT",
  "HOLD LOCATOR",
  "INCLUDE",
  "LABEL",
  "LOCK TABLE",
  "OPEN",
  "PREPARE",
  "REFRESH",
  "RELEASE",
  "RELEASE SAVEPOINT",
  "RENAME",
  "REVOKE",
  "ROLLBACK",
  "SAVEPOINT",
  "SELECT INTO",
  "SET CONNECTION",
  "SET CURRENT ACCELERATOR",
  "SET CURRENT APPLICATION COMPATIBILITY",
  "SET CURRENT APPLICATION ENCODING SCHEME",
  "SET CURRENT DEBUG MODE",
  "SET CURRENT DECFLOAT ROUNDING MODE",
  "SET CURRENT DEGREE",
  "SET CURRENT EXPLAIN MODE",
  "SET CURRENT GET_ACCEL_ARCHIVE",
  "SET CURRENT LOCALE LC_CTYPE",
  "SET CURRENT MAINTAINED TABLE TYPES FOR OPTIMIZATION",
  "SET CURRENT OPTIMIZATION HINT",
  "SET CURRENT PACKAGE PATH",
  "SET CURRENT PACKAGESET",
  "SET CURRENT PRECISION",
  "SET CURRENT QUERY ACCELERATION",
  "SET CURRENT QUERY ACCELERATION WAITFORDATA",
  "SET CURRENT REFRESH AGE",
  "SET CURRENT ROUTINE VERSION",
  "SET CURRENT RULES",
  "SET CURRENT SQLID",
  "SET CURRENT TEMPORAL BUSINESS_TIME",
  "SET CURRENT TEMPORAL SYSTEM_TIME",
  "SET ENCRYPTION PASSWORD",
  "SET PATH",
  "SET SESSION TIME ZONE",
  "SIGNAL",
  "VALUES INTO",
  "WHENEVER"
]), BV = V(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]), FV = V(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN"]), WV = V(["ON DELETE", "ON UPDATE", "SET NULL", "{ROWS | RANGE} BETWEEN"]), zV = {
  tokenizerOptions: {
    reservedSelect: XV,
    reservedClauses: [...YV, ...Fb],
    reservedSetOperations: BV,
    reservedJoins: FV,
    reservedPhrases: WV,
    reservedKeywords: HV,
    reservedFunctionNames: VV,
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["G", "N", "U&"]
    }, {
      quote: "''-raw",
      prefixes: ["X", "BX", "GX", "UX"],
      requirePrefix: !0
    }],
    identTypes: ['""-qq'],
    identChars: {
      first: "@#$"
    },
    paramTypes: {
      positional: !0,
      named: [":"]
    },
    paramChars: {
      first: "@#$",
      rest: "@#$"
    },
    operators: ["**", "¬=", "¬>", "¬<", "!>", "!<", "||"]
  },
  formatOptions: {
    onelineClauses: Fb
  }
}, ZV = Ne({
  // https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF
  math: [
    "ABS",
    "ACOS",
    "ASIN",
    "ATAN",
    "BIN",
    "BROUND",
    "CBRT",
    "CEIL",
    "CEILING",
    "CONV",
    "COS",
    "DEGREES",
    // 'E',
    "EXP",
    "FACTORIAL",
    "FLOOR",
    "GREATEST",
    "HEX",
    "LEAST",
    "LN",
    "LOG",
    "LOG10",
    "LOG2",
    "NEGATIVE",
    "PI",
    "PMOD",
    "POSITIVE",
    "POW",
    "POWER",
    "RADIANS",
    "RAND",
    "ROUND",
    "SHIFTLEFT",
    "SHIFTRIGHT",
    "SHIFTRIGHTUNSIGNED",
    "SIGN",
    "SIN",
    "SQRT",
    "TAN",
    "UNHEX",
    "WIDTH_BUCKET"
  ],
  array: ["ARRAY_CONTAINS", "MAP_KEYS", "MAP_VALUES", "SIZE", "SORT_ARRAY"],
  conversion: ["BINARY", "CAST"],
  date: ["ADD_MONTHS", "DATE", "DATE_ADD", "DATE_FORMAT", "DATE_SUB", "DATEDIFF", "DAY", "DAYNAME", "DAYOFMONTH", "DAYOFYEAR", "EXTRACT", "FROM_UNIXTIME", "FROM_UTC_TIMESTAMP", "HOUR", "LAST_DAY", "MINUTE", "MONTH", "MONTHS_BETWEEN", "NEXT_DAY", "QUARTER", "SECOND", "TIMESTAMP", "TO_DATE", "TO_UTC_TIMESTAMP", "TRUNC", "UNIX_TIMESTAMP", "WEEKOFYEAR", "YEAR"],
  conditional: ["ASSERT_TRUE", "COALESCE", "IF", "ISNOTNULL", "ISNULL", "NULLIF", "NVL"],
  string: ["ASCII", "BASE64", "CHARACTER_LENGTH", "CHR", "CONCAT", "CONCAT_WS", "CONTEXT_NGRAMS", "DECODE", "ELT", "ENCODE", "FIELD", "FIND_IN_SET", "FORMAT_NUMBER", "GET_JSON_OBJECT", "IN_FILE", "INITCAP", "INSTR", "LCASE", "LENGTH", "LEVENSHTEIN", "LOCATE", "LOWER", "LPAD", "LTRIM", "NGRAMS", "OCTET_LENGTH", "PARSE_URL", "PRINTF", "QUOTE", "REGEXP_EXTRACT", "REGEXP_REPLACE", "REPEAT", "REVERSE", "RPAD", "RTRIM", "SENTENCES", "SOUNDEX", "SPACE", "SPLIT", "STR_TO_MAP", "SUBSTR", "SUBSTRING", "TRANSLATE", "TRIM", "UCASE", "UNBASE64", "UPPER"],
  masking: ["MASK", "MASK_FIRST_N", "MASK_HASH", "MASK_LAST_N", "MASK_SHOW_FIRST_N", "MASK_SHOW_LAST_N"],
  misc: ["AES_DECRYPT", "AES_ENCRYPT", "CRC32", "CURRENT_DATABASE", "CURRENT_USER", "HASH", "JAVA_METHOD", "LOGGED_IN_USER", "MD5", "REFLECT", "SHA", "SHA1", "SHA2", "SURROGATE_KEY", "VERSION"],
  aggregate: ["AVG", "COLLECT_LIST", "COLLECT_SET", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "HISTOGRAM_NUMERIC", "MAX", "MIN", "NTILE", "PERCENTILE", "PERCENTILE_APPROX", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE"],
  table: ["EXPLODE", "INLINE", "JSON_TUPLE", "PARSE_URL_TUPLE", "POSEXPLODE", "STACK"],
  // https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics
  window: ["LEAD", "LAG", "FIRST_VALUE", "LAST_VALUE", "RANK", "ROW_NUMBER", "DENSE_RANK", "CUME_DIST", "PERCENT_RANK", "NTILE"],
  // Parameterized data types
  // https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=82706456
  // Though in reality Hive only supports parameters for DECIMAL(),
  // it doesn't hurt to allow others in here as well.
  dataTypes: ["DECIMAL", "NUMERIC", "VARCHAR", "CHAR"]
}), qV = Ne({
  // https://cwiki.apache.org/confluence/display/hive/languagemanual+ddl
  // Non-reserved keywords have proscribed meanings in. HiveQL, but can still be used as table or column names
  nonReserved: ["ADD", "ADMIN", "AFTER", "ANALYZE", "ARCHIVE", "ASC", "BEFORE", "BUCKET", "BUCKETS", "CASCADE", "CHANGE", "CLUSTER", "CLUSTERED", "CLUSTERSTATUS", "COLLECTION", "COLUMNS", "COMMENT", "COMPACT", "COMPACTIONS", "COMPUTE", "CONCATENATE", "CONTINUE", "DATA", "DATABASES", "DATETIME", "DAY", "DBPROPERTIES", "DEFERRED", "DEFINED", "DELIMITED", "DEPENDENCY", "DESC", "DIRECTORIES", "DIRECTORY", "DISABLE", "DISTRIBUTE", "ELEM_TYPE", "ENABLE", "ESCAPED", "EXCLUSIVE", "EXPLAIN", "EXPORT", "FIELDS", "FILE", "FILEFORMAT", "FIRST", "FORMAT", "FORMATTED", "FUNCTIONS", "HOLD_DDLTIME", "HOUR", "IDXPROPERTIES", "IGNORE", "INDEX", "INDEXES", "INPATH", "INPUTDRIVER", "INPUTFORMAT", "ITEMS", "JAR", "KEYS", "KEY_TYPE", "LIMIT", "LINES", "LOAD", "LOCATION", "LOCK", "LOCKS", "LOGICAL", "LONG", "MAPJOIN", "MATERIALIZED", "METADATA", "MINUS", "MINUTE", "MONTH", "MSCK", "NOSCAN", "NO_DROP", "OFFLINE", "OPTION", "OUTPUTDRIVER", "OUTPUTFORMAT", "OVERWRITE", "OWNER", "PARTITIONED", "PARTITIONS", "PLUS", "PRETTY", "PRINCIPALS", "PROTECTION", "PURGE", "READ", "READONLY", "REBUILD", "RECORDREADER", "RECORDWRITER", "RELOAD", "RENAME", "REPAIR", "REPLACE", "REPLICATION", "RESTRICT", "REWRITE", "ROLE", "ROLES", "SCHEMA", "SCHEMAS", "SECOND", "SEMI", "SERDE", "SERDEPROPERTIES", "SERVER", "SETS", "SHARED", "SHOW", "SHOW_DATABASE", "SKEWED", "SORT", "SORTED", "SSL", "STATISTICS", "STORED", "STREAMTABLE", "STRING", "STRUCT", "TABLES", "TBLPROPERTIES", "TEMPORARY", "TERMINATED", "TINYINT", "TOUCH", "TRANSACTIONS", "UNARCHIVE", "UNDO", "UNIONTYPE", "UNLOCK", "UNSET", "UNSIGNED", "URI", "USE", "UTC", "UTCTIMESTAMP", "VALUE_TYPE", "VIEW", "WHILE", "YEAR", "AUTOCOMMIT", "ISOLATION", "LEVEL", "OFFSET", "SNAPSHOT", "TRANSACTION", "WORK", "WRITE", "ABORT", "KEY", "LAST", "NORELY", "NOVALIDATE", "NULLS", "RELY", "VALIDATE", "DETAIL", "DOW", "EXPRESSION", "OPERATOR", "QUARTER", "SUMMARY", "VECTORIZATION", "WEEK", "YEARS", "MONTHS", "WEEKS", "DAYS", "HOURS", "MINUTES", "SECONDS", "TIMESTAMPTZ", "ZONE"],
  reserved: ["ALL", "ALTER", "AND", "ARRAY", "AS", "AUTHORIZATION", "BETWEEN", "BIGINT", "BINARY", "BOOLEAN", "BOTH", "BY", "CASE", "CAST", "CHAR", "COLUMN", "CONF", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_TIMESTAMP", "CURSOR", "DATABASE", "DATE", "DECIMAL", "DELETE", "DESCRIBE", "DISTINCT", "DOUBLE", "DROP", "ELSE", "END", "EXCHANGE", "EXISTS", "EXTENDED", "EXTERNAL", "FALSE", "FETCH", "FLOAT", "FOLLOWING", "FOR", "FROM", "FULL", "FUNCTION", "GRANT", "GROUP", "GROUPING", "HAVING", "IF", "IMPORT", "IN", "INNER", "INSERT", "INT", "INTERSECT", "INTERVAL", "INTO", "IS", "JOIN", "LATERAL", "LEFT", "LESS", "LIKE", "LOCAL", "MACRO", "MAP", "MORE", "NONE", "NOT", "NULL", "OF", "ON", "OR", "ORDER", "OUT", "OUTER", "OVER", "PARTIALSCAN", "PARTITION", "PERCENT", "PRECEDING", "PRESERVE", "PROCEDURE", "RANGE", "READS", "REDUCE", "REVOKE", "RIGHT", "ROLLUP", "ROW", "ROWS", "SELECT", "SET", "SMALLINT", "TABLE", "TABLESAMPLE", "THEN", "TIMESTAMP", "TO", "TRANSFORM", "TRIGGER", "TRUE", "TRUNCATE", "UNBOUNDED", "UNION", "UNIQUEJOIN", "UPDATE", "USER", "USING", "UTC_TMESTAMP", "VALUES", "VARCHAR", "WHEN", "WHERE", "WINDOW", "WITH", "COMMIT", "ONLY", "REGEXP", "RLIKE", "ROLLBACK", "START", "CACHE", "CONSTRAINT", "FOREIGN", "PRIMARY", "REFERENCES", "DAYOFWEEK", "EXTRACT", "FLOOR", "INTEGER", "PRECISION", "VIEWS", "TIME", "NUMERIC", "SYNC"],
  fileTypes: ["TEXTFILE", "SEQUENCEFILE", "ORC", "CSV", "TSV", "PARQUET", "AVRO", "RCFILE", "JSONFILE", "INPUTFORMAT", "OUTPUTFORMAT"]
}), jV = V(["SELECT [ALL | DISTINCT]"]), KV = V([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "SORT BY",
  "CLUSTER BY",
  "DISTRIBUTE BY",
  "LIMIT",
  // Data manipulation
  // - insert:
  //   Hive does not actually support plain INSERT INTO, only INSERT INTO TABLE
  //   but it's a nuisance to not support it, as all other dialects do.
  "INSERT INTO [TABLE]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  "INSERT [VALUES]",
  // - insert overwrite directory:
  //   https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML#LanguageManualDML-Writingdataintothefilesystemfromqueries
  "INSERT OVERWRITE [LOCAL] DIRECTORY",
  // - load:
  //   https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML#LanguageManualDML-Loadingfilesintotables
  "LOAD DATA [LOCAL] INPATH",
  "[OVERWRITE] INTO TABLE",
  // Data definition
  "CREATE [MATERIALIZED] VIEW [IF NOT EXISTS]",
  "CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS]"
]), Wb = V([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "RENAME TO",
  // - truncate:
  "TRUNCATE [TABLE]",
  // other
  "ALTER",
  "CREATE",
  "USE",
  "DESCRIBE",
  "DROP",
  "FETCH",
  "SHOW",
  "STORED AS",
  "STORED BY",
  "ROW FORMAT"
]), JV = V(["UNION [ALL | DISTINCT]"]), eH = V([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  // non-standard joins
  "LEFT SEMI JOIN"
]), tH = V(["{ROWS | RANGE} BETWEEN"]), iH = {
  tokenizerOptions: {
    reservedSelect: jV,
    reservedClauses: [...KV, ...Wb],
    reservedSetOperations: JV,
    reservedJoins: eH,
    reservedPhrases: tH,
    reservedKeywords: qV,
    reservedFunctionNames: ZV,
    extraParens: ["[]"],
    stringTypes: ['""-bs', "''-bs"],
    identTypes: ["``"],
    variableTypes: [{
      quote: "{}",
      prefixes: ["$"],
      requirePrefix: !0
    }],
    operators: ["%", "~", "^", "|", "&", "<=>", "==", "!", "||"]
  },
  formatOptions: {
    onelineClauses: Wb
  }
}, rH = Ne({
  // https://mariadb.com/kb/en/information-schema-keywords-table/
  all: [
    "ACCESSIBLE",
    "ACCOUNT",
    "ACTION",
    "ADD",
    "ADMIN",
    "AFTER",
    "AGAINST",
    "AGGREGATE",
    "ALL",
    "ALGORITHM",
    "ALTER",
    "ALWAYS",
    "ANALYZE",
    "AND",
    "ANY",
    "AS",
    "ASC",
    "ASCII",
    "ASENSITIVE",
    "AT",
    "ATOMIC",
    "AUTHORS",
    "AUTO_INCREMENT",
    "AUTOEXTEND_SIZE",
    "AUTO",
    "AVG",
    "AVG_ROW_LENGTH",
    "BACKUP",
    "BEFORE",
    "BEGIN",
    "BETWEEN",
    "BIGINT",
    "BINARY",
    "BINLOG",
    "BIT",
    "BLOB",
    "BLOCK",
    "BODY",
    "BOOL",
    "BOOLEAN",
    "BOTH",
    "BTREE",
    "BY",
    "BYTE",
    "CACHE",
    "CALL",
    "CASCADE",
    "CASCADED",
    "CASE",
    "CATALOG_NAME",
    "CHAIN",
    "CHANGE",
    "CHANGED",
    "CHAR",
    "CHARACTER",
    "CHARSET",
    "CHECK",
    "CHECKPOINT",
    "CHECKSUM",
    "CIPHER",
    "CLASS_ORIGIN",
    "CLIENT",
    "CLOB",
    "CLOSE",
    "COALESCE",
    "CODE",
    "COLLATE",
    "COLLATION",
    "COLUMN",
    "COLUMN_NAME",
    "COLUMNS",
    "COLUMN_ADD",
    "COLUMN_CHECK",
    "COLUMN_CREATE",
    "COLUMN_DELETE",
    "COLUMN_GET",
    "COMMENT",
    "COMMIT",
    "COMMITTED",
    "COMPACT",
    "COMPLETION",
    "COMPRESSED",
    "CONCURRENT",
    "CONDITION",
    "CONNECTION",
    "CONSISTENT",
    "CONSTRAINT",
    "CONSTRAINT_CATALOG",
    "CONSTRAINT_NAME",
    "CONSTRAINT_SCHEMA",
    "CONTAINS",
    "CONTEXT",
    "CONTINUE",
    "CONTRIBUTORS",
    "CONVERT",
    "CPU",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_DATE",
    "CURRENT_POS",
    "CURRENT_ROLE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "CURSOR",
    "CURSOR_NAME",
    "CYCLE",
    "DATA",
    "DATABASE",
    "DATABASES",
    "DATAFILE",
    "DATE",
    "DATETIME",
    "DAY",
    "DAY_HOUR",
    "DAY_MICROSECOND",
    "DAY_MINUTE",
    "DAY_SECOND",
    "DEALLOCATE",
    "DEC",
    "DECIMAL",
    "DECLARE",
    "DEFAULT",
    "DEFINER",
    "DELAYED",
    "DELAY_KEY_WRITE",
    "DELETE",
    "DELETE_DOMAIN_ID",
    "DESC",
    "DESCRIBE",
    "DES_KEY_FILE",
    "DETERMINISTIC",
    "DIAGNOSTICS",
    "DIRECTORY",
    "DISABLE",
    "DISCARD",
    "DISK",
    "DISTINCT",
    "DISTINCTROW",
    "DIV",
    "DO",
    "DOUBLE",
    "DO_DOMAIN_IDS",
    "DROP",
    "DUAL",
    "DUMPFILE",
    "DUPLICATE",
    "DYNAMIC",
    "EACH",
    "ELSE",
    "ELSEIF",
    "ELSIF",
    "EMPTY",
    "ENABLE",
    "ENCLOSED",
    "END",
    "ENDS",
    "ENGINE",
    "ENGINES",
    "ENUM",
    "ERROR",
    "ERRORS",
    "ESCAPE",
    "ESCAPED",
    "EVENT",
    "EVENTS",
    "EVERY",
    "EXAMINED",
    "EXCEPT",
    "EXCHANGE",
    "EXCLUDE",
    "EXECUTE",
    "EXCEPTION",
    "EXISTS",
    "EXIT",
    "EXPANSION",
    "EXPIRE",
    "EXPORT",
    "EXPLAIN",
    "EXTENDED",
    "EXTENT_SIZE",
    "FALSE",
    "FAST",
    "FAULTS",
    "FEDERATED",
    "FETCH",
    "FIELDS",
    "FILE",
    "FIRST",
    "FIXED",
    "FLOAT",
    "FLOAT4",
    "FLOAT8",
    "FLUSH",
    "FOLLOWING",
    "FOLLOWS",
    "FOR",
    "FORCE",
    "FOREIGN",
    "FORMAT",
    "FOUND",
    "FROM",
    "FULL",
    "FULLTEXT",
    "FUNCTION",
    "GENERAL",
    "GENERATED",
    "GET_FORMAT",
    "GET",
    "GLOBAL",
    "GOTO",
    "GRANT",
    "GRANTS",
    "GROUP",
    "HANDLER",
    "HARD",
    "HASH",
    "HAVING",
    "HELP",
    "HIGH_PRIORITY",
    "HISTORY",
    "HOST",
    "HOSTS",
    "HOUR",
    "HOUR_MICROSECOND",
    "HOUR_MINUTE",
    "HOUR_SECOND",
    // 'ID', // conflicts with common column name
    "IDENTIFIED",
    "IF",
    "IGNORE",
    "IGNORED",
    "IGNORE_DOMAIN_IDS",
    "IGNORE_SERVER_IDS",
    "IMMEDIATE",
    "IMPORT",
    "INTERSECT",
    "IN",
    "INCREMENT",
    "INDEX",
    "INDEXES",
    "INFILE",
    "INITIAL_SIZE",
    "INNER",
    "INOUT",
    "INSENSITIVE",
    "INSERT",
    "INSERT_METHOD",
    "INSTALL",
    "INT",
    "INT1",
    "INT2",
    "INT3",
    "INT4",
    "INT8",
    "INTEGER",
    "INTERVAL",
    "INVISIBLE",
    "INTO",
    "IO",
    "IO_THREAD",
    "IPC",
    "IS",
    "ISOLATION",
    "ISOPEN",
    "ISSUER",
    "ITERATE",
    "INVOKER",
    "JOIN",
    "JSON",
    "JSON_TABLE",
    "KEY",
    "KEYS",
    "KEY_BLOCK_SIZE",
    "KILL",
    "LANGUAGE",
    "LAST",
    "LAST_VALUE",
    "LASTVAL",
    "LEADING",
    "LEAVE",
    "LEAVES",
    "LEFT",
    "LESS",
    "LEVEL",
    "LIKE",
    "LIMIT",
    "LINEAR",
    "LINES",
    "LIST",
    "LOAD",
    "LOCAL",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCK",
    "LOCKED",
    "LOCKS",
    "LOGFILE",
    "LOGS",
    "LONG",
    "LONGBLOB",
    "LONGTEXT",
    "LOOP",
    "LOW_PRIORITY",
    "MASTER",
    "MASTER_CONNECT_RETRY",
    "MASTER_DELAY",
    "MASTER_GTID_POS",
    "MASTER_HOST",
    "MASTER_LOG_FILE",
    "MASTER_LOG_POS",
    "MASTER_PASSWORD",
    "MASTER_PORT",
    "MASTER_SERVER_ID",
    "MASTER_SSL",
    "MASTER_SSL_CA",
    "MASTER_SSL_CAPATH",
    "MASTER_SSL_CERT",
    "MASTER_SSL_CIPHER",
    "MASTER_SSL_CRL",
    "MASTER_SSL_CRLPATH",
    "MASTER_SSL_KEY",
    "MASTER_SSL_VERIFY_SERVER_CERT",
    "MASTER_USER",
    "MASTER_USE_GTID",
    "MASTER_HEARTBEAT_PERIOD",
    "MATCH",
    "MAX_CONNECTIONS_PER_HOUR",
    "MAX_QUERIES_PER_HOUR",
    "MAX_ROWS",
    "MAX_SIZE",
    "MAX_STATEMENT_TIME",
    "MAX_UPDATES_PER_HOUR",
    "MAX_USER_CONNECTIONS",
    "MAXVALUE",
    "MEDIUM",
    "MEDIUMBLOB",
    "MEDIUMINT",
    "MEDIUMTEXT",
    "MEMORY",
    "MERGE",
    "MESSAGE_TEXT",
    "MICROSECOND",
    "MIDDLEINT",
    "MIGRATE",
    "MINUS",
    "MINUTE",
    "MINUTE_MICROSECOND",
    "MINUTE_SECOND",
    "MINVALUE",
    "MIN_ROWS",
    "MOD",
    "MODE",
    "MODIFIES",
    "MODIFY",
    "MONITOR",
    "MONTH",
    "MUTEX",
    "MYSQL",
    "MYSQL_ERRNO",
    "NAME",
    "NAMES",
    "NATIONAL",
    "NATURAL",
    "NCHAR",
    "NESTED",
    "NEVER",
    "NEW",
    "NEXT",
    "NEXTVAL",
    "NO",
    "NOMAXVALUE",
    "NOMINVALUE",
    "NOCACHE",
    "NOCYCLE",
    "NO_WAIT",
    "NOWAIT",
    "NODEGROUP",
    "NONE",
    "NOT",
    "NOTFOUND",
    "NO_WRITE_TO_BINLOG",
    "NULL",
    "NUMBER",
    "NUMERIC",
    "NVARCHAR",
    "OF",
    "OFFSET",
    "OLD_PASSWORD",
    "ON",
    "ONE",
    "ONLINE",
    "ONLY",
    "OPEN",
    "OPTIMIZE",
    "OPTIONS",
    "OPTION",
    "OPTIONALLY",
    "OR",
    "ORDER",
    "ORDINALITY",
    "OTHERS",
    "OUT",
    "OUTER",
    "OUTFILE",
    "OVER",
    "OVERLAPS",
    "OWNER",
    "PACKAGE",
    "PACK_KEYS",
    "PAGE",
    "PAGE_CHECKSUM",
    "PARSER",
    "PARSE_VCOL_EXPR",
    "PATH",
    "PERIOD",
    "PARTIAL",
    "PARTITION",
    "PARTITIONING",
    "PARTITIONS",
    "PASSWORD",
    "PERSISTENT",
    "PHASE",
    "PLUGIN",
    "PLUGINS",
    "PORT",
    "PORTION",
    "PRECEDES",
    "PRECEDING",
    "PRECISION",
    "PREPARE",
    "PRESERVE",
    "PREV",
    "PREVIOUS",
    "PRIMARY",
    "PRIVILEGES",
    "PROCEDURE",
    "PROCESS",
    "PROCESSLIST",
    "PROFILE",
    "PROFILES",
    "PROXY",
    "PURGE",
    "QUARTER",
    "QUERY",
    "QUICK",
    "RAISE",
    "RANGE",
    "RAW",
    "READ",
    "READ_ONLY",
    "READ_WRITE",
    "READS",
    "REAL",
    "REBUILD",
    "RECOVER",
    "RECURSIVE",
    "REDO_BUFFER_SIZE",
    "REDOFILE",
    "REDUNDANT",
    "REFERENCES",
    "REGEXP",
    "RELAY",
    "RELAYLOG",
    "RELAY_LOG_FILE",
    "RELAY_LOG_POS",
    "RELAY_THREAD",
    "RELEASE",
    "RELOAD",
    "REMOVE",
    "RENAME",
    "REORGANIZE",
    "REPAIR",
    "REPEATABLE",
    "REPLACE",
    "REPLAY",
    "REPLICA",
    "REPLICAS",
    "REPLICA_POS",
    "REPLICATION",
    "REPEAT",
    "REQUIRE",
    "RESET",
    "RESIGNAL",
    "RESTART",
    "RESTORE",
    "RESTRICT",
    "RESUME",
    "RETURNED_SQLSTATE",
    "RETURN",
    "RETURNING",
    "RETURNS",
    "REUSE",
    "REVERSE",
    "REVOKE",
    "RIGHT",
    "RLIKE",
    "ROLE",
    "ROLLBACK",
    "ROLLUP",
    "ROUTINE",
    "ROW",
    "ROWCOUNT",
    "ROWNUM",
    "ROWS",
    "ROWTYPE",
    "ROW_COUNT",
    "ROW_FORMAT",
    "RTREE",
    "SAVEPOINT",
    "SCHEDULE",
    "SCHEMA",
    "SCHEMA_NAME",
    "SCHEMAS",
    "SECOND",
    "SECOND_MICROSECOND",
    "SECURITY",
    "SELECT",
    "SENSITIVE",
    "SEPARATOR",
    "SEQUENCE",
    "SERIAL",
    "SERIALIZABLE",
    "SESSION",
    "SERVER",
    "SET",
    "SETVAL",
    "SHARE",
    "SHOW",
    "SHUTDOWN",
    "SIGNAL",
    "SIGNED",
    "SIMPLE",
    "SKIP",
    "SLAVE",
    "SLAVES",
    "SLAVE_POS",
    "SLOW",
    "SNAPSHOT",
    "SMALLINT",
    "SOCKET",
    "SOFT",
    "SOME",
    "SONAME",
    "SOUNDS",
    "SOURCE",
    "STAGE",
    "STORED",
    "SPATIAL",
    "SPECIFIC",
    "REF_SYSTEM_ID",
    "SQL",
    "SQLEXCEPTION",
    "SQLSTATE",
    "SQLWARNING",
    "SQL_BIG_RESULT",
    "SQL_BUFFER_RESULT",
    "SQL_CACHE",
    "SQL_CALC_FOUND_ROWS",
    "SQL_NO_CACHE",
    "SQL_SMALL_RESULT",
    "SQL_THREAD",
    "SQL_TSI_SECOND",
    "SQL_TSI_MINUTE",
    "SQL_TSI_HOUR",
    "SQL_TSI_DAY",
    "SQL_TSI_WEEK",
    "SQL_TSI_MONTH",
    "SQL_TSI_QUARTER",
    "SQL_TSI_YEAR",
    "SSL",
    "START",
    "STARTING",
    "STARTS",
    "STATEMENT",
    "STATS_AUTO_RECALC",
    "STATS_PERSISTENT",
    "STATS_SAMPLE_PAGES",
    "STATUS",
    "STOP",
    "STORAGE",
    "STRAIGHT_JOIN",
    "STRING",
    "SUBCLASS_ORIGIN",
    "SUBJECT",
    "SUBPARTITION",
    "SUBPARTITIONS",
    "SUPER",
    "SUSPEND",
    "SWAPS",
    "SWITCHES",
    "SYSDATE",
    "SYSTEM",
    "SYSTEM_TIME",
    "TABLE",
    "TABLE_NAME",
    "TABLES",
    "TABLESPACE",
    "TABLE_CHECKSUM",
    "TEMPORARY",
    "TEMPTABLE",
    "TERMINATED",
    "TEXT",
    "THAN",
    "THEN",
    "TIES",
    "TIME",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TINYBLOB",
    "TINYINT",
    "TINYTEXT",
    "TO",
    "TRAILING",
    "TRANSACTION",
    "TRANSACTIONAL",
    "THREADS",
    "TRIGGER",
    "TRIGGERS",
    "TRUE",
    "TRUNCATE",
    "TYPE",
    "TYPES",
    "UNBOUNDED",
    "UNCOMMITTED",
    "UNDEFINED",
    "UNDO_BUFFER_SIZE",
    "UNDOFILE",
    "UNDO",
    "UNICODE",
    "UNION",
    "UNIQUE",
    "UNKNOWN",
    "UNLOCK",
    "UNINSTALL",
    "UNSIGNED",
    "UNTIL",
    "UPDATE",
    "UPGRADE",
    "USAGE",
    "USE",
    "USER",
    "USER_RESOURCES",
    "USE_FRM",
    "USING",
    "UTC_DATE",
    "UTC_TIME",
    "UTC_TIMESTAMP",
    "VALUE",
    "VALUES",
    "VARBINARY",
    "VARCHAR",
    "VARCHARACTER",
    "VARCHAR2",
    "VARIABLES",
    "VARYING",
    "VIA",
    "VIEW",
    "VIRTUAL",
    "VISIBLE",
    "VERSIONING",
    "WAIT",
    "WARNINGS",
    "WEEK",
    "WEIGHT_STRING",
    "WHEN",
    "WHERE",
    "WHILE",
    "WINDOW",
    "WITH",
    "WITHIN",
    "WITHOUT",
    "WORK",
    "WRAPPER",
    "WRITE",
    "X509",
    "XOR",
    "XA",
    "XML",
    "YEAR",
    "YEAR_MONTH",
    "ZEROFILL"
  ]
}), oH = Ne({
  // https://mariadb.com/kb/en/information-schema-sql_functions-table/
  all: [
    "ADDDATE",
    "ADD_MONTHS",
    "BIT_AND",
    "BIT_OR",
    "BIT_XOR",
    "CAST",
    "COUNT",
    "CUME_DIST",
    "CURDATE",
    "CURTIME",
    "DATE_ADD",
    "DATE_SUB",
    "DATE_FORMAT",
    "DECODE",
    "DENSE_RANK",
    "EXTRACT",
    "FIRST_VALUE",
    "GROUP_CONCAT",
    "JSON_ARRAYAGG",
    "JSON_OBJECTAGG",
    "LAG",
    "LEAD",
    "MAX",
    "MEDIAN",
    "MID",
    "MIN",
    "NOW",
    "NTH_VALUE",
    "NTILE",
    "POSITION",
    "PERCENT_RANK",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC",
    "RANK",
    "ROW_NUMBER",
    "SESSION_USER",
    "STD",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "SUBDATE",
    "SUBSTR",
    "SUBSTRING",
    "SUM",
    "SYSTEM_USER",
    "TRIM",
    "TRIM_ORACLE",
    "VARIANCE",
    "VAR_POP",
    "VAR_SAMP",
    "ABS",
    "ACOS",
    "ADDTIME",
    "AES_DECRYPT",
    "AES_ENCRYPT",
    "ASIN",
    "ATAN",
    "ATAN2",
    "BENCHMARK",
    "BIN",
    "BINLOG_GTID_POS",
    "BIT_COUNT",
    "BIT_LENGTH",
    "CEIL",
    "CEILING",
    "CHARACTER_LENGTH",
    "CHAR_LENGTH",
    "CHR",
    "COERCIBILITY",
    "COLUMN_CHECK",
    "COLUMN_EXISTS",
    "COLUMN_LIST",
    "COLUMN_JSON",
    "COMPRESS",
    "CONCAT",
    "CONCAT_OPERATOR_ORACLE",
    "CONCAT_WS",
    "CONNECTION_ID",
    "CONV",
    "CONVERT_TZ",
    "COS",
    "COT",
    "CRC32",
    "DATEDIFF",
    "DAYNAME",
    "DAYOFMONTH",
    "DAYOFWEEK",
    "DAYOFYEAR",
    "DEGREES",
    "DECODE_HISTOGRAM",
    "DECODE_ORACLE",
    "DES_DECRYPT",
    "DES_ENCRYPT",
    "ELT",
    "ENCODE",
    "ENCRYPT",
    "EXP",
    "EXPORT_SET",
    "EXTRACTVALUE",
    "FIELD",
    "FIND_IN_SET",
    "FLOOR",
    "FORMAT",
    "FOUND_ROWS",
    "FROM_BASE64",
    "FROM_DAYS",
    "FROM_UNIXTIME",
    "GET_LOCK",
    "GREATEST",
    "HEX",
    "IFNULL",
    "INSTR",
    "ISNULL",
    "IS_FREE_LOCK",
    "IS_USED_LOCK",
    "JSON_ARRAY",
    "JSON_ARRAY_APPEND",
    "JSON_ARRAY_INSERT",
    "JSON_COMPACT",
    "JSON_CONTAINS",
    "JSON_CONTAINS_PATH",
    "JSON_DEPTH",
    "JSON_DETAILED",
    "JSON_EXISTS",
    "JSON_EXTRACT",
    "JSON_INSERT",
    "JSON_KEYS",
    "JSON_LENGTH",
    "JSON_LOOSE",
    "JSON_MERGE",
    "JSON_MERGE_PATCH",
    "JSON_MERGE_PRESERVE",
    "JSON_QUERY",
    "JSON_QUOTE",
    "JSON_OBJECT",
    "JSON_REMOVE",
    "JSON_REPLACE",
    "JSON_SET",
    "JSON_SEARCH",
    "JSON_TYPE",
    "JSON_UNQUOTE",
    "JSON_VALID",
    "JSON_VALUE",
    "LAST_DAY",
    "LAST_INSERT_ID",
    "LCASE",
    "LEAST",
    "LENGTH",
    "LENGTHB",
    "LN",
    "LOAD_FILE",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG2",
    "LOWER",
    "LPAD",
    "LPAD_ORACLE",
    "LTRIM",
    "LTRIM_ORACLE",
    "MAKEDATE",
    "MAKETIME",
    "MAKE_SET",
    "MASTER_GTID_WAIT",
    "MASTER_POS_WAIT",
    "MD5",
    "MONTHNAME",
    "NAME_CONST",
    "NVL",
    "NVL2",
    "OCT",
    "OCTET_LENGTH",
    "ORD",
    "PERIOD_ADD",
    "PERIOD_DIFF",
    "PI",
    "POW",
    "POWER",
    "QUOTE",
    "REGEXP_INSTR",
    "REGEXP_REPLACE",
    "REGEXP_SUBSTR",
    "RADIANS",
    "RAND",
    "RELEASE_ALL_LOCKS",
    "RELEASE_LOCK",
    "REPLACE_ORACLE",
    "REVERSE",
    "ROUND",
    "RPAD",
    "RPAD_ORACLE",
    "RTRIM",
    "RTRIM_ORACLE",
    "SEC_TO_TIME",
    "SHA",
    "SHA1",
    "SHA2",
    "SIGN",
    "SIN",
    "SLEEP",
    "SOUNDEX",
    "SPACE",
    "SQRT",
    "STRCMP",
    "STR_TO_DATE",
    "SUBSTR_ORACLE",
    "SUBSTRING_INDEX",
    "SUBTIME",
    "SYS_GUID",
    "TAN",
    "TIMEDIFF",
    "TIME_FORMAT",
    "TIME_TO_SEC",
    "TO_BASE64",
    "TO_CHAR",
    "TO_DAYS",
    "TO_SECONDS",
    "UCASE",
    "UNCOMPRESS",
    "UNCOMPRESSED_LENGTH",
    "UNHEX",
    "UNIX_TIMESTAMP",
    "UPDATEXML",
    "UPPER",
    "UUID",
    "UUID_SHORT",
    "VERSION",
    "WEEKDAY",
    "WEEKOFYEAR",
    "WSREP_LAST_WRITTEN_GTID",
    "WSREP_LAST_SEEN_GTID",
    "WSREP_SYNC_WAIT_UPTO_GTID",
    "YEARWEEK",
    // CASE expression shorthands
    "COALESCE",
    "NULLIF",
    // Data types with parameters
    // https://mariadb.com/kb/en/data-types/
    "TINYINT",
    "SMALLINT",
    "MEDIUMINT",
    "INT",
    "INTEGER",
    "BIGINT",
    "DECIMAL",
    "DEC",
    "NUMERIC",
    "FIXED",
    // 'NUMBER', // ?? In oracle mode only
    "FLOAT",
    "DOUBLE",
    "DOUBLE PRECISION",
    "REAL",
    "BIT",
    "BINARY",
    "BLOB",
    "CHAR",
    "NATIONAL CHAR",
    "CHAR BYTE",
    "ENUM",
    "VARBINARY",
    "VARCHAR",
    "NATIONAL VARCHAR",
    // 'SET' // handled as special-case in postProcess
    "TIME",
    "DATETIME",
    "TIMESTAMP",
    "YEAR"
  ]
}), sH = V(["SELECT [ALL | DISTINCT | DISTINCTROW]"]), nH = V([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]",
  "REPLACE [LOW_PRIORITY | DELAYED] [INTO]",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [TEMPORARY] TABLE [IF NOT EXISTS]",
  // other
  "RETURNING"
]), zb = V([
  // - update:
  "UPDATE [LOW_PRIORITY] [IGNORE]",
  // - delete:
  "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER [ONLINE] [IGNORE] TABLE [IF EXISTS]",
  "ADD [COLUMN] [IF NOT EXISTS]",
  "{CHANGE | MODIFY} [COLUMN] [IF EXISTS]",
  "DROP [COLUMN] [IF EXISTS]",
  "RENAME [TO]",
  "RENAME COLUMN",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  // for alter column
  "SET {VISIBLE | INVISIBLE}",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://mariadb.com/docs/reference/mdb/sql-statements/
  "ALTER DATABASE",
  "ALTER DATABASE COMMENT",
  "ALTER EVENT",
  "ALTER FUNCTION",
  "ALTER PROCEDURE",
  "ALTER SCHEMA",
  "ALTER SCHEMA COMMENT",
  "ALTER SEQUENCE",
  "ALTER SERVER",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE",
  "ANALYZE TABLE",
  "BACKUP LOCK",
  "BACKUP STAGE",
  "BACKUP UNLOCK",
  "BEGIN",
  "BINLOG",
  "CACHE INDEX",
  "CALL",
  "CHANGE MASTER TO",
  "CHECK TABLE",
  "CHECK VIEW",
  "CHECKSUM TABLE",
  "COMMIT",
  "CREATE AGGREGATE FUNCTION",
  "CREATE DATABASE",
  "CREATE EVENT",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE PROCEDURE",
  "CREATE ROLE",
  "CREATE SEQUENCE",
  "CREATE SERVER",
  "CREATE SPATIAL INDEX",
  "CREATE TRIGGER",
  "CREATE UNIQUE INDEX",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DROP DATABASE",
  "DROP EVENT",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP PREPARE",
  "DROP PROCEDURE",
  "DROP ROLE",
  "DROP SEQUENCE",
  "DROP SERVER",
  "DROP TRIGGER",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "GET DIAGNOSTICS",
  "GET DIAGNOSTICS CONDITION",
  "GRANT",
  "HANDLER",
  "HELP",
  "INSTALL PLUGIN",
  "INSTALL SONAME",
  "KILL",
  "LOAD DATA INFILE",
  "LOAD INDEX INTO CACHE",
  "LOAD XML INFILE",
  "LOCK TABLE",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "PURGE MASTER LOGS",
  "RELEASE SAVEPOINT",
  "RENAME TABLE",
  "RENAME USER",
  "REPAIR TABLE",
  "REPAIR VIEW",
  "RESET MASTER",
  "RESET QUERY CACHE",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESIGNAL",
  "REVOKE",
  "ROLLBACK",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET GLOBAL TRANSACTION",
  "SET NAMES",
  "SET PASSWORD",
  "SET ROLE",
  "SET STATEMENT",
  "SET TRANSACTION",
  "SHOW",
  "SHOW ALL REPLICAS STATUS",
  "SHOW ALL SLAVES STATUS",
  "SHOW AUTHORS",
  "SHOW BINARY LOGS",
  "SHOW BINLOG EVENTS",
  "SHOW BINLOG STATUS",
  "SHOW CHARACTER SET",
  "SHOW CLIENT_STATISTICS",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CONTRIBUTORS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE EVENT",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PACKAGE",
  "SHOW CREATE PACKAGE BODY",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE SEQUENCE",
  "SHOW CREATE TABLE",
  "SHOW CREATE TRIGGER",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINE INNODB STATUS",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW EVENTS",
  "SHOW EXPLAIN",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW INDEXES",
  "SHOW INDEX_STATISTICS",
  "SHOW KEYS",
  "SHOW LOCALES",
  "SHOW MASTER LOGS",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PACKAGE BODY CODE",
  "SHOW PACKAGE BODY STATUS",
  "SHOW PACKAGE STATUS",
  "SHOW PLUGINS",
  "SHOW PLUGINS SONAME",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW QUERY_RESPONSE_TIME",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA",
  "SHOW REPLICA HOSTS",
  "SHOW REPLICA STATUS",
  "SHOW SCHEMAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW SLAVE STATUS",
  "SHOW STATUS",
  "SHOW STORAGE ENGINES",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW TRIGGERS",
  "SHOW USER_STATISTICS",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHOW WSREP_MEMBERSHIP",
  "SHOW WSREP_STATUS",
  "SHUTDOWN",
  "SIGNAL",
  "START ALL REPLICAS",
  "START ALL SLAVES",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP ALL REPLICAS",
  "STOP ALL SLAVES",
  "STOP REPLICA",
  "STOP SLAVE",
  "UNINSTALL PLUGIN",
  "UNINSTALL SONAME",
  "UNLOCK TABLE",
  "USE",
  "XA BEGIN",
  "XA COMMIT",
  "XA END",
  "XA PREPARE",
  "XA RECOVER",
  "XA ROLLBACK",
  "XA START"
]), aH = V(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]", "MINUS [ALL | DISTINCT]"]), lH = V([
  "JOIN",
  "{LEFT | RIGHT} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]), uH = V(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "CHARACTER SET", "{ROWS | RANGE} BETWEEN"]), hH = {
  tokenizerOptions: {
    reservedSelect: sH,
    reservedClauses: [...nH, ...zb],
    reservedSetOperations: aH,
    reservedJoins: lH,
    reservedPhrases: uH,
    supportsXor: !0,
    reservedKeywords: rH,
    reservedFunctionNames: oH,
    // TODO: support _ char set prefixes such as _utf8, _latin1, _binary, _utf8mb4, etc.
    stringTypes: ['""-qq-bs', "''-qq-bs", {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    identChars: {
      first: "$",
      rest: "$",
      allowFirstCharNumber: !0
    },
    variableTypes: [{
      regex: "@@?[A-Za-z0-9_.$]+"
    }, {
      quote: '""-qq-bs',
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "''-qq-bs",
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "``",
      prefixes: ["@"],
      requirePrefix: !0
    }],
    paramTypes: {
      positional: !0
    },
    lineCommentTypes: ["--", "#"],
    operators: ["%", ":=", "&", "|", "^", "~", "<<", ">>", "<=>", "&&", "||", "!"],
    postProcess: cH
  },
  formatOptions: {
    onelineClauses: zb
  }
};
function cH(i) {
  return i.map((e, t) => {
    const r = i[t + 1] || rs;
    return Ro.SET(e) && r.text === "(" ? {
      ...e,
      type: k.RESERVED_FUNCTION_NAME
    } : e;
  });
}
const dH = Ne({
  // https://dev.mysql.com/doc/refman/8.0/en/keywords.html
  all: [
    "ACCESSIBLE",
    // (R)
    "ACCOUNT",
    "ACTION",
    "ACTIVE",
    "ADD",
    // (R)
    "ADMIN",
    "AFTER",
    "AGAINST",
    "AGGREGATE",
    "ALGORITHM",
    "ALL",
    // (R)
    "ALTER",
    // (R)
    "ALWAYS",
    "ANALYZE",
    // (R)
    "AND",
    // (R)
    "ANY",
    "ARRAY",
    "AS",
    // (R)
    "ASC",
    // (R)
    "ASCII",
    "ASENSITIVE",
    // (R)
    "AT",
    "ATTRIBUTE",
    "AUTHENTICATION",
    "AUTOEXTEND_SIZE",
    "AUTO_INCREMENT",
    "AVG",
    "AVG_ROW_LENGTH",
    "BACKUP",
    "BEFORE",
    // (R)
    "BEGIN",
    "BETWEEN",
    // (R)
    "BIGINT",
    // (R)
    "BINARY",
    // (R)
    "BINLOG",
    "BIT",
    "BLOB",
    // (R)
    "BLOCK",
    "BOOL",
    "BOOLEAN",
    "BOTH",
    // (R)
    "BTREE",
    "BUCKETS",
    "BY",
    // (R)
    "BYTE",
    "CACHE",
    "CALL",
    // (R)
    "CASCADE",
    // (R)
    "CASCADED",
    "CASE",
    // (R)
    "CATALOG_NAME",
    "CHAIN",
    "CHALLENGE_RESPONSE",
    "CHANGE",
    // (R)
    "CHANGED",
    "CHANNEL",
    "CHAR",
    // (R)
    "CHARACTER",
    // (R)
    "CHARSET",
    "CHECK",
    // (R)
    "CHECKSUM",
    "CIPHER",
    "CLASS_ORIGIN",
    "CLIENT",
    "CLONE",
    "CLOSE",
    "COALESCE",
    "CODE",
    "COLLATE",
    // (R)
    "COLLATION",
    "COLUMN",
    // (R)
    "COLUMNS",
    "COLUMN_FORMAT",
    "COLUMN_NAME",
    "COMMENT",
    "COMMIT",
    "COMMITTED",
    "COMPACT",
    "COMPLETION",
    "COMPONENT",
    "COMPRESSED",
    "COMPRESSION",
    "CONCURRENT",
    "CONDITION",
    // (R)
    "CONNECTION",
    "CONSISTENT",
    "CONSTRAINT",
    // (R)
    "CONSTRAINT_CATALOG",
    "CONSTRAINT_NAME",
    "CONSTRAINT_SCHEMA",
    "CONTAINS",
    "CONTEXT",
    "CONTINUE",
    // (R)
    "CONVERT",
    // (R)
    "CPU",
    "CREATE",
    // (R)
    "CROSS",
    // (R)
    "CUBE",
    // (R)
    "CUME_DIST",
    // (R)
    "CURRENT",
    "CURRENT_DATE",
    // (R)
    "CURRENT_TIME",
    // (R)
    "CURRENT_TIMESTAMP",
    // (R)
    "CURRENT_USER",
    // (R)
    "CURSOR",
    // (R)
    "CURSOR_NAME",
    "DATA",
    "DATABASE",
    // (R)
    "DATABASES",
    // (R)
    "DATAFILE",
    "DATE",
    "DATETIME",
    "DAY",
    "DAY_HOUR",
    // (R)
    "DAY_MICROSECOND",
    // (R)
    "DAY_MINUTE",
    // (R)
    "DAY_SECOND",
    // (R)
    "DEALLOCATE",
    "DEC",
    // (R)
    "DECIMAL",
    // (R)
    "DECLARE",
    // (R)
    "DEFAULT",
    // (R)
    "DEFAULT_AUTH",
    "DEFINER",
    "DEFINITION",
    "DELAYED",
    // (R)
    "DELAY_KEY_WRITE",
    "DELETE",
    // (R)
    "DENSE_RANK",
    // (R)
    "DESC",
    // (R)
    "DESCRIBE",
    // (R)
    "DESCRIPTION",
    "DETERMINISTIC",
    // (R)
    "DIAGNOSTICS",
    "DIRECTORY",
    "DISABLE",
    "DISCARD",
    "DISK",
    "DISTINCT",
    // (R)
    "DISTINCTROW",
    // (R)
    "DIV",
    // (R)
    "DO",
    "DOUBLE",
    // (R)
    "DROP",
    // (R)
    "DUAL",
    // (R)
    "DUMPFILE",
    "DUPLICATE",
    "DYNAMIC",
    "EACH",
    // (R)
    "ELSE",
    // (R)
    "ELSEIF",
    // (R)
    "EMPTY",
    // (R)
    "ENABLE",
    "ENCLOSED",
    // (R)
    "ENCRYPTION",
    "END",
    "ENDS",
    "ENFORCED",
    "ENGINE",
    "ENGINES",
    "ENGINE_ATTRIBUTE",
    "ENUM",
    "ERROR",
    "ERRORS",
    "ESCAPE",
    "ESCAPED",
    // (R)
    "EVENT",
    "EVENTS",
    "EVERY",
    "EXCEPT",
    // (R)
    "EXCHANGE",
    "EXCLUDE",
    "EXECUTE",
    "EXISTS",
    // (R)
    "EXIT",
    // (R)
    "EXPANSION",
    "EXPIRE",
    "EXPLAIN",
    // (R)
    "EXPORT",
    "EXTENDED",
    "EXTENT_SIZE",
    "FACTOR",
    "FAILED_LOGIN_ATTEMPTS",
    "FALSE",
    // (R)
    "FAST",
    "FAULTS",
    "FETCH",
    // (R)
    "FIELDS",
    "FILE",
    "FILE_BLOCK_SIZE",
    "FILTER",
    "FINISH",
    "FIRST",
    "FIRST_VALUE",
    // (R)
    "FIXED",
    "FLOAT",
    // (R)
    "FLOAT4",
    // (R)
    "FLOAT8",
    // (R)
    "FLUSH",
    "FOLLOWING",
    "FOLLOWS",
    "FOR",
    // (R)
    "FORCE",
    // (R)
    "FOREIGN",
    // (R)
    "FORMAT",
    "FOUND",
    "FROM",
    // (R)
    "FULL",
    "FULLTEXT",
    // (R)
    "FUNCTION",
    // (R)
    "GENERAL",
    "GENERATED",
    // (R)
    "GEOMCOLLECTION",
    "GEOMETRY",
    "GEOMETRYCOLLECTION",
    "GET",
    // (R)
    "GET_FORMAT",
    "GET_MASTER_PUBLIC_KEY",
    "GET_SOURCE_PUBLIC_KEY",
    "GLOBAL",
    "GRANT",
    // (R)
    "GRANTS",
    "GROUP",
    // (R)
    "GROUPING",
    // (R)
    "GROUPS",
    // (R)
    "GROUP_REPLICATION",
    "GTID_ONLY",
    "HANDLER",
    "HASH",
    "HAVING",
    // (R)
    "HELP",
    "HIGH_PRIORITY",
    // (R)
    "HISTOGRAM",
    "HISTORY",
    "HOST",
    "HOSTS",
    "HOUR",
    "HOUR_MICROSECOND",
    // (R)
    "HOUR_MINUTE",
    // (R)
    "HOUR_SECOND",
    // (R)
    "IDENTIFIED",
    "IF",
    // (R)
    "IGNORE",
    // (R)
    "IGNORE_SERVER_IDS",
    "IMPORT",
    "IN",
    // (R)
    "INACTIVE",
    "INDEX",
    // (R)
    "INDEXES",
    "INFILE",
    // (R)
    "INITIAL",
    "INITIAL_SIZE",
    "INITIATE",
    "INNER",
    // (R)
    "INOUT",
    // (R)
    "INSENSITIVE",
    // (R)
    "INSERT",
    // (R)
    "INSERT_METHOD",
    "INSTALL",
    "INSTANCE",
    "IN",
    // <-- moved over from functions
    "INT",
    // (R)
    "INT1",
    // (R)
    "INT2",
    // (R)
    "INT3",
    // (R)
    "INT4",
    // (R)
    "INT8",
    // (R)
    "INTEGER",
    // (R)
    "INTERSECT",
    // (R)
    "INTERVAL",
    // (R)
    "INTO",
    // (R)
    "INVISIBLE",
    "INVOKER",
    "IO",
    "IO_AFTER_GTIDS",
    // (R)
    "IO_BEFORE_GTIDS",
    // (R)
    "IO_THREAD",
    "IPC",
    "IS",
    // (R)
    "ISOLATION",
    "ISSUER",
    "ITERATE",
    // (R)
    "JOIN",
    // (R)
    "JSON",
    "JSON_TABLE",
    // (R)
    "JSON_VALUE",
    "KEY",
    // (R)
    "KEYRING",
    "KEYS",
    // (R)
    "KEY_BLOCK_SIZE",
    "KILL",
    // (R)
    "LAG",
    // (R)
    "LANGUAGE",
    "LAST",
    "LAST_VALUE",
    // (R)
    "LATERAL",
    // (R)
    "LEAD",
    // (R)
    "LEADING",
    // (R)
    "LEAVE",
    // (R)
    "LEAVES",
    "LEFT",
    // (R)
    "LESS",
    "LEVEL",
    "LIKE",
    // (R)
    "LIMIT",
    // (R)
    "LINEAR",
    // (R)
    "LINES",
    // (R)
    "LINESTRING",
    "LIST",
    "LOAD",
    // (R)
    "LOCAL",
    "LOCALTIME",
    // (R)
    "LOCALTIMESTAMP",
    // (R)
    "LOCK",
    // (R)
    "LOCKED",
    "LOCKS",
    "LOGFILE",
    "LOGS",
    "LONG",
    // (R)
    "LONGBLOB",
    // (R)
    "LONGTEXT",
    // (R)
    "LOOP",
    // (R)
    "LOW_PRIORITY",
    // (R)
    "MASTER",
    "MASTER_AUTO_POSITION",
    "MASTER_BIND",
    // (R)
    "MASTER_COMPRESSION_ALGORITHMS",
    "MASTER_CONNECT_RETRY",
    "MASTER_DELAY",
    "MASTER_HEARTBEAT_PERIOD",
    "MASTER_HOST",
    "MASTER_LOG_FILE",
    "MASTER_LOG_POS",
    "MASTER_PASSWORD",
    "MASTER_PORT",
    "MASTER_PUBLIC_KEY_PATH",
    "MASTER_RETRY_COUNT",
    "MASTER_SSL",
    "MASTER_SSL_CA",
    "MASTER_SSL_CAPATH",
    "MASTER_SSL_CERT",
    "MASTER_SSL_CIPHER",
    "MASTER_SSL_CRL",
    "MASTER_SSL_CRLPATH",
    "MASTER_SSL_KEY",
    "MASTER_SSL_VERIFY_SERVER_CERT",
    // (R)
    "MASTER_TLS_CIPHERSUITES",
    "MASTER_TLS_VERSION",
    "MASTER_USER",
    "MASTER_ZSTD_COMPRESSION_LEVEL",
    "MATCH",
    // (R)
    "MAXVALUE",
    // (R)
    "MAX_CONNECTIONS_PER_HOUR",
    "MAX_QUERIES_PER_HOUR",
    "MAX_ROWS",
    "MAX_SIZE",
    "MAX_UPDATES_PER_HOUR",
    "MAX_USER_CONNECTIONS",
    "MEDIUM",
    "MEDIUMBLOB",
    // (R)
    "MEDIUMINT",
    // (R)
    "MEDIUMTEXT",
    // (R)
    "MEMBER",
    "MEMORY",
    "MERGE",
    "MESSAGE_TEXT",
    "MICROSECOND",
    "MIDDLEINT",
    // (R)
    "MIGRATE",
    "MINUTE",
    "MINUTE_MICROSECOND",
    // (R)
    "MINUTE_SECOND",
    // (R)
    "MIN_ROWS",
    "MOD",
    // (R)
    "MODE",
    "MODIFIES",
    // (R)
    "MODIFY",
    "MONTH",
    "MULTILINESTRING",
    "MULTIPOINT",
    "MULTIPOLYGON",
    "MUTEX",
    "MYSQL_ERRNO",
    "NAME",
    "NAMES",
    "NATIONAL",
    "NATURAL",
    // (R)
    "NCHAR",
    "NDB",
    "NDBCLUSTER",
    "NESTED",
    "NETWORK_NAMESPACE",
    "NEVER",
    "NEW",
    "NEXT",
    "NO",
    "NODEGROUP",
    "NONE",
    "NOT",
    // (R)
    "NOWAIT",
    "NO_WAIT",
    "NO_WRITE_TO_BINLOG",
    // (R)
    "NTH_VALUE",
    // (R)
    "NTILE",
    // (R)
    "NULL",
    // (R)
    "NULLS",
    "NUMBER",
    "NUMERIC",
    // (R)
    "NVARCHAR",
    "OF",
    // (R)
    "OFF",
    "OFFSET",
    "OJ",
    "OLD",
    "ON",
    // (R)
    "ONE",
    "ONLY",
    "OPEN",
    "OPTIMIZE",
    // (R)
    "OPTIMIZER_COSTS",
    // (R)
    "OPTION",
    // (R)
    "OPTIONAL",
    "OPTIONALLY",
    // (R)
    "OPTIONS",
    "OR",
    // (R)
    "ORDER",
    // (R)
    "ORDINALITY",
    "ORGANIZATION",
    "OTHERS",
    "OUT",
    // (R)
    "OUTER",
    // (R)
    "OUTFILE",
    // (R)
    "OVER",
    // (R)
    "OWNER",
    "PACK_KEYS",
    "PAGE",
    "PARSER",
    "PARTIAL",
    "PARTITION",
    // (R)
    "PARTITIONING",
    "PARTITIONS",
    "PASSWORD",
    "PASSWORD_LOCK_TIME",
    "PATH",
    "PERCENT_RANK",
    // (R)
    "PERSIST",
    "PERSIST_ONLY",
    "PHASE",
    "PLUGIN",
    "PLUGINS",
    "PLUGIN_DIR",
    "POINT",
    "POLYGON",
    "PORT",
    "PRECEDES",
    "PRECEDING",
    "PRECISION",
    // (R)
    "PREPARE",
    "PRESERVE",
    "PREV",
    "PRIMARY",
    // (R)
    "PRIVILEGES",
    "PRIVILEGE_CHECKS_USER",
    "PROCEDURE",
    // (R)
    "PROCESS",
    "PROCESSLIST",
    "PROFILE",
    "PROFILES",
    "PROXY",
    "PURGE",
    // (R)
    "QUARTER",
    "QUERY",
    "QUICK",
    "RANDOM",
    "RANGE",
    // (R)
    "RANK",
    // (R)
    "READ",
    // (R)
    "READS",
    // (R)
    "READ_ONLY",
    "READ_WRITE",
    // (R)
    "REAL",
    // (R)
    "REBUILD",
    "RECOVER",
    "RECURSIVE",
    // (R)
    "REDO_BUFFER_SIZE",
    "REDUNDANT",
    "REFERENCE",
    "REFERENCES",
    // (R)
    "REGEXP",
    // (R)
    "REGISTRATION",
    "RELAY",
    "RELAYLOG",
    "RELAY_LOG_FILE",
    "RELAY_LOG_POS",
    "RELAY_THREAD",
    "RELEASE",
    // (R)
    "RELOAD",
    "REMOVE",
    "RENAME",
    // (R)
    "REORGANIZE",
    "REPAIR",
    "REPEAT",
    // (R)
    "REPEATABLE",
    "REPLACE",
    // (R)
    "REPLICA",
    "REPLICAS",
    "REPLICATE_DO_DB",
    "REPLICATE_DO_TABLE",
    "REPLICATE_IGNORE_DB",
    "REPLICATE_IGNORE_TABLE",
    "REPLICATE_REWRITE_DB",
    "REPLICATE_WILD_DO_TABLE",
    "REPLICATE_WILD_IGNORE_TABLE",
    "REPLICATION",
    "REQUIRE",
    // (R)
    "REQUIRE_ROW_FORMAT",
    "RESET",
    "RESIGNAL",
    // (R)
    "RESOURCE",
    "RESPECT",
    "RESTART",
    "RESTORE",
    "RESTRICT",
    // (R)
    "RESUME",
    "RETAIN",
    "RETURN",
    // (R)
    "RETURNED_SQLSTATE",
    "RETURNING",
    "RETURNS",
    "REUSE",
    "REVERSE",
    "REVOKE",
    // (R)
    "RIGHT",
    // (R)
    "RLIKE",
    // (R)
    "ROLE",
    "ROLLBACK",
    "ROLLUP",
    "ROTATE",
    "ROUTINE",
    "ROW",
    // (R)
    "ROWS",
    // (R)
    "ROW_COUNT",
    "ROW_FORMAT",
    "ROW_NUMBER",
    // (R)
    "RTREE",
    "SAVEPOINT",
    "SCHEDULE",
    "SCHEMA",
    // (R)
    "SCHEMAS",
    // (R)
    "SCHEMA_NAME",
    "SECOND",
    "SECONDARY",
    "SECONDARY_ENGINE",
    "SECONDARY_ENGINE_ATTRIBUTE",
    "SECONDARY_LOAD",
    "SECONDARY_UNLOAD",
    "SECOND_MICROSECOND",
    // (R)
    "SECURITY",
    "SELECT",
    // (R)
    "SENSITIVE",
    // (R)
    "SEPARATOR",
    // (R)
    "SERIAL",
    "SERIALIZABLE",
    "SERVER",
    "SESSION",
    "SET",
    // (R)
    "SHARE",
    "SHOW",
    // (R)
    "SHUTDOWN",
    "SIGNAL",
    // (R)
    "SIGNED",
    "SIMPLE",
    "SKIP",
    "SLAVE",
    "SLOW",
    "SMALLINT",
    // (R)
    "SNAPSHOT",
    "SOCKET",
    "SOME",
    "SONAME",
    "SOUNDS",
    "SOURCE",
    "SOURCE_AUTO_POSITION",
    "SOURCE_BIND",
    "SOURCE_COMPRESSION_ALGORITHMS",
    "SOURCE_CONNECT_RETRY",
    "SOURCE_DELAY",
    "SOURCE_HEARTBEAT_PERIOD",
    "SOURCE_HOST",
    "SOURCE_LOG_FILE",
    "SOURCE_LOG_POS",
    "SOURCE_PASSWORD",
    "SOURCE_PORT",
    "SOURCE_PUBLIC_KEY_PATH",
    "SOURCE_RETRY_COUNT",
    "SOURCE_SSL",
    "SOURCE_SSL_CA",
    "SOURCE_SSL_CAPATH",
    "SOURCE_SSL_CERT",
    "SOURCE_SSL_CIPHER",
    "SOURCE_SSL_CRL",
    "SOURCE_SSL_CRLPATH",
    "SOURCE_SSL_KEY",
    "SOURCE_SSL_VERIFY_SERVER_CERT",
    "SOURCE_TLS_CIPHERSUITES",
    "SOURCE_TLS_VERSION",
    "SOURCE_USER",
    "SOURCE_ZSTD_COMPRESSION_LEVEL",
    "SPATIAL",
    // (R)
    "SPECIFIC",
    // (R)
    "SQL",
    // (R)
    "SQLEXCEPTION",
    // (R)
    "SQLSTATE",
    // (R)
    "SQLWARNING",
    // (R)
    "SQL_AFTER_GTIDS",
    "SQL_AFTER_MTS_GAPS",
    "SQL_BEFORE_GTIDS",
    "SQL_BIG_RESULT",
    // (R)
    "SQL_BUFFER_RESULT",
    "SQL_CALC_FOUND_ROWS",
    // (R)
    "SQL_NO_CACHE",
    "SQL_SMALL_RESULT",
    // (R)
    "SQL_THREAD",
    "SQL_TSI_DAY",
    "SQL_TSI_HOUR",
    "SQL_TSI_MINUTE",
    "SQL_TSI_MONTH",
    "SQL_TSI_QUARTER",
    "SQL_TSI_SECOND",
    "SQL_TSI_WEEK",
    "SQL_TSI_YEAR",
    "SRID",
    "SSL",
    // (R)
    "STACKED",
    "START",
    "STARTING",
    // (R)
    "STARTS",
    "STATS_AUTO_RECALC",
    "STATS_PERSISTENT",
    "STATS_SAMPLE_PAGES",
    "STATUS",
    "STOP",
    "STORAGE",
    "STORED",
    // (R)
    "STRAIGHT_JOIN",
    // (R)
    "STREAM",
    "STRING",
    "SUBCLASS_ORIGIN",
    "SUBJECT",
    "SUBPARTITION",
    "SUBPARTITIONS",
    "SUPER",
    "SUSPEND",
    "SWAPS",
    "SWITCHES",
    "SYSTEM",
    // (R)
    "TABLE",
    // (R)
    "TABLES",
    "TABLESPACE",
    "TABLE_CHECKSUM",
    "TABLE_NAME",
    "TEMPORARY",
    "TEMPTABLE",
    "TERMINATED",
    // (R)
    "TEXT",
    "THAN",
    "THEN",
    // (R)
    "THREAD_PRIORITY",
    "TIES",
    "TIME",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TINYBLOB",
    // (R)
    "TINYINT",
    // (R)
    "TINYTEXT",
    // (R)
    "TLS",
    "TO",
    // (R)
    "TRAILING",
    // (R)
    "TRANSACTION",
    "TRIGGER",
    // (R)
    "TRIGGERS",
    "TRUE",
    // (R)
    "TRUNCATE",
    "TYPE",
    "TYPES",
    "UNBOUNDED",
    "UNCOMMITTED",
    "UNDEFINED",
    "UNDO",
    // (R)
    "UNDOFILE",
    "UNDO_BUFFER_SIZE",
    "UNICODE",
    "UNINSTALL",
    "UNION",
    // (R)
    "UNIQUE",
    // (R)
    "UNKNOWN",
    "UNLOCK",
    // (R)
    "UNREGISTER",
    "UNSIGNED",
    // (R)
    "UNTIL",
    "UPDATE",
    // (R)
    "UPGRADE",
    "USAGE",
    // (R)
    "USE",
    // (R)
    "USER",
    "USER_RESOURCES",
    "USE_FRM",
    "USING",
    // (R)
    "UTC_DATE",
    // (R)
    "UTC_TIME",
    // (R)
    "UTC_TIMESTAMP",
    // (R)
    "VALIDATION",
    "VALUE",
    "VALUES",
    // (R)
    "VARBINARY",
    // (R)
    "VARCHAR",
    // (R)
    "VARCHARACTER",
    // (R)
    "VARIABLES",
    "VARYING",
    // (R)
    "VCPU",
    "VIEW",
    "VIRTUAL",
    // (R)
    "VISIBLE",
    "WAIT",
    "WARNINGS",
    "WEEK",
    "WEIGHT_STRING",
    "WHEN",
    // (R)
    "WHERE",
    // (R)
    "WHILE",
    // (R)
    "WINDOW",
    // (R)
    "WITH",
    // (R)
    "WITHOUT",
    "WORK",
    "WRAPPER",
    "WRITE",
    // (R)
    "X509",
    "XA",
    "XID",
    "XML",
    "XOR",
    // (R)
    "YEAR",
    "YEAR_MONTH",
    // (R)
    "ZEROFILL",
    // (R)
    "ZONE"
  ]
}), fH = Ne({
  // https://dev.mysql.com/doc/refman/8.0/en/built-in-function-reference.html
  all: [
    "ABS",
    "ACOS",
    "ADDDATE",
    "ADDTIME",
    "AES_DECRYPT",
    "AES_ENCRYPT",
    // 'AND',
    "ANY_VALUE",
    "ASCII",
    "ASIN",
    "ATAN",
    "ATAN2",
    "AVG",
    "BENCHMARK",
    "BIN",
    "BIN_TO_UUID",
    "BINARY",
    "BIT_AND",
    "BIT_COUNT",
    "BIT_LENGTH",
    "BIT_OR",
    "BIT_XOR",
    "CAN_ACCESS_COLUMN",
    "CAN_ACCESS_DATABASE",
    "CAN_ACCESS_TABLE",
    "CAN_ACCESS_USER",
    "CAN_ACCESS_VIEW",
    "CAST",
    "CEIL",
    "CEILING",
    "CHAR",
    "CHAR_LENGTH",
    "CHARACTER_LENGTH",
    "CHARSET",
    "COALESCE",
    "COERCIBILITY",
    "COLLATION",
    "COMPRESS",
    "CONCAT",
    "CONCAT_WS",
    "CONNECTION_ID",
    "CONV",
    "CONVERT",
    "CONVERT_TZ",
    "COS",
    "COT",
    "COUNT",
    "CRC32",
    "CUME_DIST",
    "CURDATE",
    "CURRENT_DATE",
    "CURRENT_ROLE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "CURTIME",
    "DATABASE",
    "DATE",
    "DATE_ADD",
    "DATE_FORMAT",
    "DATE_SUB",
    "DATEDIFF",
    "DAY",
    "DAYNAME",
    "DAYOFMONTH",
    "DAYOFWEEK",
    "DAYOFYEAR",
    "DEFAULT",
    "DEGREES",
    "DENSE_RANK",
    "DIV",
    "ELT",
    "EXP",
    "EXPORT_SET",
    "EXTRACT",
    "EXTRACTVALUE",
    "FIELD",
    "FIND_IN_SET",
    "FIRST_VALUE",
    "FLOOR",
    "FORMAT",
    "FORMAT_BYTES",
    "FORMAT_PICO_TIME",
    "FOUND_ROWS",
    "FROM_BASE64",
    "FROM_DAYS",
    "FROM_UNIXTIME",
    "GEOMCOLLECTION",
    "GEOMETRYCOLLECTION",
    "GET_DD_COLUMN_PRIVILEGES",
    "GET_DD_CREATE_OPTIONS",
    "GET_DD_INDEX_SUB_PART_LENGTH",
    "GET_FORMAT",
    "GET_LOCK",
    "GREATEST",
    "GROUP_CONCAT",
    "GROUPING",
    "GTID_SUBSET",
    "GTID_SUBTRACT",
    "HEX",
    "HOUR",
    "ICU_VERSION",
    "IF",
    "IFNULL",
    // 'IN',
    "INET_ATON",
    "INET_NTOA",
    "INET6_ATON",
    "INET6_NTOA",
    "INSERT",
    "INSTR",
    "INTERNAL_AUTO_INCREMENT",
    "INTERNAL_AVG_ROW_LENGTH",
    "INTERNAL_CHECK_TIME",
    "INTERNAL_CHECKSUM",
    "INTERNAL_DATA_FREE",
    "INTERNAL_DATA_LENGTH",
    "INTERNAL_DD_CHAR_LENGTH",
    "INTERNAL_GET_COMMENT_OR_ERROR",
    "INTERNAL_GET_ENABLED_ROLE_JSON",
    "INTERNAL_GET_HOSTNAME",
    "INTERNAL_GET_USERNAME",
    "INTERNAL_GET_VIEW_WARNING_OR_ERROR",
    "INTERNAL_INDEX_COLUMN_CARDINALITY",
    "INTERNAL_INDEX_LENGTH",
    "INTERNAL_IS_ENABLED_ROLE",
    "INTERNAL_IS_MANDATORY_ROLE",
    "INTERNAL_KEYS_DISABLED",
    "INTERNAL_MAX_DATA_LENGTH",
    "INTERNAL_TABLE_ROWS",
    "INTERNAL_UPDATE_TIME",
    "INTERVAL",
    "IS",
    "IS_FREE_LOCK",
    "IS_IPV4",
    "IS_IPV4_COMPAT",
    "IS_IPV4_MAPPED",
    "IS_IPV6",
    "IS NOT",
    "IS NOT NULL",
    "IS NULL",
    "IS_USED_LOCK",
    "IS_UUID",
    "ISNULL",
    "JSON_ARRAY",
    "JSON_ARRAY_APPEND",
    "JSON_ARRAY_INSERT",
    "JSON_ARRAYAGG",
    "JSON_CONTAINS",
    "JSON_CONTAINS_PATH",
    "JSON_DEPTH",
    "JSON_EXTRACT",
    "JSON_INSERT",
    "JSON_KEYS",
    "JSON_LENGTH",
    "JSON_MERGE",
    "JSON_MERGE_PATCH",
    "JSON_MERGE_PRESERVE",
    "JSON_OBJECT",
    "JSON_OBJECTAGG",
    "JSON_OVERLAPS",
    "JSON_PRETTY",
    "JSON_QUOTE",
    "JSON_REMOVE",
    "JSON_REPLACE",
    "JSON_SCHEMA_VALID",
    "JSON_SCHEMA_VALIDATION_REPORT",
    "JSON_SEARCH",
    "JSON_SET",
    "JSON_STORAGE_FREE",
    "JSON_STORAGE_SIZE",
    "JSON_TABLE",
    "JSON_TYPE",
    "JSON_UNQUOTE",
    "JSON_VALID",
    "JSON_VALUE",
    "LAG",
    "LAST_DAY",
    "LAST_INSERT_ID",
    "LAST_VALUE",
    "LCASE",
    "LEAD",
    "LEAST",
    "LEFT",
    "LENGTH",
    "LIKE",
    "LINESTRING",
    "LN",
    "LOAD_FILE",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG2",
    "LOWER",
    "LPAD",
    "LTRIM",
    "MAKE_SET",
    "MAKEDATE",
    "MAKETIME",
    "MASTER_POS_WAIT",
    "MATCH",
    "MAX",
    "MBRCONTAINS",
    "MBRCOVEREDBY",
    "MBRCOVERS",
    "MBRDISJOINT",
    "MBREQUALS",
    "MBRINTERSECTS",
    "MBROVERLAPS",
    "MBRTOUCHES",
    "MBRWITHIN",
    "MD5",
    "MEMBER OF",
    "MICROSECOND",
    "MID",
    "MIN",
    "MINUTE",
    "MOD",
    "MONTH",
    "MONTHNAME",
    "MULTILINESTRING",
    "MULTIPOINT",
    "MULTIPOLYGON",
    "NAME_CONST",
    "NOT",
    "NOT IN",
    "NOT LIKE",
    "NOT REGEXP",
    "NOW",
    "NTH_VALUE",
    "NTILE",
    "NULLIF",
    "OCT",
    "OCTET_LENGTH",
    // 'OR',
    "ORD",
    "PERCENT_RANK",
    "PERIOD_ADD",
    "PERIOD_DIFF",
    "PI",
    "POINT",
    "POLYGON",
    "POSITION",
    "POW",
    "POWER",
    "PS_CURRENT_THREAD_ID",
    "PS_THREAD_ID",
    "QUARTER",
    "QUOTE",
    "RADIANS",
    "RAND",
    "RANDOM_BYTES",
    "RANK",
    "REGEXP",
    "REGEXP_INSTR",
    "REGEXP_LIKE",
    "REGEXP_REPLACE",
    "REGEXP_SUBSTR",
    "RELEASE_ALL_LOCKS",
    "RELEASE_LOCK",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "RIGHT",
    "RLIKE",
    "ROLES_GRAPHML",
    "ROUND",
    "ROW_COUNT",
    "ROW_NUMBER",
    "RPAD",
    "RTRIM",
    "SCHEMA",
    "SEC_TO_TIME",
    "SECOND",
    "SESSION_USER",
    "SHA1",
    "SHA2",
    "SIGN",
    "SIN",
    "SLEEP",
    "SOUNDEX",
    "SOUNDS LIKE",
    "SOURCE_POS_WAIT",
    "SPACE",
    "SQRT",
    "ST_AREA",
    "ST_ASBINARY",
    "ST_ASGEOJSON",
    "ST_ASTEXT",
    "ST_BUFFER",
    "ST_BUFFER_STRATEGY",
    "ST_CENTROID",
    "ST_COLLECT",
    "ST_CONTAINS",
    "ST_CONVEXHULL",
    "ST_CROSSES",
    "ST_DIFFERENCE",
    "ST_DIMENSION",
    "ST_DISJOINT",
    "ST_DISTANCE",
    "ST_DISTANCE_SPHERE",
    "ST_ENDPOINT",
    "ST_ENVELOPE",
    "ST_EQUALS",
    "ST_EXTERIORRING",
    "ST_FRECHETDISTANCE",
    "ST_GEOHASH",
    "ST_GEOMCOLLFROMTEXT",
    "ST_GEOMCOLLFROMWKB",
    "ST_GEOMETRYN",
    "ST_GEOMETRYTYPE",
    "ST_GEOMFROMGEOJSON",
    "ST_GEOMFROMTEXT",
    "ST_GEOMFROMWKB",
    "ST_HAUSDORFFDISTANCE",
    "ST_INTERIORRINGN",
    "ST_INTERSECTION",
    "ST_INTERSECTS",
    "ST_ISCLOSED",
    "ST_ISEMPTY",
    "ST_ISSIMPLE",
    "ST_ISVALID",
    "ST_LATFROMGEOHASH",
    "ST_LATITUDE",
    "ST_LENGTH",
    "ST_LINEFROMTEXT",
    "ST_LINEFROMWKB",
    "ST_LINEINTERPOLATEPOINT",
    "ST_LINEINTERPOLATEPOINTS",
    "ST_LONGFROMGEOHASH",
    "ST_LONGITUDE",
    "ST_MAKEENVELOPE",
    "ST_MLINEFROMTEXT",
    "ST_MLINEFROMWKB",
    "ST_MPOINTFROMTEXT",
    "ST_MPOINTFROMWKB",
    "ST_MPOLYFROMTEXT",
    "ST_MPOLYFROMWKB",
    "ST_NUMGEOMETRIES",
    "ST_NUMINTERIORRING",
    "ST_NUMPOINTS",
    "ST_OVERLAPS",
    "ST_POINTATDISTANCE",
    "ST_POINTFROMGEOHASH",
    "ST_POINTFROMTEXT",
    "ST_POINTFROMWKB",
    "ST_POINTN",
    "ST_POLYFROMTEXT",
    "ST_POLYFROMWKB",
    "ST_SIMPLIFY",
    "ST_SRID",
    "ST_STARTPOINT",
    "ST_SWAPXY",
    "ST_SYMDIFFERENCE",
    "ST_TOUCHES",
    "ST_TRANSFORM",
    "ST_UNION",
    "ST_VALIDATE",
    "ST_WITHIN",
    "ST_X",
    "ST_Y",
    "STATEMENT_DIGEST",
    "STATEMENT_DIGEST_TEXT",
    "STD",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STR_TO_DATE",
    "STRCMP",
    "SUBDATE",
    "SUBSTR",
    "SUBSTRING",
    "SUBSTRING_INDEX",
    "SUBTIME",
    "SUM",
    "SYSDATE",
    "SYSTEM_USER",
    "TAN",
    "TIME",
    "TIME_FORMAT",
    "TIME_TO_SEC",
    "TIMEDIFF",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TO_BASE64",
    "TO_DAYS",
    "TO_SECONDS",
    "TRIM",
    "TRUNCATE",
    "UCASE",
    "UNCOMPRESS",
    "UNCOMPRESSED_LENGTH",
    "UNHEX",
    "UNIX_TIMESTAMP",
    "UPDATEXML",
    "UPPER",
    "USER",
    "UTC_DATE",
    "UTC_TIME",
    "UTC_TIMESTAMP",
    "UUID",
    "UUID_SHORT",
    "UUID_TO_BIN",
    "VALIDATE_PASSWORD_STRENGTH",
    "VALUES",
    "VAR_POP",
    "VAR_SAMP",
    "VARIANCE",
    "VERSION",
    "WAIT_FOR_EXECUTED_GTID_SET",
    "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS",
    "WEEK",
    "WEEKDAY",
    "WEEKOFYEAR",
    "WEIGHT_STRING",
    // 'XOR',
    "YEAR",
    "YEARWEEK",
    // Data types with parameters
    // https://dev.mysql.com/doc/refman/8.0/en/data-types.html
    "BIT",
    "TINYINT",
    "SMALLINT",
    "MEDIUMINT",
    "INT",
    "INTEGER",
    "BIGINT",
    "DECIMAL",
    "DEC",
    "NUMERIC",
    "FIXED",
    "FLOAT",
    "DOUBLE",
    "DOUBLE PRECISION",
    "REAL",
    "DATETIME",
    "TIMESTAMP",
    "TIME",
    "YEAR",
    "CHAR",
    "NATIONAL CHAR",
    "VARCHAR",
    "NATIONAL VARCHAR",
    "BINARY",
    "VARBINARY",
    "BLOB",
    "TEXT",
    "ENUM"
    // 'SET' // handled as special-case in postProcess
  ]
}), pH = V(["SELECT [ALL | DISTINCT | DISTINCTROW]"]), OH = V([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]",
  "REPLACE [LOW_PRIORITY | DELAYED] [INTO]",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]",
  "CREATE [TEMPORARY] TABLE [IF NOT EXISTS]"
]), Zb = V([
  // - update:
  "UPDATE [LOW_PRIORITY] [IGNORE]",
  // - delete:
  "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "{CHANGE | MODIFY} [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [TO | AS]",
  "RENAME COLUMN",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://dev.mysql.com/doc/refman/8.0/en/sql-statements.html
  "ALTER DATABASE",
  "ALTER EVENT",
  "ALTER FUNCTION",
  "ALTER INSTANCE",
  "ALTER LOGFILE GROUP",
  "ALTER PROCEDURE",
  "ALTER RESOURCE GROUP",
  "ALTER SERVER",
  "ALTER TABLESPACE",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE TABLE",
  "BINLOG",
  "CACHE INDEX",
  "CALL",
  "CHANGE MASTER TO",
  "CHANGE REPLICATION FILTER",
  "CHANGE REPLICATION SOURCE TO",
  "CHECK TABLE",
  "CHECKSUM TABLE",
  "CLONE",
  "COMMIT",
  "CREATE DATABASE",
  "CREATE EVENT",
  "CREATE FUNCTION",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE LOGFILE GROUP",
  "CREATE PROCEDURE",
  "CREATE RESOURCE GROUP",
  "CREATE ROLE",
  "CREATE SERVER",
  "CREATE SPATIAL REFERENCE SYSTEM",
  "CREATE TABLESPACE",
  "CREATE TRIGGER",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DROP DATABASE",
  "DROP EVENT",
  "DROP FUNCTION",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP LOGFILE GROUP",
  "DROP PROCEDURE",
  "DROP RESOURCE GROUP",
  "DROP ROLE",
  "DROP SERVER",
  "DROP SPATIAL REFERENCE SYSTEM",
  "DROP TABLESPACE",
  "DROP TRIGGER",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "GRANT",
  "HANDLER",
  "HELP",
  "IMPORT TABLE",
  "INSTALL COMPONENT",
  "INSTALL PLUGIN",
  "KILL",
  "LOAD DATA",
  "LOAD INDEX INTO CACHE",
  "LOAD XML",
  "LOCK INSTANCE FOR BACKUP",
  "LOCK TABLES",
  "MASTER_POS_WAIT",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "RELEASE SAVEPOINT",
  "RENAME TABLE",
  "RENAME USER",
  "REPAIR TABLE",
  "RESET",
  "RESET MASTER",
  "RESET PERSIST",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESTART",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET NAMES",
  "SET PASSWORD",
  "SET RESOURCE GROUP",
  "SET ROLE",
  "SET TRANSACTION",
  "SHOW",
  "SHOW BINARY LOGS",
  "SHOW BINLOG EVENTS",
  "SHOW CHARACTER SET",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE EVENT",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE TABLE",
  "SHOW CREATE TRIGGER",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW EVENTS",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PLUGINS",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA STATUS",
  "SHOW REPLICAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW STATUS",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW TRIGGERS",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHUTDOWN",
  "SOURCE_POS_WAIT",
  "START GROUP_REPLICATION",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP GROUP_REPLICATION",
  "STOP REPLICA",
  "STOP SLAVE",
  "TABLE",
  "UNINSTALL COMPONENT",
  "UNINSTALL PLUGIN",
  "UNLOCK INSTANCE",
  "UNLOCK TABLES",
  "USE",
  "XA",
  // flow control
  // 'IF',
  "ITERATE",
  "LEAVE",
  "LOOP",
  "REPEAT",
  "RETURN",
  "WHILE"
]), EH = V(["UNION [ALL | DISTINCT]"]), mH = V([
  "JOIN",
  "{LEFT | RIGHT} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]), gH = V(["ON {UPDATE | DELETE} [SET NULL]", "CHARACTER SET", "{ROWS | RANGE} BETWEEN"]), bH = {
  tokenizerOptions: {
    reservedSelect: pH,
    reservedClauses: [...OH, ...Zb],
    reservedSetOperations: EH,
    reservedJoins: mH,
    reservedPhrases: gH,
    supportsXor: !0,
    reservedKeywords: dH,
    reservedFunctionNames: fH,
    // TODO: support _ char set prefixes such as _utf8, _latin1, _binary, _utf8mb4, etc.
    stringTypes: ['""-qq-bs', {
      quote: "''-qq-bs",
      prefixes: ["N"]
    }, {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    identChars: {
      first: "$",
      rest: "$",
      allowFirstCharNumber: !0
    },
    variableTypes: [{
      regex: "@@?[A-Za-z0-9_.$]+"
    }, {
      quote: '""-qq-bs',
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "''-qq-bs",
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "``",
      prefixes: ["@"],
      requirePrefix: !0
    }],
    paramTypes: {
      positional: !0
    },
    lineCommentTypes: ["--", "#"],
    operators: ["%", ":=", "&", "|", "^", "~", "<<", ">>", "<=>", "->", "->>", "&&", "||", "!"],
    postProcess: TH
  },
  formatOptions: {
    onelineClauses: Zb
  }
};
function TH(i) {
  return i.map((e, t) => {
    const r = i[t + 1] || rs;
    return Ro.SET(e) && r.text === "(" ? {
      ...e,
      type: k.RESERVED_FUNCTION_NAME
    } : e;
  });
}
const SH = Ne({
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/functions.html
  all: [
    "ABORT",
    "ABS",
    "ACOS",
    "ADVISOR",
    "ARRAY_AGG",
    "ARRAY_AGG",
    "ARRAY_APPEND",
    "ARRAY_AVG",
    "ARRAY_BINARY_SEARCH",
    "ARRAY_CONCAT",
    "ARRAY_CONTAINS",
    "ARRAY_COUNT",
    "ARRAY_DISTINCT",
    "ARRAY_EXCEPT",
    "ARRAY_FLATTEN",
    "ARRAY_IFNULL",
    "ARRAY_INSERT",
    "ARRAY_INTERSECT",
    "ARRAY_LENGTH",
    "ARRAY_MAX",
    "ARRAY_MIN",
    "ARRAY_MOVE",
    "ARRAY_POSITION",
    "ARRAY_PREPEND",
    "ARRAY_PUT",
    "ARRAY_RANGE",
    "ARRAY_REMOVE",
    "ARRAY_REPEAT",
    "ARRAY_REPLACE",
    "ARRAY_REVERSE",
    "ARRAY_SORT",
    "ARRAY_STAR",
    "ARRAY_SUM",
    "ARRAY_SYMDIFF",
    "ARRAY_SYMDIFF1",
    "ARRAY_SYMDIFFN",
    "ARRAY_UNION",
    "ASIN",
    "ATAN",
    "ATAN2",
    "AVG",
    "BASE64",
    "BASE64_DECODE",
    "BASE64_ENCODE",
    "BITAND ",
    "BITCLEAR ",
    "BITNOT ",
    "BITOR ",
    "BITSET ",
    "BITSHIFT ",
    "BITTEST ",
    "BITXOR ",
    "CEIL",
    "CLOCK_LOCAL",
    "CLOCK_MILLIS",
    "CLOCK_STR",
    "CLOCK_TZ",
    "CLOCK_UTC",
    "COALESCE",
    "CONCAT",
    "CONCAT2",
    "CONTAINS",
    "CONTAINS_TOKEN",
    "CONTAINS_TOKEN_LIKE",
    "CONTAINS_TOKEN_REGEXP",
    "COS",
    "COUNT",
    "COUNT",
    "COUNTN",
    "CUME_DIST",
    "CURL",
    "DATE_ADD_MILLIS",
    "DATE_ADD_STR",
    "DATE_DIFF_MILLIS",
    "DATE_DIFF_STR",
    "DATE_FORMAT_STR",
    "DATE_PART_MILLIS",
    "DATE_PART_STR",
    "DATE_RANGE_MILLIS",
    "DATE_RANGE_STR",
    "DATE_TRUNC_MILLIS",
    "DATE_TRUNC_STR",
    "DECODE",
    "DECODE_JSON",
    "DEGREES",
    "DENSE_RANK",
    "DURATION_TO_STR",
    // 'E',
    "ENCODED_SIZE",
    "ENCODE_JSON",
    "EXP",
    "FIRST_VALUE",
    "FLOOR",
    "GREATEST",
    "HAS_TOKEN",
    "IFINF",
    "IFMISSING",
    "IFMISSINGORNULL",
    "IFNAN",
    "IFNANORINF",
    "IFNULL",
    "INITCAP",
    "ISARRAY",
    "ISATOM",
    "ISBITSET",
    "ISBOOLEAN",
    "ISNUMBER",
    "ISOBJECT",
    "ISSTRING",
    "LAG",
    "LAST_VALUE",
    "LEAD",
    "LEAST",
    "LENGTH",
    "LN",
    "LOG",
    "LOWER",
    "LTRIM",
    "MAX",
    "MEAN",
    "MEDIAN",
    "META",
    "MILLIS",
    "MILLIS_TO_LOCAL",
    "MILLIS_TO_STR",
    "MILLIS_TO_TZ",
    "MILLIS_TO_UTC",
    "MILLIS_TO_ZONE_NAME",
    "MIN",
    "MISSINGIF",
    "NANIF",
    "NEGINFIF",
    "NOW_LOCAL",
    "NOW_MILLIS",
    "NOW_STR",
    "NOW_TZ",
    "NOW_UTC",
    "NTH_VALUE",
    "NTILE",
    "NULLIF",
    "NVL",
    "NVL2",
    "OBJECT_ADD",
    "OBJECT_CONCAT",
    "OBJECT_INNER_PAIRS",
    "OBJECT_INNER_VALUES",
    "OBJECT_LENGTH",
    "OBJECT_NAMES",
    "OBJECT_PAIRS",
    "OBJECT_PUT",
    "OBJECT_REMOVE",
    "OBJECT_RENAME",
    "OBJECT_REPLACE",
    "OBJECT_UNWRAP",
    "OBJECT_VALUES",
    "PAIRS",
    "PERCENT_RANK",
    "PI",
    "POLY_LENGTH",
    "POSINFIF",
    "POSITION",
    "POWER",
    "RADIANS",
    "RANDOM",
    "RANK",
    "RATIO_TO_REPORT",
    "REGEXP_CONTAINS",
    "REGEXP_LIKE",
    "REGEXP_MATCHES",
    "REGEXP_POSITION",
    "REGEXP_REPLACE",
    "REGEXP_SPLIT",
    "REGEX_CONTAINS",
    "REGEX_LIKE",
    "REGEX_MATCHES",
    "REGEX_POSITION",
    "REGEX_REPLACE",
    "REGEX_SPLIT",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "ROUND",
    "ROW_NUMBER",
    "RTRIM",
    "SEARCH",
    "SEARCH_META",
    "SEARCH_SCORE",
    "SIGN",
    "SIN",
    "SPLIT",
    "SQRT",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STR_TO_DURATION",
    "STR_TO_MILLIS",
    "STR_TO_TZ",
    "STR_TO_UTC",
    "STR_TO_ZONE_NAME",
    "SUBSTR",
    "SUFFIXES",
    "SUM",
    "TAN",
    "TITLE",
    "TOARRAY",
    "TOATOM",
    "TOBOOLEAN",
    "TOKENS",
    "TOKENS",
    "TONUMBER",
    "TOOBJECT",
    "TOSTRING",
    "TRIM",
    "TRUNC",
    // 'TYPE', // disabled
    "UPPER",
    "UUID",
    "VARIANCE",
    "VARIANCE_POP",
    "VARIANCE_SAMP",
    "VAR_POP",
    "VAR_SAMP",
    "WEEKDAY_MILLIS",
    "WEEKDAY_STR",
    // type casting
    // not implemented in N1QL, but added here now for the sake of tests
    // https://docs.couchbase.com/server/current/analytics/3_query.html#Vs_SQL-92
    "CAST"
  ]
}), RH = Ne({
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html
  all: ["ADVISE", "ALL", "ALTER", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "AT", "BEGIN", "BETWEEN", "BINARY", "BOOLEAN", "BREAK", "BUCKET", "BUILD", "BY", "CALL", "CASE", "CAST", "CLUSTER", "COLLATE", "COLLECTION", "COMMIT", "COMMITTED", "CONNECT", "CONTINUE", "CORRELATED", "COVER", "CREATE", "CURRENT", "DATABASE", "DATASET", "DATASTORE", "DECLARE", "DECREMENT", "DELETE", "DERIVED", "DESC", "DESCRIBE", "DISTINCT", "DO", "DROP", "EACH", "ELEMENT", "ELSE", "END", "EVERY", "EXCEPT", "EXCLUDE", "EXECUTE", "EXISTS", "EXPLAIN", "FALSE", "FETCH", "FILTER", "FIRST", "FLATTEN", "FLUSH", "FOLLOWING", "FOR", "FORCE", "FROM", "FTS", "FUNCTION", "GOLANG", "GRANT", "GROUP", "GROUPS", "GSI", "HASH", "HAVING", "IF", "ISOLATION", "IGNORE", "ILIKE", "IN", "INCLUDE", "INCREMENT", "INDEX", "INFER", "INLINE", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "JAVASCRIPT", "JOIN", "KEY", "KEYS", "KEYSPACE", "KNOWN", "LANGUAGE", "LAST", "LEFT", "LET", "LETTING", "LEVEL", "LIKE", "LIMIT", "LSM", "MAP", "MAPPING", "MATCHED", "MATERIALIZED", "MERGE", "MINUS", "MISSING", "NAMESPACE", "NEST", "NL", "NO", "NOT", "NTH_VALUE", "NULL", "NULLS", "NUMBER", "OBJECT", "OFFSET", "ON", "OPTION", "OPTIONS", "OR", "ORDER", "OTHERS", "OUTER", "OVER", "PARSE", "PARTITION", "PASSWORD", "PATH", "POOL", "PRECEDING", "PREPARE", "PRIMARY", "PRIVATE", "PRIVILEGE", "PROBE", "PROCEDURE", "PUBLIC", "RANGE", "RAW", "REALM", "REDUCE", "RENAME", "RESPECT", "RETURN", "RETURNING", "REVOKE", "RIGHT", "ROLE", "ROLLBACK", "ROW", "ROWS", "SATISFIES", "SAVEPOINT", "SCHEMA", "SCOPE", "SELECT", "SELF", "SEMI", "SET", "SHOW", "SOME", "START", "STATISTICS", "STRING", "SYSTEM", "THEN", "TIES", "TO", "TRAN", "TRANSACTION", "TRIGGER", "TRUE", "TRUNCATE", "UNBOUNDED", "UNDER", "UNION", "UNIQUE", "UNKNOWN", "UNNEST", "UNSET", "UPDATE", "UPSERT", "USE", "USER", "USING", "VALIDATE", "VALUE", "VALUED", "VALUES", "VIA", "VIEW", "WHEN", "WHERE", "WHILE", "WINDOW", "WITH", "WITHIN", "WORK", "XOR"]
}), AH = V(["SELECT [ALL | DISTINCT]"]), CH = V([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED THEN",
  "UPDATE SET",
  "INSERT",
  // other
  "NEST",
  "UNNEST",
  "RETURNING"
]), qb = V([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - set schema:
  "SET SCHEMA",
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html
  "ADVISE",
  "ALTER INDEX",
  "BEGIN TRANSACTION",
  "BUILD INDEX",
  "COMMIT TRANSACTION",
  "CREATE COLLECTION",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE PRIMARY INDEX",
  "CREATE SCOPE",
  "DROP COLLECTION",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP PRIMARY INDEX",
  "DROP SCOPE",
  "EXECUTE",
  "EXECUTE FUNCTION",
  "EXPLAIN",
  "GRANT",
  "INFER",
  "PREPARE",
  "REVOKE",
  "ROLLBACK TRANSACTION",
  "SAVEPOINT",
  "SET TRANSACTION",
  "UPDATE STATISTICS",
  "UPSERT",
  // other
  "LET",
  "SET CURRENT SCHEMA",
  "SHOW",
  "USE [PRIMARY] KEYS"
]), NH = V(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]), IH = V(["JOIN", "{LEFT | RIGHT} [OUTER] JOIN", "INNER JOIN"]), vH = V(["{ROWS | RANGE | GROUPS} BETWEEN"]), _H = {
  tokenizerOptions: {
    reservedSelect: AH,
    reservedClauses: [...CH, ...qb],
    reservedSetOperations: NH,
    reservedJoins: IH,
    reservedPhrases: vH,
    supportsXor: !0,
    reservedKeywords: RH,
    reservedFunctionNames: SH,
    // NOTE: single quotes are actually not supported in N1QL,
    // but we support them anyway as all other SQL dialects do,
    // which simplifies writing tests that are shared between all dialects.
    stringTypes: ['""-bs', "''-bs"],
    identTypes: ["``"],
    extraParens: ["[]", "{}"],
    paramTypes: {
      positional: !0,
      numbered: ["$"],
      named: ["$"]
    },
    lineCommentTypes: ["#", "--"],
    operators: ["%", "==", ":", "||"]
  },
  formatOptions: {
    onelineClauses: qb
  }
}, PH = Ne({
  // https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/reservewords.htm
  all: [
    // 'A',
    "ADD",
    "AGENT",
    "AGGREGATE",
    "ALL",
    "ALTER",
    "AND",
    "ANY",
    "ARRAY",
    "ARROW",
    "AS",
    "ASC",
    "AT",
    "ATTRIBUTE",
    "AUTHID",
    "AVG",
    "BEGIN",
    "BETWEEN",
    "BFILE_BASE",
    "BINARY",
    "BLOB_BASE",
    "BLOCK",
    "BODY",
    "BOTH",
    "BOUND",
    "BULK",
    "BY",
    "BYTE",
    // 'C',
    "CALL",
    "CALLING",
    "CASCADE",
    "CASE",
    "CHAR",
    "CHAR_BASE",
    "CHARACTER",
    "CHARSET",
    "CHARSETFORM",
    "CHARSETID",
    "CHECK",
    "CLOB_BASE",
    "CLOSE",
    "CLUSTER",
    "CLUSTERS",
    "COLAUTH",
    "COLLECT",
    "COLUMNS",
    "COMMENT",
    "COMMIT",
    "COMMITTED",
    "COMPILED",
    "COMPRESS",
    "CONNECT",
    "CONSTANT",
    "CONSTRUCTOR",
    "CONTEXT",
    "CONVERT",
    "COUNT",
    "CRASH",
    "CREATE",
    "CURRENT",
    "CURSOR",
    "CUSTOMDATUM",
    "DANGLING",
    "DATA",
    "DATE",
    "DATE_BASE",
    "DAY",
    "DECIMAL",
    "DECLARE",
    "DEFAULT",
    "DEFINE",
    "DELETE",
    "DESC",
    "DETERMINISTIC",
    "DISTINCT",
    "DOUBLE",
    "DROP",
    "DURATION",
    "ELEMENT",
    "ELSE",
    "ELSIF",
    "EMPTY",
    "END",
    "ESCAPE",
    "EXCEPT",
    "EXCEPTION",
    "EXCEPTIONS",
    "EXCLUSIVE",
    "EXECUTE",
    "EXISTS",
    "EXIT",
    "EXTERNAL",
    "FETCH",
    "FINAL",
    "FIXED",
    "FLOAT",
    "FOR",
    "FORALL",
    "FORCE",
    "FORM",
    "FROM",
    "FUNCTION",
    "GENERAL",
    "GOTO",
    "GRANT",
    "GROUP",
    "HASH",
    "HAVING",
    "HEAP",
    "HIDDEN",
    "HOUR",
    "IDENTIFIED",
    "IF",
    "IMMEDIATE",
    "IN",
    "INCLUDING",
    "INDEX",
    "INDEXES",
    "INDICATOR",
    "INDICES",
    "INFINITE",
    "INSERT",
    "INSTANTIABLE",
    "INT",
    "INTERFACE",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "INVALIDATE",
    "IS",
    "ISOLATION",
    "JAVA",
    "LANGUAGE",
    "LARGE",
    "LEADING",
    "LENGTH",
    "LEVEL",
    "LIBRARY",
    "LIKE",
    "LIKE2",
    "LIKE4",
    "LIKEC",
    "LIMIT",
    "LIMITED",
    "LOCAL",
    "LOCK",
    "LONG",
    "LOOP",
    "MAP",
    "MAX",
    "MAXLEN",
    "MEMBER",
    "MERGE",
    "MIN",
    "MINUS",
    "MINUTE",
    "MOD",
    "MODE",
    "MODIFY",
    "MONTH",
    "MULTISET",
    "NAME",
    "NAN",
    "NATIONAL",
    "NATIVE",
    "NCHAR",
    "NEW",
    "NOCOMPRESS",
    "NOCOPY",
    "NOT",
    "NOWAIT",
    "NULL",
    "NUMBER_BASE",
    "OBJECT",
    "OCICOLL",
    "OCIDATE",
    "OCIDATETIME",
    "OCIDURATION",
    "OCIINTERVAL",
    "OCILOBLOCATOR",
    "OCINUMBER",
    "OCIRAW",
    "OCIREF",
    "OCIREFCURSOR",
    "OCIROWID",
    "OCISTRING",
    "OCITYPE",
    "OF",
    "ON",
    "ONLY",
    "OPAQUE",
    "OPEN",
    "OPERATOR",
    "OPTION",
    "OR",
    "ORACLE",
    "ORADATA",
    "ORDER",
    "OVERLAPS",
    "ORGANIZATION",
    "ORLANY",
    "ORLVARY",
    "OTHERS",
    "OUT",
    "OVERRIDING",
    "PACKAGE",
    "PARALLEL_ENABLE",
    "PARAMETER",
    "PARAMETERS",
    "PARTITION",
    "PASCAL",
    "PIPE",
    "PIPELINED",
    "PRAGMA",
    "PRECISION",
    "PRIOR",
    "PRIVATE",
    "PROCEDURE",
    "PUBLIC",
    "RAISE",
    "RANGE",
    "RAW",
    "READ",
    "RECORD",
    "REF",
    "REFERENCE",
    "REM",
    "REMAINDER",
    "RENAME",
    "RESOURCE",
    "RESULT",
    "RETURN",
    "RETURNING",
    "REVERSE",
    "REVOKE",
    "ROLLBACK",
    "ROW",
    "SAMPLE",
    "SAVE",
    "SAVEPOINT",
    "SB1",
    "SB2",
    "SB4",
    "SECOND",
    "SEGMENT",
    "SELECT",
    "SELF",
    "SEPARATE",
    "SEQUENCE",
    "SERIALIZABLE",
    "SET",
    "SHARE",
    "SHORT",
    "SIZE",
    "SIZE_T",
    "SOME",
    "SPARSE",
    "SQL",
    "SQLCODE",
    "SQLDATA",
    "SQLNAME",
    "SQLSTATE",
    "STANDARD",
    "START",
    "STATIC",
    "STDDEV",
    "STORED",
    "STRING",
    "STRUCT",
    "STYLE",
    "SUBMULTISET",
    "SUBPARTITION",
    "SUBSTITUTABLE",
    "SUBTYPE",
    "SUM",
    "SYNONYM",
    "TABAUTH",
    "TABLE",
    "TDO",
    "THE",
    "THEN",
    "TIME",
    "TIMESTAMP",
    "TIMEZONE_ABBR",
    "TIMEZONE_HOUR",
    "TIMEZONE_MINUTE",
    "TIMEZONE_REGION",
    "TO",
    "TRAILING",
    "TRANSAC",
    "TRANSACTIONAL",
    "TRUSTED",
    "TYPE",
    "UB1",
    "UB2",
    "UB4",
    "UNDER",
    "UNION",
    "UNIQUE",
    "UNSIGNED",
    "UNTRUSTED",
    "UPDATE",
    "USE",
    "USING",
    "VALIST",
    "VALUE",
    "VALUES",
    "VARIABLE",
    "VARIANCE",
    "VARRAY",
    "VARYING",
    "VIEW",
    "VIEWS",
    "VOID",
    "WHEN",
    "WHERE",
    "WHILE",
    "WITH",
    "WORK",
    "WRAPPED",
    "WRITE",
    "YEAR",
    "ZONE"
  ]
}), LH = Ne({
  // https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions001.htm
  numeric: ["ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "BITAND", "CEIL", "COS", "COSH", "EXP", "FLOOR", "LN", "LOG", "MOD", "NANVL", "POWER", "REMAINDER", "ROUND", "SIGN", "SIN", "SINH", "SQRT", "TAN", "TANH", "TRUNC", "WIDTH_BUCKET"],
  character: ["CHR", "CONCAT", "INITCAP", "LOWER", "LPAD", "LTRIM", "NLS_INITCAP", "NLS_LOWER", "NLSSORT", "NLS_UPPER", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPLACE", "RPAD", "RTRIM", "SOUNDEX", "SUBSTR", "TRANSLATE", "TREAT", "TRIM", "UPPER", "NLS_CHARSET_DECL_LEN", "NLS_CHARSET_ID", "NLS_CHARSET_NAME", "ASCII", "INSTR", "LENGTH", "REGEXP_INSTR"],
  datetime: ["ADD_MONTHS", "CURRENT_DATE", "CURRENT_TIMESTAMP", "DBTIMEZONE", "EXTRACT", "FROM_TZ", "LAST_DAY", "LOCALTIMESTAMP", "MONTHS_BETWEEN", "NEW_TIME", "NEXT_DAY", "NUMTODSINTERVAL", "NUMTOYMINTERVAL", "ROUND", "SESSIONTIMEZONE", "SYS_EXTRACT_UTC", "SYSDATE", "SYSTIMESTAMP", "TO_CHAR", "TO_TIMESTAMP", "TO_TIMESTAMP_TZ", "TO_DSINTERVAL", "TO_YMINTERVAL", "TRUNC", "TZ_OFFSET"],
  comparison: ["GREATEST", "LEAST"],
  conversion: ["ASCIISTR", "BIN_TO_NUM", "CAST", "CHARTOROWID", "COMPOSE", "CONVERT", "DECOMPOSE", "HEXTORAW", "NUMTODSINTERVAL", "NUMTOYMINTERVAL", "RAWTOHEX", "RAWTONHEX", "ROWIDTOCHAR", "ROWIDTONCHAR", "SCN_TO_TIMESTAMP", "TIMESTAMP_TO_SCN", "TO_BINARY_DOUBLE", "TO_BINARY_FLOAT", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_DSINTERVAL", "TO_LOB", "TO_MULTI_BYTE", "TO_NCHAR", "TO_NCLOB", "TO_NUMBER", "TO_DSINTERVAL", "TO_SINGLE_BYTE", "TO_TIMESTAMP", "TO_TIMESTAMP_TZ", "TO_YMINTERVAL", "TO_YMINTERVAL", "TRANSLATE", "UNISTR"],
  largeObject: ["BFILENAME", "EMPTY_BLOB,", "EMPTY_CLOB"],
  collection: ["CARDINALITY", "COLLECT", "POWERMULTISET", "POWERMULTISET_BY_CARDINALITY", "SET"],
  hierarchical: ["SYS_CONNECT_BY_PATH"],
  dataMining: ["CLUSTER_ID", "CLUSTER_PROBABILITY", "CLUSTER_SET", "FEATURE_ID", "FEATURE_SET", "FEATURE_VALUE", "PREDICTION", "PREDICTION_COST", "PREDICTION_DETAILS", "PREDICTION_PROBABILITY", "PREDICTION_SET"],
  xml: ["APPENDCHILDXML", "DELETEXML", "DEPTH", "EXTRACT", "EXISTSNODE", "EXTRACTVALUE", "INSERTCHILDXML", "INSERTXMLBEFORE", "PATH", "SYS_DBURIGEN", "SYS_XMLAGG", "SYS_XMLGEN", "UPDATEXML", "XMLAGG", "XMLCDATA", "XMLCOLATTVAL", "XMLCOMMENT", "XMLCONCAT", "XMLFOREST", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROOT", "XMLSEQUENCE", "XMLSERIALIZE", "XMLTABLE", "XMLTRANSFORM"],
  encoding: ["DECODE", "DUMP", "ORA_HASH", "VSIZE"],
  nullRelated: ["COALESCE", "LNNVL", "NULLIF", "NVL", "NVL2"],
  env: ["SYS_CONTEXT", "SYS_GUID", "SYS_TYPEID", "UID", "USER", "USERENV"],
  aggregate: ["AVG", "COLLECT", "CORR", "CORR_S", "CORR_K", "COUNT", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "DENSE_RANK", "FIRST", "GROUP_ID", "GROUPING", "GROUPING_ID", "LAST", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "RANK", "REGR_SLOPE", "REGR_INTERCEPT", "REGR_COUNT", "REGR_R2", "REGR_AVGX", "REGR_AVGY", "REGR_SXX", "REGR_SYY", "REGR_SXY", "STATS_BINOMIAL_TEST", "STATS_CROSSTAB", "STATS_F_TEST", "STATS_KS_TEST", "STATS_MODE", "STATS_MW_TEST", "STATS_ONE_WAY_ANOVA", "STATS_T_TEST_ONE", "STATS_T_TEST_PAIRED", "STATS_T_TEST_INDEP", "STATS_T_TEST_INDEPU", "STATS_WSR_TEST", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE"],
  // Windowing functions (minus the ones already listed in aggregates)
  window: ["FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTILE", "RATIO_TO_REPORT", "ROW_NUMBER"],
  objectReference: ["DEREF", "MAKE_REF", "REF", "REFTOHEX", "VALUE"],
  model: ["CV", "ITERATION_NUMBER", "PRESENTNNV", "PRESENTV", "PREVIOUS"],
  // Parameterized data types
  // https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html
  dataTypes: [
    // Oracle builtin data types
    "VARCHAR2",
    "NVARCHAR2",
    "NUMBER",
    "FLOAT",
    "TIMESTAMP",
    "INTERVAL YEAR",
    "INTERVAL DAY",
    "RAW",
    "UROWID",
    "NCHAR",
    // ANSI Data Types
    "CHARACTER",
    "CHAR",
    "CHARACTER VARYING",
    "CHAR VARYING",
    "NATIONAL CHARACTER",
    "NATIONAL CHAR",
    "NATIONAL CHARACTER VARYING",
    "NATIONAL CHAR VARYING",
    "NCHAR VARYING",
    "NUMERIC",
    "DECIMAL",
    "FLOAT",
    // SQL/DS and DB2 Data Types
    "VARCHAR"
  ]
}), wH = V(["SELECT [ALL | DISTINCT | UNIQUE]"]), yH = V([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER [SIBLINGS] BY",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  "FOR UPDATE [OF]",
  // Data manipulation
  // - insert:
  "INSERT [INTO | ALL INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  // Data definition
  "CREATE [OR REPLACE] [NO FORCE | FORCE] [EDITIONING | EDITIONABLE | EDITIONABLE EDITIONING | NONEDITIONABLE] VIEW",
  "CREATE MATERIALIZED VIEW",
  "CREATE [GLOBAL TEMPORARY | PRIVATE TEMPORARY | SHARDED | DUPLICATED | IMMUTABLE BLOCKCHAIN | BLOCKCHAIN | IMMUTABLE] TABLE",
  // other
  "RETURNING"
]), jb = V([
  // - update:
  "UPDATE [ONLY]",
  // - delete:
  "DELETE FROM [ONLY]",
  // - drop table:
  "DROP TABLE",
  // - alter table:
  "ALTER TABLE",
  "ADD",
  "DROP {COLUMN | UNUSED COLUMNS | COLUMNS CONTINUE}",
  "MODIFY",
  "RENAME TO",
  "RENAME COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "SET SCHEMA",
  "BEGIN",
  "CONNECT BY",
  "DECLARE",
  "EXCEPT",
  "EXCEPTION",
  "LOOP",
  "START WITH"
]), DH = V(["UNION [ALL]", "EXCEPT", "INTERSECT"]), xH = V([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN",
  // non-standard joins
  "{CROSS | OUTER} APPLY"
]), MH = V(["ON {UPDATE | DELETE} [SET NULL]", "ON COMMIT", "{ROWS | RANGE} BETWEEN"]), UH = {
  tokenizerOptions: {
    reservedSelect: wH,
    reservedClauses: [...yH, ...jb],
    reservedSetOperations: DH,
    reservedJoins: xH,
    reservedPhrases: MH,
    supportsXor: !0,
    reservedKeywords: PH,
    reservedFunctionNames: LH,
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["N"]
    }, {
      quote: "q''",
      prefixes: ["N"]
    }],
    // PL/SQL doesn't actually support escaping of quotes in identifiers,
    // but for the sake of simpler testing we'll support this anyway
    // as all other SQL dialects with "identifiers" do.
    identTypes: ['""-qq'],
    identChars: {
      rest: "$#"
    },
    variableTypes: [{
      regex: "&{1,2}[A-Za-z][A-Za-z0-9_$#]*"
    }],
    paramTypes: {
      numbered: [":"],
      named: [":"]
    },
    paramChars: {},
    // Empty object used on purpose to not allow $ and # chars as specified in identChars
    operators: [
      "**",
      ":=",
      "%",
      "~=",
      "^=",
      // '..', // Conflicts with float followed by dot (so "2..3" gets parsed as ["2.", ".", "3"])
      ">>",
      "<<",
      "=>",
      "@",
      "||"
    ],
    postProcess: QH
  },
  formatOptions: {
    alwaysDenseOperators: ["@"],
    onelineClauses: jb
  }
};
function QH(i) {
  let e = rs;
  return i.map((t) => Ro.SET(t) && Ro.BY(e) ? {
    ...t,
    type: k.RESERVED_KEYWORD
  } : ($I(t.type) && (e = t), t));
}
const kH = Ne({
  // https://www.postgresql.org/docs/14/functions.html
  //
  // https://www.postgresql.org/docs/14/functions-math.html
  math: ["ABS", "ACOS", "ACOSD", "ACOSH", "ASIN", "ASIND", "ASINH", "ATAN", "ATAN2", "ATAN2D", "ATAND", "ATANH", "CBRT", "CEIL", "CEILING", "COS", "COSD", "COSH", "COT", "COTD", "DEGREES", "DIV", "EXP", "FACTORIAL", "FLOOR", "GCD", "LCM", "LN", "LOG", "LOG10", "MIN_SCALE", "MOD", "PI", "POWER", "RADIANS", "RANDOM", "ROUND", "SCALE", "SETSEED", "SIGN", "SIN", "SIND", "SINH", "SQRT", "TAN", "TAND", "TANH", "TRIM_SCALE", "TRUNC", "WIDTH_BUCKET"],
  // https://www.postgresql.org/docs/14/functions-string.html
  string: ["ABS", "ASCII", "BIT_LENGTH", "BTRIM", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHR", "CONCAT", "CONCAT_WS", "FORMAT", "INITCAP", "LEFT", "LENGTH", "LOWER", "LPAD", "LTRIM", "MD5", "NORMALIZE", "OCTET_LENGTH", "OVERLAY", "PARSE_IDENT", "PG_CLIENT_ENCODING", "POSITION", "QUOTE_IDENT", "QUOTE_LITERAL", "QUOTE_NULLABLE", "REGEXP_MATCH", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY", "REGEXP_SPLIT_TO_TABLE", "REPEAT", "REPLACE", "REVERSE", "RIGHT", "RPAD", "RTRIM", "SPLIT_PART", "SPRINTF", "STARTS_WITH", "STRING_AGG", "STRING_TO_ARRAY", "STRING_TO_TABLE", "STRPOS", "SUBSTR", "SUBSTRING", "TO_ASCII", "TO_HEX", "TRANSLATE", "TRIM", "UNISTR", "UPPER"],
  // https://www.postgresql.org/docs/14/functions-binarystring.html
  binary: ["BIT_COUNT", "BIT_LENGTH", "BTRIM", "CONVERT", "CONVERT_FROM", "CONVERT_TO", "DECODE", "ENCODE", "GET_BIT", "GET_BYTE", "LENGTH", "LTRIM", "MD5", "OCTET_LENGTH", "OVERLAY", "POSITION", "RTRIM", "SET_BIT", "SET_BYTE", "SHA224", "SHA256", "SHA384", "SHA512", "STRING_AGG", "SUBSTR", "SUBSTRING", "TRIM"],
  // https://www.postgresql.org/docs/14/functions-bitstring.html
  bitstring: ["BIT_COUNT", "BIT_LENGTH", "GET_BIT", "LENGTH", "OCTET_LENGTH", "OVERLAY", "POSITION", "SET_BIT", "SUBSTRING"],
  // https://www.postgresql.org/docs/14/functions-matching.html
  pattern: ["REGEXP_MATCH", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY", "REGEXP_SPLIT_TO_TABLE"],
  // https://www.postgresql.org/docs/14/functions-formatting.html
  datatype: ["TO_CHAR", "TO_DATE", "TO_NUMBER", "TO_TIMESTAMP"],
  // https://www.postgresql.org/docs/14/functions-datetime.html
  datetime: [
    // 'AGE',
    "CLOCK_TIMESTAMP",
    "CURRENT_DATE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "DATE_BIN",
    "DATE_PART",
    "DATE_TRUNC",
    "EXTRACT",
    "ISFINITE",
    "JUSTIFY_DAYS",
    "JUSTIFY_HOURS",
    "JUSTIFY_INTERVAL",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "MAKE_DATE",
    "MAKE_INTERVAL",
    "MAKE_TIME",
    "MAKE_TIMESTAMP",
    "MAKE_TIMESTAMPTZ",
    "NOW",
    "PG_SLEEP",
    "PG_SLEEP_FOR",
    "PG_SLEEP_UNTIL",
    "STATEMENT_TIMESTAMP",
    "TIMEOFDAY",
    "TO_TIMESTAMP",
    "TRANSACTION_TIMESTAMP"
  ],
  // https://www.postgresql.org/docs/14/functions-enum.html
  enum: ["ENUM_FIRST", "ENUM_LAST", "ENUM_RANGE"],
  // https://www.postgresql.org/docs/14/functions-geometry.html
  geometry: ["AREA", "BOUND_BOX", "BOX", "CENTER", "CIRCLE", "DIAGONAL", "DIAMETER", "HEIGHT", "ISCLOSED", "ISOPEN", "LENGTH", "LINE", "LSEG", "NPOINTS", "PATH", "PCLOSE", "POINT", "POLYGON", "POPEN", "RADIUS", "SLOPE", "WIDTH"],
  // https://www.postgresql.org/docs/14/functions-net.html
  network: ["ABBREV", "BROADCAST", "FAMILY", "HOST", "HOSTMASK", "INET_MERGE", "INET_SAME_FAMILY", "MACADDR8_SET7BIT", "MASKLEN", "NETMASK", "NETWORK", "SET_MASKLEN", "TEXT", "TRUNC"],
  // https://www.postgresql.org/docs/14/functions-textsearch.html
  textsearch: ["ARRAY_TO_TSVECTOR", "GET_CURRENT_TS_CONFIG", "JSONB_TO_TSVECTOR", "JSON_TO_TSVECTOR", "LENGTH", "NUMNODE", "PHRASETO_TSQUERY", "PLAINTO_TSQUERY", "QUERYTREE", "SETWEIGHT", "STRIP", "TO_TSQUERY", "TO_TSVECTOR", "TSQUERY_PHRASE", "TSVECTOR_TO_ARRAY", "TS_DEBUG", "TS_DELETE", "TS_FILTER", "TS_HEADLINE", "TS_LEXIZE", "TS_PARSE", "TS_RANK", "TS_RANK_CD", "TS_REWRITE", "TS_STAT", "TS_TOKEN_TYPE", "WEBSEARCH_TO_TSQUERY"],
  // https://www.postgresql.org/docs/14/functions-uuid.html
  uuid: ["UUID"],
  // https://www.postgresql.org/docs/14/functions-xml.html
  xml: ["CURSOR_TO_XML", "CURSOR_TO_XMLSCHEMA", "DATABASE_TO_XML", "DATABASE_TO_XMLSCHEMA", "DATABASE_TO_XML_AND_XMLSCHEMA", "NEXTVAL", "QUERY_TO_XML", "QUERY_TO_XMLSCHEMA", "QUERY_TO_XML_AND_XMLSCHEMA", "SCHEMA_TO_XML", "SCHEMA_TO_XMLSCHEMA", "SCHEMA_TO_XML_AND_XMLSCHEMA", "STRING", "TABLE_TO_XML", "TABLE_TO_XMLSCHEMA", "TABLE_TO_XML_AND_XMLSCHEMA", "XMLAGG", "XMLCOMMENT", "XMLCONCAT", "XMLELEMENT", "XMLEXISTS", "XMLFOREST", "XMLPARSE", "XMLPI", "XMLROOT", "XMLSERIALIZE", "XMLTABLE", "XML_IS_WELL_FORMED", "XML_IS_WELL_FORMED_CONTENT", "XML_IS_WELL_FORMED_DOCUMENT", "XPATH", "XPATH_EXISTS"],
  // https://www.postgresql.org/docs/14/functions-json.html
  json: ["ARRAY_TO_JSON", "JSONB_AGG", "JSONB_ARRAY_ELEMENTS", "JSONB_ARRAY_ELEMENTS_TEXT", "JSONB_ARRAY_LENGTH", "JSONB_BUILD_ARRAY", "JSONB_BUILD_OBJECT", "JSONB_EACH", "JSONB_EACH_TEXT", "JSONB_EXTRACT_PATH", "JSONB_EXTRACT_PATH_TEXT", "JSONB_INSERT", "JSONB_OBJECT", "JSONB_OBJECT_AGG", "JSONB_OBJECT_KEYS", "JSONB_PATH_EXISTS", "JSONB_PATH_EXISTS_TZ", "JSONB_PATH_MATCH", "JSONB_PATH_MATCH_TZ", "JSONB_PATH_QUERY", "JSONB_PATH_QUERY_ARRAY", "JSONB_PATH_QUERY_ARRAY_TZ", "JSONB_PATH_QUERY_FIRST", "JSONB_PATH_QUERY_FIRST_TZ", "JSONB_PATH_QUERY_TZ", "JSONB_POPULATE_RECORD", "JSONB_POPULATE_RECORDSET", "JSONB_PRETTY", "JSONB_SET", "JSONB_SET_LAX", "JSONB_STRIP_NULLS", "JSONB_TO_RECORD", "JSONB_TO_RECORDSET", "JSONB_TYPEOF", "JSON_AGG", "JSON_ARRAY_ELEMENTS", "JSON_ARRAY_ELEMENTS_TEXT", "JSON_ARRAY_LENGTH", "JSON_BUILD_ARRAY", "JSON_BUILD_OBJECT", "JSON_EACH", "JSON_EACH_TEXT", "JSON_EXTRACT_PATH", "JSON_EXTRACT_PATH_TEXT", "JSON_OBJECT", "JSON_OBJECT_AGG", "JSON_OBJECT_KEYS", "JSON_POPULATE_RECORD", "JSON_POPULATE_RECORDSET", "JSON_STRIP_NULLS", "JSON_TO_RECORD", "JSON_TO_RECORDSET", "JSON_TYPEOF", "ROW_TO_JSON", "TO_JSON", "TO_JSONB", "TO_TIMESTAMP"],
  // https://www.postgresql.org/docs/14/functions-sequence.html
  sequence: ["CURRVAL", "LASTVAL", "NEXTVAL", "SETVAL"],
  // https://www.postgresql.org/docs/14/functions-conditional.html
  conditional: [
    // 'CASE',
    "COALESCE",
    "GREATEST",
    "LEAST",
    "NULLIF"
  ],
  // https://www.postgresql.org/docs/14/functions-array.html
  array: ["ARRAY_AGG", "ARRAY_APPEND", "ARRAY_CAT", "ARRAY_DIMS", "ARRAY_FILL", "ARRAY_LENGTH", "ARRAY_LOWER", "ARRAY_NDIMS", "ARRAY_POSITION", "ARRAY_POSITIONS", "ARRAY_PREPEND", "ARRAY_REMOVE", "ARRAY_REPLACE", "ARRAY_TO_STRING", "ARRAY_UPPER", "CARDINALITY", "STRING_TO_ARRAY", "TRIM_ARRAY", "UNNEST"],
  // https://www.postgresql.org/docs/14/functions-range.html
  range: ["ISEMPTY", "LOWER", "LOWER_INC", "LOWER_INF", "MULTIRANGE", "RANGE_MERGE", "UPPER", "UPPER_INC", "UPPER_INF"],
  // https://www.postgresql.org/docs/14/functions-aggregate.html
  aggregate: [
    // 'ANY',
    "ARRAY_AGG",
    "AVG",
    "BIT_AND",
    "BIT_OR",
    "BIT_XOR",
    "BOOL_AND",
    "BOOL_OR",
    "COALESCE",
    "CORR",
    "COUNT",
    "COVAR_POP",
    "COVAR_SAMP",
    "CUME_DIST",
    "DENSE_RANK",
    "EVERY",
    "GROUPING",
    "JSONB_AGG",
    "JSONB_OBJECT_AGG",
    "JSON_AGG",
    "JSON_OBJECT_AGG",
    "MAX",
    "MIN",
    "MODE",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC",
    "PERCENT_RANK",
    "RANGE_AGG",
    "RANGE_INTERSECT_AGG",
    "RANK",
    "REGR_AVGX",
    "REGR_AVGY",
    "REGR_COUNT",
    "REGR_INTERCEPT",
    "REGR_R2",
    "REGR_SLOPE",
    "REGR_SXX",
    "REGR_SXY",
    "REGR_SYY",
    // 'SOME',
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STRING_AGG",
    "SUM",
    "TO_JSON",
    "TO_JSONB",
    "VARIANCE",
    "VAR_POP",
    "VAR_SAMP",
    "XMLAGG"
  ],
  // https://www.postgresql.org/docs/14/functions-window.html
  window: ["CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "RANK", "ROW_NUMBER"],
  // https://www.postgresql.org/docs/14/functions-srf.html
  set: ["GENERATE_SERIES", "GENERATE_SUBSCRIPTS"],
  // https://www.postgresql.org/docs/14/functions-info.html
  sysInfo: ["ACLDEFAULT", "ACLEXPLODE", "COL_DESCRIPTION", "CURRENT_CATALOG", "CURRENT_DATABASE", "CURRENT_QUERY", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_USER", "FORMAT_TYPE", "HAS_ANY_COLUMN_PRIVILEGE", "HAS_COLUMN_PRIVILEGE", "HAS_DATABASE_PRIVILEGE", "HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE", "HAS_FUNCTION_PRIVILEGE", "HAS_LANGUAGE_PRIVILEGE", "HAS_SCHEMA_PRIVILEGE", "HAS_SEQUENCE_PRIVILEGE", "HAS_SERVER_PRIVILEGE", "HAS_TABLESPACE_PRIVILEGE", "HAS_TABLE_PRIVILEGE", "HAS_TYPE_PRIVILEGE", "INET_CLIENT_ADDR", "INET_CLIENT_PORT", "INET_SERVER_ADDR", "INET_SERVER_PORT", "MAKEACLITEM", "OBJ_DESCRIPTION", "PG_BACKEND_PID", "PG_BLOCKING_PIDS", "PG_COLLATION_IS_VISIBLE", "PG_CONF_LOAD_TIME", "PG_CONTROL_CHECKPOINT", "PG_CONTROL_INIT", "PG_CONTROL_SYSTEM", "PG_CONVERSION_IS_VISIBLE", "PG_CURRENT_LOGFILE", "PG_CURRENT_SNAPSHOT", "PG_CURRENT_XACT_ID", "PG_CURRENT_XACT_ID_IF_ASSIGNED", "PG_DESCRIBE_OBJECT", "PG_FUNCTION_IS_VISIBLE", "PG_GET_CATALOG_FOREIGN_KEYS", "PG_GET_CONSTRAINTDEF", "PG_GET_EXPR", "PG_GET_FUNCTIONDEF", "PG_GET_FUNCTION_ARGUMENTS", "PG_GET_FUNCTION_IDENTITY_ARGUMENTS", "PG_GET_FUNCTION_RESULT", "PG_GET_INDEXDEF", "PG_GET_KEYWORDS", "PG_GET_OBJECT_ADDRESS", "PG_GET_OWNED_SEQUENCE", "PG_GET_RULEDEF", "PG_GET_SERIAL_SEQUENCE", "PG_GET_STATISTICSOBJDEF", "PG_GET_TRIGGERDEF", "PG_GET_USERBYID", "PG_GET_VIEWDEF", "PG_HAS_ROLE", "PG_IDENTIFY_OBJECT", "PG_IDENTIFY_OBJECT_AS_ADDRESS", "PG_INDEXAM_HAS_PROPERTY", "PG_INDEX_COLUMN_HAS_PROPERTY", "PG_INDEX_HAS_PROPERTY", "PG_IS_OTHER_TEMP_SCHEMA", "PG_JIT_AVAILABLE", "PG_LAST_COMMITTED_XACT", "PG_LISTENING_CHANNELS", "PG_MY_TEMP_SCHEMA", "PG_NOTIFICATION_QUEUE_USAGE", "PG_OPCLASS_IS_VISIBLE", "PG_OPERATOR_IS_VISIBLE", "PG_OPFAMILY_IS_VISIBLE", "PG_OPTIONS_TO_TABLE", "PG_POSTMASTER_START_TIME", "PG_SAFE_SNAPSHOT_BLOCKING_PIDS", "PG_SNAPSHOT_XIP", "PG_SNAPSHOT_XMAX", "PG_SNAPSHOT_XMIN", "PG_STATISTICS_OBJ_IS_VISIBLE", "PG_TABLESPACE_DATABASES", "PG_TABLESPACE_LOCATION", "PG_TABLE_IS_VISIBLE", "PG_TRIGGER_DEPTH", "PG_TS_CONFIG_IS_VISIBLE", "PG_TS_DICT_IS_VISIBLE", "PG_TS_PARSER_IS_VISIBLE", "PG_TS_TEMPLATE_IS_VISIBLE", "PG_TYPEOF", "PG_TYPE_IS_VISIBLE", "PG_VISIBLE_IN_SNAPSHOT", "PG_XACT_COMMIT_TIMESTAMP", "PG_XACT_COMMIT_TIMESTAMP_ORIGIN", "PG_XACT_STATUS", "PQSERVERVERSION", "ROW_SECURITY_ACTIVE", "SESSION_USER", "SHOBJ_DESCRIPTION", "TO_REGCLASS", "TO_REGCOLLATION", "TO_REGNAMESPACE", "TO_REGOPER", "TO_REGOPERATOR", "TO_REGPROC", "TO_REGPROCEDURE", "TO_REGROLE", "TO_REGTYPE", "TXID_CURRENT", "TXID_CURRENT_IF_ASSIGNED", "TXID_CURRENT_SNAPSHOT", "TXID_SNAPSHOT_XIP", "TXID_SNAPSHOT_XMAX", "TXID_SNAPSHOT_XMIN", "TXID_STATUS", "TXID_VISIBLE_IN_SNAPSHOT", "USER", "VERSION"],
  // https://www.postgresql.org/docs/14/functions-admin.html
  sysAdmin: ["BRIN_DESUMMARIZE_RANGE", "BRIN_SUMMARIZE_NEW_VALUES", "BRIN_SUMMARIZE_RANGE", "CONVERT_FROM", "CURRENT_SETTING", "GIN_CLEAN_PENDING_LIST", "PG_ADVISORY_LOCK", "PG_ADVISORY_LOCK_SHARED", "PG_ADVISORY_UNLOCK", "PG_ADVISORY_UNLOCK_ALL", "PG_ADVISORY_UNLOCK_SHARED", "PG_ADVISORY_XACT_LOCK", "PG_ADVISORY_XACT_LOCK_SHARED", "PG_BACKUP_START_TIME", "PG_CANCEL_BACKEND", "PG_COLLATION_ACTUAL_VERSION", "PG_COLUMN_COMPRESSION", "PG_COLUMN_SIZE", "PG_COPY_LOGICAL_REPLICATION_SLOT", "PG_COPY_PHYSICAL_REPLICATION_SLOT", "PG_CREATE_LOGICAL_REPLICATION_SLOT", "PG_CREATE_PHYSICAL_REPLICATION_SLOT", "PG_CREATE_RESTORE_POINT", "PG_CURRENT_WAL_FLUSH_LSN", "PG_CURRENT_WAL_INSERT_LSN", "PG_CURRENT_WAL_LSN", "PG_DATABASE_SIZE", "PG_DROP_REPLICATION_SLOT", "PG_EXPORT_SNAPSHOT", "PG_FILENODE_RELATION", "PG_GET_WAL_REPLAY_PAUSE_STATE", "PG_IMPORT_SYSTEM_COLLATIONS", "PG_INDEXES_SIZE", "PG_IS_IN_BACKUP", "PG_IS_IN_RECOVERY", "PG_IS_WAL_REPLAY_PAUSED", "PG_LAST_WAL_RECEIVE_LSN", "PG_LAST_WAL_REPLAY_LSN", "PG_LAST_XACT_REPLAY_TIMESTAMP", "PG_LOGICAL_EMIT_MESSAGE", "PG_LOGICAL_SLOT_GET_BINARY_CHANGES", "PG_LOGICAL_SLOT_GET_CHANGES", "PG_LOGICAL_SLOT_PEEK_BINARY_CHANGES", "PG_LOGICAL_SLOT_PEEK_CHANGES", "PG_LOG_BACKEND_MEMORY_CONTEXTS", "PG_LS_ARCHIVE_STATUSDIR", "PG_LS_DIR", "PG_LS_LOGDIR", "PG_LS_TMPDIR", "PG_LS_WALDIR", "PG_PARTITION_ANCESTORS", "PG_PARTITION_ROOT", "PG_PARTITION_TREE", "PG_PROMOTE", "PG_READ_BINARY_FILE", "PG_READ_FILE", "PG_RELATION_FILENODE", "PG_RELATION_FILEPATH", "PG_RELATION_SIZE", "PG_RELOAD_CONF", "PG_REPLICATION_ORIGIN_ADVANCE", "PG_REPLICATION_ORIGIN_CREATE", "PG_REPLICATION_ORIGIN_DROP", "PG_REPLICATION_ORIGIN_OID", "PG_REPLICATION_ORIGIN_PROGRESS", "PG_REPLICATION_ORIGIN_SESSION_IS_SETUP", "PG_REPLICATION_ORIGIN_SESSION_PROGRESS", "PG_REPLICATION_ORIGIN_SESSION_RESET", "PG_REPLICATION_ORIGIN_SESSION_SETUP", "PG_REPLICATION_ORIGIN_XACT_RESET", "PG_REPLICATION_ORIGIN_XACT_SETUP", "PG_REPLICATION_SLOT_ADVANCE", "PG_ROTATE_LOGFILE", "PG_SIZE_BYTES", "PG_SIZE_PRETTY", "PG_START_BACKUP", "PG_STAT_FILE", "PG_STOP_BACKUP", "PG_SWITCH_WAL", "PG_TABLESPACE_SIZE", "PG_TABLE_SIZE", "PG_TERMINATE_BACKEND", "PG_TOTAL_RELATION_SIZE", "PG_TRY_ADVISORY_LOCK", "PG_TRY_ADVISORY_LOCK_SHARED", "PG_TRY_ADVISORY_XACT_LOCK", "PG_TRY_ADVISORY_XACT_LOCK_SHARED", "PG_WALFILE_NAME", "PG_WALFILE_NAME_OFFSET", "PG_WAL_LSN_DIFF", "PG_WAL_REPLAY_PAUSE", "PG_WAL_REPLAY_RESUME", "SET_CONFIG"],
  // https://www.postgresql.org/docs/14/functions-trigger.html
  trigger: ["SUPPRESS_REDUNDANT_UPDATES_TRIGGER", "TSVECTOR_UPDATE_TRIGGER", "TSVECTOR_UPDATE_TRIGGER_COLUMN"],
  // https://www.postgresql.org/docs/14/functions-event-triggers.html
  eventTrigger: ["PG_EVENT_TRIGGER_DDL_COMMANDS", "PG_EVENT_TRIGGER_DROPPED_OBJECTS", "PG_EVENT_TRIGGER_TABLE_REWRITE_OID", "PG_EVENT_TRIGGER_TABLE_REWRITE_REASON", "PG_GET_OBJECT_ADDRESS"],
  // https://www.postgresql.org/docs/14/functions-statistics.html
  stats: ["PG_MCV_LIST_ITEMS"],
  cast: ["CAST"],
  // Parameterized data types
  // https://www.postgresql.org/docs/current/datatype.html
  dataTypes: ["BIT", "BIT VARYING", "CHARACTER", "CHARACTER VARYING", "VARCHAR", "CHAR", "DECIMAL", "NUMERIC", "TIME", "TIMESTAMP", "ENUM"]
}), $H = Ne({
  // https://www.postgresql.org/docs/14/sql-keywords-appendix.html
  all: [
    "ABORT",
    "ABSOLUTE",
    "ACCESS",
    "ACTION",
    "ADD",
    "ADMIN",
    "AFTER",
    "AGGREGATE",
    "ALL",
    // reserved
    "ALSO",
    "ALTER",
    "ALWAYS",
    "ANALYSE",
    // reserved
    "ANALYZE",
    // reserved
    "AND",
    // reserved
    "ANY",
    // reserved
    "ARRAY",
    // reserved, requires AS
    "AS",
    // reserved, requires AS
    "ASC",
    // reserved
    "ASENSITIVE",
    "ASSERTION",
    "ASSIGNMENT",
    "ASYMMETRIC",
    // reserved
    "AT",
    "ATOMIC",
    "ATTACH",
    "ATTRIBUTE",
    "AUTHORIZATION",
    // reserved (can be function or type)
    "BACKWARD",
    "BEFORE",
    "BEGIN",
    "BETWEEN",
    // (cannot be function or type)
    "BIGINT",
    // (cannot be function or type)
    "BINARY",
    // reserved (can be function or type)
    "BIT",
    // (cannot be function or type)
    "BOOLEAN",
    // (cannot be function or type)
    "BOTH",
    // reserved
    "BREADTH",
    "BY",
    "CACHE",
    "CALL",
    "CALLED",
    "CASCADE",
    "CASCADED",
    "CASE",
    // reserved
    "CAST",
    // reserved
    "CATALOG",
    "CHAIN",
    "CHAR",
    // (cannot be function or type), requires AS
    "CHARACTER",
    // (cannot be function or type), requires AS
    "CHARACTERISTICS",
    "CHECK",
    // reserved
    "CHECKPOINT",
    "CLASS",
    "CLOSE",
    "CLUSTER",
    "COALESCE",
    // (cannot be function or type)
    "COLLATE",
    // reserved
    "COLLATION",
    // reserved (can be function or type)
    "COLUMN",
    // reserved
    "COLUMNS",
    "COMMENT",
    "COMMENTS",
    "COMMIT",
    "COMMITTED",
    "COMPRESSION",
    "CONCURRENTLY",
    // reserved (can be function or type)
    "CONFIGURATION",
    "CONFLICT",
    "CONNECTION",
    "CONSTRAINT",
    // reserved
    "CONSTRAINTS",
    "CONTENT",
    "CONTINUE",
    "CONVERSION",
    "COPY",
    "COST",
    "CREATE",
    // reserved, requires AS
    "CROSS",
    // reserved (can be function or type)
    "CSV",
    "CUBE",
    "CURRENT",
    "CURRENT_CATALOG",
    // reserved
    "CURRENT_DATE",
    // reserved
    "CURRENT_ROLE",
    // reserved
    "CURRENT_SCHEMA",
    // reserved (can be function or type)
    "CURRENT_TIME",
    // reserved
    "CURRENT_TIMESTAMP",
    // reserved
    "CURRENT_USER",
    // reserved
    "CURSOR",
    "CYCLE",
    "DATA",
    "DATABASE",
    "DAY",
    // requires AS
    "DEALLOCATE",
    "DEC",
    // (cannot be function or type)
    "DECIMAL",
    // (cannot be function or type)
    "DECLARE",
    "DEFAULT",
    // reserved
    "DEFAULTS",
    "DEFERRABLE",
    // reserved
    "DEFERRED",
    "DEFINER",
    "DELETE",
    "DELIMITER",
    "DELIMITERS",
    "DEPENDS",
    "DEPTH",
    "DESC",
    // reserved
    "DETACH",
    "DICTIONARY",
    "DISABLE",
    "DISCARD",
    "DISTINCT",
    // reserved
    "DO",
    // reserved
    "DOCUMENT",
    "DOMAIN",
    "DOUBLE",
    "DROP",
    "EACH",
    "ELSE",
    // reserved
    "ENABLE",
    "ENCODING",
    "ENCRYPTED",
    "END",
    // reserved
    "ENUM",
    "ESCAPE",
    "EVENT",
    "EXCEPT",
    // reserved, requires AS
    "EXCLUDE",
    "EXCLUDING",
    "EXCLUSIVE",
    "EXECUTE",
    "EXISTS",
    // (cannot be function or type)
    "EXPLAIN",
    "EXPRESSION",
    "EXTENSION",
    "EXTERNAL",
    "EXTRACT",
    // (cannot be function or type)
    "FALSE",
    // reserved
    "FAMILY",
    "FETCH",
    // reserved, requires AS
    "FILTER",
    // requires AS
    "FINALIZE",
    "FIRST",
    "FLOAT",
    // (cannot be function or type)
    "FOLLOWING",
    "FOR",
    // reserved, requires AS
    "FORCE",
    "FOREIGN",
    // reserved
    "FORWARD",
    "FREEZE",
    // reserved (can be function or type)
    "FROM",
    // reserved, requires AS
    "FULL",
    // reserved (can be function or type)
    "FUNCTION",
    "FUNCTIONS",
    "GENERATED",
    "GLOBAL",
    "GRANT",
    // reserved, requires AS
    "GRANTED",
    "GREATEST",
    // (cannot be function or type)
    "GROUP",
    // reserved, requires AS
    "GROUPING",
    // (cannot be function or type)
    "GROUPS",
    "HANDLER",
    "HAVING",
    // reserved, requires AS
    "HEADER",
    "HOLD",
    "HOUR",
    // requires AS
    "IDENTITY",
    "IF",
    "ILIKE",
    // reserved (can be function or type)
    "IMMEDIATE",
    "IMMUTABLE",
    "IMPLICIT",
    "IMPORT",
    "IN",
    // reserved
    "INCLUDE",
    "INCLUDING",
    "INCREMENT",
    "INDEX",
    "INDEXES",
    "INHERIT",
    "INHERITS",
    "INITIALLY",
    // reserved
    "INLINE",
    "INNER",
    // reserved (can be function or type)
    "INOUT",
    // (cannot be function or type)
    "INPUT",
    "INSENSITIVE",
    "INSERT",
    "INSTEAD",
    "INT",
    // (cannot be function or type)
    "INTEGER",
    // (cannot be function or type)
    "INTERSECT",
    // reserved, requires AS
    "INTERVAL",
    // (cannot be function or type)
    "INTO",
    // reserved, requires AS
    "INVOKER",
    "IS",
    // reserved (can be function or type)
    "ISNULL",
    // reserved (can be function or type), requires AS
    "ISOLATION",
    "JOIN",
    // reserved (can be function or type)
    "KEY",
    "LABEL",
    "LANGUAGE",
    "LARGE",
    "LAST",
    "LATERAL",
    // reserved
    "LEADING",
    // reserved
    "LEAKPROOF",
    "LEAST",
    // (cannot be function or type)
    "LEFT",
    // reserved (can be function or type)
    "LEVEL",
    "LIKE",
    // reserved (can be function or type)
    "LIMIT",
    // reserved, requires AS
    "LISTEN",
    "LOAD",
    "LOCAL",
    "LOCALTIME",
    // reserved
    "LOCALTIMESTAMP",
    // reserved
    "LOCATION",
    "LOCK",
    "LOCKED",
    "LOGGED",
    "MAPPING",
    "MATCH",
    "MATERIALIZED",
    "MAXVALUE",
    "METHOD",
    "MINUTE",
    // requires AS
    "MINVALUE",
    "MODE",
    "MONTH",
    // requires AS
    "MOVE",
    "NAME",
    "NAMES",
    "NATIONAL",
    // (cannot be function or type)
    "NATURAL",
    // reserved (can be function or type)
    "NCHAR",
    // (cannot be function or type)
    "NEW",
    "NEXT",
    "NFC",
    "NFD",
    "NFKC",
    "NFKD",
    "NO",
    "NONE",
    // (cannot be function or type)
    "NORMALIZE",
    // (cannot be function or type)
    "NORMALIZED",
    "NOT",
    // reserved
    "NOTHING",
    "NOTIFY",
    "NOTNULL",
    // reserved (can be function or type), requires AS
    "NOWAIT",
    "NULL",
    // reserved
    "NULLIF",
    // (cannot be function or type)
    "NULLS",
    "NUMERIC",
    // (cannot be function or type)
    "OBJECT",
    "OF",
    "OFF",
    "OFFSET",
    // reserved, requires AS
    "OIDS",
    "OLD",
    "ON",
    // reserved, requires AS
    "ONLY",
    // reserved
    "OPERATOR",
    "OPTION",
    "OPTIONS",
    "OR",
    // reserved
    "ORDER",
    // reserved, requires AS
    "ORDINALITY",
    "OTHERS",
    "OUT",
    // (cannot be function or type)
    "OUTER",
    // reserved (can be function or type)
    "OVER",
    // requires AS
    "OVERLAPS",
    // reserved (can be function or type), requires AS
    "OVERLAY",
    // (cannot be function or type)
    "OVERRIDING",
    "OWNED",
    "OWNER",
    "PARALLEL",
    "PARSER",
    "PARTIAL",
    "PARTITION",
    "PASSING",
    "PASSWORD",
    "PLACING",
    // reserved
    "PLANS",
    "POLICY",
    "POSITION",
    // (cannot be function or type)
    "PRECEDING",
    "PRECISION",
    // (cannot be function or type), requires AS
    "PREPARE",
    "PREPARED",
    "PRESERVE",
    "PRIMARY",
    // reserved
    "PRIOR",
    "PRIVILEGES",
    "PROCEDURAL",
    "PROCEDURE",
    "PROCEDURES",
    "PROGRAM",
    "PUBLICATION",
    "QUOTE",
    "RANGE",
    "READ",
    "REAL",
    // (cannot be function or type)
    "REASSIGN",
    "RECHECK",
    "RECURSIVE",
    "REF",
    "REFERENCES",
    // reserved
    "REFERENCING",
    "REFRESH",
    "REINDEX",
    "RELATIVE",
    "RELEASE",
    "RENAME",
    "REPEATABLE",
    "REPLACE",
    "REPLICA",
    "RESET",
    "RESTART",
    "RESTRICT",
    "RETURN",
    "RETURNING",
    // reserved, requires AS
    "RETURNS",
    "REVOKE",
    "RIGHT",
    // reserved (can be function or type)
    "ROLE",
    "ROLLBACK",
    "ROLLUP",
    "ROUTINE",
    "ROUTINES",
    "ROW",
    // (cannot be function or type)
    "ROWS",
    "RULE",
    "SAVEPOINT",
    "SCHEMA",
    "SCHEMAS",
    "SCROLL",
    "SEARCH",
    "SECOND",
    // requires AS
    "SECURITY",
    "SELECT",
    // reserved
    "SEQUENCE",
    "SEQUENCES",
    "SERIALIZABLE",
    "SERVER",
    "SESSION",
    "SESSION_USER",
    // reserved
    "SET",
    "SETOF",
    // (cannot be function or type)
    "SETS",
    "SHARE",
    "SHOW",
    "SIMILAR",
    // reserved (can be function or type)
    "SIMPLE",
    "SKIP",
    "SMALLINT",
    // (cannot be function or type)
    "SNAPSHOT",
    "SOME",
    // reserved
    "SQL",
    "STABLE",
    "STANDALONE",
    "START",
    "STATEMENT",
    "STATISTICS",
    "STDIN",
    "STDOUT",
    "STORAGE",
    "STORED",
    "STRICT",
    "STRIP",
    "SUBSCRIPTION",
    "SUBSTRING",
    // (cannot be function or type)
    "SUPPORT",
    "SYMMETRIC",
    // reserved
    "SYSID",
    "SYSTEM",
    "TABLE",
    // reserved
    "TABLES",
    "TABLESAMPLE",
    // reserved (can be function or type)
    "TABLESPACE",
    "TEMP",
    "TEMPLATE",
    "TEMPORARY",
    "TEXT",
    "THEN",
    // reserved
    "TIES",
    "TIME",
    // (cannot be function or type)
    "TIMESTAMP",
    // (cannot be function or type)
    "TO",
    // reserved, requires AS
    "TRAILING",
    // reserved
    "TRANSACTION",
    "TRANSFORM",
    "TREAT",
    // (cannot be function or type)
    "TRIGGER",
    "TRIM",
    // (cannot be function or type)
    "TRUE",
    // reserved
    "TRUNCATE",
    "TRUSTED",
    "TYPE",
    "TYPES",
    "UESCAPE",
    "UNBOUNDED",
    "UNCOMMITTED",
    "UNENCRYPTED",
    "UNION",
    // reserved, requires AS
    "UNIQUE",
    // reserved
    "UNKNOWN",
    "UNLISTEN",
    "UNLOGGED",
    "UNTIL",
    "UPDATE",
    "USER",
    // reserved
    "USING",
    // reserved
    "VACUUM",
    "VALID",
    "VALIDATE",
    "VALIDATOR",
    "VALUE",
    "VALUES",
    // (cannot be function or type)
    "VARCHAR",
    // (cannot be function or type)
    "VARIADIC",
    // reserved
    "VARYING",
    // requires AS
    "VERBOSE",
    // reserved (can be function or type)
    "VERSION",
    "VIEW",
    "VIEWS",
    "VOLATILE",
    "WHEN",
    // reserved
    "WHERE",
    // reserved, requires AS
    "WHITESPACE",
    "WINDOW",
    // reserved, requires AS
    "WITH",
    // reserved, requires AS
    "WITHIN",
    // requires AS
    "WITHOUT",
    // requires AS
    "WORK",
    "WRAPPER",
    "WRITE",
    "XML",
    "XMLATTRIBUTES",
    // (cannot be function or type)
    "XMLCONCAT",
    // (cannot be function or type)
    "XMLELEMENT",
    // (cannot be function or type)
    "XMLEXISTS",
    // (cannot be function or type)
    "XMLFOREST",
    // (cannot be function or type)
    "XMLNAMESPACES",
    // (cannot be function or type)
    "XMLPARSE",
    // (cannot be function or type)
    "XMLPI",
    // (cannot be function or type)
    "XMLROOT",
    // (cannot be function or type)
    "XMLSERIALIZE",
    // (cannot be function or type)
    "XMLTABLE",
    // (cannot be function or type)
    "YEAR",
    // requires AS
    "YES",
    "ZONE"
  ]
}), GH = V(["SELECT [ALL | DISTINCT]"]), VH = V([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  "FOR {UPDATE | NO KEY UPDATE | SHARE | KEY SHARE} [OF]",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [TEMP | TEMPORARY] [RECURSIVE] VIEW",
  "CREATE MATERIALIZED VIEW [IF NOT EXISTS]",
  "CREATE [GLOBAL | LOCAL] [TEMPORARY | TEMP | UNLOGGED] TABLE [IF NOT EXISTS]",
  // other
  "RETURNING"
]), Kb = V([
  // - update:
  "UPDATE [ONLY]",
  "WHERE CURRENT OF",
  // - insert:
  "ON CONFLICT",
  // - delete:
  "DELETE FROM [ONLY]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS] [ONLY]",
  "ALTER TABLE ALL IN TABLESPACE",
  "RENAME [COLUMN]",
  "RENAME TO",
  "ADD [COLUMN] [IF NOT EXISTS]",
  "DROP [COLUMN] [IF EXISTS]",
  "ALTER [COLUMN]",
  "[SET DATA] TYPE",
  // for alter column
  "{SET | DROP} DEFAULT",
  // for alter column
  "{SET | DROP} NOT NULL",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE] [ONLY]",
  // other
  "SET SCHEMA",
  "AFTER",
  // https://www.postgresql.org/docs/14/sql-commands.html
  "ABORT",
  "ALTER AGGREGATE",
  "ALTER COLLATION",
  "ALTER CONVERSION",
  "ALTER DATABASE",
  "ALTER DEFAULT PRIVILEGES",
  "ALTER DOMAIN",
  "ALTER EVENT TRIGGER",
  "ALTER EXTENSION",
  "ALTER FOREIGN DATA WRAPPER",
  "ALTER FOREIGN TABLE",
  "ALTER FUNCTION",
  "ALTER GROUP",
  "ALTER INDEX",
  "ALTER LANGUAGE",
  "ALTER LARGE OBJECT",
  "ALTER MATERIALIZED VIEW",
  "ALTER OPERATOR",
  "ALTER OPERATOR CLASS",
  "ALTER OPERATOR FAMILY",
  "ALTER POLICY",
  "ALTER PROCEDURE",
  "ALTER PUBLICATION",
  "ALTER ROLE",
  "ALTER ROUTINE",
  "ALTER RULE",
  "ALTER SCHEMA",
  "ALTER SEQUENCE",
  "ALTER SERVER",
  "ALTER STATISTICS",
  "ALTER SUBSCRIPTION",
  "ALTER SYSTEM",
  "ALTER TABLESPACE",
  "ALTER TEXT SEARCH CONFIGURATION",
  "ALTER TEXT SEARCH DICTIONARY",
  "ALTER TEXT SEARCH PARSER",
  "ALTER TEXT SEARCH TEMPLATE",
  "ALTER TRIGGER",
  "ALTER TYPE",
  "ALTER USER",
  "ALTER USER MAPPING",
  "ALTER VIEW",
  "ANALYZE",
  "BEGIN",
  "CALL",
  "CHECKPOINT",
  "CLOSE",
  "CLUSTER",
  "COMMENT",
  "COMMIT",
  "COMMIT PREPARED",
  "COPY",
  "CREATE ACCESS METHOD",
  "CREATE AGGREGATE",
  "CREATE CAST",
  "CREATE COLLATION",
  "CREATE CONVERSION",
  "CREATE DATABASE",
  "CREATE DOMAIN",
  "CREATE EVENT TRIGGER",
  "CREATE EXTENSION",
  "CREATE FOREIGN DATA WRAPPER",
  "CREATE FOREIGN TABLE",
  "CREATE FUNCTION",
  "CREATE GROUP",
  "CREATE INDEX",
  "CREATE LANGUAGE",
  "CREATE OPERATOR",
  "CREATE OPERATOR CLASS",
  "CREATE OPERATOR FAMILY",
  "CREATE POLICY",
  "CREATE PROCEDURE",
  "CREATE PUBLICATION",
  "CREATE ROLE",
  "CREATE RULE",
  "CREATE SCHEMA",
  "CREATE SEQUENCE",
  "CREATE SERVER",
  "CREATE STATISTICS",
  "CREATE SUBSCRIPTION",
  "CREATE TABLESPACE",
  "CREATE TEXT SEARCH CONFIGURATION",
  "CREATE TEXT SEARCH DICTIONARY",
  "CREATE TEXT SEARCH PARSER",
  "CREATE TEXT SEARCH TEMPLATE",
  "CREATE TRANSFORM",
  "CREATE TRIGGER",
  "CREATE TYPE",
  "CREATE USER",
  "CREATE USER MAPPING",
  "DEALLOCATE",
  "DECLARE",
  "DISCARD",
  "DROP ACCESS METHOD",
  "DROP AGGREGATE",
  "DROP CAST",
  "DROP COLLATION",
  "DROP CONVERSION",
  "DROP DATABASE",
  "DROP DOMAIN",
  "DROP EVENT TRIGGER",
  "DROP EXTENSION",
  "DROP FOREIGN DATA WRAPPER",
  "DROP FOREIGN TABLE",
  "DROP FUNCTION",
  "DROP GROUP",
  "DROP INDEX",
  "DROP LANGUAGE",
  "DROP MATERIALIZED VIEW",
  "DROP OPERATOR",
  "DROP OPERATOR CLASS",
  "DROP OPERATOR FAMILY",
  "DROP OWNED",
  "DROP POLICY",
  "DROP PROCEDURE",
  "DROP PUBLICATION",
  "DROP ROLE",
  "DROP ROUTINE",
  "DROP RULE",
  "DROP SCHEMA",
  "DROP SEQUENCE",
  "DROP SERVER",
  "DROP STATISTICS",
  "DROP SUBSCRIPTION",
  "DROP TABLESPACE",
  "DROP TEXT SEARCH CONFIGURATION",
  "DROP TEXT SEARCH DICTIONARY",
  "DROP TEXT SEARCH PARSER",
  "DROP TEXT SEARCH TEMPLATE",
  "DROP TRANSFORM",
  "DROP TRIGGER",
  "DROP TYPE",
  "DROP USER",
  "DROP USER MAPPING",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FETCH",
  "GRANT",
  "IMPORT FOREIGN SCHEMA",
  "LISTEN",
  "LOAD",
  "LOCK",
  "MOVE",
  "NOTIFY",
  "PREPARE",
  "PREPARE TRANSACTION",
  "REASSIGN OWNED",
  "REFRESH MATERIALIZED VIEW",
  "REINDEX",
  "RELEASE SAVEPOINT",
  "RESET",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK PREPARED",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SECURITY LABEL",
  "SELECT INTO",
  "SET CONSTRAINTS",
  "SET ROLE",
  "SET SESSION AUTHORIZATION",
  "SET TRANSACTION",
  "SHOW",
  "START TRANSACTION",
  "UNLISTEN",
  "VACUUM"
]), HH = V(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), XH = V(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), YH = V([
  "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]",
  "{ROWS | RANGE | GROUPS} BETWEEN",
  // https://www.postgresql.org/docs/current/datatype-datetime.html
  "{TIMESTAMP | TIME} {WITH | WITHOUT} TIME ZONE",
  // comparison operator
  "IS [NOT] DISTINCT FROM"
]), BH = {
  tokenizerOptions: {
    reservedSelect: GH,
    reservedClauses: [...VH, ...Kb],
    reservedSetOperations: HH,
    reservedJoins: XH,
    reservedPhrases: YH,
    reservedKeywords: $H,
    reservedFunctionNames: kH,
    nestedBlockComments: !0,
    extraParens: ["[]"],
    stringTypes: ["$$", {
      quote: "''-qq",
      prefixes: ["U&"]
    }, {
      quote: "''-bs",
      prefixes: ["E"],
      requirePrefix: !0
    }, {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: [{
      quote: '""-qq',
      prefixes: ["U&"]
    }],
    identChars: {
      rest: "$"
    },
    paramTypes: {
      numbered: ["$"]
    },
    operators: [
      // Arithmetic
      "%",
      "^",
      "|/",
      "||/",
      "@",
      // Assignment
      ":=",
      // Bitwise
      "&",
      "|",
      "#",
      "~",
      "<<",
      ">>",
      // Byte comparison
      "~>~",
      "~<~",
      "~>=~",
      "~<=~",
      // Geometric
      "@-@",
      "@@",
      "##",
      "<->",
      "&&",
      "&<",
      "&>",
      "<<|",
      "&<|",
      "|>>",
      "|&>",
      "<^",
      "^>",
      "?#",
      "?-",
      "?|",
      "?-|",
      "?||",
      "@>",
      "<@",
      "~=",
      // JSON
      "?",
      "@?",
      "?&",
      "->",
      "->>",
      "#>",
      "#>>",
      "#-",
      // Named function params
      "=>",
      // Network address
      ">>=",
      "<<=",
      // Pattern matching
      "~~",
      "~~*",
      "!~~",
      "!~~*",
      // POSIX RegExp
      "~",
      "~*",
      "!~",
      "!~*",
      // Range/multirange
      "-|-",
      // String concatenation
      "||",
      // Text search
      "@@@",
      "!!",
      // Trigram/trigraph
      "<%",
      "%>",
      "<<%",
      "%>>",
      "<<->",
      "<->>",
      "<<<->",
      "<->>>",
      // Type cast
      "::"
    ]
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: Kb
  }
}, FH = Ne({
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Aggregate_Functions.html
  aggregate: ["ANY_VALUE", "APPROXIMATE PERCENTILE_DISC", "AVG", "COUNT", "LISTAGG", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "STDDEV_SAMP", "STDDEV_POP", "SUM", "VAR_SAMP", "VAR_POP"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Array_Functions.html
  array: ["array", "array_concat", "array_flatten", "get_array_length", "split_to_array", "subarray"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_bitwise_aggregate_functions.html
  bitwise: ["BIT_AND", "BIT_OR", "BOOL_AND", "BOOL_OR"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_conditional_expressions.html
  conditional: ["COALESCE", "DECODE", "GREATEST", "LEAST", "NVL", "NVL2", "NULLIF"],
  // https://docs.aws.amazon.com/redshift/latest/dg/Date_functions_header.html
  dateTime: ["ADD_MONTHS", "AT TIME ZONE", "CONVERT_TIMEZONE", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE_CMP", "DATE_CMP_TIMESTAMP", "DATE_CMP_TIMESTAMPTZ", "DATE_PART_YEAR", "DATEADD", "DATEDIFF", "DATE_PART", "DATE_TRUNC", "EXTRACT", "GETDATE", "INTERVAL_CMP", "LAST_DAY", "MONTHS_BETWEEN", "NEXT_DAY", "SYSDATE", "TIMEOFDAY", "TIMESTAMP_CMP", "TIMESTAMP_CMP_DATE", "TIMESTAMP_CMP_TIMESTAMPTZ", "TIMESTAMPTZ_CMP", "TIMESTAMPTZ_CMP_DATE", "TIMESTAMPTZ_CMP_TIMESTAMP", "TIMEZONE", "TO_TIMESTAMP", "TRUNC"],
  // https://docs.aws.amazon.com/redshift/latest/dg/geospatial-functions.html
  spatial: ["AddBBox", "DropBBox", "GeometryType", "ST_AddPoint", "ST_Angle", "ST_Area", "ST_AsBinary", "ST_AsEWKB", "ST_AsEWKT", "ST_AsGeoJSON", "ST_AsText", "ST_Azimuth", "ST_Boundary", "ST_Collect", "ST_Contains", "ST_ContainsProperly", "ST_ConvexHull", "ST_CoveredBy", "ST_Covers", "ST_Crosses", "ST_Dimension", "ST_Disjoint", "ST_Distance", "ST_DistanceSphere", "ST_DWithin", "ST_EndPoint", "ST_Envelope", "ST_Equals", "ST_ExteriorRing", "ST_Force2D", "ST_Force3D", "ST_Force3DM", "ST_Force3DZ", "ST_Force4D", "ST_GeometryN", "ST_GeometryType", "ST_GeomFromEWKB", "ST_GeomFromEWKT", "ST_GeomFromText", "ST_GeomFromWKB", "ST_InteriorRingN", "ST_Intersects", "ST_IsPolygonCCW", "ST_IsPolygonCW", "ST_IsClosed", "ST_IsCollection", "ST_IsEmpty", "ST_IsSimple", "ST_IsValid", "ST_Length", "ST_LengthSphere", "ST_Length2D", "ST_LineFromMultiPoint", "ST_LineInterpolatePoint", "ST_M", "ST_MakeEnvelope", "ST_MakeLine", "ST_MakePoint", "ST_MakePolygon", "ST_MemSize", "ST_MMax", "ST_MMin", "ST_Multi", "ST_NDims", "ST_NPoints", "ST_NRings", "ST_NumGeometries", "ST_NumInteriorRings", "ST_NumPoints", "ST_Perimeter", "ST_Perimeter2D", "ST_Point", "ST_PointN", "ST_Points", "ST_Polygon", "ST_RemovePoint", "ST_Reverse", "ST_SetPoint", "ST_SetSRID", "ST_Simplify", "ST_SRID", "ST_StartPoint", "ST_Touches", "ST_Within", "ST_X", "ST_XMax", "ST_XMin", "ST_Y", "ST_YMax", "ST_YMin", "ST_Z", "ST_ZMax", "ST_ZMin", "SupportsBBox"],
  // https://docs.aws.amazon.com/redshift/latest/dg/hash-functions.html
  hash: ["CHECKSUM", "FUNC_SHA1", "FNV_HASH", "MD5", "SHA", "SHA1", "SHA2"],
  // https://docs.aws.amazon.com/redshift/latest/dg/hyperloglog-functions.html
  hyperLogLog: ["HLL", "HLL_CREATE_SKETCH", "HLL_CARDINALITY", "HLL_COMBINE"],
  // https://docs.aws.amazon.com/redshift/latest/dg/json-functions.html
  json: ["IS_VALID_JSON", "IS_VALID_JSON_ARRAY", "JSON_ARRAY_LENGTH", "JSON_EXTRACT_ARRAY_ELEMENT_TEXT", "JSON_EXTRACT_PATH_TEXT", "JSON_PARSE", "JSON_SERIALIZE"],
  // https://docs.aws.amazon.com/redshift/latest/dg/Math_functions.html
  math: ["ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "CBRT", "CEILING", "CEIL", "COS", "COT", "DEGREES", "DEXP", "DLOG1", "DLOG10", "EXP", "FLOOR", "LN", "LOG", "MOD", "PI", "POWER", "RADIANS", "RANDOM", "ROUND", "SIN", "SIGN", "SQRT", "TAN", "TO_HEX", "TRUNC"],
  // https://docs.aws.amazon.com/redshift/latest/dg/ml-function.html
  machineLearning: ["EXPLAIN_MODEL"],
  // https://docs.aws.amazon.com/redshift/latest/dg/String_functions_header.html
  string: ["ASCII", "BPCHARCMP", "BTRIM", "BTTEXT_PATTERN_CMP", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHARINDEX", "CHR", "COLLATE", "CONCAT", "CRC32", "DIFFERENCE", "INITCAP", "LEFT", "RIGHT", "LEN", "LENGTH", "LOWER", "LPAD", "RPAD", "LTRIM", "OCTETINDEX", "OCTET_LENGTH", "POSITION", "QUOTE_IDENT", "QUOTE_LITERAL", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPEAT", "REPLACE", "REPLICATE", "REVERSE", "RTRIM", "SOUNDEX", "SPLIT_PART", "STRPOS", "STRTOL", "SUBSTRING", "TEXTLEN", "TRANSLATE", "TRIM", "UPPER"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Type_Info_Functions.html
  superType: ["decimal_precision", "decimal_scale", "is_array", "is_bigint", "is_boolean", "is_char", "is_decimal", "is_float", "is_integer", "is_object", "is_scalar", "is_smallint", "is_varchar", "json_typeof"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Window_functions.html
  window: ["AVG", "COUNT", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAST_VALUE", "LAG", "LEAD", "LISTAGG", "MAX", "MEDIAN", "MIN", "NTH_VALUE", "NTILE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "RATIO_TO_REPORT", "ROW_NUMBER", "STDDEV_SAMP", "STDDEV_POP", "SUM", "VAR_SAMP", "VAR_POP"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_Data_type_formatting.html
  dataType: ["CAST", "CONVERT", "TO_CHAR", "TO_DATE", "TO_NUMBER", "TEXT_TO_INT_ALT", "TEXT_TO_NUMERIC_ALT"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_System_administration_functions.html
  sysAdmin: ["CHANGE_QUERY_PRIORITY", "CHANGE_SESSION_PRIORITY", "CHANGE_USER_PRIORITY", "CURRENT_SETTING", "PG_CANCEL_BACKEND", "PG_TERMINATE_BACKEND", "REBOOT_CLUSTER", "SET_CONFIG"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_System_information_functions.html
  sysInfo: ["CURRENT_AWS_ACCOUNT", "CURRENT_DATABASE", "CURRENT_NAMESPACE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_USER", "CURRENT_USER_ID", "HAS_ASSUMEROLE_PRIVILEGE", "HAS_DATABASE_PRIVILEGE", "HAS_SCHEMA_PRIVILEGE", "HAS_TABLE_PRIVILEGE", "PG_BACKEND_PID", "PG_GET_COLS", "PG_GET_GRANTEE_BY_IAM_ROLE", "PG_GET_IAM_ROLE_BY_USER", "PG_GET_LATE_BINDING_VIEW_COLS", "PG_LAST_COPY_COUNT", "PG_LAST_COPY_ID", "PG_LAST_UNLOAD_ID", "PG_LAST_QUERY_ID", "PG_LAST_UNLOAD_COUNT", "SESSION_USER", "SLICE_NUM", "USER", "VERSION"],
  dataTypes: ["DECIMAL", "NUMERIC", "CHAR", "CHARACTER", "VARCHAR", "CHARACTER VARYING", "NCHAR", "NVARCHAR", "VARBYTE"]
}), WH = Ne({
  // https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html
  standard: ["AES128", "AES256", "ALL", "ALLOWOVERWRITE", "ANY", "ARRAY", "AS", "ASC", "AUTHORIZATION", "BACKUP", "BETWEEN", "BINARY", "BOTH", "CHECK", "COLUMN", "CONSTRAINT", "CREATE", "CROSS", "DEFAULT", "DEFERRABLE", "DEFLATE", "DEFRAG", "DESC", "DISABLE", "DISTINCT", "DO", "ENABLE", "ENCODE", "ENCRYPT", "ENCRYPTION", "EXPLICIT", "FALSE", "FOR", "FOREIGN", "FREEZE", "FROM", "FULL", "GLOBALDICT256", "GLOBALDICT64K", "GROUP", "IDENTITY", "IGNORE", "ILIKE", "IN", "INITIALLY", "INNER", "INTO", "IS", "ISNULL", "LANGUAGE", "LEADING", "LIKE", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "LUN", "LUNS", "MINUS", "NATURAL", "NEW", "NOT", "NOTNULL", "NULL", "NULLS", "OFF", "OFFLINE", "OFFSET", "OID", "OLD", "ON", "ONLY", "OPEN", "ORDER", "OUTER", "OVERLAPS", "PARALLEL", "PARTITION", "PERCENT", "PERMISSIONS", "PLACING", "PRIMARY", "RECOVER", "REFERENCES", "REJECTLOG", "RESORT", "RESPECT", "RESTORE", "SIMILAR", "SNAPSHOT", "SOME", "SYSTEM", "TABLE", "TAG", "TDES", "THEN", "TIMESTAMP", "TO", "TOP", "TRAILING", "TRUE", "UNIQUE", "USING", "VERBOSE", "WALLET", "WITHOUT"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-conversion.html
  dataConversionParams: ["ACCEPTANYDATE", "ACCEPTINVCHARS", "BLANKSASNULL", "DATEFORMAT", "EMPTYASNULL", "ENCODING", "ESCAPE", "EXPLICIT_IDS", "FILLRECORD", "IGNOREBLANKLINES", "IGNOREHEADER", "REMOVEQUOTES", "ROUNDEC", "TIMEFORMAT", "TRIMBLANKS", "TRUNCATECOLUMNS"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-load.html
  dataLoadParams: ["COMPROWS", "COMPUPDATE", "MAXERROR", "NOLOAD", "STATUPDATE"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-format.html
  dataFormatParams: ["FORMAT", "CSV", "DELIMITER", "FIXEDWIDTH", "SHAPEFILE", "AVRO", "JSON", "PARQUET", "ORC"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-authorization.html
  copyAuthParams: ["ACCESS_KEY_ID", "CREDENTIALS", "ENCRYPTED", "IAM_ROLE", "MASTER_SYMMETRIC_KEY", "SECRET_ACCESS_KEY", "SESSION_TOKEN"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-file-compression.html
  copyCompressionParams: ["BZIP2", "GZIP", "LZOP", "ZSTD"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_COPY-alphabetical-parm-list.html
  copyMiscParams: ["MANIFEST", "READRATIO", "REGION", "SSH"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Compression_encodings.html
  compressionEncodings: ["RAW", "AZ64", "BYTEDICT", "DELTA", "DELTA32K", "LZO", "MOSTLY8", "MOSTLY16", "MOSTLY32", "RUNLENGTH", "TEXT255", "TEXT32K"],
  misc: [
    // CREATE EXTERNAL SCHEMA (https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_EXTERNAL_SCHEMA.html)
    "CATALOG_ROLE",
    "SECRET_ARN",
    "EXTERNAL",
    // https://docs.aws.amazon.com/redshift/latest/dg/c_choosing_dist_sort.html
    "AUTO",
    "EVEN",
    "KEY",
    "PREDICATE",
    // ANALYZE | ANALYSE (https://docs.aws.amazon.com/redshift/latest/dg/r_ANALYZE.html)
    // unknown
    "COMPRESSION"
  ],
  /**
   * Other keywords not included:
   * STL: https://docs.aws.amazon.com/redshift/latest/dg/c_intro_STL_tables.html
   * SVCS: https://docs.aws.amazon.com/redshift/latest/dg/svcs_views.html
   * SVL: https://docs.aws.amazon.com/redshift/latest/dg/svl_views.html
   * SVV: https://docs.aws.amazon.com/redshift/latest/dg/svv_views.html
   */
  // https://docs.aws.amazon.com/redshift/latest/dg/r_Character_types.html#r_Character_types-text-and-bpchar-types
  dataTypes: ["BPCHAR", "TEXT"]
}), zH = V(["SELECT [ALL | DISTINCT]"]), ZH = V([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE | MATERIALIZED] VIEW",
  "CREATE [TEMPORARY | TEMP | LOCAL TEMPORARY | LOCAL TEMP] TABLE [IF NOT EXISTS]"
]), Jb = V([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ALTER TABLE APPEND",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME TO",
  "RENAME COLUMN",
  "ALTER COLUMN",
  "TYPE",
  // for alter column
  "ENCODE",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://docs.aws.amazon.com/redshift/latest/dg/c_SQL_commands.html
  "ABORT",
  "ALTER DATABASE",
  "ALTER DATASHARE",
  "ALTER DEFAULT PRIVILEGES",
  "ALTER GROUP",
  "ALTER MATERIALIZED VIEW",
  "ALTER PROCEDURE",
  "ALTER SCHEMA",
  "ALTER USER",
  "ANALYSE",
  "ANALYZE",
  "ANALYSE COMPRESSION",
  "ANALYZE COMPRESSION",
  "BEGIN",
  "CALL",
  "CANCEL",
  "CLOSE",
  "COMMENT",
  "COMMIT",
  "COPY",
  "CREATE DATABASE",
  "CREATE DATASHARE",
  "CREATE EXTERNAL FUNCTION",
  "CREATE EXTERNAL SCHEMA",
  "CREATE EXTERNAL TABLE",
  "CREATE FUNCTION",
  "CREATE GROUP",
  "CREATE LIBRARY",
  "CREATE MODEL",
  "CREATE PROCEDURE",
  "CREATE SCHEMA",
  "CREATE USER",
  "DEALLOCATE",
  "DECLARE",
  "DESC DATASHARE",
  "DROP DATABASE",
  "DROP DATASHARE",
  "DROP FUNCTION",
  "DROP GROUP",
  "DROP LIBRARY",
  "DROP MODEL",
  "DROP MATERIALIZED VIEW",
  "DROP PROCEDURE",
  "DROP SCHEMA",
  "DROP USER",
  "DROP VIEW",
  "DROP",
  "EXECUTE",
  "EXPLAIN",
  "FETCH",
  "GRANT",
  "LOCK",
  "PREPARE",
  "REFRESH MATERIALIZED VIEW",
  "RESET",
  "REVOKE",
  "ROLLBACK",
  "SELECT INTO",
  "SET SESSION AUTHORIZATION",
  "SET SESSION CHARACTERISTICS",
  "SHOW",
  "SHOW EXTERNAL TABLE",
  "SHOW MODEL",
  "SHOW DATASHARES",
  "SHOW PROCEDURE",
  "SHOW TABLE",
  "SHOW VIEW",
  "START TRANSACTION",
  "UNLOAD",
  "VACUUM"
]), qH = V(["UNION [ALL]", "EXCEPT", "INTERSECT", "MINUS"]), jH = V(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), KH = V([
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-conversion.html
  "NULL AS",
  // https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_EXTERNAL_SCHEMA.html
  "DATA CATALOG",
  "HIVE METASTORE",
  // in window specifications
  "{ROWS | RANGE} BETWEEN"
]), JH = {
  tokenizerOptions: {
    reservedSelect: zH,
    reservedClauses: [...ZH, ...Jb],
    reservedSetOperations: qH,
    reservedJoins: jH,
    reservedPhrases: KH,
    reservedKeywords: WH,
    reservedFunctionNames: FH,
    stringTypes: ["''-qq"],
    identTypes: ['""-qq'],
    identChars: {
      first: "#"
    },
    paramTypes: {
      numbered: ["$"]
    },
    operators: [
      "^",
      "%",
      "@",
      "|/",
      "||/",
      "&",
      "|",
      // '#', conflicts with first char of identifier
      "~",
      "<<",
      ">>",
      "||",
      "::"
    ]
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: Jb
  }
}, eX = Ne({
  // https://deepkb.com/CO_000013/en/kb/IMPORT-fbfa59f0-2bf1-31fe-bb7b-0f9efe9932c6/spark-sql-keywords
  all: [
    "ADD",
    "AFTER",
    "ALL",
    "ALTER",
    "ANALYZE",
    "AND",
    "ANTI",
    "ANY",
    "ARCHIVE",
    "ARRAY",
    "AS",
    "ASC",
    "AT",
    "AUTHORIZATION",
    "BETWEEN",
    "BOTH",
    "BUCKET",
    "BUCKETS",
    "BY",
    "CACHE",
    "CASCADE",
    "CAST",
    "CHANGE",
    "CHECK",
    "CLEAR",
    "CLUSTER",
    "CLUSTERED",
    "CODEGEN",
    "COLLATE",
    "COLLECTION",
    "COLUMN",
    "COLUMNS",
    "COMMENT",
    "COMMIT",
    "COMPACT",
    "COMPACTIONS",
    "COMPUTE",
    "CONCATENATE",
    "CONSTRAINT",
    "COST",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_DATE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "DATA",
    "DATABASE",
    "DATABASES",
    "DAY",
    "DBPROPERTIES",
    "DEFINED",
    "DELETE",
    "DELIMITED",
    "DESC",
    "DESCRIBE",
    "DFS",
    "DIRECTORIES",
    "DIRECTORY",
    "DISTINCT",
    "DISTRIBUTE",
    "DIV",
    "DROP",
    "ESCAPE",
    "ESCAPED",
    "EXCEPT",
    "EXCHANGE",
    "EXISTS",
    "EXPORT",
    "EXTENDED",
    "EXTERNAL",
    "EXTRACT",
    "FALSE",
    "FETCH",
    "FIELDS",
    "FILTER",
    "FILEFORMAT",
    "FIRST",
    "FIRST_VALUE",
    "FOLLOWING",
    "FOR",
    "FOREIGN",
    "FORMAT",
    "FORMATTED",
    "FULL",
    "FUNCTION",
    "FUNCTIONS",
    "GLOBAL",
    "GRANT",
    "GROUP",
    "GROUPING",
    "HOUR",
    "IF",
    "IGNORE",
    "IMPORT",
    "IN",
    "INDEX",
    "INDEXES",
    "INNER",
    "INPATH",
    "INPUTFORMAT",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "IS",
    "ITEMS",
    "KEYS",
    "LAST",
    "LAST_VALUE",
    "LATERAL",
    "LAZY",
    "LEADING",
    "LEFT",
    "LIKE",
    "LINES",
    "LIST",
    "LOCAL",
    "LOCATION",
    "LOCK",
    "LOCKS",
    "LOGICAL",
    "MACRO",
    "MAP",
    "MATCHED",
    "MERGE",
    "MINUTE",
    "MONTH",
    "MSCK",
    "NAMESPACE",
    "NAMESPACES",
    "NATURAL",
    "NO",
    "NOT",
    "NULL",
    "NULLS",
    "OF",
    "ONLY",
    "OPTION",
    "OPTIONS",
    "OR",
    "ORDER",
    "OUT",
    "OUTER",
    "OUTPUTFORMAT",
    "OVER",
    "OVERLAPS",
    "OVERLAY",
    "OVERWRITE",
    "OWNER",
    "PARTITION",
    "PARTITIONED",
    "PARTITIONS",
    "PERCENT",
    "PLACING",
    "POSITION",
    "PRECEDING",
    "PRIMARY",
    "PRINCIPALS",
    "PROPERTIES",
    "PURGE",
    "QUERY",
    "RANGE",
    "RECORDREADER",
    "RECORDWRITER",
    "RECOVER",
    "REDUCE",
    "REFERENCES",
    "RENAME",
    "REPAIR",
    "REPLACE",
    "RESPECT",
    "RESTRICT",
    "REVOKE",
    "RIGHT",
    "RLIKE",
    "ROLE",
    "ROLES",
    "ROLLBACK",
    "ROLLUP",
    "ROW",
    "ROWS",
    "SCHEMA",
    "SECOND",
    "SELECT",
    "SEMI",
    "SEPARATED",
    "SERDE",
    "SERDEPROPERTIES",
    "SESSION_USER",
    "SETS",
    "SHOW",
    "SKEWED",
    "SOME",
    "SORT",
    "SORTED",
    "START",
    "STATISTICS",
    "STORED",
    "STRATIFY",
    "STRUCT",
    "SUBSTR",
    "SUBSTRING",
    "TABLE",
    "TABLES",
    "TBLPROPERTIES",
    "TEMPORARY",
    "TERMINATED",
    "THEN",
    "TO",
    "TOUCH",
    "TRAILING",
    "TRANSACTION",
    "TRANSACTIONS",
    "TRIM",
    "TRUE",
    "TRUNCATE",
    "UNARCHIVE",
    "UNBOUNDED",
    "UNCACHE",
    "UNIQUE",
    "UNKNOWN",
    "UNLOCK",
    "UNSET",
    "USE",
    "USER",
    "USING",
    "VIEW",
    "WINDOW",
    "YEAR",
    // other
    "ANALYSE",
    "ARRAY_ZIP",
    "COALESCE",
    "CONTAINS",
    "CONVERT",
    "DAYS",
    "DAY_HOUR",
    "DAY_MINUTE",
    "DAY_SECOND",
    "DECODE",
    "DEFAULT",
    "DISTINCTROW",
    "ENCODE",
    "EXPLODE",
    "EXPLODE_OUTER",
    "FIXED",
    "GREATEST",
    "GROUP_CONCAT",
    "HOURS",
    "HOUR_MINUTE",
    "HOUR_SECOND",
    "IFNULL",
    "LEAST",
    "LEVEL",
    "MINUTE_SECOND",
    "NULLIF",
    "OFFSET",
    "ON",
    "OPTIMIZE",
    "REGEXP",
    "SEPARATOR",
    "SIZE",
    "STRING",
    "TYPE",
    "TYPES",
    "UNSIGNED",
    "VARIABLES",
    "YEAR_MONTH"
  ]
}), tX = Ne({
  // http://spark.apache.org/docs/latest/sql-ref-functions.html
  //
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#aggregate-functions
  aggregate: [
    // 'ANY',
    "APPROX_COUNT_DISTINCT",
    "APPROX_PERCENTILE",
    "AVG",
    "BIT_AND",
    "BIT_OR",
    "BIT_XOR",
    "BOOL_AND",
    "BOOL_OR",
    "COLLECT_LIST",
    "COLLECT_SET",
    "CORR",
    "COUNT",
    "COUNT",
    "COUNT",
    "COUNT_IF",
    "COUNT_MIN_SKETCH",
    "COVAR_POP",
    "COVAR_SAMP",
    "EVERY",
    "FIRST",
    "FIRST_VALUE",
    "GROUPING",
    "GROUPING_ID",
    "KURTOSIS",
    "LAST",
    "LAST_VALUE",
    "MAX",
    "MAX_BY",
    "MEAN",
    "MIN",
    "MIN_BY",
    "PERCENTILE",
    "PERCENTILE",
    "PERCENTILE_APPROX",
    "SKEWNESS",
    // 'SOME',
    "STD",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "SUM",
    "VAR_POP",
    "VAR_SAMP",
    "VARIANCE"
  ],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#window-functions
  window: ["CUME_DIST", "DENSE_RANK", "LAG", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "RANK", "ROW_NUMBER"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#array-functions
  array: ["ARRAY", "ARRAY_CONTAINS", "ARRAY_DISTINCT", "ARRAY_EXCEPT", "ARRAY_INTERSECT", "ARRAY_JOIN", "ARRAY_MAX", "ARRAY_MIN", "ARRAY_POSITION", "ARRAY_REMOVE", "ARRAY_REPEAT", "ARRAY_UNION", "ARRAYS_OVERLAP", "ARRAYS_ZIP", "FLATTEN", "SEQUENCE", "SHUFFLE", "SLICE", "SORT_ARRAY"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#map-functions
  map: ["ELEMENT_AT", "ELEMENT_AT", "MAP", "MAP_CONCAT", "MAP_ENTRIES", "MAP_FROM_ARRAYS", "MAP_FROM_ENTRIES", "MAP_KEYS", "MAP_VALUES", "STR_TO_MAP"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#date-and-timestamp-functions
  datetime: ["ADD_MONTHS", "CURRENT_DATE", "CURRENT_DATE", "CURRENT_TIMESTAMP", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "DATE_ADD", "DATE_FORMAT", "DATE_FROM_UNIX_DATE", "DATE_PART", "DATE_SUB", "DATE_TRUNC", "DATEDIFF", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "EXTRACT", "FROM_UNIXTIME", "FROM_UTC_TIMESTAMP", "HOUR", "LAST_DAY", "MAKE_DATE", "MAKE_DT_INTERVAL", "MAKE_INTERVAL", "MAKE_TIMESTAMP", "MAKE_YM_INTERVAL", "MINUTE", "MONTH", "MONTHS_BETWEEN", "NEXT_DAY", "NOW", "QUARTER", "SECOND", "SESSION_WINDOW", "TIMESTAMP_MICROS", "TIMESTAMP_MILLIS", "TIMESTAMP_SECONDS", "TO_DATE", "TO_TIMESTAMP", "TO_UNIX_TIMESTAMP", "TO_UTC_TIMESTAMP", "TRUNC", "UNIX_DATE", "UNIX_MICROS", "UNIX_MILLIS", "UNIX_SECONDS", "UNIX_TIMESTAMP", "WEEKDAY", "WEEKOFYEAR", "WINDOW", "YEAR"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#json-functions
  json: ["FROM_JSON", "GET_JSON_OBJECT", "JSON_ARRAY_LENGTH", "JSON_OBJECT_KEYS", "JSON_TUPLE", "SCHEMA_OF_JSON", "TO_JSON"],
  // http://spark.apache.org/docs/latest/api/sql/index.html
  misc: [
    "ABS",
    "ACOS",
    "ACOSH",
    "AGGREGATE",
    "ARRAY_SORT",
    "ASCII",
    "ASIN",
    "ASINH",
    "ASSERT_TRUE",
    "ATAN",
    "ATAN2",
    "ATANH",
    "BASE64",
    "BIGINT",
    "BIN",
    "BINARY",
    "BIT_COUNT",
    "BIT_GET",
    "BIT_LENGTH",
    "BOOLEAN",
    "BROUND",
    "BTRIM",
    "CARDINALITY",
    "CBRT",
    "CEIL",
    "CEILING",
    "CHAR",
    "CHAR_LENGTH",
    "CHARACTER_LENGTH",
    "CHR",
    "CONCAT",
    "CONCAT_WS",
    "CONV",
    "COS",
    "COSH",
    "COT",
    "CRC32",
    "CURRENT_CATALOG",
    "CURRENT_DATABASE",
    "CURRENT_USER",
    "DATE",
    "DECIMAL",
    "DEGREES",
    "DOUBLE",
    // 'E',
    "ELT",
    "EXP",
    "EXPM1",
    "FACTORIAL",
    "FIND_IN_SET",
    "FLOAT",
    "FLOOR",
    "FORALL",
    "FORMAT_NUMBER",
    "FORMAT_STRING",
    "FROM_CSV",
    "GETBIT",
    "HASH",
    "HEX",
    "HYPOT",
    "INITCAP",
    "INLINE",
    "INLINE_OUTER",
    "INPUT_FILE_BLOCK_LENGTH",
    "INPUT_FILE_BLOCK_START",
    "INPUT_FILE_NAME",
    "INSTR",
    "INT",
    "ISNAN",
    "ISNOTNULL",
    "ISNULL",
    "JAVA_METHOD",
    "LCASE",
    "LEFT",
    "LENGTH",
    "LEVENSHTEIN",
    "LN",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG1P",
    "LOG2",
    "LOWER",
    "LPAD",
    "LTRIM",
    "MAP_FILTER",
    "MAP_ZIP_WITH",
    "MD5",
    "MOD",
    "MONOTONICALLY_INCREASING_ID",
    "NAMED_STRUCT",
    "NANVL",
    "NEGATIVE",
    "NVL",
    "NVL2",
    "OCTET_LENGTH",
    "OVERLAY",
    "PARSE_URL",
    "PI",
    "PMOD",
    "POSEXPLODE",
    "POSEXPLODE_OUTER",
    "POSITION",
    "POSITIVE",
    "POW",
    "POWER",
    "PRINTF",
    "RADIANS",
    "RAISE_ERROR",
    "RAND",
    "RANDN",
    "RANDOM",
    "REFLECT",
    "REGEXP_EXTRACT",
    "REGEXP_EXTRACT_ALL",
    "REGEXP_LIKE",
    "REGEXP_REPLACE",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "RIGHT",
    "RINT",
    "ROUND",
    "RPAD",
    "RTRIM",
    "SCHEMA_OF_CSV",
    "SENTENCES",
    "SHA",
    "SHA1",
    "SHA2",
    "SHIFTLEFT",
    "SHIFTRIGHT",
    "SHIFTRIGHTUNSIGNED",
    "SIGN",
    "SIGNUM",
    "SIN",
    "SINH",
    "SMALLINT",
    "SOUNDEX",
    "SPACE",
    "SPARK_PARTITION_ID",
    "SPLIT",
    "SQRT",
    "STACK",
    "SUBSTR",
    "SUBSTRING",
    "SUBSTRING_INDEX",
    "TAN",
    "TANH",
    "TIMESTAMP",
    "TINYINT",
    "TO_CSV",
    "TRANSFORM_KEYS",
    "TRANSFORM_VALUES",
    "TRANSLATE",
    "TRIM",
    "TRY_ADD",
    "TRY_DIVIDE",
    "TYPEOF",
    "UCASE",
    "UNBASE64",
    "UNHEX",
    "UPPER",
    "UUID",
    "VERSION",
    "WIDTH_BUCKET",
    "XPATH",
    "XPATH_BOOLEAN",
    "XPATH_DOUBLE",
    "XPATH_FLOAT",
    "XPATH_INT",
    "XPATH_LONG",
    "XPATH_NUMBER",
    "XPATH_SHORT",
    "XPATH_STRING",
    "XXHASH64",
    "ZIP_WITH"
  ],
  cast: ["CAST"],
  // Shorthand functions to use in place of CASE expression
  caseAbbrev: ["COALESCE", "NULLIF"],
  // Parameterized data types
  // https://spark.apache.org/docs/latest/sql-ref-datatypes.html
  dataTypes: [
    "DECIMAL",
    "DEC",
    "NUMERIC",
    // No varchar type in Spark, only STRING. Added for the sake of tests
    "VARCHAR"
  ]
}), iX = V(["SELECT [ALL | DISTINCT]"]), rX = V([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "SORT BY",
  "CLUSTER BY",
  "DISTRIBUTE BY",
  "LIMIT",
  // Data manipulation
  // - insert:
  "INSERT [INTO | OVERWRITE] [TABLE]",
  "VALUES",
  // - insert overwrite directory:
  //   https://spark.apache.org/docs/latest/sql-ref-syntax-dml-insert-overwrite-directory.html
  "INSERT OVERWRITE [LOCAL] DIRECTORY",
  // - load:
  //   https://spark.apache.org/docs/latest/sql-ref-syntax-dml-load.html
  "LOAD DATA [LOCAL] INPATH",
  "[OVERWRITE] INTO TABLE",
  // Data definition
  "CREATE [OR REPLACE] [GLOBAL TEMPORARY | TEMPORARY] VIEW [IF NOT EXISTS]",
  "CREATE [EXTERNAL] TABLE [IF NOT EXISTS]"
]), eT = V([
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD COLUMNS",
  "DROP {COLUMN | COLUMNS}",
  "RENAME TO",
  "RENAME COLUMN",
  "ALTER COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "LATERAL VIEW",
  "ALTER DATABASE",
  "ALTER VIEW",
  "CREATE DATABASE",
  "CREATE FUNCTION",
  "DROP DATABASE",
  "DROP FUNCTION",
  "DROP VIEW",
  "REPAIR TABLE",
  "USE DATABASE",
  // Data Retrieval
  "TABLESAMPLE",
  "PIVOT",
  "TRANSFORM",
  "EXPLAIN",
  // Auxiliary
  "ADD FILE",
  "ADD JAR",
  "ANALYZE TABLE",
  "CACHE TABLE",
  "CLEAR CACHE",
  "DESCRIBE DATABASE",
  "DESCRIBE FUNCTION",
  "DESCRIBE QUERY",
  "DESCRIBE TABLE",
  "LIST FILE",
  "LIST JAR",
  "REFRESH",
  "REFRESH TABLE",
  "REFRESH FUNCTION",
  "RESET",
  "SHOW COLUMNS",
  "SHOW CREATE TABLE",
  "SHOW DATABASES",
  "SHOW FUNCTIONS",
  "SHOW PARTITIONS",
  "SHOW TABLE EXTENDED",
  "SHOW TABLES",
  "SHOW TBLPROPERTIES",
  "SHOW VIEWS",
  "UNCACHE TABLE"
]), oX = V(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), sX = V([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN",
  // non-standard-joins
  "[LEFT] {ANTI | SEMI} JOIN",
  "NATURAL [LEFT] {ANTI | SEMI} JOIN"
]), nX = V(["ON DELETE", "ON UPDATE", "CURRENT ROW", "{ROWS | RANGE} BETWEEN"]), aX = {
  tokenizerOptions: {
    reservedSelect: iX,
    reservedClauses: [...rX, ...eT],
    reservedSetOperations: oX,
    reservedJoins: sX,
    reservedPhrases: nX,
    supportsXor: !0,
    reservedKeywords: eX,
    reservedFunctionNames: tX,
    extraParens: ["[]"],
    stringTypes: ["''-bs", '""-bs', {
      quote: "''-raw",
      prefixes: ["R", "X"],
      requirePrefix: !0
    }, {
      quote: '""-raw',
      prefixes: ["R", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    variableTypes: [{
      quote: "{}",
      prefixes: ["$"],
      requirePrefix: !0
    }],
    operators: ["%", "~", "^", "|", "&", "<=>", "==", "!", "||", "->"],
    postProcess: lX
  },
  formatOptions: {
    onelineClauses: eT
  }
};
function lX(i) {
  return i.map((e, t) => {
    const r = i[t - 1] || rs, o = i[t + 1] || rs;
    return Ro.WINDOW(e) && o.type === k.OPEN_PAREN ? {
      ...e,
      type: k.RESERVED_FUNCTION_NAME
    } : e.text === "ITEMS" && e.type === k.RESERVED_KEYWORD && !(r.text === "COLLECTION" && o.text === "TERMINATED") ? {
      ...e,
      type: k.IDENTIFIER,
      text: e.raw
    } : e;
  });
}
const uX = Ne({
  // https://www.sqlite.org/lang_corefunc.html
  scalar: ["ABS", "CHANGES", "CHAR", "COALESCE", "FORMAT", "GLOB", "HEX", "IFNULL", "IIF", "INSTR", "LAST_INSERT_ROWID", "LENGTH", "LIKE", "LIKELIHOOD", "LIKELY", "LOAD_EXTENSION", "LOWER", "LTRIM", "NULLIF", "PRINTF", "QUOTE", "RANDOM", "RANDOMBLOB", "REPLACE", "ROUND", "RTRIM", "SIGN", "SOUNDEX", "SQLITE_COMPILEOPTION_GET", "SQLITE_COMPILEOPTION_USED", "SQLITE_OFFSET", "SQLITE_SOURCE_ID", "SQLITE_VERSION", "SUBSTR", "SUBSTRING", "TOTAL_CHANGES", "TRIM", "TYPEOF", "UNICODE", "UNLIKELY", "UPPER", "ZEROBLOB"],
  // https://www.sqlite.org/lang_aggfunc.html
  aggregate: ["AVG", "COUNT", "GROUP_CONCAT", "MAX", "MIN", "SUM", "TOTAL"],
  // https://www.sqlite.org/lang_datefunc.html
  datetime: ["DATE", "TIME", "DATETIME", "JULIANDAY", "UNIXEPOCH", "STRFTIME"],
  // https://www.sqlite.org/windowfunctions.html#biwinfunc
  window: ["row_number", "rank", "dense_rank", "percent_rank", "cume_dist", "ntile", "lag", "lead", "first_value", "last_value", "nth_value"],
  // https://www.sqlite.org/lang_mathfunc.html
  math: ["ACOS", "ACOSH", "ASIN", "ASINH", "ATAN", "ATAN2", "ATANH", "CEIL", "CEILING", "COS", "COSH", "DEGREES", "EXP", "FLOOR", "LN", "LOG", "LOG", "LOG10", "LOG2", "MOD", "PI", "POW", "POWER", "RADIANS", "SIN", "SINH", "SQRT", "TAN", "TANH", "TRUNC"],
  // https://www.sqlite.org/json1.html
  json: ["JSON", "JSON_ARRAY", "JSON_ARRAY_LENGTH", "JSON_ARRAY_LENGTH", "JSON_EXTRACT", "JSON_INSERT", "JSON_OBJECT", "JSON_PATCH", "JSON_REMOVE", "JSON_REPLACE", "JSON_SET", "JSON_TYPE", "JSON_TYPE", "JSON_VALID", "JSON_QUOTE", "JSON_GROUP_ARRAY", "JSON_GROUP_OBJECT", "JSON_EACH", "JSON_TREE"],
  cast: ["CAST"],
  // SQLite allows parameters for all data types
  // Well, in fact it allows any word as a data type, e.g. CREATE TABLE foo (col1 madeupname(123));
  // https://www.sqlite.org/datatype3.html
  dataTypes: ["CHARACTER", "VARCHAR", "VARYING CHARACTER", "NCHAR", "NATIVE CHARACTER", "NVARCHAR", "NUMERIC", "DECIMAL"]
}), hX = Ne({
  // https://www.sqlite.org/lang_keywords.html
  all: ["ABORT", "ACTION", "ADD", "AFTER", "ALL", "ALTER", "AND", "ANY", "ARE", "ARRAY", "ALWAYS", "ANALYZE", "AS", "ASC", "ATTACH", "AUTOINCREMENT", "BEFORE", "BEGIN", "BETWEEN", "BY", "CASCADE", "CASE", "CAST", "CHECK", "COLLATE", "COLUMN", "COMMIT", "CONFLICT", "CONSTRAINT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATABASE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE", "DESC", "DETACH", "DISTINCT", "DO", "DROP", "EACH", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUDE", "EXCLUSIVE", "EXISTS", "EXPLAIN", "FAIL", "FILTER", "FIRST", "FOLLOWING", "FOR", "FOREIGN", "FROM", "FULL", "GENERATED", "GLOB", "GROUP", "GROUPS", "HAVING", "IF", "IGNORE", "IMMEDIATE", "IN", "INDEX", "INDEXED", "INITIALLY", "INNER", "INSERT", "INSTEAD", "INTERSECT", "INTO", "IS", "ISNULL", "JOIN", "KEY", "LAST", "LEFT", "LIKE", "LIMIT", "MATCH", "MATERIALIZED", "NATURAL", "NO", "NOT", "NOTHING", "NOTNULL", "NULL", "NULLS", "OF", "OFFSET", "ON", "ONLY", "OPEN", "OR", "ORDER", "OTHERS", "OUTER", "OVER", "PARTITION", "PLAN", "PRAGMA", "PRECEDING", "PRIMARY", "QUERY", "RAISE", "RANGE", "RECURSIVE", "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "RENAME", "REPLACE", "RESTRICT", "RETURNING", "RIGHT", "ROLLBACK", "ROW", "ROWS", "SAVEPOINT", "SELECT", "SET", "TABLE", "TEMP", "TEMPORARY", "THEN", "TIES", "TO", "TRANSACTION", "TRIGGER", "UNBOUNDED", "UNION", "UNIQUE", "UPDATE", "USING", "VACUUM", "VALUES", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WINDOW", "WITH", "WITHOUT"]
}), cX = V(["SELECT [ALL | DISTINCT]"]), dX = V([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [OR ABORT | OR FAIL | OR IGNORE | OR REPLACE | OR ROLLBACK] INTO",
  "REPLACE INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [TEMPORARY | TEMP] VIEW [IF NOT EXISTS]",
  "CREATE [TEMPORARY | TEMP] TABLE [IF NOT EXISTS]"
]), tT = V([
  // - update:
  "UPDATE [OR ABORT | OR FAIL | OR IGNORE | OR REPLACE | OR ROLLBACK]",
  // - insert:
  "ON CONFLICT",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [COLUMN]",
  "RENAME TO",
  // - set schema
  "SET SCHEMA"
]), fX = V(["UNION [ALL]", "EXCEPT", "INTERSECT"]), pX = V(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), OX = V(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE | GROUPS} BETWEEN"]), EX = {
  tokenizerOptions: {
    reservedSelect: cX,
    reservedClauses: [...dX, ...tT],
    reservedSetOperations: fX,
    reservedJoins: pX,
    reservedPhrases: OX,
    reservedKeywords: hX,
    reservedFunctionNames: uX,
    stringTypes: [
      "''-qq",
      {
        quote: "''-raw",
        prefixes: ["X"],
        requirePrefix: !0
      }
      // Depending on context SQLite also supports double-quotes for strings,
      // and single-quotes for identifiers.
    ],
    identTypes: ['""-qq', "``", "[]"],
    // https://www.sqlite.org/lang_expr.html#parameters
    paramTypes: {
      positional: !0,
      numbered: ["?"],
      named: [":", "@", "$"]
    },
    operators: ["%", "~", "&", "|", "<<", ">>", "==", "->", "->>", "||"]
  },
  formatOptions: {
    onelineClauses: tT
  }
}, mX = Ne({
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_9_set_function_specification
  set: ["GROUPING"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_10_window_function
  window: ["RANK", "DENSE_RANK", "PERCENT_RANK", "CUME_DIST", "ROW_NUMBER"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_27_numeric_value_function
  numeric: ["POSITION", "OCCURRENCES_REGEX", "POSITION_REGEX", "EXTRACT", "CHAR_LENGTH", "CHARACTER_LENGTH", "OCTET_LENGTH", "CARDINALITY", "ABS", "MOD", "LN", "EXP", "POWER", "SQRT", "FLOOR", "CEIL", "CEILING", "WIDTH_BUCKET"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_29_string_value_function
  string: ["SUBSTRING", "SUBSTRING_REGEX", "UPPER", "LOWER", "CONVERT", "TRANSLATE", "TRANSLATE_REGEX", "TRIM", "OVERLAY", "NORMALIZE", "SPECIFICTYPE"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_31_datetime_value_function
  datetime: ["CURRENT_DATE", "CURRENT_TIME", "LOCALTIME", "CURRENT_TIMESTAMP", "LOCALTIMESTAMP"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_38_multiset_value_function
  // SET serves multiple roles: a SET() function and a SET keyword e.g. in UPDATE table SET ...
  // multiset: ['SET'], (disabled for now)
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_10_9_aggregate_function
  aggregate: [
    "COUNT",
    "AVG",
    "MAX",
    "MIN",
    "SUM",
    // 'EVERY',
    // 'ANY',
    // 'SOME',
    "STDDEV_POP",
    "STDDEV_SAMP",
    "VAR_SAMP",
    "VAR_POP",
    "COLLECT",
    "FUSION",
    "INTERSECTION",
    "COVAR_POP",
    "COVAR_SAMP",
    "CORR",
    "REGR_SLOPE",
    "REGR_INTERCEPT",
    "REGR_COUNT",
    "REGR_R2",
    "REGR_AVGX",
    "REGR_AVGY",
    "REGR_SXX",
    "REGR_SYY",
    "REGR_SXY",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC"
  ],
  // CAST is a pretty complex case, involving multiple forms:
  // - CAST(col AS int)
  // - CAST(...) WITH ...
  // - CAST FROM int
  // - CREATE CAST(mycol AS int) WITH ...
  cast: ["CAST"],
  // Shorthand functions to use in place of CASE expression
  caseAbbrev: ["COALESCE", "NULLIF"],
  // Non-standard functions that have widespread support
  nonStandard: ["ROUND", "SIN", "COS", "TAN", "ASIN", "ACOS", "ATAN"],
  // Data types with parameters like VARCHAR(100)
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#predefined-type
  dataTypes: ["CHARACTER", "CHAR", "CHARACTER VARYING", "CHAR VARYING", "VARCHAR", "CHARACTER LARGE OBJECT", "CHAR LARGE OBJECT", "CLOB", "NATIONAL CHARACTER", "NATIONAL CHAR", "NCHAR", "NATIONAL CHARACTER VARYING", "NATIONAL CHAR VARYING", "NCHAR VARYING", "NATIONAL CHARACTER LARGE OBJECT", "NCHAR LARGE OBJECT", "NCLOB", "BINARY", "BINARY VARYING", "VARBINARY", "BINARY LARGE OBJECT", "BLOB", "NUMERIC", "DECIMAL", "DEC", "TIME", "TIMESTAMP"]
}), gX = Ne({
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#reserved-word
  all: [
    "ALL",
    "ALLOCATE",
    "ALTER",
    "ANY",
    // <- moved over from functions
    "ARE",
    "ARRAY",
    "AS",
    "ASENSITIVE",
    "ASYMMETRIC",
    "AT",
    "ATOMIC",
    "AUTHORIZATION",
    "BEGIN",
    "BETWEEN",
    "BIGINT",
    "BINARY",
    "BLOB",
    "BOOLEAN",
    "BOTH",
    "BY",
    "CALL",
    "CALLED",
    "CASCADED",
    "CAST",
    "CHAR",
    "CHARACTER",
    "CHECK",
    "CLOB",
    "CLOSE",
    "COALESCE",
    "COLLATE",
    "COLUMN",
    "COMMIT",
    "CONDITION",
    "CONNECT",
    "CONSTRAINT",
    "CORRESPONDING",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_CATALOG",
    "CURRENT_DEFAULT_TRANSFORM_GROUP",
    "CURRENT_PATH",
    "CURRENT_ROLE",
    "CURRENT_SCHEMA",
    "CURRENT_TRANSFORM_GROUP_FOR_TYPE",
    "CURRENT_USER",
    "CURSOR",
    "CYCLE",
    "DATE",
    "DAY",
    "DEALLOCATE",
    "DEC",
    "DECIMAL",
    "DECLARE",
    "DEFAULT",
    "DELETE",
    "DEREF",
    "DESCRIBE",
    "DETERMINISTIC",
    "DISCONNECT",
    "DISTINCT",
    "DOUBLE",
    "DROP",
    "DYNAMIC",
    "EACH",
    "ELEMENT",
    "END-EXEC",
    "ESCAPE",
    "EVERY",
    // <- moved over from functions
    "EXCEPT",
    "EXEC",
    "EXECUTE",
    "EXISTS",
    "EXTERNAL",
    "FALSE",
    "FETCH",
    "FILTER",
    "FLOAT",
    "FOR",
    "FOREIGN",
    "FREE",
    "FROM",
    "FULL",
    "FUNCTION",
    "GET",
    "GLOBAL",
    "GRANT",
    "GROUP",
    "HAVING",
    "HOLD",
    "HOUR",
    "IDENTITY",
    "IN",
    "INDICATOR",
    "INNER",
    "INOUT",
    "INSENSITIVE",
    "INSERT",
    "INT",
    "INTEGER",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "IS",
    "LANGUAGE",
    "LARGE",
    "LATERAL",
    "LEADING",
    "LEFT",
    "LIKE",
    "LIKE_REGEX",
    "LOCAL",
    "MATCH",
    "MEMBER",
    "MERGE",
    "METHOD",
    "MINUTE",
    "MODIFIES",
    "MODULE",
    "MONTH",
    "MULTISET",
    "NATIONAL",
    "NATURAL",
    "NCHAR",
    "NCLOB",
    "NEW",
    "NO",
    "NONE",
    "NOT",
    "NULL",
    "NULLIF",
    "NUMERIC",
    "OF",
    "OLD",
    "ON",
    "ONLY",
    "OPEN",
    "ORDER",
    "OUT",
    "OUTER",
    "OVER",
    "OVERLAPS",
    "PARAMETER",
    "PARTITION",
    "PRECISION",
    "PREPARE",
    "PRIMARY",
    "PROCEDURE",
    "RANGE",
    "READS",
    "REAL",
    "RECURSIVE",
    "REF",
    "REFERENCES",
    "REFERENCING",
    "RELEASE",
    "RESULT",
    "RETURN",
    "RETURNS",
    "REVOKE",
    "RIGHT",
    "ROLLBACK",
    "ROLLUP",
    "ROW",
    "ROWS",
    "SAVEPOINT",
    "SCOPE",
    "SCROLL",
    "SEARCH",
    "SECOND",
    "SELECT",
    "SENSITIVE",
    "SESSION_USER",
    "SET",
    "SIMILAR",
    "SMALLINT",
    "SOME",
    // <- moved over from functions
    "SPECIFIC",
    "SQL",
    "SQLEXCEPTION",
    "SQLSTATE",
    "SQLWARNING",
    "START",
    "STATIC",
    "SUBMULTISET",
    "SYMMETRIC",
    "SYSTEM",
    "SYSTEM_USER",
    "TABLE",
    "TABLESAMPLE",
    "THEN",
    "TIME",
    "TIMESTAMP",
    "TIMEZONE_HOUR",
    "TIMEZONE_MINUTE",
    "TO",
    "TRAILING",
    "TRANSLATION",
    "TREAT",
    "TRIGGER",
    "TRUE",
    "UESCAPE",
    "UNION",
    "UNIQUE",
    "UNKNOWN",
    "UNNEST",
    "UPDATE",
    "USER",
    "USING",
    "VALUE",
    "VALUES",
    "VARBINARY",
    "VARCHAR",
    "VARYING",
    "WHENEVER",
    "WINDOW",
    "WITHIN",
    "WITHOUT",
    "YEAR"
  ]
}), bX = V(["SELECT [ALL | DISTINCT]"]), TX = V([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [RECURSIVE] VIEW",
  "CREATE [GLOBAL TEMPORARY | LOCAL TEMPORARY] TABLE"
]), iT = V([
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE",
  // - alter table:
  "ALTER TABLE",
  "ADD COLUMN",
  "DROP [COLUMN]",
  "RENAME COLUMN",
  "RENAME TO",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  // for alter column
  "ADD SCOPE",
  // for alter column
  "DROP SCOPE {CASCADE | RESTRICT}",
  // for alter column
  "RESTART WITH",
  // for alter column
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "SET SCHEMA"
]), SX = V(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), RX = V(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), AX = V(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE} BETWEEN"]), CX = {
  tokenizerOptions: {
    reservedSelect: bX,
    reservedClauses: [...TX, ...iT],
    reservedSetOperations: SX,
    reservedJoins: RX,
    reservedPhrases: AX,
    reservedKeywords: gX,
    reservedFunctionNames: mX,
    stringTypes: [{
      quote: "''-qq-bs",
      prefixes: ["N", "U&"]
    }, {
      quote: "''-raw",
      prefixes: ["X"],
      requirePrefix: !0
    }],
    identTypes: ['""-qq', "``"],
    paramTypes: {
      positional: !0
    },
    operators: ["||"]
  },
  formatOptions: {
    onelineClauses: iT
  }
}, NX = Ne({
  // https://github.com/trinodb/trino/tree/432d2897bdef99388c1a47188743a061c4ac1f34/docs/src/main/sphinx/functions
  // rg '^\.\. function::' ./docs/src/main/sphinx/functions | cut -d' ' -f 3 | cut -d '(' -f 1 | sort | uniq
  // rg '\* ' ./docs/src/main/sphinx/functions/list-by-topic.rst | grep    '\* :func:' | cut -d'`' -f 2
  // rg '\* ' ./docs/src/main/sphinx/functions/list-by-topic.rst | grep -v '\* :func:'
  // grep -e '^- ' ./docs/src/main/sphinx/functions/list.rst | grep  -e '^- :func:' | cut -d'`' -f2
  // grep -e '^- ' ./docs/src/main/sphinx/functions/list.rst | grep -ve '^- :func:'
  all: ["ABS", "ACOS", "ALL_MATCH", "ANY_MATCH", "APPROX_DISTINCT", "APPROX_MOST_FREQUENT", "APPROX_PERCENTILE", "APPROX_SET", "ARBITRARY", "ARRAYS_OVERLAP", "ARRAY_AGG", "ARRAY_DISTINCT", "ARRAY_EXCEPT", "ARRAY_INTERSECT", "ARRAY_JOIN", "ARRAY_MAX", "ARRAY_MIN", "ARRAY_POSITION", "ARRAY_REMOVE", "ARRAY_SORT", "ARRAY_UNION", "ASIN", "ATAN", "ATAN2", "AT_TIMEZONE", "AVG", "BAR", "BETA_CDF", "BING_TILE", "BING_TILES_AROUND", "BING_TILE_AT", "BING_TILE_COORDINATES", "BING_TILE_POLYGON", "BING_TILE_QUADKEY", "BING_TILE_ZOOM_LEVEL", "BITWISE_AND", "BITWISE_AND_AGG", "BITWISE_LEFT_SHIFT", "BITWISE_NOT", "BITWISE_OR", "BITWISE_OR_AGG", "BITWISE_RIGHT_SHIFT", "BITWISE_RIGHT_SHIFT_ARITHMETIC", "BITWISE_XOR", "BIT_COUNT", "BOOL_AND", "BOOL_OR", "CARDINALITY", "CAST", "CBRT", "CEIL", "CEILING", "CHAR2HEXINT", "CHECKSUM", "CHR", "CLASSIFY", "COALESCE", "CODEPOINT", "COLOR", "COMBINATIONS", "CONCAT", "CONCAT_WS", "CONTAINS", "CONTAINS_SEQUENCE", "CONVEX_HULL_AGG", "CORR", "COS", "COSH", "COSINE_SIMILARITY", "COUNT", "COUNT_IF", "COVAR_POP", "COVAR_SAMP", "CRC32", "CUME_DIST", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_GROUPS", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "CURRENT_USER", "DATE", "DATE_ADD", "DATE_DIFF", "DATE_FORMAT", "DATE_PARSE", "DATE_TRUNC", "DAY", "DAY_OF_MONTH", "DAY_OF_WEEK", "DAY_OF_YEAR", "DEGREES", "DENSE_RANK", "DOW", "DOY", "E", "ELEMENT_AT", "EMPTY_APPROX_SET", "EVALUATE_CLASSIFIER_PREDICTIONS", "EVERY", "EXP", "EXTRACT", "FEATURES", "FILTER", "FIRST_VALUE", "FLATTEN", "FLOOR", "FORMAT", "FORMAT_DATETIME", "FORMAT_NUMBER", "FROM_BASE", "FROM_BASE32", "FROM_BASE64", "FROM_BASE64URL", "FROM_BIG_ENDIAN_32", "FROM_BIG_ENDIAN_64", "FROM_ENCODED_POLYLINE", "FROM_GEOJSON_GEOMETRY", "FROM_HEX", "FROM_IEEE754_32", "FROM_IEEE754_64", "FROM_ISO8601_DATE", "FROM_ISO8601_TIMESTAMP", "FROM_ISO8601_TIMESTAMP_NANOS", "FROM_UNIXTIME", "FROM_UNIXTIME_NANOS", "FROM_UTF8", "GEOMETRIC_MEAN", "GEOMETRY_FROM_HADOOP_SHAPE", "GEOMETRY_INVALID_REASON", "GEOMETRY_NEAREST_POINTS", "GEOMETRY_TO_BING_TILES", "GEOMETRY_UNION", "GEOMETRY_UNION_AGG", "GREATEST", "GREAT_CIRCLE_DISTANCE", "HAMMING_DISTANCE", "HASH_COUNTS", "HISTOGRAM", "HMAC_MD5", "HMAC_SHA1", "HMAC_SHA256", "HMAC_SHA512", "HOUR", "HUMAN_READABLE_SECONDS", "IF", "INDEX", "INFINITY", "INTERSECTION_CARDINALITY", "INVERSE_BETA_CDF", "INVERSE_NORMAL_CDF", "IS_FINITE", "IS_INFINITE", "IS_JSON_SCALAR", "IS_NAN", "JACCARD_INDEX", "JSON_ARRAY_CONTAINS", "JSON_ARRAY_GET", "JSON_ARRAY_LENGTH", "JSON_EXISTS", "JSON_EXTRACT", "JSON_EXTRACT_SCALAR", "JSON_FORMAT", "JSON_PARSE", "JSON_QUERY", "JSON_SIZE", "JSON_VALUE", "KURTOSIS", "LAG", "LAST_DAY_OF_MONTH", "LAST_VALUE", "LEAD", "LEARN_CLASSIFIER", "LEARN_LIBSVM_CLASSIFIER", "LEARN_LIBSVM_REGRESSOR", "LEARN_REGRESSOR", "LEAST", "LENGTH", "LEVENSHTEIN_DISTANCE", "LINE_INTERPOLATE_POINT", "LINE_INTERPOLATE_POINTS", "LINE_LOCATE_POINT", "LISTAGG", "LN", "LOCALTIME", "LOCALTIMESTAMP", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", "LTRIM", "LUHN_CHECK", "MAKE_SET_DIGEST", "MAP", "MAP_AGG", "MAP_CONCAT", "MAP_ENTRIES", "MAP_FILTER", "MAP_FROM_ENTRIES", "MAP_KEYS", "MAP_UNION", "MAP_VALUES", "MAP_ZIP_WITH", "MAX", "MAX_BY", "MD5", "MERGE", "MERGE_SET_DIGEST", "MILLISECOND", "MIN", "MINUTE", "MIN_BY", "MOD", "MONTH", "MULTIMAP_AGG", "MULTIMAP_FROM_ENTRIES", "MURMUR3", "NAN", "NGRAMS", "NONE_MATCH", "NORMALIZE", "NORMAL_CDF", "NOW", "NTH_VALUE", "NTILE", "NULLIF", "NUMERIC_HISTOGRAM", "OBJECTID", "OBJECTID_TIMESTAMP", "PARSE_DATA_SIZE", "PARSE_DATETIME", "PARSE_DURATION", "PERCENT_RANK", "PI", "POSITION", "POW", "POWER", "QDIGEST_AGG", "QUARTER", "RADIANS", "RAND", "RANDOM", "RANK", "REDUCE", "REDUCE_AGG", "REGEXP_COUNT", "REGEXP_EXTRACT", "REGEXP_EXTRACT_ALL", "REGEXP_LIKE", "REGEXP_POSITION", "REGEXP_REPLACE", "REGEXP_SPLIT", "REGRESS", "REGR_INTERCEPT", "REGR_SLOPE", "RENDER", "REPEAT", "REPLACE", "REVERSE", "RGB", "ROUND", "ROW_NUMBER", "RPAD", "RTRIM", "SECOND", "SEQUENCE", "SHA1", "SHA256", "SHA512", "SHUFFLE", "SIGN", "SIMPLIFY_GEOMETRY", "SIN", "SKEWNESS", "SLICE", "SOUNDEX", "SPATIAL_PARTITIONING", "SPATIAL_PARTITIONS", "SPLIT", "SPLIT_PART", "SPLIT_TO_MAP", "SPLIT_TO_MULTIMAP", "SPOOKY_HASH_V2_32", "SPOOKY_HASH_V2_64", "SQRT", "STARTS_WITH", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STRPOS", "ST_AREA", "ST_ASBINARY", "ST_ASTEXT", "ST_BOUNDARY", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", "ST_CONVEXHULL", "ST_COORDDIM", "ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_ENDPOINT", "ST_ENVELOPE", "ST_ENVELOPEASPTS", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMETRIES", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMBINARY", "ST_INTERIORRINGN", "ST_INTERIORRINGS", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED", "ST_ISEMPTY", "ST_ISRING", "ST_ISSIMPLE", "ST_ISVALID", "ST_LENGTH", "ST_LINEFROMTEXT", "ST_LINESTRING", "ST_MULTIPOINT", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINT", "ST_POINTN", "ST_POINTS", "ST_POLYGON", "ST_RELATE", "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", "ST_UNION", "ST_WITHIN", "ST_X", "ST_XMAX", "ST_XMIN", "ST_Y", "ST_YMAX", "ST_YMIN", "SUBSTR", "SUBSTRING", "SUM", "TAN", "TANH", "TDIGEST_AGG", "TIMESTAMP_OBJECTID", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TO_BASE", "TO_BASE32", "TO_BASE64", "TO_BASE64URL", "TO_BIG_ENDIAN_32", "TO_BIG_ENDIAN_64", "TO_CHAR", "TO_DATE", "TO_ENCODED_POLYLINE", "TO_GEOJSON_GEOMETRY", "TO_GEOMETRY", "TO_HEX", "TO_IEEE754_32", "TO_IEEE754_64", "TO_ISO8601", "TO_MILLISECONDS", "TO_SPHERICAL_GEOGRAPHY", "TO_TIMESTAMP", "TO_UNIXTIME", "TO_UTF8", "TRANSFORM", "TRANSFORM_KEYS", "TRANSFORM_VALUES", "TRANSLATE", "TRIM", "TRIM_ARRAY", "TRUNCATE", "TRY", "TRY_CAST", "TYPEOF", "UPPER", "URL_DECODE", "URL_ENCODE", "URL_EXTRACT_FRAGMENT", "URL_EXTRACT_HOST", "URL_EXTRACT_PARAMETER", "URL_EXTRACT_PATH", "URL_EXTRACT_PORT", "URL_EXTRACT_PROTOCOL", "URL_EXTRACT_QUERY", "UUID", "VALUES_AT_QUANTILES", "VALUE_AT_QUANTILE", "VARIANCE", "VAR_POP", "VAR_SAMP", "VERSION", "WEEK", "WEEK_OF_YEAR", "WIDTH_BUCKET", "WILSON_INTERVAL_LOWER", "WILSON_INTERVAL_UPPER", "WITH_TIMEZONE", "WORD_STEM", "XXHASH64", "YEAR", "YEAR_OF_WEEK", "YOW", "ZIP", "ZIP_WITH"],
  // https://trino.io/docs/current/sql/match-recognize.html#row-pattern-recognition-expressions
  rowPattern: ["CLASSIFIER", "FIRST", "LAST", "MATCH_NUMBER", "NEXT", "PERMUTE", "PREV"]
}), IX = Ne({
  // https://github.com/trinodb/trino/blob/432d2897bdef99388c1a47188743a061c4ac1f34/core/trino-parser/src/main/antlr4/io/trino/sql/parser/SqlBase.g4#L858-L1128
  all: ["ABSENT", "ADD", "ADMIN", "AFTER", "ALL", "ALTER", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "AT", "AUTHORIZATION", "BERNOULLI", "BETWEEN", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CATALOGS", "COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "CONDITIONAL", "CONSTRAINT", "COPARTITION", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_PATH", "CURRENT_ROLE", "DATA", "DEALLOCATE", "DEFAULT", "DEFINE", "DEFINER", "DELETE", "DENY", "DESC", "DESCRIBE", "DESCRIPTOR", "DISTINCT", "DISTRIBUTED", "DOUBLE", "DROP", "ELSE", "EMPTY", "ENCODING", "END", "ERROR", "ESCAPE", "EXCEPT", "EXCLUDING", "EXECUTE", "EXISTS", "EXPLAIN", "FALSE", "FETCH", "FINAL", "FIRST", "FOLLOWING", "FOR", "FROM", "FULL", "FUNCTIONS", "GRANT", "GRANTED", "GRANTS", "GRAPHVIZ", "GROUP", "GROUPING", "GROUPS", "HAVING", "IGNORE", "IN", "INCLUDING", "INITIAL", "INNER", "INPUT", "INSERT", "INTERSECT", "INTERVAL", "INTO", "INVOKER", "IO", "IS", "ISOLATION", "JOIN", "JSON", "JSON_ARRAY", "JSON_OBJECT", "KEEP", "KEY", "KEYS", "LAST", "LATERAL", "LEADING", "LEFT", "LEVEL", "LIKE", "LIMIT", "LOCAL", "LOGICAL", "MATCH", "MATCHED", "MATCHES", "MATCH_RECOGNIZE", "MATERIALIZED", "MEASURES", "NATURAL", "NEXT", "NFC", "NFD", "NFKC", "NFKD", "NO", "NONE", "NOT", "NULL", "NULLS", "OBJECT", "OF", "OFFSET", "OMIT", "ON", "ONE", "ONLY", "OPTION", "OR", "ORDER", "ORDINALITY", "OUTER", "OUTPUT", "OVER", "OVERFLOW", "PARTITION", "PARTITIONS", "PASSING", "PAST", "PATH", "PATTERN", "PER", "PERMUTE", "PRECEDING", "PRECISION", "PREPARE", "PRIVILEGES", "PROPERTIES", "PRUNE", "QUOTES", "RANGE", "READ", "RECURSIVE", "REFRESH", "RENAME", "REPEATABLE", "RESET", "RESPECT", "RESTRICT", "RETURNING", "REVOKE", "RIGHT", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROW", "ROWS", "RUNNING", "SCALAR", "SCHEMA", "SCHEMAS", "SECURITY", "SEEK", "SELECT", "SERIALIZABLE", "SESSION", "SET", "SETS", "SHOW", "SKIP", "SOME", "START", "STATS", "STRING", "SUBSET", "SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", "TEXT", "THEN", "TIES", "TIME", "TIMESTAMP", "TO", "TRAILING", "TRANSACTION", "TRUE", "TYPE", "UESCAPE", "UNBOUNDED", "UNCOMMITTED", "UNCONDITIONAL", "UNION", "UNIQUE", "UNKNOWN", "UNMATCHED", "UNNEST", "UPDATE", "USE", "USER", "USING", "UTF16", "UTF32", "UTF8", "VALIDATE", "VALUE", "VALUES", "VERBOSE", "VIEW", "WHEN", "WHERE", "WINDOW", "WITH", "WITHIN", "WITHOUT", "WORK", "WRAPPER", "WRITE", "ZONE"],
  // https://github.com/trinodb/trino/blob/432d2897bdef99388c1a47188743a061c4ac1f34/core/trino-main/src/main/java/io/trino/metadata/TypeRegistry.java#L131-L168
  // or https://trino.io/docs/current/language/types.html
  types: ["BIGINT", "INT", "INTEGER", "SMALLINT", "TINYINT", "BOOLEAN", "DATE", "DECIMAL", "REAL", "DOUBLE", "HYPERLOGLOG", "QDIGEST", "TDIGEST", "P4HYPERLOGLOG", "INTERVAL", "TIMESTAMP", "TIME", "VARBINARY", "VARCHAR", "CHAR", "ROW", "ARRAY", "MAP", "JSON", "JSON2016", "IPADDRESS", "GEOMETRY", "UUID", "SETDIGEST", "JONIREGEXP", "RE2JREGEXP", "LIKEPATTERN", "COLOR", "CODEPOINTS", "FUNCTION", "JSONPATH"]
}), vX = V(["SELECT [ALL | DISTINCT]"]), _X = V([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [MATERIALIZED] VIEW",
  "CREATE TABLE [IF NOT EXISTS]",
  // MATCH_RECOGNIZE
  "MATCH_RECOGNIZE",
  "MEASURES",
  "ONE ROW PER MATCH",
  "ALL ROWS PER MATCH",
  "AFTER MATCH",
  "PATTERN",
  "SUBSET",
  "DEFINE"
]), rT = V([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "ADD COLUMN [IF NOT EXISTS]",
  "DROP COLUMN [IF EXISTS]",
  "RENAME COLUMN [IF EXISTS]",
  "RENAME TO",
  "SET AUTHORIZATION [USER | ROLE]",
  "SET PROPERTIES",
  "EXECUTE",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "ALTER SCHEMA",
  "ALTER MATERIALIZED VIEW",
  "ALTER VIEW",
  "CREATE SCHEMA",
  "CREATE ROLE",
  "DROP SCHEMA",
  "DROP MATERIALIZED VIEW",
  "DROP VIEW",
  "DROP ROLE",
  // Auxiliary
  "EXPLAIN",
  "ANALYZE",
  "EXPLAIN ANALYZE",
  "EXPLAIN ANALYZE VERBOSE",
  "USE",
  "COMMENT ON TABLE",
  "COMMENT ON COLUMN",
  "DESCRIBE INPUT",
  "DESCRIBE OUTPUT",
  "REFRESH MATERIALIZED VIEW",
  "RESET SESSION",
  "SET SESSION",
  "SET PATH",
  "SET TIME ZONE",
  "SHOW GRANTS",
  "SHOW CREATE TABLE",
  "SHOW CREATE SCHEMA",
  "SHOW CREATE VIEW",
  "SHOW CREATE MATERIALIZED VIEW",
  "SHOW TABLES",
  "SHOW SCHEMAS",
  "SHOW CATALOGS",
  "SHOW COLUMNS",
  "SHOW STATS FOR",
  "SHOW ROLES",
  "SHOW CURRENT ROLES",
  "SHOW ROLE GRANTS",
  "SHOW FUNCTIONS",
  "SHOW SESSION"
]), PX = V(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), LX = V(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), wX = V([
  "{ROWS | RANGE | GROUPS} BETWEEN",
  // comparison operator
  "IS [NOT] DISTINCT FROM"
]), yX = {
  tokenizerOptions: {
    reservedSelect: vX,
    reservedClauses: [..._X, ...rT],
    reservedSetOperations: PX,
    reservedJoins: LX,
    reservedPhrases: wX,
    reservedKeywords: IX,
    reservedFunctionNames: NX,
    // Trino also supports {- ... -} parenthesis.
    // The formatting of these currently works out as a result of { and -
    // not getting a space added in-between.
    // https://trino.io/docs/current/sql/match-recognize.html#row-pattern-syntax
    extraParens: ["[]", "{}"],
    // https://trino.io/docs/current/language/types.html#string
    // https://trino.io/docs/current/language/types.html#varbinary
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["U&"]
    }, {
      quote: "''-raw",
      prefixes: ["X"],
      requirePrefix: !0
    }],
    // https://trino.io/docs/current/language/reserved.html
    identTypes: ['""-qq'],
    paramTypes: {
      positional: !0
    },
    operators: [
      "%",
      "->",
      "=>",
      ":",
      "||",
      // Row pattern syntax
      "|",
      "^",
      "$"
      // '?', conflicts with positional placeholders
    ]
  },
  formatOptions: {
    onelineClauses: rT
  }
}, DX = Ne({
  // https://docs.microsoft.com/en-us/sql/t-sql/functions/functions?view=sql-server-ver15
  aggregate: ["APPROX_COUNT_DISTINCT", "AVG", "CHECKSUM_AGG", "COUNT", "COUNT_BIG", "GROUPING", "GROUPING_ID", "MAX", "MIN", "STDEV", "STDEVP", "SUM", "VAR", "VARP"],
  analytic: ["CUME_DIST", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "Collation - COLLATIONPROPERTY", "Collation - TERTIARY_WEIGHTS"],
  configuration: ["@@DBTS", "@@LANGID", "@@LANGUAGE", "@@LOCK_TIMEOUT", "@@MAX_CONNECTIONS", "@@MAX_PRECISION", "@@NESTLEVEL", "@@OPTIONS", "@@REMSERVER", "@@SERVERNAME", "@@SERVICENAME", "@@SPID", "@@TEXTSIZE", "@@VERSION"],
  conversion: ["CAST", "CONVERT", "PARSE", "TRY_CAST", "TRY_CONVERT", "TRY_PARSE"],
  cryptographic: ["ASYMKEY_ID", "ASYMKEYPROPERTY", "CERTPROPERTY", "CERT_ID", "CRYPT_GEN_RANDOM", "DECRYPTBYASYMKEY", "DECRYPTBYCERT", "DECRYPTBYKEY", "DECRYPTBYKEYAUTOASYMKEY", "DECRYPTBYKEYAUTOCERT", "DECRYPTBYPASSPHRASE", "ENCRYPTBYASYMKEY", "ENCRYPTBYCERT", "ENCRYPTBYKEY", "ENCRYPTBYPASSPHRASE", "HASHBYTES", "IS_OBJECTSIGNED", "KEY_GUID", "KEY_ID", "KEY_NAME", "SIGNBYASYMKEY", "SIGNBYCERT", "SYMKEYPROPERTY", "VERIFYSIGNEDBYCERT", "VERIFYSIGNEDBYASYMKEY"],
  cursor: ["@@CURSOR_ROWS", "@@FETCH_STATUS", "CURSOR_STATUS"],
  dataType: ["DATALENGTH", "IDENT_CURRENT", "IDENT_INCR", "IDENT_SEED", "IDENTITY", "SQL_VARIANT_PROPERTY"],
  datetime: ["@@DATEFIRST", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "CURRENT_TIMEZONE_ID", "DATEADD", "DATEDIFF", "DATEDIFF_BIG", "DATEFROMPARTS", "DATENAME", "DATEPART", "DATETIME2FROMPARTS", "DATETIMEFROMPARTS", "DATETIMEOFFSETFROMPARTS", "DAY", "EOMONTH", "GETDATE", "GETUTCDATE", "ISDATE", "MONTH", "SMALLDATETIMEFROMPARTS", "SWITCHOFFSET", "SYSDATETIME", "SYSDATETIMEOFFSET", "SYSUTCDATETIME", "TIMEFROMPARTS", "TODATETIMEOFFSET", "YEAR", "JSON", "ISJSON", "JSON_VALUE", "JSON_QUERY", "JSON_MODIFY"],
  mathematical: ["ABS", "ACOS", "ASIN", "ATAN", "ATN2", "CEILING", "COS", "COT", "DEGREES", "EXP", "FLOOR", "LOG", "LOG10", "PI", "POWER", "RADIANS", "RAND", "ROUND", "SIGN", "SIN", "SQRT", "SQUARE", "TAN", "CHOOSE", "GREATEST", "IIF", "LEAST"],
  metadata: ["@@PROCID", "APP_NAME", "APPLOCK_MODE", "APPLOCK_TEST", "ASSEMBLYPROPERTY", "COL_LENGTH", "COL_NAME", "COLUMNPROPERTY", "DATABASEPROPERTYEX", "DB_ID", "DB_NAME", "FILE_ID", "FILE_IDEX", "FILE_NAME", "FILEGROUP_ID", "FILEGROUP_NAME", "FILEGROUPPROPERTY", "FILEPROPERTY", "FILEPROPERTYEX", "FULLTEXTCATALOGPROPERTY", "FULLTEXTSERVICEPROPERTY", "INDEX_COL", "INDEXKEY_PROPERTY", "INDEXPROPERTY", "NEXT VALUE FOR", "OBJECT_DEFINITION", "OBJECT_ID", "OBJECT_NAME", "OBJECT_SCHEMA_NAME", "OBJECTPROPERTY", "OBJECTPROPERTYEX", "ORIGINAL_DB_NAME", "PARSENAME", "SCHEMA_ID", "SCHEMA_NAME", "SCOPE_IDENTITY", "SERVERPROPERTY", "STATS_DATE", "TYPE_ID", "TYPE_NAME", "TYPEPROPERTY"],
  ranking: ["DENSE_RANK", "NTILE", "RANK", "ROW_NUMBER", "PUBLISHINGSERVERNAME"],
  security: ["CERTENCODED", "CERTPRIVATEKEY", "CURRENT_USER", "DATABASE_PRINCIPAL_ID", "HAS_DBACCESS", "HAS_PERMS_BY_NAME", "IS_MEMBER", "IS_ROLEMEMBER", "IS_SRVROLEMEMBER", "LOGINPROPERTY", "ORIGINAL_LOGIN", "PERMISSIONS", "PWDENCRYPT", "PWDCOMPARE", "SESSION_USER", "SESSIONPROPERTY", "SUSER_ID", "SUSER_NAME", "SUSER_SID", "SUSER_SNAME", "SYSTEM_USER", "USER", "USER_ID", "USER_NAME"],
  string: ["ASCII", "CHAR", "CHARINDEX", "CONCAT", "CONCAT_WS", "DIFFERENCE", "FORMAT", "LEFT", "LEN", "LOWER", "LTRIM", "NCHAR", "PATINDEX", "QUOTENAME", "REPLACE", "REPLICATE", "REVERSE", "RIGHT", "RTRIM", "SOUNDEX", "SPACE", "STR", "STRING_AGG", "STRING_ESCAPE", "STUFF", "SUBSTRING", "TRANSLATE", "TRIM", "UNICODE", "UPPER"],
  system: ["$PARTITION", "@@ERROR", "@@IDENTITY", "@@PACK_RECEIVED", "@@ROWCOUNT", "@@TRANCOUNT", "BINARY_CHECKSUM", "CHECKSUM", "COMPRESS", "CONNECTIONPROPERTY", "CONTEXT_INFO", "CURRENT_REQUEST_ID", "CURRENT_TRANSACTION_ID", "DECOMPRESS", "ERROR_LINE", "ERROR_MESSAGE", "ERROR_NUMBER", "ERROR_PROCEDURE", "ERROR_SEVERITY", "ERROR_STATE", "FORMATMESSAGE", "GET_FILESTREAM_TRANSACTION_CONTEXT", "GETANSINULL", "HOST_ID", "HOST_NAME", "ISNULL", "ISNUMERIC", "MIN_ACTIVE_ROWVERSION", "NEWID", "NEWSEQUENTIALID", "ROWCOUNT_BIG", "SESSION_CONTEXT", "XACT_STATE"],
  statistical: ["@@CONNECTIONS", "@@CPU_BUSY", "@@IDLE", "@@IO_BUSY", "@@PACK_SENT", "@@PACKET_ERRORS", "@@TIMETICKS", "@@TOTAL_ERRORS", "@@TOTAL_READ", "@@TOTAL_WRITE", "TEXTPTR", "TEXTVALID"],
  trigger: ["COLUMNS_UPDATED", "EVENTDATA", "TRIGGER_NESTLEVEL", "UPDATE"],
  // Shorthand functions to use in place of CASE expression
  caseAbbrev: ["COALESCE", "NULLIF"],
  // Parameterized types
  // https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver15
  dataTypes: ["DECIMAL", "NUMERIC", "FLOAT", "REAL", "DATETIME2", "DATETIMEOFFSET", "TIME", "CHAR", "VARCHAR", "NCHAR", "NVARCHAR", "BINARY", "VARBINARY"]
}), xX = Ne({
  // https://docs.microsoft.com/en-us/sql/t-sql/language-elements/reserved-keywords-transact-sql?view=sql-server-ver15
  standard: ["ADD", "ALL", "ALTER", "AND", "ANY", "AS", "ASC", "AUTHORIZATION", "BACKUP", "BEGIN", "BETWEEN", "BREAK", "BROWSE", "BULK", "BY", "CASCADE", "CHECK", "CHECKPOINT", "CLOSE", "CLUSTERED", "COALESCE", "COLLATE", "COLUMN", "COMMIT", "COMPUTE", "CONSTRAINT", "CONTAINS", "CONTAINSTABLE", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATABASE", "DBCC", "DEALLOCATE", "DECLARE", "DEFAULT", "DELETE", "DENY", "DESC", "DISK", "DISTINCT", "DISTRIBUTED", "DOUBLE", "DROP", "DUMP", "ERRLVL", "ESCAPE", "EXEC", "EXECUTE", "EXISTS", "EXIT", "EXTERNAL", "FETCH", "FILE", "FILLFACTOR", "FOR", "FOREIGN", "FREETEXT", "FREETEXTTABLE", "FROM", "FULL", "FUNCTION", "GOTO", "GRANT", "GROUP", "HAVING", "HOLDLOCK", "IDENTITY", "IDENTITYCOL", "IDENTITY_INSERT", "IF", "IN", "INDEX", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "JOIN", "KEY", "KILL", "LEFT", "LIKE", "LINENO", "LOAD", "MERGE", "NATIONAL", "NOCHECK", "NONCLUSTERED", "NOT", "NULL", "NULLIF", "OF", "OFF", "OFFSETS", "ON", "OPEN", "OPENDATASOURCE", "OPENQUERY", "OPENROWSET", "OPENXML", "OPTION", "OR", "ORDER", "OUTER", "OVER", "PERCENT", "PIVOT", "PLAN", "PRECISION", "PRIMARY", "PRINT", "PROC", "PROCEDURE", "PUBLIC", "RAISERROR", "READ", "READTEXT", "RECONFIGURE", "REFERENCES", "REPLICATION", "RESTORE", "RESTRICT", "RETURN", "REVERT", "REVOKE", "RIGHT", "ROLLBACK", "ROWCOUNT", "ROWGUIDCOL", "RULE", "SAVE", "SCHEMA", "SECURITYAUDIT", "SELECT", "SEMANTICKEYPHRASETABLE", "SEMANTICSIMILARITYDETAILSTABLE", "SEMANTICSIMILARITYTABLE", "SESSION_USER", "SET", "SETUSER", "SHUTDOWN", "SOME", "STATISTICS", "SYSTEM_USER", "TABLE", "TABLESAMPLE", "TEXTSIZE", "THEN", "TO", "TOP", "TRAN", "TRANSACTION", "TRIGGER", "TRUNCATE", "TRY_CONVERT", "TSEQUAL", "UNION", "UNIQUE", "UNPIVOT", "UPDATE", "UPDATETEXT", "USE", "USER", "VALUES", "VARYING", "VIEW", "WAITFOR", "WHERE", "WHILE", "WITH", "WITHIN GROUP", "WRITETEXT"],
  odbc: ["ABSOLUTE", "ACTION", "ADA", "ADD", "ALL", "ALLOCATE", "ALTER", "AND", "ANY", "ARE", "AS", "ASC", "ASSERTION", "AT", "AUTHORIZATION", "AVG", "BEGIN", "BETWEEN", "BIT", "BIT_LENGTH", "BOTH", "BY", "CASCADE", "CASCADED", "CAST", "CATALOG", "CHAR", "CHARACTER", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHECK", "CLOSE", "COALESCE", "COLLATE", "COLLATION", "COLUMN", "COMMIT", "CONNECT", "CONNECTION", "CONSTRAINT", "CONSTRAINTS", "CONTINUE", "CONVERT", "CORRESPONDING", "COUNT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATE", "DAY", "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE", "DESC", "DESCRIBE", "DESCRIPTOR", "DIAGNOSTICS", "DISCONNECT", "DISTINCT", "DOMAIN", "DOUBLE", "DROP", "END-EXEC", "ESCAPE", "EXCEPTION", "EXEC", "EXECUTE", "EXISTS", "EXTERNAL", "EXTRACT", "FALSE", "FETCH", "FIRST", "FLOAT", "FOR", "FOREIGN", "FORTRAN", "FOUND", "FROM", "FULL", "GET", "GLOBAL", "GO", "GOTO", "GRANT", "GROUP", "HAVING", "HOUR", "IDENTITY", "IMMEDIATE", "IN", "INCLUDE", "INDEX", "INDICATOR", "INITIALLY", "INNER", "INPUT", "INSENSITIVE", "INSERT", "INT", "INTEGER", "INTERSECT", "INTERVAL", "INTO", "IS", "ISOLATION", "JOIN", "KEY", "LANGUAGE", "LAST", "LEADING", "LEFT", "LEVEL", "LIKE", "LOCAL", "LOWER", "MATCH", "MAX", "MIN", "MINUTE", "MODULE", "MONTH", "NAMES", "NATIONAL", "NATURAL", "NCHAR", "NEXT", "NO", "NONE", "NOT", "NULL", "NULLIF", "NUMERIC", "OCTET_LENGTH", "OF", "ONLY", "OPEN", "OPTION", "OR", "ORDER", "OUTER", "OUTPUT", "OVERLAPS", "PAD", "PARTIAL", "PASCAL", "POSITION", "PRECISION", "PREPARE", "PRESERVE", "PRIMARY", "PRIOR", "PRIVILEGES", "PROCEDURE", "PUBLIC", "READ", "REAL", "REFERENCES", "RELATIVE", "RESTRICT", "REVOKE", "RIGHT", "ROLLBACK", "ROWS", "SCHEMA", "SCROLL", "SECOND", "SECTION", "SELECT", "SESSION", "SESSION_USER", "SET", "SIZE", "SMALLINT", "SOME", "SPACE", "SQL", "SQLCA", "SQLCODE", "SQLERROR", "SQLSTATE", "SQLWARNING", "SUBSTRING", "SUM", "SYSTEM_USER", "TABLE", "TEMPORARY", "TIME", "TIMESTAMP", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TO", "TRAILING", "TRANSACTION", "TRANSLATE", "TRANSLATION", "TRIM", "TRUE", "UNION", "UNIQUE", "UNKNOWN", "UPDATE", "UPPER", "USAGE", "USER", "VALUE", "VALUES", "VARCHAR", "VARYING", "VIEW", "WHENEVER", "WHERE", "WITH", "WORK", "WRITE", "YEAR", "ZONE"]
}), MX = V(["SELECT [ALL | DISTINCT]"]), UX = V([
  // queries
  "WITH",
  "INTO",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT [INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [BY TARGET | BY SOURCE] [THEN]",
  "UPDATE SET",
  // Data definition
  "CREATE [OR ALTER] [MATERIALIZED] VIEW",
  "CREATE TABLE",
  "CREATE [OR ALTER] {PROC | PROCEDURE}"
]), oT = V([
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD",
  "DROP COLUMN [IF EXISTS]",
  "ALTER COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // https://docs.microsoft.com/en-us/sql/t-sql/statements/statements?view=sql-server-ver15
  "ADD SENSITIVITY CLASSIFICATION",
  "ADD SIGNATURE",
  "AGGREGATE",
  "ANSI_DEFAULTS",
  "ANSI_NULLS",
  "ANSI_NULL_DFLT_OFF",
  "ANSI_NULL_DFLT_ON",
  "ANSI_PADDING",
  "ANSI_WARNINGS",
  "APPLICATION ROLE",
  "ARITHABORT",
  "ARITHIGNORE",
  "ASSEMBLY",
  "ASYMMETRIC KEY",
  "AUTHORIZATION",
  "AVAILABILITY GROUP",
  "BACKUP",
  "BACKUP CERTIFICATE",
  "BACKUP MASTER KEY",
  "BACKUP SERVICE MASTER KEY",
  "BEGIN CONVERSATION TIMER",
  "BEGIN DIALOG CONVERSATION",
  "BROKER PRIORITY",
  "BULK INSERT",
  "CERTIFICATE",
  "CLOSE MASTER KEY",
  "CLOSE SYMMETRIC KEY",
  "COLLATE",
  "COLUMN ENCRYPTION KEY",
  "COLUMN MASTER KEY",
  "COLUMNSTORE INDEX",
  "CONCAT_NULL_YIELDS_NULL",
  "CONTEXT_INFO",
  "CONTRACT",
  "CREDENTIAL",
  "CRYPTOGRAPHIC PROVIDER",
  "CURSOR_CLOSE_ON_COMMIT",
  "DATABASE",
  "DATABASE AUDIT SPECIFICATION",
  "DATABASE ENCRYPTION KEY",
  "DATABASE HADR",
  "DATABASE SCOPED CONFIGURATION",
  "DATABASE SCOPED CREDENTIAL",
  "DATABASE SET",
  "DATEFIRST",
  "DATEFORMAT",
  "DEADLOCK_PRIORITY",
  "DENY",
  "DENY XML",
  "DISABLE TRIGGER",
  "ENABLE TRIGGER",
  "END CONVERSATION",
  "ENDPOINT",
  "EVENT NOTIFICATION",
  "EVENT SESSION",
  "EXECUTE AS",
  "EXTERNAL DATA SOURCE",
  "EXTERNAL FILE FORMAT",
  "EXTERNAL LANGUAGE",
  "EXTERNAL LIBRARY",
  "EXTERNAL RESOURCE POOL",
  "EXTERNAL TABLE",
  "FIPS_FLAGGER",
  "FMTONLY",
  "FORCEPLAN",
  "FULLTEXT CATALOG",
  "FULLTEXT INDEX",
  "FULLTEXT STOPLIST",
  "FUNCTION",
  "GET CONVERSATION GROUP",
  "GET_TRANSMISSION_STATUS",
  "GRANT",
  "GRANT XML",
  "IDENTITY_INSERT",
  "IMPLICIT_TRANSACTIONS",
  "INDEX",
  "LANGUAGE",
  "LOCK_TIMEOUT",
  "LOGIN",
  "MASTER KEY",
  "MESSAGE TYPE",
  "MOVE CONVERSATION",
  "NOCOUNT",
  "NOEXEC",
  "NUMERIC_ROUNDABORT",
  "OFFSETS",
  "OPEN MASTER KEY",
  "OPEN SYMMETRIC KEY",
  "PARSEONLY",
  "PARTITION FUNCTION",
  "PARTITION SCHEME",
  "PROCEDURE",
  "QUERY_GOVERNOR_COST_LIMIT",
  "QUEUE",
  "QUOTED_IDENTIFIER",
  "RECEIVE",
  "REMOTE SERVICE BINDING",
  "REMOTE_PROC_TRANSACTIONS",
  "RESOURCE GOVERNOR",
  "RESOURCE POOL",
  "RESTORE",
  "RESTORE FILELISTONLY",
  "RESTORE HEADERONLY",
  "RESTORE LABELONLY",
  "RESTORE MASTER KEY",
  "RESTORE REWINDONLY",
  "RESTORE SERVICE MASTER KEY",
  "RESTORE VERIFYONLY",
  "REVERT",
  "REVOKE",
  "REVOKE XML",
  "ROLE",
  "ROUTE",
  "ROWCOUNT",
  "RULE",
  "SCHEMA",
  "SEARCH PROPERTY LIST",
  "SECURITY POLICY",
  "SELECTIVE XML INDEX",
  "SEND",
  "SENSITIVITY CLASSIFICATION",
  "SEQUENCE",
  "SERVER AUDIT",
  "SERVER AUDIT SPECIFICATION",
  "SERVER CONFIGURATION",
  "SERVER ROLE",
  "SERVICE",
  "SERVICE MASTER KEY",
  "SETUSER",
  "SHOWPLAN_ALL",
  "SHOWPLAN_TEXT",
  "SHOWPLAN_XML",
  "SIGNATURE",
  "SPATIAL INDEX",
  "STATISTICS",
  "STATISTICS IO",
  "STATISTICS PROFILE",
  "STATISTICS TIME",
  "STATISTICS XML",
  "SYMMETRIC KEY",
  "SYNONYM",
  "TABLE",
  "TABLE IDENTITY",
  "TEXTSIZE",
  "TRANSACTION ISOLATION LEVEL",
  "TRIGGER",
  "TYPE",
  "UPDATE STATISTICS",
  "USER",
  "WORKLOAD GROUP",
  "XACT_ABORT",
  "XML INDEX",
  "XML SCHEMA COLLECTION"
]), QX = V(["UNION [ALL]", "EXCEPT", "INTERSECT"]), kX = V([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  // non-standard joins
  "{CROSS | OUTER} APPLY"
]), $X = V(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE} BETWEEN"]), GX = {
  tokenizerOptions: {
    reservedSelect: MX,
    reservedClauses: [...UX, ...oT],
    reservedSetOperations: QX,
    reservedJoins: kX,
    reservedPhrases: $X,
    reservedKeywords: xX,
    reservedFunctionNames: DX,
    nestedBlockComments: !0,
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["N"]
    }],
    identTypes: ['""-qq', "[]"],
    identChars: {
      first: "#@",
      rest: "#@$"
    },
    paramTypes: {
      named: ["@"],
      quoted: ["@"]
    },
    operators: ["%", "&", "|", "^", "~", "!<", "!>", "+=", "-=", "*=", "/=", "%=", "|=", "&=", "^=", "::"]
    // TODO: Support for money constants
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: oT
  }
}, VX = Ne({
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/restricted-keywords/list-of-restricted-keywords.html
  all: ["ABORT", "ABSOLUTE", "ACCESS", "ACCESSIBLE", "ACCOUNT", "ACTION", "ACTIVE", "ADD", "ADMIN", "AFTER", "AGAINST", "AGGREGATE", "AGGREGATES", "AGGREGATOR", "AGGREGATOR_ID", "AGGREGATOR_PLAN_HASH", "AGGREGATORS", "ALGORITHM", "ALL", "ALSO", "ALTER", "ALWAYS", "ANALYZE", "AND", "ANY", "ARGHISTORY", "ARRANGE", "ARRANGEMENT", "ARRAY", "AS", "ASC", "ASCII", "ASENSITIVE", "ASM", "ASSERTION", "ASSIGNMENT", "AST", "ASYMMETRIC", "ASYNC", "AT", "ATTACH", "ATTRIBUTE", "AUTHORIZATION", "AUTO", "AUTO_INCREMENT", "AUTO_REPROVISION", "AUTOSTATS", "AUTOSTATS_CARDINALITY_MODE", "AUTOSTATS_ENABLED", "AUTOSTATS_HISTOGRAM_MODE", "AUTOSTATS_SAMPLING", "AVAILABILITY", "AVG", "AVG_ROW_LENGTH", "AVRO", "AZURE", "BACKGROUND", "_BACKGROUND_THREADS_FOR_CLEANUP", "BACKUP", "BACKUP_HISTORY", "BACKUP_ID", "BACKWARD", "BATCH", "BATCHES", "BATCH_INTERVAL", "_BATCH_SIZE_LIMIT", "BEFORE", "BEGIN", "BETWEEN", "BIGINT", "BINARY", "_BINARY", "BIT", "BLOB", "BOOL", "BOOLEAN", "BOOTSTRAP", "BOTH", "_BT", "BTREE", "BUCKET_COUNT", "BUCKETS", "BY", "BYTE", "BYTE_LENGTH", "CACHE", "CALL", "CALL_FOR_PIPELINE", "CALLED", "CAPTURE", "CASCADE", "CASCADED", "CASE", "CATALOG", "CHAIN", "CHANGE", "CHAR", "CHARACTER", "CHARACTERISTICS", "CHARSET", "CHECK", "CHECKPOINT", "_CHECK_CAN_CONNECT", "_CHECK_CONSISTENCY", "CHECKSUM", "_CHECKSUM", "CLASS", "CLEAR", "CLIENT", "CLIENT_FOUND_ROWS", "CLOSE", "CLUSTER", "CLUSTERED", "CNF", "COALESCE", "COLLATE", "COLLATION", "COLUMN", "COLUMNAR", "COLUMNS", "COLUMNSTORE", "COLUMNSTORE_SEGMENT_ROWS", "COMMENT", "COMMENTS", "COMMIT", "COMMITTED", "_COMMIT_LOG_TAIL", "COMPACT", "COMPILE", "COMPRESSED", "COMPRESSION", "CONCURRENT", "CONCURRENTLY", "CONDITION", "CONFIGURATION", "CONNECTION", "CONNECTIONS", "CONFIG", "CONSTRAINT", "CONTAINS", "CONTENT", "CONTINUE", "_CONTINUE_REPLAY", "CONVERSION", "CONVERT", "COPY", "_CORE", "COST", "CREATE", "CREDENTIALS", "CROSS", "CUBE", "CSV", "CUME_DIST", "CURRENT", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_SCHEMA", "CURRENT_SECURITY_GROUPS", "CURRENT_SECURITY_ROLES", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "CYCLE", "DATA", "DATABASE", "DATABASES", "DATE", "DATETIME", "DAY", "DAY_HOUR", "DAY_MICROSECOND", "DAY_MINUTE", "DAY_SECOND", "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DEFAULTS", "DEFERRABLE", "DEFERRED", "DEFINED", "DEFINER", "DELAYED", "DELAY_KEY_WRITE", "DELETE", "DELIMITER", "DELIMITERS", "DENSE_RANK", "DESC", "DESCRIBE", "DETACH", "DETERMINISTIC", "DICTIONARY", "DIFFERENTIAL", "DIRECTORY", "DISABLE", "DISCARD", "_DISCONNECT", "DISK", "DISTINCT", "DISTINCTROW", "DISTRIBUTED_JOINS", "DIV", "DO", "DOCUMENT", "DOMAIN", "DOUBLE", "DROP", "_DROP_PROFILE", "DUAL", "DUMP", "DUPLICATE", "DURABILITY", "DYNAMIC", "EARLIEST", "EACH", "ECHO", "ELECTION", "ELSE", "ELSEIF", "ENABLE", "ENCLOSED", "ENCODING", "ENCRYPTED", "END", "ENGINE", "ENGINES", "ENUM", "ERRORS", "ESCAPE", "ESCAPED", "ESTIMATE", "EVENT", "EVENTS", "EXCEPT", "EXCLUDE", "EXCLUDING", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPLAIN", "EXTENDED", "EXTENSION", "EXTERNAL", "EXTERNAL_HOST", "EXTERNAL_PORT", "EXTRACTOR", "EXTRACTORS", "EXTRA_JOIN", "_FAILOVER", "FAILED_LOGIN_ATTEMPTS", "FAILURE", "FALSE", "FAMILY", "FAULT", "FETCH", "FIELDS", "FILE", "FILES", "FILL", "FIX_ALTER", "FIXED", "FLOAT", "FLOAT4", "FLOAT8", "FLUSH", "FOLLOWING", "FOR", "FORCE", "FORCE_COMPILED_MODE", "FORCE_INTERPRETER_MODE", "FOREGROUND", "FOREIGN", "FORMAT", "FORWARD", "FREEZE", "FROM", "FS", "_FSYNC", "FULL", "FULLTEXT", "FUNCTION", "FUNCTIONS", "GC", "GCS", "GET_FORMAT", "_GC", "_GCX", "GENERATE", "GEOGRAPHY", "GEOGRAPHYPOINT", "GEOMETRY", "GEOMETRYPOINT", "GLOBAL", "_GLOBAL_VERSION_TIMESTAMP", "GRANT", "GRANTED", "GRANTS", "GROUP", "GROUPING", "GROUPS", "GZIP", "HANDLE", "HANDLER", "HARD_CPU_LIMIT_PERCENTAGE", "HASH", "HAS_TEMP_TABLES", "HAVING", "HDFS", "HEADER", "HEARTBEAT_NO_LOGGING", "HIGH_PRIORITY", "HISTOGRAM", "HOLD", "HOLDING", "HOST", "HOSTS", "HOUR", "HOUR_MICROSECOND", "HOUR_MINUTE", "HOUR_SECOND", "IDENTIFIED", "IDENTITY", "IF", "IGNORE", "ILIKE", "IMMEDIATE", "IMMUTABLE", "IMPLICIT", "IMPORT", "IN", "INCLUDING", "INCREMENT", "INCREMENTAL", "INDEX", "INDEXES", "INFILE", "INHERIT", "INHERITS", "_INIT_PROFILE", "INIT", "INITIALIZE", "INITIALLY", "INJECT", "INLINE", "INNER", "INOUT", "INPUT", "INSENSITIVE", "INSERT", "INSERT_METHOD", "INSTANCE", "INSTEAD", "IN", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "_INTERNAL_DYNAMIC_TYPECAST", "INTERPRETER_MODE", "INTERSECT", "INTERVAL", "INTO", "INVOKER", "ISOLATION", "ITERATE", "JOIN", "JSON", "KAFKA", "KEY", "KEY_BLOCK_SIZE", "KEYS", "KILL", "KILLALL", "LABEL", "LAG", "LANGUAGE", "LARGE", "LAST", "LAST_VALUE", "LATERAL", "LATEST", "LC_COLLATE", "LC_CTYPE", "LEAD", "LEADING", "LEAF", "LEAKPROOF", "LEAVE", "LEAVES", "LEFT", "LEVEL", "LICENSE", "LIKE", "LIMIT", "LINES", "LISTEN", "LLVM", "LOADDATA_WHERE", "LOAD", "LOCAL", "LOCALTIME", "LOCALTIMESTAMP", "LOCATION", "LOCK", "LONG", "LONGBLOB", "LONGTEXT", "LOOP", "LOW_PRIORITY", "_LS", "LZ4", "MANAGEMENT", "_MANAGEMENT_THREAD", "MAPPING", "MASTER", "MATCH", "MATERIALIZED", "MAXVALUE", "MAX_CONCURRENCY", "MAX_ERRORS", "MAX_PARTITIONS_PER_BATCH", "MAX_QUEUE_DEPTH", "MAX_RETRIES_PER_BATCH_PARTITION", "MAX_ROWS", "MBC", "MPL", "MEDIUMBLOB", "MEDIUMINT", "MEDIUMTEXT", "MEMBER", "MEMORY", "MEMORY_PERCENTAGE", "_MEMSQL_TABLE_ID_LOOKUP", "MEMSQL", "MEMSQL_DESERIALIZE", "MEMSQL_IMITATING_KAFKA", "MEMSQL_SERIALIZE", "MERGE", "METADATA", "MICROSECOND", "MIDDLEINT", "MIN_ROWS", "MINUS", "MINUTE_MICROSECOND", "MINUTE_SECOND", "MINVALUE", "MOD", "MODE", "MODEL", "MODIFIES", "MODIFY", "MONTH", "MOVE", "MPL", "NAMES", "NAMED", "NAMESPACE", "NATIONAL", "NATURAL", "NCHAR", "NEXT", "NO", "NODE", "NONE", "NO_QUERY_REWRITE", "NOPARAM", "NOT", "NOTHING", "NOTIFY", "NOWAIT", "NO_WRITE_TO_BINLOG", "NO_QUERY_REWRITE", "NORELY", "NTH_VALUE", "NTILE", "NULL", "NULLCOLS", "NULLS", "NUMERIC", "NVARCHAR", "OBJECT", "OF", "OFF", "OFFLINE", "OFFSET", "OFFSETS", "OIDS", "ON", "ONLINE", "ONLY", "OPEN", "OPERATOR", "OPTIMIZATION", "OPTIMIZE", "OPTIMIZER", "OPTIMIZER_STATE", "OPTION", "OPTIONS", "OPTIONALLY", "OR", "ORDER", "ORDERED_SERIALIZE", "ORPHAN", "OUT", "OUT_OF_ORDER", "OUTER", "OUTFILE", "OVER", "OVERLAPS", "OVERLAY", "OWNED", "OWNER", "PACK_KEYS", "PAIRED", "PARSER", "PARQUET", "PARTIAL", "PARTITION", "PARTITION_ID", "PARTITIONING", "PARTITIONS", "PASSING", "PASSWORD", "PASSWORD_LOCK_TIME", "PAUSE", "_PAUSE_REPLAY", "PERIODIC", "PERSISTED", "PIPELINE", "PIPELINES", "PLACING", "PLAN", "PLANS", "PLANCACHE", "PLUGINS", "POOL", "POOLS", "PORT", "PRECEDING", "PRECISION", "PREPARE", "PRESERVE", "PRIMARY", "PRIOR", "PRIVILEGES", "PROCEDURAL", "PROCEDURE", "PROCEDURES", "PROCESS", "PROCESSLIST", "PROFILE", "PROFILES", "PROGRAM", "PROMOTE", "PROXY", "PURGE", "QUARTER", "QUERIES", "QUERY", "QUERY_TIMEOUT", "QUEUE", "RANGE", "RANK", "READ", "_READ", "READS", "REAL", "REASSIGN", "REBALANCE", "RECHECK", "RECORD", "RECURSIVE", "REDUNDANCY", "REDUNDANT", "REF", "REFERENCE", "REFERENCES", "REFRESH", "REGEXP", "REINDEX", "RELATIVE", "RELEASE", "RELOAD", "RELY", "REMOTE", "REMOVE", "RENAME", "REPAIR", "_REPAIR_TABLE", "REPEAT", "REPEATABLE", "_REPL", "_REPROVISIONING", "REPLACE", "REPLICA", "REPLICATE", "REPLICATING", "REPLICATION", "REQUIRE", "RESOURCE", "RESOURCE_POOL", "RESET", "RESTART", "RESTORE", "RESTRICT", "RESULT", "_RESURRECT", "RETRY", "RETURN", "RETURNING", "RETURNS", "REVERSE", "RG_POOL", "REVOKE", "RIGHT", "RIGHT_ANTI_JOIN", "RIGHT_SEMI_JOIN", "RIGHT_STRAIGHT_JOIN", "RLIKE", "ROLES", "ROLLBACK", "ROLLUP", "ROUTINE", "ROW", "ROW_COUNT", "ROW_FORMAT", "ROW_NUMBER", "ROWS", "ROWSTORE", "RULE", "_RPC", "RUNNING", "S3", "SAFE", "SAVE", "SAVEPOINT", "SCALAR", "SCHEMA", "SCHEMAS", "SCHEMA_BINDING", "SCROLL", "SEARCH", "SECOND", "SECOND_MICROSECOND", "SECURITY", "SELECT", "SEMI_JOIN", "_SEND_THREADS", "SENSITIVE", "SEPARATOR", "SEQUENCE", "SEQUENCES", "SERIAL", "SERIALIZABLE", "SERIES", "SERVICE_USER", "SERVER", "SESSION", "SESSION_USER", "SET", "SETOF", "SECURITY_LISTS_INTERSECT", "SHA", "SHARD", "SHARDED", "SHARDED_ID", "SHARE", "SHOW", "SHUTDOWN", "SIGNAL", "SIGNED", "SIMILAR", "SIMPLE", "SITE", "SKIP", "SKIPPED_BATCHES", "__SLEEP", "SMALLINT", "SNAPSHOT", "_SNAPSHOT", "_SNAPSHOTS", "SOFT_CPU_LIMIT_PERCENTAGE", "SOME", "SONAME", "SPARSE", "SPATIAL", "SPATIAL_CHECK_INDEX", "SPECIFIC", "SQL", "SQL_BIG_RESULT", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_CALC_FOUND_ROWS", "SQLEXCEPTION", "SQL_MODE", "SQL_NO_CACHE", "SQL_NO_LOGGING", "SQL_SMALL_RESULT", "SQLSTATE", "SQLWARNING", "STDIN", "STDOUT", "STOP", "STORAGE", "STRAIGHT_JOIN", "STRICT", "STRING", "STRIP", "SUCCESS", "SUPER", "SYMMETRIC", "SYNC_SNAPSHOT", "SYNC", "_SYNC", "_SYNC2", "_SYNC_PARTITIONS", "_SYNC_SNAPSHOT", "SYNCHRONIZE", "SYSID", "SYSTEM", "TABLE", "TABLE_CHECKSUM", "TABLES", "TABLESPACE", "TAGS", "TARGET_SIZE", "TASK", "TEMP", "TEMPLATE", "TEMPORARY", "TEMPTABLE", "_TERM_BUMP", "TERMINATE", "TERMINATED", "TEXT", "THEN", "TIME", "TIMEOUT", "TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIMEZONE", "TINYBLOB", "TINYINT", "TINYTEXT", "TO", "TRACELOGS", "TRADITIONAL", "TRAILING", "TRANSFORM", "TRANSACTION", "_TRANSACTIONS_EXPERIMENTAL", "TREAT", "TRIGGER", "TRIGGERS", "TRUE", "TRUNC", "TRUNCATE", "TRUSTED", "TWO_PHASE", "_TWOPCID", "TYPE", "TYPES", "UNBOUNDED", "UNCOMMITTED", "UNDEFINED", "UNDO", "UNENCRYPTED", "UNENFORCED", "UNHOLD", "UNICODE", "UNION", "UNIQUE", "_UNITTEST", "UNKNOWN", "UNLISTEN", "_UNLOAD", "UNLOCK", "UNLOGGED", "UNPIVOT", "UNSIGNED", "UNTIL", "UPDATE", "UPGRADE", "USAGE", "USE", "USER", "USERS", "USING", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "_UTF8", "VACUUM", "VALID", "VALIDATE", "VALIDATOR", "VALUE", "VALUES", "VARBINARY", "VARCHAR", "VARCHARACTER", "VARIABLES", "VARIADIC", "VARYING", "VERBOSE", "VIEW", "VOID", "VOLATILE", "VOTING", "WAIT", "_WAKE", "WARNINGS", "WEEK", "WHEN", "WHERE", "WHILE", "WHITESPACE", "WINDOW", "WITH", "WITHOUT", "WITHIN", "_WM_HEARTBEAT", "WORK", "WORKLOAD", "WRAPPER", "WRITE", "XACT_ID", "XOR", "YEAR", "YEAR_MONTH", "YES", "ZEROFILL", "ZONE"]
}), HX = Ne({
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/vector-functions/vector-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/window-functions/window-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/string-functions/string-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/conditional-functions/conditional-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/numeric-functions/numeric-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/geospatial-functions/geospatial-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/json-functions/json-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/information-functions/information-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/aggregate-functions/aggregate-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/time-series-functions/time-series-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/identifier-generation-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/date-and-time-functions/date-and-time-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/distinct-count-estimation-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/full-text-search-functions/full-text-search-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/regular-expression-functions.html
  all: [
    "ABS",
    "ACOS",
    "ADDDATE",
    "ADDTIME",
    "AES_DECRYPT",
    "AES_ENCRYPT",
    "ANY_VALUE",
    "APPROX_COUNT_DISTINCT",
    "APPROX_COUNT_DISTINCT_ACCUMULATE",
    "APPROX_COUNT_DISTINCT_COMBINE",
    "APPROX_COUNT_DISTINCT_ESTIMATE",
    "APPROX_GEOGRAPHY_INTERSECTS",
    "APPROX_PERCENTILE",
    "ASCII",
    "ASIN",
    "ATAN",
    "ATAN2",
    "AVG",
    "BIN",
    "BINARY",
    "BIT_AND",
    "BIT_COUNT",
    "BIT_OR",
    "BIT_XOR",
    "CAST",
    "CEIL",
    "CEILING",
    "CHAR",
    "CHARACTER_LENGTH",
    "CHAR_LENGTH",
    "CHARSET",
    "COALESCE",
    "COERCIBILITY",
    "COLLATION",
    "COLLECT",
    "CONCAT",
    "CONCAT_WS",
    "CONNECTION_ID",
    "CONV",
    "CONVERT",
    "CONVERT_TZ",
    "COS",
    "COT",
    "COUNT",
    "CUME_DIST",
    "CURDATE",
    "CURRENT_DATE",
    "CURRENT_ROLE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "CURTIME",
    "DATABASE",
    "DATE",
    "DATE_ADD",
    "DATEDIFF",
    "DATE_FORMAT",
    "DATE_SUB",
    "DATE_TRUNC",
    "DAY",
    "DAYNAME",
    "DAYOFMONTH",
    "DAYOFWEEK",
    "DAYOFYEAR",
    "DECODE",
    "DEFAULT",
    "DEGREES",
    "DENSE_RANK",
    "DIV",
    "DOT_PRODUCT",
    "ELT",
    "EUCLIDEAN_DISTANCE",
    "EXP",
    "EXTRACT",
    "FIELD",
    "FIRST",
    "FIRST_VALUE",
    "FLOOR",
    "FORMAT",
    "FOUND_ROWS",
    "FROM_BASE64",
    "FROM_DAYS",
    "FROM_UNIXTIME",
    "GEOGRAPHY_AREA",
    "GEOGRAPHY_CONTAINS",
    "GEOGRAPHY_DISTANCE",
    "GEOGRAPHY_INTERSECTS",
    "GEOGRAPHY_LATITUDE",
    "GEOGRAPHY_LENGTH",
    "GEOGRAPHY_LONGITUDE",
    "GEOGRAPHY_POINT",
    "GEOGRAPHY_WITHIN_DISTANCE",
    "GEOMETRY_AREA",
    "GEOMETRY_CONTAINS",
    "GEOMETRY_DISTANCE",
    "GEOMETRY_FILTER",
    "GEOMETRY_INTERSECTS",
    "GEOMETRY_LENGTH",
    "GEOMETRY_POINT",
    "GEOMETRY_WITHIN_DISTANCE",
    "GEOMETRY_X",
    "GEOMETRY_Y",
    "GREATEST",
    "GROUPING",
    "GROUP_CONCAT",
    "HEX",
    "HIGHLIGHT",
    "HOUR",
    "ICU_VERSION",
    "IF",
    "IFNULL",
    "INET_ATON",
    "INET_NTOA",
    "INET6_ATON",
    "INET6_NTOA",
    "INITCAP",
    "INSERT",
    "INSTR",
    "INTERVAL",
    "IS",
    "IS NULL",
    "JSON_AGG",
    "JSON_ARRAY_CONTAINS_DOUBLE",
    "JSON_ARRAY_CONTAINS_JSON",
    "JSON_ARRAY_CONTAINS_STRING",
    "JSON_ARRAY_PUSH_DOUBLE",
    "JSON_ARRAY_PUSH_JSON",
    "JSON_ARRAY_PUSH_STRING",
    "JSON_DELETE_KEY",
    "JSON_EXTRACT_DOUBLE",
    "JSON_EXTRACT_JSON",
    "JSON_EXTRACT_STRING",
    "JSON_EXTRACT_BIGINT",
    "JSON_GET_TYPE",
    "JSON_LENGTH",
    "JSON_SET_DOUBLE",
    "JSON_SET_JSON",
    "JSON_SET_STRING",
    "JSON_SPLICE_DOUBLE",
    "JSON_SPLICE_JSON",
    "JSON_SPLICE_STRING",
    "LAG",
    "LAST_DAY",
    "LAST_VALUE",
    "LCASE",
    "LEAD",
    "LEAST",
    "LEFT",
    "LENGTH",
    "LIKE",
    "LN",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG2",
    "LPAD",
    "LTRIM",
    "MATCH",
    "MAX",
    "MD5",
    "MEDIAN",
    "MICROSECOND",
    "MIN",
    "MINUTE",
    "MOD",
    "MONTH",
    "MONTHNAME",
    "MONTHS_BETWEEN",
    "NOT",
    "NOW",
    "NTH_VALUE",
    "NTILE",
    "NULLIF",
    "OCTET_LENGTH",
    "PERCENT_RANK",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC",
    "PI",
    "PIVOT",
    "POSITION",
    "POW",
    "POWER",
    "QUARTER",
    "QUOTE",
    "RADIANS",
    "RAND",
    "RANK",
    "REGEXP",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "RIGHT",
    "RLIKE",
    "ROUND",
    "ROW_COUNT",
    "ROW_NUMBER",
    "RPAD",
    "RTRIM",
    "SCALAR",
    "SCHEMA",
    "SEC_TO_TIME",
    "SHA1",
    "SHA2",
    "SIGMOID",
    "SIGN",
    "SIN",
    "SLEEP",
    "SPLIT",
    "SOUNDEX",
    "SOUNDS LIKE",
    "SOURCE_POS_WAIT",
    "SPACE",
    "SQRT",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STR_TO_DATE",
    "SUBDATE",
    "SUBSTR",
    "SUBSTRING",
    "SUBSTRING_INDEX",
    "SUM",
    "SYS_GUID",
    "TAN",
    "TIME",
    "TIMEDIFF",
    "TIME_BUCKET",
    "TIME_FORMAT",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TIME_TO_SEC",
    "TO_BASE64",
    "TO_CHAR",
    "TO_DAYS",
    "TO_JSON",
    "TO_NUMBER",
    "TO_SECONDS",
    "TO_TIMESTAMP",
    "TRIM",
    "TRUNC",
    "TRUNCATE",
    "UCASE",
    "UNHEX",
    "UNIX_TIMESTAMP",
    "UPDATEXML",
    "UPPER",
    "USER",
    "UTC_DATE",
    "UTC_TIME",
    "UTC_TIMESTAMP",
    "UUID",
    "VALUES",
    "VARIANCE",
    "VAR_POP",
    "VAR_SAMP",
    "VECTOR_SUB",
    "VERSION",
    "WEEK",
    "WEEKDAY",
    "WEEKOFYEAR",
    "YEAR",
    // Data types with parameters
    // https://docs.singlestore.com/managed-service/en/reference/sql-reference/data-types.html
    "BIT",
    "TINYINT",
    "SMALLINT",
    "MEDIUMINT",
    "INT",
    "INTEGER",
    "BIGINT",
    "DECIMAL",
    "DEC",
    "NUMERIC",
    "FIXED",
    "FLOAT",
    "DOUBLE",
    "DOUBLE PRECISION",
    "REAL",
    "DATETIME",
    "TIMESTAMP",
    "TIME",
    "YEAR",
    "CHAR",
    "NATIONAL CHAR",
    "VARCHAR",
    "NATIONAL VARCHAR",
    "BINARY",
    "VARBINARY",
    "BLOB",
    "TEXT",
    "ENUM"
  ]
}), XX = V(["SELECT [ALL | DISTINCT | DISTINCTROW]"]), YX = V([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [IGNORE] [INTO]",
  "VALUES",
  "REPLACE [INTO]",
  // - update:
  "SET",
  // Data definition
  "CREATE VIEW",
  "CREATE [ROWSTORE] [REFERENCE | TEMPORARY | GLOBAL TEMPORARY] TABLE [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [TEMPORARY] PROCEDURE [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [EXTERNAL] FUNCTION"
]), sT = V([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER [ONLINE] TABLE",
  "ADD [COLUMN]",
  "ADD [UNIQUE] {INDEX | KEY}",
  "DROP [COLUMN]",
  "MODIFY [COLUMN]",
  "CHANGE",
  "RENAME [TO | AS]",
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference.html
  "ADD AGGREGATOR",
  "ADD LEAF",
  "AGGREGATOR SET AS MASTER",
  "ALTER DATABASE",
  "ALTER PIPELINE",
  "ALTER RESOURCE POOL",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE TABLE",
  "ATTACH DATABASE",
  "ATTACH LEAF",
  "ATTACH LEAF ALL",
  "BACKUP DATABASE",
  "BINLOG",
  "BOOTSTRAP AGGREGATOR",
  "CACHE INDEX",
  "CALL",
  "CHANGE",
  "CHANGE MASTER TO",
  "CHANGE REPLICATION FILTER",
  "CHANGE REPLICATION SOURCE TO",
  "CHECK BLOB CHECKSUM",
  "CHECK TABLE",
  "CHECKSUM TABLE",
  "CLEAR ORPHAN DATABASES",
  "CLONE",
  "COMMIT",
  "CREATE DATABASE",
  "CREATE GROUP",
  "CREATE INDEX",
  "CREATE LINK",
  "CREATE MILESTONE",
  "CREATE PIPELINE",
  "CREATE RESOURCE POOL",
  "CREATE ROLE",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DETACH DATABASE",
  "DETACH PIPELINE",
  "DROP DATABASE",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP LINK",
  "DROP PIPELINE",
  "DROP PROCEDURE",
  "DROP RESOURCE POOL",
  "DROP ROLE",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "FORCE",
  "GRANT",
  "HANDLER",
  "HELP",
  "KILL CONNECTION",
  "KILLALL QUERIES",
  "LOAD DATA",
  "LOAD INDEX INTO CACHE",
  "LOAD XML",
  "LOCK INSTANCE FOR BACKUP",
  "LOCK TABLES",
  "MASTER_POS_WAIT",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "REBALANCE PARTITIONS",
  "RELEASE SAVEPOINT",
  "REMOVE AGGREGATOR",
  "REMOVE LEAF",
  "REPAIR TABLE",
  "REPLACE",
  "REPLICATE DATABASE",
  "RESET",
  "RESET MASTER",
  "RESET PERSIST",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESTART",
  "RESTORE DATABASE",
  "RESTORE REDUNDANCY",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET NAMES",
  "SET PASSWORD",
  "SET RESOURCE GROUP",
  "SET ROLE",
  "SET TRANSACTION",
  "SHOW",
  "SHOW CHARACTER SET",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PIPELINE",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE TABLE",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PLUGINS",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA STATUS",
  "SHOW REPLICAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW STATUS",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHUTDOWN",
  "SNAPSHOT DATABASE",
  "SOURCE_POS_WAIT",
  "START GROUP_REPLICATION",
  "START PIPELINE",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP GROUP_REPLICATION",
  "STOP PIPELINE",
  "STOP REPLICA",
  "STOP REPLICATING",
  "STOP SLAVE",
  "TEST PIPELINE",
  "UNLOCK INSTANCE",
  "UNLOCK TABLES",
  "USE",
  "XA",
  // flow control
  "ITERATE",
  "LEAVE",
  "LOOP",
  "REPEAT",
  "RETURN",
  "WHILE"
]), BX = V(["UNION [ALL | DISTINCT]", "EXCEPT", "INTERSECT", "MINUS"]), FX = V([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]), WX = V(["ON DELETE", "ON UPDATE", "CHARACTER SET", "{ROWS | RANGE} BETWEEN"]), zX = {
  tokenizerOptions: {
    reservedSelect: XX,
    reservedClauses: [...YX, ...sT],
    reservedSetOperations: BX,
    reservedJoins: FX,
    reservedPhrases: WX,
    reservedKeywords: VX,
    reservedFunctionNames: HX,
    // TODO: support _binary"some string" prefix
    stringTypes: ['""-qq-bs', "''-qq-bs", {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    identChars: {
      first: "$",
      rest: "$",
      allowFirstCharNumber: !0
    },
    variableTypes: [{
      regex: "@@?[A-Za-z0-9_$]+"
    }, {
      quote: "``",
      prefixes: ["@"],
      requirePrefix: !0
    }],
    lineCommentTypes: ["--", "#"],
    operators: [":=", "&", "|", "^", "~", "<<", ">>", "<=>", "&&", "||", "::", "::$", "::%", ":>", "!:>"],
    postProcess: ZX
  },
  formatOptions: {
    alwaysDenseOperators: ["::", "::$", "::%"],
    onelineClauses: sT
  }
};
function ZX(i) {
  return i.map((e, t) => {
    const r = i[t + 1] || rs;
    return Ro.SET(e) && r.text === "(" ? {
      ...e,
      type: k.RESERVED_FUNCTION_NAME
    } : e;
  });
}
const qX = Ne({
  // https://docs.snowflake.com/en/sql-reference-functions.html
  //
  // https://docs.snowflake.com/en/sql-reference/functions-all.html
  // 1. run in console on this page: $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue)
  // 2. split all lines that contain ',' or '/' into multiple lines
  // 3. remove all '— Deprecated' parts from the strings
  // 4. delete all strings that end with '<object_type>', they are already covered in the list
  // 5. remove all strings that contain '[', they are operators not functions
  // 6. fix all values that contain '*'
  // 7. delete operatos ':', '::', '||'
  //
  // Steps 1-5 can be combined by the following script in the developer console:
  // $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue) // Step 1
  //   .map(x => x.split(x.includes(',') ? ',' : '/')).flat().map(x => x.trim()) // Step 2
  //   .map(x => x.replace('— Deprecated', '')) // Step 3
  //   .filter(x => !x.endsWith('<object_type>')) // Step 4
  //   .filter(x => !x.includes('[')) // Step 5
  all: ["ABS", "ACOS", "ACOSH", "ADD_MONTHS", "ALL_USER_NAMES", "ANY_VALUE", "APPROX_COUNT_DISTINCT", "APPROX_PERCENTILE", "APPROX_PERCENTILE_ACCUMULATE", "APPROX_PERCENTILE_COMBINE", "APPROX_PERCENTILE_ESTIMATE", "APPROX_TOP_K", "APPROX_TOP_K_ACCUMULATE", "APPROX_TOP_K_COMBINE", "APPROX_TOP_K_ESTIMATE", "APPROXIMATE_JACCARD_INDEX", "APPROXIMATE_SIMILARITY", "ARRAY_AGG", "ARRAY_APPEND", "ARRAY_CAT", "ARRAY_COMPACT", "ARRAY_CONSTRUCT", "ARRAY_CONSTRUCT_COMPACT", "ARRAY_CONTAINS", "ARRAY_INSERT", "ARRAY_INTERSECTION", "ARRAY_POSITION", "ARRAY_PREPEND", "ARRAY_SIZE", "ARRAY_SLICE", "ARRAY_TO_STRING", "ARRAY_UNION_AGG", "ARRAY_UNIQUE_AGG", "ARRAYS_OVERLAP", "AS_ARRAY", "AS_BINARY", "AS_BOOLEAN", "AS_CHAR", "AS_VARCHAR", "AS_DATE", "AS_DECIMAL", "AS_NUMBER", "AS_DOUBLE", "AS_REAL", "AS_INTEGER", "AS_OBJECT", "AS_TIME", "AS_TIMESTAMP_LTZ", "AS_TIMESTAMP_NTZ", "AS_TIMESTAMP_TZ", "ASCII", "ASIN", "ASINH", "ATAN", "ATAN2", "ATANH", "AUTO_REFRESH_REGISTRATION_HISTORY", "AUTOMATIC_CLUSTERING_HISTORY", "AVG", "BASE64_DECODE_BINARY", "BASE64_DECODE_STRING", "BASE64_ENCODE", "BIT_LENGTH", "BITAND", "BITAND_AGG", "BITMAP_BIT_POSITION", "BITMAP_BUCKET_NUMBER", "BITMAP_CONSTRUCT_AGG", "BITMAP_COUNT", "BITMAP_OR_AGG", "BITNOT", "BITOR", "BITOR_AGG", "BITSHIFTLEFT", "BITSHIFTRIGHT", "BITXOR", "BITXOR_AGG", "BOOLAND", "BOOLAND_AGG", "BOOLNOT", "BOOLOR", "BOOLOR_AGG", "BOOLXOR", "BOOLXOR_AGG", "BUILD_SCOPED_FILE_URL", "BUILD_STAGE_FILE_URL", "CASE", "CAST", "CBRT", "CEIL", "CHARINDEX", "CHECK_JSON", "CHECK_XML", "CHR", "CHAR", "COALESCE", "COLLATE", "COLLATION", "COMPLETE_TASK_GRAPHS", "COMPRESS", "CONCAT", "CONCAT_WS", "CONDITIONAL_CHANGE_EVENT", "CONDITIONAL_TRUE_EVENT", "CONTAINS", "CONVERT_TIMEZONE", "COPY_HISTORY", "CORR", "COS", "COSH", "COT", "COUNT", "COUNT_IF", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "CURRENT_ACCOUNT", "CURRENT_AVAILABLE_ROLES", "CURRENT_CLIENT", "CURRENT_DATABASE", "CURRENT_DATE", "CURRENT_IP_ADDRESS", "CURRENT_REGION", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_SECONDARY_ROLES", "CURRENT_SESSION", "CURRENT_STATEMENT", "CURRENT_TASK_GRAPHS", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_TRANSACTION", "CURRENT_USER", "CURRENT_VERSION", "CURRENT_WAREHOUSE", "DATA_TRANSFER_HISTORY", "DATABASE_REFRESH_HISTORY", "DATABASE_REFRESH_PROGRESS", "DATABASE_REFRESH_PROGRESS_BY_JOB", "DATABASE_STORAGE_USAGE_HISTORY", "DATE_FROM_PARTS", "DATE_PART", "DATE_TRUNC", "DATEADD", "DATEDIFF", "DAYNAME", "DECODE", "DECOMPRESS_BINARY", "DECOMPRESS_STRING", "DECRYPT", "DECRYPT_RAW", "DEGREES", "DENSE_RANK", "DIV0", "EDITDISTANCE", "ENCRYPT", "ENCRYPT_RAW", "ENDSWITH", "EQUAL_NULL", "EXP", "EXPLAIN_JSON", "EXTERNAL_FUNCTIONS_HISTORY", "EXTERNAL_TABLE_FILES", "EXTERNAL_TABLE_FILE_REGISTRATION_HISTORY", "EXTRACT", "EXTRACT_SEMANTIC_CATEGORIES", "FACTORIAL", "FIRST_VALUE", "FLATTEN", "FLOOR", "GENERATE_COLUMN_DESCRIPTION", "GENERATOR", "GET", "GET_ABSOLUTE_PATH", "GET_DDL", "GET_IGNORE_CASE", "GET_OBJECT_REFERENCES", "GET_PATH", "GET_PRESIGNED_URL", "GET_RELATIVE_PATH", "GET_STAGE_LOCATION", "GETBIT", "GREATEST", "GROUPING", "GROUPING_ID", "HASH", "HASH_AGG", "HAVERSINE", "HEX_DECODE_BINARY", "HEX_DECODE_STRING", "HEX_ENCODE", "HLL", "HLL_ACCUMULATE", "HLL_COMBINE", "HLL_ESTIMATE", "HLL_EXPORT", "HLL_IMPORT", "HOUR", "MINUTE", "SECOND", "IFF", "IFNULL", "ILIKE", "ILIKE ANY", "INFER_SCHEMA", "INITCAP", "INSERT", "INVOKER_ROLE", "INVOKER_SHARE", "IS_ARRAY", "IS_BINARY", "IS_BOOLEAN", "IS_CHAR", "IS_VARCHAR", "IS_DATE", "IS_DATE_VALUE", "IS_DECIMAL", "IS_DOUBLE", "IS_REAL", "IS_GRANTED_TO_INVOKER_ROLE", "IS_INTEGER", "IS_NULL_VALUE", "IS_OBJECT", "IS_ROLE_IN_SESSION", "IS_TIME", "IS_TIMESTAMP_LTZ", "IS_TIMESTAMP_NTZ", "IS_TIMESTAMP_TZ", "JAROWINKLER_SIMILARITY", "JSON_EXTRACT_PATH_TEXT", "KURTOSIS", "LAG", "LAST_DAY", "LAST_QUERY_ID", "LAST_TRANSACTION", "LAST_VALUE", "LEAD", "LEAST", "LEFT", "LENGTH", "LEN", "LIKE", "LIKE ALL", "LIKE ANY", "LISTAGG", "LN", "LOCALTIME", "LOCALTIMESTAMP", "LOG", "LOGIN_HISTORY", "LOGIN_HISTORY_BY_USER", "LOWER", "LPAD", "LTRIM", "MATERIALIZED_VIEW_REFRESH_HISTORY", "MD5", "MD5_HEX", "MD5_BINARY", "MD5_NUMBER — Obsoleted", "MD5_NUMBER_LOWER64", "MD5_NUMBER_UPPER64", "MEDIAN", "MIN", "MAX", "MINHASH", "MINHASH_COMBINE", "MOD", "MODE", "MONTHNAME", "MONTHS_BETWEEN", "NEXT_DAY", "NORMAL", "NTH_VALUE", "NTILE", "NULLIF", "NULLIFZERO", "NVL", "NVL2", "OBJECT_AGG", "OBJECT_CONSTRUCT", "OBJECT_CONSTRUCT_KEEP_NULL", "OBJECT_DELETE", "OBJECT_INSERT", "OBJECT_KEYS", "OBJECT_PICK", "OCTET_LENGTH", "PARSE_IP", "PARSE_JSON", "PARSE_URL", "PARSE_XML", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "PI", "PIPE_USAGE_HISTORY", "POLICY_CONTEXT", "POLICY_REFERENCES", "POSITION", "POW", "POWER", "PREVIOUS_DAY", "QUERY_ACCELERATION_HISTORY", "QUERY_HISTORY", "QUERY_HISTORY_BY_SESSION", "QUERY_HISTORY_BY_USER", "QUERY_HISTORY_BY_WAREHOUSE", "RADIANS", "RANDOM", "RANDSTR", "RANK", "RATIO_TO_REPORT", "REGEXP", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_LIKE", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REGEXP_SUBSTR_ALL", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "REGR_VALX", "REGR_VALY", "REPEAT", "REPLACE", "REPLICATION_GROUP_REFRESH_HISTORY", "REPLICATION_GROUP_REFRESH_PROGRESS", "REPLICATION_GROUP_REFRESH_PROGRESS_BY_JOB", "REPLICATION_GROUP_USAGE_HISTORY", "REPLICATION_USAGE_HISTORY", "REST_EVENT_HISTORY", "RESULT_SCAN", "REVERSE", "RIGHT", "RLIKE", "ROUND", "ROW_NUMBER", "RPAD", "RTRIM", "RTRIMMED_LENGTH", "SEARCH_OPTIMIZATION_HISTORY", "SEQ1", "SEQ2", "SEQ4", "SEQ8", "SERVERLESS_TASK_HISTORY", "SHA1", "SHA1_HEX", "SHA1_BINARY", "SHA2", "SHA2_HEX", "SHA2_BINARY", "SIGN", "SIN", "SINH", "SKEW", "SOUNDEX", "SPACE", "SPLIT", "SPLIT_PART", "SPLIT_TO_TABLE", "SQRT", "SQUARE", "ST_AREA", "ST_ASEWKB", "ST_ASEWKT", "ST_ASGEOJSON", "ST_ASWKB", "ST_ASBINARY", "ST_ASWKT", "ST_ASTEXT", "ST_AZIMUTH", "ST_CENTROID", "ST_COLLECT", "ST_CONTAINS", "ST_COVEREDBY", "ST_COVERS", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_DWITHIN", "ST_ENDPOINT", "ST_ENVELOPE", "ST_GEOGFROMGEOHASH", "ST_GEOGPOINTFROMGEOHASH", "ST_GEOGRAPHYFROMWKB", "ST_GEOGRAPHYFROMWKT", "ST_GEOHASH", "ST_GEOMETRYFROMWKB", "ST_GEOMETRYFROMWKT", "ST_HAUSDORFFDISTANCE", "ST_INTERSECTION", "ST_INTERSECTS", "ST_LENGTH", "ST_MAKEGEOMPOINT", "ST_GEOM_POINT", "ST_MAKELINE", "ST_MAKEPOINT", "ST_POINT", "ST_MAKEPOLYGON", "ST_POLYGON", "ST_NPOINTS", "ST_NUMPOINTS", "ST_PERIMETER", "ST_POINTN", "ST_SETSRID", "ST_SIMPLIFY", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_UNION", "ST_WITHIN", "ST_X", "ST_XMAX", "ST_XMIN", "ST_Y", "ST_YMAX", "ST_YMIN", "STAGE_DIRECTORY_FILE_REGISTRATION_HISTORY", "STAGE_STORAGE_USAGE_HISTORY", "STARTSWITH", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STRIP_NULL_VALUE", "STRTOK", "STRTOK_SPLIT_TO_TABLE", "STRTOK_TO_ARRAY", "SUBSTR", "SUBSTRING", "SUM", "SYSDATE", "SYSTEM$ABORT_SESSION", "SYSTEM$ABORT_TRANSACTION", "SYSTEM$AUTHORIZE_PRIVATELINK", "SYSTEM$AUTHORIZE_STAGE_PRIVATELINK_ACCESS", "SYSTEM$BEHAVIOR_CHANGE_BUNDLE_STATUS", "SYSTEM$CANCEL_ALL_QUERIES", "SYSTEM$CANCEL_QUERY", "SYSTEM$CLUSTERING_DEPTH", "SYSTEM$CLUSTERING_INFORMATION", "SYSTEM$CLUSTERING_RATIO ", "SYSTEM$CURRENT_USER_TASK_NAME", "SYSTEM$DATABASE_REFRESH_HISTORY ", "SYSTEM$DATABASE_REFRESH_PROGRESS", "SYSTEM$DATABASE_REFRESH_PROGRESS_BY_JOB ", "SYSTEM$DISABLE_BEHAVIOR_CHANGE_BUNDLE", "SYSTEM$DISABLE_DATABASE_REPLICATION", "SYSTEM$ENABLE_BEHAVIOR_CHANGE_BUNDLE", "SYSTEM$ESTIMATE_QUERY_ACCELERATION", "SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS", "SYSTEM$EXPLAIN_JSON_TO_TEXT", "SYSTEM$EXPLAIN_PLAN_JSON", "SYSTEM$EXTERNAL_TABLE_PIPE_STATUS", "SYSTEM$GENERATE_SAML_CSR", "SYSTEM$GENERATE_SCIM_ACCESS_TOKEN", "SYSTEM$GET_AWS_SNS_IAM_POLICY", "SYSTEM$GET_PREDECESSOR_RETURN_VALUE", "SYSTEM$GET_PRIVATELINK", "SYSTEM$GET_PRIVATELINK_AUTHORIZED_ENDPOINTS", "SYSTEM$GET_PRIVATELINK_CONFIG", "SYSTEM$GET_SNOWFLAKE_PLATFORM_INFO", "SYSTEM$GET_TAG", "SYSTEM$GET_TAG_ALLOWED_VALUES", "SYSTEM$GET_TAG_ON_CURRENT_COLUMN", "SYSTEM$GET_TAG_ON_CURRENT_TABLE", "SYSTEM$GLOBAL_ACCOUNT_SET_PARAMETER", "SYSTEM$LAST_CHANGE_COMMIT_TIME", "SYSTEM$LINK_ACCOUNT_OBJECTS_BY_NAME", "SYSTEM$MIGRATE_SAML_IDP_REGISTRATION", "SYSTEM$PIPE_FORCE_RESUME", "SYSTEM$PIPE_STATUS", "SYSTEM$REVOKE_PRIVATELINK", "SYSTEM$REVOKE_STAGE_PRIVATELINK_ACCESS", "SYSTEM$SET_RETURN_VALUE", "SYSTEM$SHOW_OAUTH_CLIENT_SECRETS", "SYSTEM$STREAM_GET_TABLE_TIMESTAMP", "SYSTEM$STREAM_HAS_DATA", "SYSTEM$TASK_DEPENDENTS_ENABLE", "SYSTEM$TYPEOF", "SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS", "SYSTEM$VERIFY_EXTERNAL_OAUTH_TOKEN", "SYSTEM$WAIT", "SYSTEM$WHITELIST", "SYSTEM$WHITELIST_PRIVATELINK", "TAG_REFERENCES", "TAG_REFERENCES_ALL_COLUMNS", "TAG_REFERENCES_WITH_LINEAGE", "TAN", "TANH", "TASK_DEPENDENTS", "TASK_HISTORY", "TIME_FROM_PARTS", "TIME_SLICE", "TIMEADD", "TIMEDIFF", "TIMESTAMP_FROM_PARTS", "TIMESTAMPADD", "TIMESTAMPDIFF", "TO_ARRAY", "TO_BINARY", "TO_BOOLEAN", "TO_CHAR", "TO_VARCHAR", "TO_DATE", "DATE", "TO_DECIMAL", "TO_NUMBER", "TO_NUMERIC", "TO_DOUBLE", "TO_GEOGRAPHY", "TO_GEOMETRY", "TO_JSON", "TO_OBJECT", "TO_TIME", "TIME", "TO_TIMESTAMP", "TO_TIMESTAMP_LTZ", "TO_TIMESTAMP_NTZ", "TO_TIMESTAMP_TZ", "TO_VARIANT", "TO_XML", "TRANSLATE", "TRIM", "TRUNCATE", "TRUNC", "TRUNC", "TRY_BASE64_DECODE_BINARY", "TRY_BASE64_DECODE_STRING", "TRY_CAST", "TRY_HEX_DECODE_BINARY", "TRY_HEX_DECODE_STRING", "TRY_PARSE_JSON", "TRY_TO_BINARY", "TRY_TO_BOOLEAN", "TRY_TO_DATE", "TRY_TO_DECIMAL", "TRY_TO_NUMBER", "TRY_TO_NUMERIC", "TRY_TO_DOUBLE", "TRY_TO_GEOGRAPHY", "TRY_TO_GEOMETRY", "TRY_TO_TIME", "TRY_TO_TIMESTAMP", "TRY_TO_TIMESTAMP_LTZ", "TRY_TO_TIMESTAMP_NTZ", "TRY_TO_TIMESTAMP_TZ", "TYPEOF", "UNICODE", "UNIFORM", "UPPER", "UUID_STRING", "VALIDATE", "VALIDATE_PIPE_LOAD", "VAR_POP", "VAR_SAMP", "VARIANCE", "VARIANCE_SAMP", "VARIANCE_POP", "WAREHOUSE_LOAD_HISTORY", "WAREHOUSE_METERING_HISTORY", "WIDTH_BUCKET", "XMLGET", "YEAR", "YEAROFWEEK", "YEAROFWEEKISO", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFWEEKISO", "DAYOFYEAR", "WEEK", "WEEK", "WEEKOFYEAR", "WEEKISO", "MONTH", "QUARTER", "ZEROIFNULL", "ZIPF"]
}), jX = Ne({
  // https://docs.snowflake.com/en/sql-reference/reserved-keywords.html
  //
  // run in console on this page: $x('//tbody/tr/*[1]/p/text()').map(x => x.nodeValue)
  all: ["ACCOUNT", "ALL", "ALTER", "AND", "ANY", "AS", "BETWEEN", "BY", "CASE", "CAST", "CHECK", "COLUMN", "CONNECT", "CONNECTION", "CONSTRAINT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "DATABASE", "DELETE", "DISTINCT", "DROP", "ELSE", "EXISTS", "FALSE", "FOLLOWING", "FOR", "FROM", "FULL", "GRANT", "GROUP", "GSCLUSTER", "HAVING", "ILIKE", "IN", "INCREMENT", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "ISSUE", "JOIN", "LATERAL", "LEFT", "LIKE", "LOCALTIME", "LOCALTIMESTAMP", "MINUS", "NATURAL", "NOT", "NULL", "OF", "ON", "OR", "ORDER", "ORGANIZATION", "QUALIFY", "REGEXP", "REVOKE", "RIGHT", "RLIKE", "ROW", "ROWS", "SAMPLE", "SCHEMA", "SELECT", "SET", "SOME", "START", "TABLE", "TABLESAMPLE", "THEN", "TO", "TRIGGER", "TRUE", "TRY_CAST", "UNION", "UNIQUE", "UPDATE", "USING", "VALUES", "VIEW", "WHEN", "WHENEVER", "WHERE", "WITH"]
}), KX = V(["SELECT [ALL | DISTINCT]"]), JX = V([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "QUALIFY",
  "LIMIT",
  "OFFSET",
  "FETCH [FIRST | NEXT]",
  // Data manipulation
  // - insert:
  "INSERT [OVERWRITE] [ALL INTO | INTO | ALL | FIRST]",
  "{THEN | ELSE} INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  // - view
  "CREATE [OR REPLACE] [SECURE] [RECURSIVE] VIEW [IF NOT EXISTS]",
  // - create/drop/merge table
  "CREATE [OR REPLACE] [VOLATILE] TABLE [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [LOCAL | GLOBAL] {TEMP|TEMPORARY} TABLE [IF NOT EXISTS]",
  "CLUSTER BY",
  "[WITH] {MASKING POLICY | TAG | ROW ACCESS POLICY}",
  "COPY GRANTS",
  "USING TEMPLATE",
  "MERGE INTO",
  "WHEN MATCHED [AND]",
  "THEN {UPDATE SET | DELETE}",
  "WHEN NOT MATCHED THEN INSERT"
]), nT = V([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "RENAME TO",
  "SWAP WITH",
  "[SUSPEND | RESUME] RECLUSTER",
  "DROP CLUSTERING KEY",
  "ADD [COLUMN]",
  "RENAME COLUMN",
  "{ALTER | MODIFY} [COLUMN]",
  "DROP [COLUMN]",
  "{ADD | ALTER | MODIFY | DROP} [CONSTRAINT]",
  "RENAME CONSTRAINT",
  "{ADD | DROP} SEARCH OPTIMIZATION",
  "{SET | UNSET} TAG",
  // Actually TAG is optional, but that conflicts with UPDATE..SET statement
  "{ADD | DROP} ROW ACCESS POLICY",
  "DROP ALL ROW ACCESS POLICIES",
  "{SET | DROP} DEFAULT",
  // for alter column
  "{SET | DROP} NOT NULL",
  // for alter column
  "[SET DATA] TYPE",
  // for alter column
  "[UNSET] COMMENT",
  // for alter column
  "{SET | UNSET} MASKING POLICY",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE] [IF EXISTS]",
  // other
  // https://docs.snowflake.com/en/sql-reference/sql-all.html
  //
  // 1. run in console on this page: $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue)
  // 2. delete all lines that contain a sting like '(.*)', they are already covered in the list
  // 3. delete all lines that contain a sting like '<.*>', they are already covered in the list
  // 4. delete all lines that contain '…', they are part of a regex statement that can't be covered here
  // 5. Manually add 'COPY INTO'
  // 6. Remove all lines that are already in `reservedClauses`
  //
  // Steps 1-4 can be combined by the following script in the developer console:
  // $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue) // Step 1
  //   filter(x => !x.match(/\(.*\)/) && !x.match(/…/) && !x.match(/<.*>/)) // Step 2-4
  "ALTER ACCOUNT",
  "ALTER API INTEGRATION",
  "ALTER CONNECTION",
  "ALTER DATABASE",
  "ALTER EXTERNAL TABLE",
  "ALTER FAILOVER GROUP",
  "ALTER FILE FORMAT",
  "ALTER FUNCTION",
  "ALTER INTEGRATION",
  "ALTER MASKING POLICY",
  "ALTER MATERIALIZED VIEW",
  "ALTER NETWORK POLICY",
  "ALTER NOTIFICATION INTEGRATION",
  "ALTER PIPE",
  "ALTER PROCEDURE",
  "ALTER REPLICATION GROUP",
  "ALTER RESOURCE MONITOR",
  "ALTER ROLE",
  "ALTER ROW ACCESS POLICY",
  "ALTER SCHEMA",
  "ALTER SECURITY INTEGRATION",
  "ALTER SEQUENCE",
  "ALTER SESSION",
  "ALTER SESSION POLICY",
  "ALTER SHARE",
  "ALTER STAGE",
  "ALTER STORAGE INTEGRATION",
  "ALTER STREAM",
  "ALTER TAG",
  "ALTER TASK",
  "ALTER USER",
  "ALTER VIEW",
  "ALTER WAREHOUSE",
  "BEGIN",
  "CALL",
  "COMMIT",
  "COPY INTO",
  "CREATE ACCOUNT",
  "CREATE API INTEGRATION",
  "CREATE CONNECTION",
  "CREATE DATABASE",
  "CREATE EXTERNAL FUNCTION",
  "CREATE EXTERNAL TABLE",
  "CREATE FAILOVER GROUP",
  "CREATE FILE FORMAT",
  "CREATE FUNCTION",
  "CREATE INTEGRATION",
  "CREATE MANAGED ACCOUNT",
  "CREATE MASKING POLICY",
  "CREATE MATERIALIZED VIEW",
  "CREATE NETWORK POLICY",
  "CREATE NOTIFICATION INTEGRATION",
  "CREATE PIPE",
  "CREATE PROCEDURE",
  "CREATE REPLICATION GROUP",
  "CREATE RESOURCE MONITOR",
  "CREATE ROLE",
  "CREATE ROW ACCESS POLICY",
  "CREATE SCHEMA",
  "CREATE SECURITY INTEGRATION",
  "CREATE SEQUENCE",
  "CREATE SESSION POLICY",
  "CREATE SHARE",
  "CREATE STAGE",
  "CREATE STORAGE INTEGRATION",
  "CREATE STREAM",
  "CREATE TAG",
  "CREATE TASK",
  "CREATE USER",
  "CREATE WAREHOUSE",
  "DELETE",
  "DESCRIBE DATABASE",
  "DESCRIBE EXTERNAL TABLE",
  "DESCRIBE FILE FORMAT",
  "DESCRIBE FUNCTION",
  "DESCRIBE INTEGRATION",
  "DESCRIBE MASKING POLICY",
  "DESCRIBE MATERIALIZED VIEW",
  "DESCRIBE NETWORK POLICY",
  "DESCRIBE PIPE",
  "DESCRIBE PROCEDURE",
  "DESCRIBE RESULT",
  "DESCRIBE ROW ACCESS POLICY",
  "DESCRIBE SCHEMA",
  "DESCRIBE SEQUENCE",
  "DESCRIBE SESSION POLICY",
  "DESCRIBE SHARE",
  "DESCRIBE STAGE",
  "DESCRIBE STREAM",
  "DESCRIBE TABLE",
  "DESCRIBE TASK",
  "DESCRIBE TRANSACTION",
  "DESCRIBE USER",
  "DESCRIBE VIEW",
  "DESCRIBE WAREHOUSE",
  "DROP CONNECTION",
  "DROP DATABASE",
  "DROP EXTERNAL TABLE",
  "DROP FAILOVER GROUP",
  "DROP FILE FORMAT",
  "DROP FUNCTION",
  "DROP INTEGRATION",
  "DROP MANAGED ACCOUNT",
  "DROP MASKING POLICY",
  "DROP MATERIALIZED VIEW",
  "DROP NETWORK POLICY",
  "DROP PIPE",
  "DROP PROCEDURE",
  "DROP REPLICATION GROUP",
  "DROP RESOURCE MONITOR",
  "DROP ROLE",
  "DROP ROW ACCESS POLICY",
  "DROP SCHEMA",
  "DROP SEQUENCE",
  "DROP SESSION POLICY",
  "DROP SHARE",
  "DROP STAGE",
  "DROP STREAM",
  "DROP TAG",
  "DROP TASK",
  "DROP USER",
  "DROP VIEW",
  "DROP WAREHOUSE",
  "EXECUTE IMMEDIATE",
  "EXECUTE TASK",
  "EXPLAIN",
  "GET",
  "GRANT OWNERSHIP",
  "GRANT ROLE",
  "INSERT",
  "LIST",
  "MERGE",
  "PUT",
  "REMOVE",
  "REVOKE ROLE",
  "ROLLBACK",
  "SHOW COLUMNS",
  "SHOW CONNECTIONS",
  "SHOW DATABASES",
  "SHOW DATABASES IN FAILOVER GROUP",
  "SHOW DATABASES IN REPLICATION GROUP",
  "SHOW DELEGATED AUTHORIZATIONS",
  "SHOW EXTERNAL FUNCTIONS",
  "SHOW EXTERNAL TABLES",
  "SHOW FAILOVER GROUPS",
  "SHOW FILE FORMATS",
  "SHOW FUNCTIONS",
  "SHOW GLOBAL ACCOUNTS",
  "SHOW GRANTS",
  "SHOW INTEGRATIONS",
  "SHOW LOCKS",
  "SHOW MANAGED ACCOUNTS",
  "SHOW MASKING POLICIES",
  "SHOW MATERIALIZED VIEWS",
  "SHOW NETWORK POLICIES",
  "SHOW OBJECTS",
  "SHOW ORGANIZATION ACCOUNTS",
  "SHOW PARAMETERS",
  "SHOW PIPES",
  "SHOW PRIMARY KEYS",
  "SHOW PROCEDURES",
  "SHOW REGIONS",
  "SHOW REPLICATION ACCOUNTS",
  "SHOW REPLICATION DATABASES",
  "SHOW REPLICATION GROUPS",
  "SHOW RESOURCE MONITORS",
  "SHOW ROLES",
  "SHOW ROW ACCESS POLICIES",
  "SHOW SCHEMAS",
  "SHOW SEQUENCES",
  "SHOW SESSION POLICIES",
  "SHOW SHARES",
  "SHOW SHARES IN FAILOVER GROUP",
  "SHOW SHARES IN REPLICATION GROUP",
  "SHOW STAGES",
  "SHOW STREAMS",
  "SHOW TABLES",
  "SHOW TAGS",
  "SHOW TASKS",
  "SHOW TRANSACTIONS",
  "SHOW USER FUNCTIONS",
  "SHOW USERS",
  "SHOW VARIABLES",
  "SHOW VIEWS",
  "SHOW WAREHOUSES",
  "TRUNCATE MATERIALIZED VIEW",
  "UNDROP DATABASE",
  "UNDROP SCHEMA",
  "UNDROP TABLE",
  "UNDROP TAG",
  "UNSET",
  "USE DATABASE",
  "USE ROLE",
  "USE SCHEMA",
  "USE SECONDARY ROLES",
  "USE WAREHOUSE"
]), eY = V(["UNION [ALL]", "MINUS", "EXCEPT", "INTERSECT"]), tY = V(["[INNER] JOIN", "[NATURAL] {LEFT | RIGHT | FULL} [OUTER] JOIN", "{CROSS | NATURAL} JOIN"]), iY = V(["{ROWS | RANGE} BETWEEN", "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]"]), rY = {
  tokenizerOptions: {
    reservedSelect: KX,
    reservedClauses: [...JX, ...nT],
    reservedSetOperations: eY,
    reservedJoins: tY,
    reservedPhrases: iY,
    reservedKeywords: jX,
    reservedFunctionNames: qX,
    stringTypes: ["$$", "''-qq-bs"],
    identTypes: ['""-qq'],
    variableTypes: [
      // for accessing columns at certain positons in the table
      {
        regex: "[$][1-9]\\d*"
      },
      // identifier style syntax
      {
        regex: "[$][_a-zA-Z][_a-zA-Z0-9$]*"
      }
    ],
    extraParens: ["[]"],
    identChars: {
      rest: "$"
    },
    lineCommentTypes: ["--", "//"],
    operators: [
      // Modulo
      "%",
      // Type cast
      "::",
      // String concat
      "||",
      // Get Path
      ":",
      // Generators: https://docs.snowflake.com/en/sql-reference/functions/generator.html#generator
      "=>"
    ]
  },
  formatOptions: {
    alwaysDenseOperators: [":", "::"],
    onelineClauses: nT
  }
}, oY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bigquery: UV,
  db2: zV,
  hive: iH,
  mariadb: hH,
  mysql: bH,
  n1ql: _H,
  plsql: UH,
  postgresql: BH,
  redshift: JH,
  singlestoredb: zX,
  snowflake: rY,
  spark: aX,
  sql: CX,
  sqlite: EX,
  transactsql: GX,
  trino: yX
}, Symbol.toStringTag, { value: "Module" })), Qi = (i) => i.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&"), aT = /\s+/uy, ms = (i) => new RegExp(`(?:${i})`, "uy"), sY = (i) => i.split("").map((e) => / /gu.test(e) ? "\\s+" : `[${e.toUpperCase()}${e.toLowerCase()}]`).join(""), nY = (i) => i + "(?:-" + i + ")*", aY = ({
  prefixes: i,
  requirePrefix: e
}) => `(?:${i.map(sY).join("|")}${e ? "" : "|"})`, lY = (i) => new RegExp(`(?:${i.map(Qi).join("|")}).*?(?=\r
|\r|
|$)`, "uy"), lT = (i, e = []) => {
  const t = i === "open" ? 0 : 1, r = ["()", ...e].map((o) => o[t]);
  return ms(r.map(Qi).join("|"));
}, uY = (i) => ms(`${VI(i).map(Qi).join("|")}`), hY = ({
  rest: i,
  dashes: e
}) => i || e ? `(?![${i || ""}${e ? "-" : ""}])` : "", Lo = (i, e = {}) => {
  if (i.length === 0)
    return /^\b$/u;
  const t = hY(e), r = VI(i).map(Qi).join("|").replace(/ /gu, "\\s+");
  return new RegExp(`(?:${r})${t}\\b`, "iuy");
}, sd = (i, e) => {
  if (!i.length)
    return;
  const t = i.map(Qi).join("|");
  return ms(`(?:${t})(?:${e})`);
}, cY = () => {
  const i = {
    "<": ">",
    "[": "]",
    "(": ")",
    "{": "}"
  }, e = "{left}(?:(?!{right}').)*?{right}", t = Object.entries(i).map(([n, a]) => e.replace(/{left}/g, Qi(n)).replace(/{right}/g, Qi(a))), r = Qi(Object.keys(i).join(""));
  return `[Qq]'(?:${String.raw`(?<tag>[^\s${r}])(?:(?!\k<tag>').)*?\k<tag>`}|${t.join("|")})'`;
}, uT = {
  // - backtick quoted (using `` to escape)
  "``": "(?:`[^`]*`)+",
  // - Transact-SQL square bracket quoted (using ]] to escape)
  "[]": String.raw`(?:\[[^\]]*\])(?:\][^\]]*\])*`,
  // double-quoted
  '""-qq': String.raw`(?:"[^"]*")+`,
  // with repeated quote escapes
  '""-bs': String.raw`(?:"[^"\\]*(?:\\.[^"\\]*)*")`,
  // with backslash escapes
  '""-qq-bs': String.raw`(?:"[^"\\]*(?:\\.[^"\\]*)*")+`,
  // with repeated quote or backslash escapes
  '""-raw': String.raw`(?:"[^"]*")`,
  // no escaping
  // single-quoted
  "''-qq": String.raw`(?:'[^']*')+`,
  // with repeated quote escapes
  "''-bs": String.raw`(?:'[^'\\]*(?:\\.[^'\\]*)*')`,
  // with backslash escapes
  "''-qq-bs": String.raw`(?:'[^'\\]*(?:\\.[^'\\]*)*')+`,
  // with repeated quote or backslash escapes
  "''-raw": String.raw`(?:'[^']*')`,
  // no escaping
  // PostgreSQL dollar-quoted
  $$: String.raw`(?<tag>\$\w*\$)[\s\S]*?\k<tag>`,
  // BigQuery '''triple-quoted''' (using \' to escape)
  "'''..'''": String.raw`'''[^\\]*?(?:\\.[^\\]*?)*?'''`,
  // BigQuery """triple-quoted""" (using \" to escape)
  '""".."""': String.raw`"""[^\\]*?(?:\\.[^\\]*?)*?"""`,
  // Hive and Spark variables: ${name}
  "{}": String.raw`(?:\{[^\}]*\})`,
  // Oracle q'' strings: q'<text>' q'|text|' ...
  "q''": cY()
}, YI = (i) => typeof i == "string" ? uT[i] : "regex" in i ? i.regex : aY(i) + uT[i.quote], dY = (i) => ms(i.map((e) => "regex" in e ? e.regex : YI(e)).join("|")), BI = (i) => i.map(YI).join("|"), hT = (i) => ms(BI(i)), fY = (i = {}) => ms(FI(i)), FI = ({
  first: i,
  rest: e,
  dashes: t,
  allowFirstCharNumber: r
} = {}) => {
  const o = "\\p{Alphabetic}\\p{Mark}_", s = "\\p{Decimal_Number}", n = Qi(i ?? ""), a = Qi(e ?? ""), l = r ? `[${o}${s}${n}][${o}${s}${a}]*` : `[${o}${n}][${o}${s}${a}]*`;
  return t ? nY(l) : l;
};
function WI(i, e) {
  const t = i.slice(0, e).split(/\n/);
  return {
    line: t.length,
    col: t[t.length - 1].length + 1
  };
}
class pY {
  // Current position in string
  constructor(e) {
    Rt(this, "input", "");
    // The input SQL string to process
    Rt(this, "index", 0);
    this.rules = e;
  }
  /**
   * Takes a SQL string and breaks it into tokens.
   * Each token is an object with type and value.
   *
   * @param {string} input - The SQL string
   * @returns {Token[]} output token stream
   */
  tokenize(e) {
    this.input = e, this.index = 0;
    const t = [];
    let r;
    for (; this.index < this.input.length; ) {
      const o = this.getWhitespace();
      if (this.index < this.input.length) {
        if (r = this.getNextToken(), !r)
          throw this.createParseError();
        t.push({
          ...r,
          precedingWhitespace: o
        });
      }
    }
    return t;
  }
  createParseError() {
    const e = this.input.slice(this.index, this.index + 10), {
      line: t,
      col: r
    } = WI(this.input, this.index);
    return new Error(`Parse error: Unexpected "${e}" at line ${t} column ${r}`);
  }
  getWhitespace() {
    aT.lastIndex = this.index;
    const e = aT.exec(this.input);
    if (e)
      return this.index += e[0].length, e[0];
  }
  getNextToken() {
    for (const e of this.rules) {
      const t = this.match(e);
      if (t)
        return t;
    }
  }
  // Attempts to match token rule regex at current position in input
  match(e) {
    e.regex.lastIndex = this.index;
    const t = e.regex.exec(this.input);
    if (t) {
      const r = t[0], o = {
        type: e.type,
        raw: r,
        text: e.text ? e.text(r) : r,
        start: this.index
      };
      return e.key && (o.key = e.key(r)), this.index += r.length, o;
    }
  }
}
const cT = /\/\*/uy, OY = /([^/*]|\*[^/]|\/[^*])+/uy, EY = /\*\//uy;
class mY {
  constructor() {
    Rt(this, "lastIndex", 0);
  }
  exec(e) {
    let t = "", r, o = 0;
    if (r = this.matchSection(cT, e))
      t += r, o++;
    else
      return null;
    for (; o > 0; )
      if (r = this.matchSection(cT, e))
        t += r, o++;
      else if (r = this.matchSection(EY, e))
        t += r, o--;
      else if (r = this.matchSection(OY, e))
        t += r;
      else
        return null;
    return [t];
  }
  matchSection(e, t) {
    e.lastIndex = this.lastIndex;
    const r = e.exec(t);
    return r && (this.lastIndex += r[0].length), r ? r[0] : null;
  }
}
class gY {
  constructor(e) {
    this.cfg = e, this.rulesBeforeParams = this.buildRulesBeforeParams(e), this.rulesAfterParams = this.buildRulesAfterParams(e);
  }
  tokenize(e, t) {
    const r = [...this.rulesBeforeParams, ...this.buildParamRules(this.cfg, t), ...this.rulesAfterParams], o = new pY(r).tokenize(e);
    return this.cfg.postProcess ? this.cfg.postProcess(o) : o;
  }
  // These rules can be cached as they only depend on
  // the Tokenizer config options specified for each SQL dialect
  buildRulesBeforeParams(e) {
    return this.validRules([
      {
        type: k.BLOCK_COMMENT,
        regex: e.nestedBlockComments ? new mY() : /(\/\*[^]*?\*\/)/uy
      },
      {
        type: k.LINE_COMMENT,
        regex: lY(e.lineCommentTypes ?? ["--"])
      },
      {
        type: k.QUOTED_IDENTIFIER,
        regex: hT(e.identTypes)
      },
      {
        type: k.NUMBER,
        regex: /(?:0x[0-9a-fA-F]+|0b[01]+|(?:-\s*)?[0-9]+(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+(?:\.[0-9]+)?)?)(?!\w)/uy
      },
      // RESERVED_PHRASE is matched before all other keyword tokens
      // to e.g. prioritize matching "TIMESTAMP WITH TIME ZONE" phrase over "WITH" clause.
      {
        type: k.RESERVED_PHRASE,
        regex: Lo(e.reservedPhrases ?? [], e.identChars),
        text: dt
      },
      {
        type: k.CASE,
        regex: /CASE\b/iuy,
        text: dt
      },
      {
        type: k.END,
        regex: /END\b/iuy,
        text: dt
      },
      {
        type: k.BETWEEN,
        regex: /BETWEEN\b/iuy,
        text: dt
      },
      {
        type: k.LIMIT,
        regex: e.reservedClauses.includes("LIMIT") ? /LIMIT\b/iuy : void 0,
        text: dt
      },
      {
        type: k.RESERVED_CLAUSE,
        regex: Lo(e.reservedClauses, e.identChars),
        text: dt
      },
      {
        type: k.RESERVED_SELECT,
        regex: Lo(e.reservedSelect, e.identChars),
        text: dt
      },
      {
        type: k.RESERVED_SET_OPERATION,
        regex: Lo(e.reservedSetOperations, e.identChars),
        text: dt
      },
      {
        type: k.WHEN,
        regex: /WHEN\b/iuy,
        text: dt
      },
      {
        type: k.ELSE,
        regex: /ELSE\b/iuy,
        text: dt
      },
      {
        type: k.THEN,
        regex: /THEN\b/iuy,
        text: dt
      },
      {
        type: k.RESERVED_JOIN,
        regex: Lo(e.reservedJoins, e.identChars),
        text: dt
      },
      {
        type: k.AND,
        regex: /AND\b/iuy,
        text: dt
      },
      {
        type: k.OR,
        regex: /OR\b/iuy,
        text: dt
      },
      {
        type: k.XOR,
        regex: e.supportsXor ? /XOR\b/iuy : void 0,
        text: dt
      },
      {
        type: k.RESERVED_FUNCTION_NAME,
        regex: Lo(e.reservedFunctionNames, e.identChars),
        text: dt
      },
      {
        type: k.RESERVED_KEYWORD,
        regex: Lo(e.reservedKeywords, e.identChars),
        text: dt
      }
    ]);
  }
  // These rules can also be cached as they only depend on
  // the Tokenizer config options specified for each SQL dialect
  buildRulesAfterParams(e) {
    return this.validRules([{
      type: k.VARIABLE,
      regex: e.variableTypes ? dY(e.variableTypes) : void 0
    }, {
      type: k.STRING,
      regex: hT(e.stringTypes)
    }, {
      type: k.IDENTIFIER,
      regex: fY(e.identChars)
    }, {
      type: k.DELIMITER,
      regex: /[;]/uy
    }, {
      type: k.COMMA,
      regex: /[,]/y
    }, {
      type: k.OPEN_PAREN,
      regex: lT("open", e.extraParens)
    }, {
      type: k.CLOSE_PAREN,
      regex: lT("close", e.extraParens)
    }, {
      type: k.OPERATOR,
      regex: uY([
        // standard operators
        "+",
        "-",
        "/",
        ">",
        "<",
        "=",
        "<>",
        "<=",
        ">=",
        "!=",
        ...e.operators ?? []
      ])
    }, {
      type: k.ASTERISK,
      regex: /[*]/uy
    }, {
      type: k.DOT,
      regex: /[.]/uy
    }]);
  }
  // These rules can't be blindly cached as the paramTypesOverrides object
  // can differ on each invocation of the format() function.
  buildParamRules(e, t) {
    var r, o, s, n, a;
    const l = {
      named: (t == null ? void 0 : t.named) || ((r = e.paramTypes) === null || r === void 0 ? void 0 : r.named) || [],
      quoted: (t == null ? void 0 : t.quoted) || ((o = e.paramTypes) === null || o === void 0 ? void 0 : o.quoted) || [],
      numbered: (t == null ? void 0 : t.numbered) || ((s = e.paramTypes) === null || s === void 0 ? void 0 : s.numbered) || [],
      positional: typeof (t == null ? void 0 : t.positional) == "boolean" ? t.positional : (n = e.paramTypes) === null || n === void 0 ? void 0 : n.positional,
      custom: (t == null ? void 0 : t.custom) || ((a = e.paramTypes) === null || a === void 0 ? void 0 : a.custom) || []
    };
    return this.validRules([{
      type: k.NAMED_PARAMETER,
      regex: sd(l.named, FI(e.paramChars || e.identChars)),
      key: (u) => u.slice(1)
    }, {
      type: k.QUOTED_PARAMETER,
      regex: sd(l.quoted, BI(e.identTypes)),
      key: (u) => (({
        tokenKey: h,
        quoteChar: c
      }) => h.replace(new RegExp(Qi("\\" + c), "gu"), c))({
        tokenKey: u.slice(2, -1),
        quoteChar: u.slice(-1)
      })
    }, {
      type: k.NUMBERED_PARAMETER,
      regex: sd(l.numbered, "[0-9]+"),
      key: (u) => u.slice(1)
    }, {
      type: k.POSITIONAL_PARAMETER,
      regex: l.positional ? /[?]/y : void 0
    }, ...l.custom.map((u) => ({
      type: k.CUSTOM_PARAMETER,
      regex: ms(u.regex),
      key: u.key ?? ((h) => h)
    }))]);
  }
  // filters out rules for token types whose regex is undefined
  validRules(e) {
    return e.filter((t) => !!t.regex);
  }
}
const dt = (i) => XI(i.toUpperCase()), dT = /* @__PURE__ */ new Map(), bY = (i) => {
  let e = dT.get(i);
  return e || (e = TY(i), dT.set(i, e)), e;
}, TY = (i) => ({
  tokenizer: new gY(i.tokenizerOptions),
  formatOptions: SY(i.formatOptions)
}), SY = (i) => ({
  alwaysDenseOperators: i.alwaysDenseOperators || [],
  onelineClauses: Object.fromEntries(i.onelineClauses.map((e) => [e, !0]))
});
function fT(i) {
  return i.indentStyle === "tabularLeft" || i.indentStyle === "tabularRight" ? " ".repeat(10) : i.useTabs ? "	" : " ".repeat(i.tabWidth);
}
function $n(i) {
  return i.indentStyle === "tabularLeft" || i.indentStyle === "tabularRight";
}
class RY {
  constructor(e) {
    this.params = e, this.index = 0;
  }
  /**
   * Returns param value that matches given placeholder with param key.
   */
  get({
    key: e,
    text: t
  }) {
    return this.params ? e ? this.params[e] : this.params[this.index++] : t;
  }
  /**
   * Returns index of current positional parameter.
   */
  getPositionalParameterIndex() {
    return this.index;
  }
  /**
   * Sets index of current positional parameter.
   */
  setPositionalParameterIndex(e) {
    this.index = e;
  }
}
var AY = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function CY(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var zI = { exports: {} };
(function(i) {
  (function(e, t) {
    i.exports ? i.exports = t() : e.nearley = t();
  })(AY, function() {
    function e(u, h, c) {
      return this.id = ++e.highestId, this.name = u, this.symbols = h, this.postprocess = c, this;
    }
    e.highestId = 0, e.prototype.toString = function(u) {
      var h = typeof u > "u" ? this.symbols.map(l).join(" ") : this.symbols.slice(0, u).map(l).join(" ") + " ● " + this.symbols.slice(u).map(l).join(" ");
      return this.name + " → " + h;
    };
    function t(u, h, c, d) {
      this.rule = u, this.dot = h, this.reference = c, this.data = [], this.wantedBy = d, this.isComplete = this.dot === u.symbols.length;
    }
    t.prototype.toString = function() {
      return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
    }, t.prototype.nextState = function(u) {
      var h = new t(this.rule, this.dot + 1, this.reference, this.wantedBy);
      return h.left = this, h.right = u, h.isComplete && (h.data = h.build(), h.right = void 0), h;
    }, t.prototype.build = function() {
      var u = [], h = this;
      do
        u.push(h.right.data), h = h.left;
      while (h.left);
      return u.reverse(), u;
    }, t.prototype.finish = function() {
      this.rule.postprocess && (this.data = this.rule.postprocess(this.data, this.reference, n.fail));
    };
    function r(u, h) {
      this.grammar = u, this.index = h, this.states = [], this.wants = {}, this.scannable = [], this.completed = {};
    }
    r.prototype.process = function(u) {
      for (var h = this.states, c = this.wants, d = this.completed, f = 0; f < h.length; f++) {
        var p = h[f];
        if (p.isComplete) {
          if (p.finish(), p.data !== n.fail) {
            for (var O = p.wantedBy, m = O.length; m--; ) {
              var E = O[m];
              this.complete(E, p);
            }
            if (p.reference === this.index) {
              var g = p.rule.name;
              (this.completed[g] = this.completed[g] || []).push(p);
            }
          }
        } else {
          var g = p.rule.symbols[p.dot];
          if (typeof g != "string") {
            this.scannable.push(p);
            continue;
          }
          if (c[g]) {
            if (c[g].push(p), d.hasOwnProperty(g))
              for (var A = d[g], m = 0; m < A.length; m++) {
                var S = A[m];
                this.complete(p, S);
              }
          } else
            c[g] = [p], this.predict(g);
        }
      }
    }, r.prototype.predict = function(u) {
      for (var h = this.grammar.byName[u] || [], c = 0; c < h.length; c++) {
        var d = h[c], f = this.wants[u], p = new t(d, 0, this.index, f);
        this.states.push(p);
      }
    }, r.prototype.complete = function(u, h) {
      var c = u.nextState(h);
      this.states.push(c);
    };
    function o(u, h) {
      this.rules = u, this.start = h || this.rules[0].name;
      var c = this.byName = {};
      this.rules.forEach(function(d) {
        c.hasOwnProperty(d.name) || (c[d.name] = []), c[d.name].push(d);
      });
    }
    o.fromCompiled = function(d, h) {
      var c = d.Lexer;
      d.ParserStart && (h = d.ParserStart, d = d.ParserRules);
      var d = d.map(function(p) {
        return new e(p.name, p.symbols, p.postprocess);
      }), f = new o(d, h);
      return f.lexer = c, f;
    };
    function s() {
      this.reset("");
    }
    s.prototype.reset = function(u, h) {
      this.buffer = u, this.index = 0, this.line = h ? h.line : 1, this.lastLineBreak = h ? -h.col : 0;
    }, s.prototype.next = function() {
      if (this.index < this.buffer.length) {
        var u = this.buffer[this.index++];
        return u === `
` && (this.line += 1, this.lastLineBreak = this.index), { value: u };
      }
    }, s.prototype.save = function() {
      return {
        line: this.line,
        col: this.index - this.lastLineBreak
      };
    }, s.prototype.formatError = function(u, h) {
      var c = this.buffer;
      if (typeof c == "string") {
        var d = c.split(`
`).slice(
          Math.max(0, this.line - 5),
          this.line
        ), f = c.indexOf(`
`, this.index);
        f === -1 && (f = c.length);
        var p = this.index - this.lastLineBreak, O = String(this.line).length;
        return h += " at line " + this.line + " col " + p + `:

`, h += d.map(function(E, g) {
          return m(this.line - d.length + g + 1, O) + " " + E;
        }, this).join(`
`), h += `
` + m("", O + p) + `^
`, h;
      } else
        return h + " at index " + (this.index - 1);
      function m(E, g) {
        var A = String(E);
        return Array(g - A.length + 1).join(" ") + A;
      }
    };
    function n(u, h, c) {
      if (u instanceof o)
        var d = u, c = h;
      else
        var d = o.fromCompiled(u, h);
      this.grammar = d, this.options = {
        keepHistory: !1,
        lexer: d.lexer || new s()
      };
      for (var f in c || {})
        this.options[f] = c[f];
      this.lexer = this.options.lexer, this.lexerState = void 0;
      var p = new r(d, 0);
      this.table = [p], p.wants[d.start] = [], p.predict(d.start), p.process(), this.current = 0;
    }
    n.fail = {}, n.prototype.feed = function(u) {
      var h = this.lexer;
      h.reset(u, this.lexerState);
      for (var c; ; ) {
        try {
          if (c = h.next(), !c)
            break;
        } catch (I) {
          var O = new r(this.grammar, this.current + 1);
          this.table.push(O);
          var d = new Error(this.reportLexerError(I));
          throw d.offset = this.current, d.token = I.token, d;
        }
        var f = this.table[this.current];
        this.options.keepHistory || delete this.table[this.current - 1];
        var p = this.current + 1, O = new r(this.grammar, p);
        this.table.push(O);
        for (var m = c.text !== void 0 ? c.text : c.value, E = h.constructor === s ? c.value : c, g = f.scannable, A = g.length; A--; ) {
          var S = g[A], R = S.rule.symbols[S.dot];
          if (R.test ? R.test(E) : R.type ? R.type === c.type : R.literal === m) {
            var v = S.nextState({ data: E, token: c, isToken: !0, reference: p - 1 });
            O.states.push(v);
          }
        }
        if (O.process(), O.states.length === 0) {
          var d = new Error(this.reportError(c));
          throw d.offset = this.current, d.token = c, d;
        }
        this.options.keepHistory && (f.lexerState = h.save()), this.current++;
      }
      return f && (this.lexerState = h.save()), this.results = this.finish(), this;
    }, n.prototype.reportLexerError = function(u) {
      var h, c, d = u.token;
      return d ? (h = "input " + JSON.stringify(d.text[0]) + " (lexer error)", c = this.lexer.formatError(d, "Syntax error")) : (h = "input (lexer error)", c = u.message), this.reportErrorCommon(c, h);
    }, n.prototype.reportError = function(u) {
      var h = (u.type ? u.type + " token: " : "") + JSON.stringify(u.value !== void 0 ? u.value : u), c = this.lexer.formatError(u, "Syntax error");
      return this.reportErrorCommon(c, h);
    }, n.prototype.reportErrorCommon = function(u, h) {
      var c = [];
      c.push(u);
      var d = this.table.length - 2, f = this.table[d], p = f.states.filter(function(m) {
        var E = m.rule.symbols[m.dot];
        return E && typeof E != "string";
      });
      if (p.length === 0)
        c.push("Unexpected " + h + `. I did not expect any more input. Here is the state of my parse table:
`), this.displayStateStack(f.states, c);
      else {
        c.push("Unexpected " + h + `. Instead, I was expecting to see one of the following:
`);
        var O = p.map(function(m) {
          return this.buildFirstStateStack(m, []) || [m];
        }, this);
        O.forEach(function(m) {
          var E = m[0], g = E.rule.symbols[E.dot], A = this.getSymbolDisplay(g);
          c.push("A " + A + " based on:"), this.displayStateStack(m, c);
        }, this);
      }
      return c.push(""), c.join(`
`);
    }, n.prototype.displayStateStack = function(u, h) {
      for (var c, d = 0, f = 0; f < u.length; f++) {
        var p = u[f], O = p.rule.toString(p.dot);
        O === c ? d++ : (d > 0 && h.push("    ^ " + d + " more lines identical to this"), d = 0, h.push("    " + O)), c = O;
      }
    }, n.prototype.getSymbolDisplay = function(u) {
      return a(u);
    }, n.prototype.buildFirstStateStack = function(u, h) {
      if (h.indexOf(u) !== -1)
        return null;
      if (u.wantedBy.length === 0)
        return [u];
      var c = u.wantedBy[0], d = [u].concat(h), f = this.buildFirstStateStack(c, d);
      return f === null ? null : [u].concat(f);
    }, n.prototype.save = function() {
      var u = this.table[this.current];
      return u.lexerState = this.lexerState, u;
    }, n.prototype.restore = function(u) {
      var h = u.index;
      this.current = h, this.table[h] = u, this.table.splice(h + 1), this.lexerState = u.lexerState, this.results = this.finish();
    }, n.prototype.rewind = function(u) {
      if (!this.options.keepHistory)
        throw new Error("set option `keepHistory` to enable rewinding");
      this.restore(this.table[u]);
    }, n.prototype.finish = function() {
      var u = [], h = this.grammar.start, c = this.table[this.table.length - 1];
      return c.states.forEach(function(d) {
        d.rule.name === h && d.dot === d.rule.symbols.length && d.reference === 0 && d.data !== n.fail && u.push(d);
      }), u.map(function(d) {
        return d.data;
      });
    };
    function a(u) {
      var h = typeof u;
      if (h === "string")
        return u;
      if (h === "object") {
        if (u.literal)
          return JSON.stringify(u.literal);
        if (u instanceof RegExp)
          return "character matching " + u;
        if (u.type)
          return u.type + " token";
        if (u.test)
          return "token matching " + String(u.test);
        throw new Error("Unknown symbol type: " + u);
      }
    }
    function l(u) {
      var h = typeof u;
      if (h === "string")
        return u;
      if (h === "object") {
        if (u.literal)
          return JSON.stringify(u.literal);
        if (u instanceof RegExp)
          return u.toString();
        if (u.type)
          return "%" + u.type;
        if (u.test)
          return "<" + String(u.test) + ">";
        throw new Error("Unknown symbol type: " + u);
      }
    }
    return {
      Parser: n,
      Grammar: o,
      Rule: e
    };
  });
})(zI);
var NY = zI.exports;
const IY = /* @__PURE__ */ CY(NY);
function vY(i) {
  return i.map(_Y).map(PY).map(LY).map(wY);
}
const _Y = (i, e, t) => {
  if ($I(i.type)) {
    const r = yY(t, e);
    if (r && r.text === ".")
      return {
        ...i,
        type: k.IDENTIFIER,
        text: i.raw
      };
  }
  return i;
}, PY = (i, e, t) => {
  if (i.type === k.RESERVED_FUNCTION_NAME) {
    const r = ec(t, e);
    if (!r || !DY(r))
      return {
        ...i,
        type: k.RESERVED_KEYWORD
      };
  }
  return i;
}, LY = (i, e, t) => {
  if (i.type === k.IDENTIFIER) {
    const r = ec(t, e);
    if (r && ZI(r))
      return {
        ...i,
        type: k.ARRAY_IDENTIFIER
      };
  }
  return i;
}, wY = (i, e, t) => {
  if (i.type === k.RESERVED_KEYWORD) {
    const r = ec(t, e);
    if (r && ZI(r))
      return {
        ...i,
        type: k.ARRAY_KEYWORD
      };
  }
  return i;
}, yY = (i, e) => ec(i, e, -1), ec = (i, e, t = 1) => {
  let r = 1;
  for (; i[e + r * t] && xY(i[e + r * t]); )
    r++;
  return i[e + r * t];
}, DY = (i) => i.type === k.OPEN_PAREN && i.text === "(", ZI = (i) => i.type === k.OPEN_PAREN && i.text === "[", xY = (i) => i.type === k.BLOCK_COMMENT || i.type === k.LINE_COMMENT;
class qI {
  constructor(e) {
    Rt(this, "index", 0);
    Rt(this, "tokens", []);
    Rt(this, "input", "");
    this.tokenize = e;
  }
  reset(e, t) {
    this.input = e, this.index = 0, this.tokens = this.tokenize(e);
  }
  next() {
    return this.tokens[this.index++];
  }
  save() {
  }
  formatError(e) {
    const {
      line: t,
      col: r
    } = WI(this.input, e.start);
    return `Parse error at token: ${e.text} at line ${t} column ${r}`;
  }
  has(e) {
    return e in k;
  }
}
let ne;
(function(i) {
  i.statement = "statement", i.clause = "clause", i.set_operation = "set_operation", i.function_call = "function_call", i.array_subscript = "array_subscript", i.property_access = "property_access", i.parenthesis = "parenthesis", i.between_predicate = "between_predicate", i.case_expression = "case_expression", i.case_when = "case_when", i.case_else = "case_else", i.limit_clause = "limit_clause", i.all_columns_asterisk = "all_columns_asterisk", i.literal = "literal", i.identifier = "identifier", i.keyword = "keyword", i.parameter = "parameter", i.operator = "operator", i.comma = "comma", i.line_comment = "line_comment", i.block_comment = "block_comment";
})(ne || (ne = {}));
function nd(i) {
  return i[0];
}
const ue = new qI((i) => []), Ns = ([[i]]) => i, ut = (i) => ({
  type: ne.keyword,
  tokenType: i.type,
  text: i.text,
  raw: i.raw
}), pt = (i, {
  leading: e,
  trailing: t
}) => (e != null && e.length && (i = {
  ...i,
  leadingComments: e
}), t != null && t.length && (i = {
  ...i,
  trailingComments: t
}), i), MY = (i, {
  leading: e,
  trailing: t
}) => {
  if (e != null && e.length) {
    const [r, ...o] = i;
    i = [pt(r, {
      leading: e
    }), ...o];
  }
  if (t != null && t.length) {
    const r = i.slice(0, -1), o = i[i.length - 1];
    i = [...r, pt(o, {
      trailing: t
    })];
  }
  return i;
}, UY = {
  Lexer: ue,
  ParserRules: [{
    name: "main$ebnf$1",
    symbols: []
  }, {
    name: "main$ebnf$1",
    symbols: ["main$ebnf$1", "statement"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "main",
    symbols: ["main$ebnf$1"],
    postprocess: ([i]) => {
      const e = i[i.length - 1];
      return e && !e.hasSemicolon ? e.children.length > 0 ? i : i.slice(0, -1) : i;
    }
  }, {
    name: "statement$subexpression$1",
    symbols: [ue.has("DELIMITER") ? {
      type: "DELIMITER"
    } : DELIMITER]
  }, {
    name: "statement$subexpression$1",
    symbols: [ue.has("EOF") ? {
      type: "EOF"
    } : EOF]
  }, {
    name: "statement",
    symbols: ["expressions_or_clauses", "statement$subexpression$1"],
    postprocess: ([i, [e]]) => ({
      type: ne.statement,
      children: i,
      hasSemicolon: e.type === k.DELIMITER
    })
  }, {
    name: "expressions_or_clauses$ebnf$1",
    symbols: []
  }, {
    name: "expressions_or_clauses$ebnf$1",
    symbols: ["expressions_or_clauses$ebnf$1", "free_form_sql"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "expressions_or_clauses$ebnf$2",
    symbols: []
  }, {
    name: "expressions_or_clauses$ebnf$2",
    symbols: ["expressions_or_clauses$ebnf$2", "clause"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "expressions_or_clauses",
    symbols: ["expressions_or_clauses$ebnf$1", "expressions_or_clauses$ebnf$2"],
    postprocess: ([i, e]) => [...i, ...e]
  }, {
    name: "clause$subexpression$1",
    symbols: ["limit_clause"]
  }, {
    name: "clause$subexpression$1",
    symbols: ["select_clause"]
  }, {
    name: "clause$subexpression$1",
    symbols: ["other_clause"]
  }, {
    name: "clause$subexpression$1",
    symbols: ["set_operation"]
  }, {
    name: "clause",
    symbols: ["clause$subexpression$1"],
    postprocess: Ns
  }, {
    name: "limit_clause$ebnf$1$subexpression$1$ebnf$1",
    symbols: ["free_form_sql"]
  }, {
    name: "limit_clause$ebnf$1$subexpression$1$ebnf$1",
    symbols: ["limit_clause$ebnf$1$subexpression$1$ebnf$1", "free_form_sql"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "limit_clause$ebnf$1$subexpression$1",
    symbols: [ue.has("COMMA") ? {
      type: "COMMA"
    } : COMMA, "limit_clause$ebnf$1$subexpression$1$ebnf$1"]
  }, {
    name: "limit_clause$ebnf$1",
    symbols: ["limit_clause$ebnf$1$subexpression$1"],
    postprocess: nd
  }, {
    name: "limit_clause$ebnf$1",
    symbols: [],
    postprocess: () => null
  }, {
    name: "limit_clause",
    symbols: [ue.has("LIMIT") ? {
      type: "LIMIT"
    } : LIMIT, "_", "expression_chain_", "limit_clause$ebnf$1"],
    postprocess: ([i, e, t, r]) => {
      if (r) {
        const [o, s] = r;
        return {
          type: ne.limit_clause,
          limitKw: pt(ut(i), {
            trailing: e
          }),
          offset: t,
          count: s
        };
      } else
        return {
          type: ne.limit_clause,
          limitKw: pt(ut(i), {
            trailing: e
          }),
          count: t
        };
    }
  }, {
    name: "select_clause$subexpression$1$ebnf$1",
    symbols: []
  }, {
    name: "select_clause$subexpression$1$ebnf$1",
    symbols: ["select_clause$subexpression$1$ebnf$1", "free_form_sql"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "select_clause$subexpression$1",
    symbols: ["all_columns_asterisk", "select_clause$subexpression$1$ebnf$1"]
  }, {
    name: "select_clause$subexpression$1$ebnf$2",
    symbols: []
  }, {
    name: "select_clause$subexpression$1$ebnf$2",
    symbols: ["select_clause$subexpression$1$ebnf$2", "free_form_sql"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "select_clause$subexpression$1",
    symbols: ["asteriskless_free_form_sql", "select_clause$subexpression$1$ebnf$2"]
  }, {
    name: "select_clause",
    symbols: [ue.has("RESERVED_SELECT") ? {
      type: "RESERVED_SELECT"
    } : RESERVED_SELECT, "select_clause$subexpression$1"],
    postprocess: ([i, [e, t]]) => ({
      type: ne.clause,
      nameKw: ut(i),
      children: [e, ...t]
    })
  }, {
    name: "select_clause",
    symbols: [ue.has("RESERVED_SELECT") ? {
      type: "RESERVED_SELECT"
    } : RESERVED_SELECT],
    postprocess: ([i]) => ({
      type: ne.clause,
      nameKw: ut(i),
      children: []
    })
  }, {
    name: "all_columns_asterisk",
    symbols: [ue.has("ASTERISK") ? {
      type: "ASTERISK"
    } : ASTERISK],
    postprocess: () => ({
      type: ne.all_columns_asterisk
    })
  }, {
    name: "other_clause$ebnf$1",
    symbols: []
  }, {
    name: "other_clause$ebnf$1",
    symbols: ["other_clause$ebnf$1", "free_form_sql"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "other_clause",
    symbols: [ue.has("RESERVED_CLAUSE") ? {
      type: "RESERVED_CLAUSE"
    } : RESERVED_CLAUSE, "other_clause$ebnf$1"],
    postprocess: ([i, e]) => ({
      type: ne.clause,
      nameKw: ut(i),
      children: e
    })
  }, {
    name: "set_operation$ebnf$1",
    symbols: []
  }, {
    name: "set_operation$ebnf$1",
    symbols: ["set_operation$ebnf$1", "free_form_sql"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "set_operation",
    symbols: [ue.has("RESERVED_SET_OPERATION") ? {
      type: "RESERVED_SET_OPERATION"
    } : RESERVED_SET_OPERATION, "set_operation$ebnf$1"],
    postprocess: ([i, e]) => ({
      type: ne.set_operation,
      nameKw: ut(i),
      children: e
    })
  }, {
    name: "expression_chain_$ebnf$1",
    symbols: ["expression_with_comments_"]
  }, {
    name: "expression_chain_$ebnf$1",
    symbols: ["expression_chain_$ebnf$1", "expression_with_comments_"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "expression_chain_",
    symbols: ["expression_chain_$ebnf$1"],
    postprocess: nd
  }, {
    name: "expression_chain$ebnf$1",
    symbols: []
  }, {
    name: "expression_chain$ebnf$1",
    symbols: ["expression_chain$ebnf$1", "_expression_with_comments"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "expression_chain",
    symbols: ["expression", "expression_chain$ebnf$1"],
    postprocess: ([i, e]) => [i, ...e]
  }, {
    name: "andless_expression_chain$ebnf$1",
    symbols: []
  }, {
    name: "andless_expression_chain$ebnf$1",
    symbols: ["andless_expression_chain$ebnf$1", "_andless_expression_with_comments"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "andless_expression_chain",
    symbols: ["andless_expression", "andless_expression_chain$ebnf$1"],
    postprocess: ([i, e]) => [i, ...e]
  }, {
    name: "expression_with_comments_",
    symbols: ["expression", "_"],
    postprocess: ([i, e]) => pt(i, {
      trailing: e
    })
  }, {
    name: "_expression_with_comments",
    symbols: ["_", "expression"],
    postprocess: ([i, e]) => pt(e, {
      leading: i
    })
  }, {
    name: "_andless_expression_with_comments",
    symbols: ["_", "andless_expression"],
    postprocess: ([i, e]) => pt(e, {
      leading: i
    })
  }, {
    name: "free_form_sql$subexpression$1",
    symbols: ["asteriskless_free_form_sql"]
  }, {
    name: "free_form_sql$subexpression$1",
    symbols: ["asterisk"]
  }, {
    name: "free_form_sql",
    symbols: ["free_form_sql$subexpression$1"],
    postprocess: Ns
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["asteriskless_andless_expression"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["logic_operator"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["between_predicate"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["comma"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["comment"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["other_keyword"]
  }, {
    name: "asteriskless_free_form_sql",
    symbols: ["asteriskless_free_form_sql$subexpression$1"],
    postprocess: Ns
  }, {
    name: "expression$subexpression$1",
    symbols: ["andless_expression"]
  }, {
    name: "expression$subexpression$1",
    symbols: ["logic_operator"]
  }, {
    name: "expression",
    symbols: ["expression$subexpression$1"],
    postprocess: Ns
  }, {
    name: "andless_expression$subexpression$1",
    symbols: ["asteriskless_andless_expression"]
  }, {
    name: "andless_expression$subexpression$1",
    symbols: ["asterisk"]
  }, {
    name: "andless_expression",
    symbols: ["andless_expression$subexpression$1"],
    postprocess: Ns
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["array_subscript"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["case_expression"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["function_call"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["property_access"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["parenthesis"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["curly_braces"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["square_brackets"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["operator"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["identifier"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["parameter"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["literal"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["keyword"]
  }, {
    name: "asteriskless_andless_expression",
    symbols: ["asteriskless_andless_expression$subexpression$1"],
    postprocess: Ns
  }, {
    name: "array_subscript",
    symbols: [ue.has("ARRAY_IDENTIFIER") ? {
      type: "ARRAY_IDENTIFIER"
    } : ARRAY_IDENTIFIER, "_", "square_brackets"],
    postprocess: ([i, e, t]) => ({
      type: ne.array_subscript,
      array: pt({
        type: ne.identifier,
        text: i.text
      }, {
        trailing: e
      }),
      parenthesis: t
    })
  }, {
    name: "array_subscript",
    symbols: [ue.has("ARRAY_KEYWORD") ? {
      type: "ARRAY_KEYWORD"
    } : ARRAY_KEYWORD, "_", "square_brackets"],
    postprocess: ([i, e, t]) => ({
      type: ne.array_subscript,
      array: pt(ut(i), {
        trailing: e
      }),
      parenthesis: t
    })
  }, {
    name: "function_call",
    symbols: [ue.has("RESERVED_FUNCTION_NAME") ? {
      type: "RESERVED_FUNCTION_NAME"
    } : RESERVED_FUNCTION_NAME, "_", "parenthesis"],
    postprocess: ([i, e, t]) => ({
      type: ne.function_call,
      nameKw: pt(ut(i), {
        trailing: e
      }),
      parenthesis: t
    })
  }, {
    name: "parenthesis",
    symbols: [{
      literal: "("
    }, "expressions_or_clauses", {
      literal: ")"
    }],
    postprocess: ([i, e, t]) => ({
      type: ne.parenthesis,
      children: e,
      openParen: "(",
      closeParen: ")"
    })
  }, {
    name: "curly_braces$ebnf$1",
    symbols: []
  }, {
    name: "curly_braces$ebnf$1",
    symbols: ["curly_braces$ebnf$1", "free_form_sql"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "curly_braces",
    symbols: [{
      literal: "{"
    }, "curly_braces$ebnf$1", {
      literal: "}"
    }],
    postprocess: ([i, e, t]) => ({
      type: ne.parenthesis,
      children: e,
      openParen: "{",
      closeParen: "}"
    })
  }, {
    name: "square_brackets$ebnf$1",
    symbols: []
  }, {
    name: "square_brackets$ebnf$1",
    symbols: ["square_brackets$ebnf$1", "free_form_sql"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "square_brackets",
    symbols: [{
      literal: "["
    }, "square_brackets$ebnf$1", {
      literal: "]"
    }],
    postprocess: ([i, e, t]) => ({
      type: ne.parenthesis,
      children: e,
      openParen: "[",
      closeParen: "]"
    })
  }, {
    name: "property_access$subexpression$1",
    symbols: ["identifier"]
  }, {
    name: "property_access$subexpression$1",
    symbols: ["array_subscript"]
  }, {
    name: "property_access$subexpression$1",
    symbols: ["all_columns_asterisk"]
  }, {
    name: "property_access",
    symbols: ["expression", "_", ue.has("DOT") ? {
      type: "DOT"
    } : DOT, "_", "property_access$subexpression$1"],
    postprocess: (
      // Allowing property to be <array_subscript> is currently a hack.
      // A better way would be to allow <property_access> on the left side of array_subscript,
      // but we currently can't do that because of another hack that requires
      // %ARRAY_IDENTIFIER on the left side of <array_subscript>.
      ([i, e, t, r, [o]]) => ({
        type: ne.property_access,
        object: pt(i, {
          trailing: e
        }),
        property: pt(o, {
          leading: r
        })
      })
    )
  }, {
    name: "between_predicate",
    symbols: [ue.has("BETWEEN") ? {
      type: "BETWEEN"
    } : BETWEEN, "_", "andless_expression_chain", "_", ue.has("AND") ? {
      type: "AND"
    } : AND, "_", "andless_expression"],
    postprocess: ([i, e, t, r, o, s, n]) => ({
      type: ne.between_predicate,
      betweenKw: ut(i),
      expr1: MY(t, {
        leading: e,
        trailing: r
      }),
      andKw: ut(o),
      expr2: [pt(n, {
        leading: s
      })]
    })
  }, {
    name: "case_expression$ebnf$1",
    symbols: ["expression_chain_"],
    postprocess: nd
  }, {
    name: "case_expression$ebnf$1",
    symbols: [],
    postprocess: () => null
  }, {
    name: "case_expression$ebnf$2",
    symbols: []
  }, {
    name: "case_expression$ebnf$2",
    symbols: ["case_expression$ebnf$2", "case_clause"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "case_expression",
    symbols: [ue.has("CASE") ? {
      type: "CASE"
    } : CASE, "_", "case_expression$ebnf$1", "case_expression$ebnf$2", ue.has("END") ? {
      type: "END"
    } : END],
    postprocess: ([i, e, t, r, o]) => ({
      type: ne.case_expression,
      caseKw: pt(ut(i), {
        trailing: e
      }),
      endKw: ut(o),
      expr: t || [],
      clauses: r
    })
  }, {
    name: "case_clause",
    symbols: [ue.has("WHEN") ? {
      type: "WHEN"
    } : WHEN, "_", "expression_chain_", ue.has("THEN") ? {
      type: "THEN"
    } : THEN, "_", "expression_chain_"],
    postprocess: ([i, e, t, r, o, s]) => ({
      type: ne.case_when,
      whenKw: pt(ut(i), {
        trailing: e
      }),
      thenKw: pt(ut(r), {
        trailing: o
      }),
      condition: t,
      result: s
    })
  }, {
    name: "case_clause",
    symbols: [ue.has("ELSE") ? {
      type: "ELSE"
    } : ELSE, "_", "expression_chain_"],
    postprocess: ([i, e, t]) => ({
      type: ne.case_else,
      elseKw: pt(ut(i), {
        trailing: e
      }),
      result: t
    })
  }, {
    name: "comma$subexpression$1",
    symbols: [ue.has("COMMA") ? {
      type: "COMMA"
    } : COMMA]
  }, {
    name: "comma",
    symbols: ["comma$subexpression$1"],
    postprocess: ([[i]]) => ({
      type: ne.comma
    })
  }, {
    name: "asterisk$subexpression$1",
    symbols: [ue.has("ASTERISK") ? {
      type: "ASTERISK"
    } : ASTERISK]
  }, {
    name: "asterisk",
    symbols: ["asterisk$subexpression$1"],
    postprocess: ([[i]]) => ({
      type: ne.operator,
      text: i.text
    })
  }, {
    name: "operator$subexpression$1",
    symbols: [ue.has("OPERATOR") ? {
      type: "OPERATOR"
    } : OPERATOR]
  }, {
    name: "operator",
    symbols: ["operator$subexpression$1"],
    postprocess: ([[i]]) => ({
      type: ne.operator,
      text: i.text
    })
  }, {
    name: "identifier$subexpression$1",
    symbols: [ue.has("IDENTIFIER") ? {
      type: "IDENTIFIER"
    } : IDENTIFIER]
  }, {
    name: "identifier$subexpression$1",
    symbols: [ue.has("QUOTED_IDENTIFIER") ? {
      type: "QUOTED_IDENTIFIER"
    } : QUOTED_IDENTIFIER]
  }, {
    name: "identifier$subexpression$1",
    symbols: [ue.has("VARIABLE") ? {
      type: "VARIABLE"
    } : VARIABLE]
  }, {
    name: "identifier",
    symbols: ["identifier$subexpression$1"],
    postprocess: ([[i]]) => ({
      type: ne.identifier,
      text: i.text
    })
  }, {
    name: "parameter$subexpression$1",
    symbols: [ue.has("NAMED_PARAMETER") ? {
      type: "NAMED_PARAMETER"
    } : NAMED_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [ue.has("QUOTED_PARAMETER") ? {
      type: "QUOTED_PARAMETER"
    } : QUOTED_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [ue.has("NUMBERED_PARAMETER") ? {
      type: "NUMBERED_PARAMETER"
    } : NUMBERED_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [ue.has("POSITIONAL_PARAMETER") ? {
      type: "POSITIONAL_PARAMETER"
    } : POSITIONAL_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [ue.has("CUSTOM_PARAMETER") ? {
      type: "CUSTOM_PARAMETER"
    } : CUSTOM_PARAMETER]
  }, {
    name: "parameter",
    symbols: ["parameter$subexpression$1"],
    postprocess: ([[i]]) => ({
      type: ne.parameter,
      key: i.key,
      text: i.text
    })
  }, {
    name: "literal$subexpression$1",
    symbols: [ue.has("NUMBER") ? {
      type: "NUMBER"
    } : NUMBER]
  }, {
    name: "literal$subexpression$1",
    symbols: [ue.has("STRING") ? {
      type: "STRING"
    } : STRING]
  }, {
    name: "literal",
    symbols: ["literal$subexpression$1"],
    postprocess: ([[i]]) => ({
      type: ne.literal,
      text: i.text
    })
  }, {
    name: "keyword$subexpression$1",
    symbols: [ue.has("RESERVED_KEYWORD") ? {
      type: "RESERVED_KEYWORD"
    } : RESERVED_KEYWORD]
  }, {
    name: "keyword$subexpression$1",
    symbols: [ue.has("RESERVED_PHRASE") ? {
      type: "RESERVED_PHRASE"
    } : RESERVED_PHRASE]
  }, {
    name: "keyword$subexpression$1",
    symbols: [ue.has("RESERVED_JOIN") ? {
      type: "RESERVED_JOIN"
    } : RESERVED_JOIN]
  }, {
    name: "keyword",
    symbols: ["keyword$subexpression$1"],
    postprocess: ([[i]]) => ut(i)
  }, {
    name: "logic_operator$subexpression$1",
    symbols: [ue.has("AND") ? {
      type: "AND"
    } : AND]
  }, {
    name: "logic_operator$subexpression$1",
    symbols: [ue.has("OR") ? {
      type: "OR"
    } : OR]
  }, {
    name: "logic_operator$subexpression$1",
    symbols: [ue.has("XOR") ? {
      type: "XOR"
    } : XOR]
  }, {
    name: "logic_operator",
    symbols: ["logic_operator$subexpression$1"],
    postprocess: ([[i]]) => ut(i)
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [ue.has("WHEN") ? {
      type: "WHEN"
    } : WHEN]
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [ue.has("THEN") ? {
      type: "THEN"
    } : THEN]
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [ue.has("ELSE") ? {
      type: "ELSE"
    } : ELSE]
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [ue.has("END") ? {
      type: "END"
    } : END]
  }, {
    name: "other_keyword",
    symbols: ["other_keyword$subexpression$1"],
    postprocess: ([[i]]) => ut(i)
  }, {
    name: "_$ebnf$1",
    symbols: []
  }, {
    name: "_$ebnf$1",
    symbols: ["_$ebnf$1", "comment"],
    postprocess: (i) => i[0].concat([i[1]])
  }, {
    name: "_",
    symbols: ["_$ebnf$1"],
    postprocess: ([i]) => i
  }, {
    name: "comment",
    symbols: [ue.has("LINE_COMMENT") ? {
      type: "LINE_COMMENT"
    } : LINE_COMMENT],
    postprocess: ([i]) => ({
      type: ne.line_comment,
      text: i.text,
      precedingWhitespace: i.precedingWhitespace
    })
  }, {
    name: "comment",
    symbols: [ue.has("BLOCK_COMMENT") ? {
      type: "BLOCK_COMMENT"
    } : BLOCK_COMMENT],
    postprocess: ([i]) => ({
      type: ne.block_comment,
      text: i.text,
      precedingWhitespace: i.precedingWhitespace
    })
  }],
  ParserStart: "main"
}, QY = UY, {
  Parser: kY,
  Grammar: $Y
} = IY;
function GY(i) {
  let e = {};
  const t = new qI((o) => [...vY(i.tokenize(o, e)), kI(o.length)]), r = new kY($Y.fromCompiled(QY), {
    lexer: t
  });
  return {
    parse: (o, s) => {
      e = s;
      const {
        results: n
      } = r.feed(o);
      if (n.length === 1)
        return n[0];
      throw n.length === 0 ? new Error("Parse error: Invalid SQL") : new Error(`Parse error: Ambiguous grammar
${JSON.stringify(n, void 0, 2)}`);
    }
  };
}
const VY = /^\s+/u;
function HY(i, e, t) {
  return XY(i.split(`
`)).flatMap((r) => {
    if (r.length === 1)
      return r;
    if (e === "tabular")
      return YY(r);
    if (e === "before")
      return FY(r, t);
    throw new Error(`Unexpected commaPosition: ${e}`);
  }).join(`
`);
}
function XY(i) {
  const e = [];
  for (let t = 0; t < i.length; t++) {
    const r = [i[t]];
    for (; i[t].match(/.*,(\s*(--.*)?$)/); )
      t++, r.push(i[t]);
    e.push(r);
  }
  return e;
}
function YY(i) {
  const e = HI(ZY(i)) - 1;
  return i.map((t, r) => r === i.length - 1 ? t : BY(t, e));
}
function BY(i, e) {
  const [, t, r] = i.match(/^(.*?),(\s*--.*)?$/) || [], o = " ".repeat(e - t.length);
  return `${t}${o},${r ?? ""}`;
}
function FY(i, e) {
  return zY(i).map((t, r) => {
    if (r === 0)
      return t;
    const [o] = t.match(VY) || [""];
    return WY(o, e) + e.replace(/ {2}$/, ", ") + // add comma to the end of last indent
    t.trimStart();
  });
}
function WY(i, e) {
  return i.replace(new RegExp(e + "$"), "");
}
function zY(i) {
  return i.map((e) => e.replace(/,(\s*(--.*)?$)/, "$1"));
}
function ZY(i) {
  return i.map((e) => e.replace(/\s*--.*/, ""));
}
function qY(i) {
  const e = i.split(`
`);
  let t = [];
  for (let r = 0; r < e.length; r++) {
    if (e[r].match(/^\s*SELECT/i)) {
      let o = [];
      if (e[r].match(/.*,$/))
        o = [e[r]];
      else {
        if (t.push(e[r]), e[r].match(/^\s*SELECT\s+.+(?!,$)/i))
          continue;
        o.push(e[++r]);
      }
      for (; e[r++].match(/.*,$/); )
        o.push(e[r]);
      const s = o.map((a) => ({
        line: a,
        matches: a.match(/(^.*?\S) (AS )?(\S+,?$)/i)
      })).map(({
        line: a,
        matches: l
      }) => l ? {
        precedingText: l[1],
        as: l[2],
        alias: l[3]
      } : {
        precedingText: a
      }), n = HI(s.map(({
        precedingText: a
      }) => a.replace(/\s*,\s*$/, "")));
      o = s.map(({
        precedingText: a,
        as: l,
        alias: u
      }) => a + (u ? " ".repeat(n - a.length + 1) + (l ?? "") + u : "")), t = [...t, ...o];
    }
    t.push(e[r]);
  }
  return t.join(`
`);
}
let M;
(function(i) {
  i[i.SPACE = 0] = "SPACE", i[i.NO_SPACE = 1] = "NO_SPACE", i[i.NO_NEWLINE = 2] = "NO_NEWLINE", i[i.NEWLINE = 3] = "NEWLINE", i[i.MANDATORY_NEWLINE = 4] = "MANDATORY_NEWLINE", i[i.INDENT = 5] = "INDENT", i[i.SINGLE_INDENT = 6] = "SINGLE_INDENT";
})(M || (M = {}));
let jI = class {
  constructor(e) {
    Rt(this, "items", []);
    this.indentation = e;
  }
  /**
   * Appends token strings and whitespace modifications to SQL string.
   */
  add(...e) {
    for (const t of e)
      switch (t) {
        case M.SPACE:
          this.items.push(M.SPACE);
          break;
        case M.NO_SPACE:
          this.trimHorizontalWhitespace();
          break;
        case M.NO_NEWLINE:
          this.trimWhitespace();
          break;
        case M.NEWLINE:
          this.trimHorizontalWhitespace(), this.addNewline(M.NEWLINE);
          break;
        case M.MANDATORY_NEWLINE:
          this.trimHorizontalWhitespace(), this.addNewline(M.MANDATORY_NEWLINE);
          break;
        case M.INDENT:
          this.addIndentation();
          break;
        case M.SINGLE_INDENT:
          this.items.push(M.SINGLE_INDENT);
          break;
        default:
          this.items.push(t);
      }
  }
  trimHorizontalWhitespace() {
    for (; jY(ha(this.items)); )
      this.items.pop();
  }
  trimWhitespace() {
    for (; KY(ha(this.items)); )
      this.items.pop();
  }
  addNewline(e) {
    if (this.items.length > 0)
      switch (ha(this.items)) {
        case M.NEWLINE:
          this.items.pop(), this.items.push(e);
          break;
        case M.MANDATORY_NEWLINE:
          break;
        default:
          this.items.push(e);
          break;
      }
  }
  addIndentation() {
    for (let e = 0; e < this.indentation.getLevel(); e++)
      this.items.push(M.SINGLE_INDENT);
  }
  /**
   * Returns the final SQL string.
   */
  toString() {
    return this.items.map((e) => this.itemToString(e)).join("");
  }
  /**
   * Returns the internal layout data
   */
  getLayoutItems() {
    return this.items;
  }
  itemToString(e) {
    switch (e) {
      case M.SPACE:
        return " ";
      case M.NEWLINE:
      case M.MANDATORY_NEWLINE:
        return `
`;
      case M.SINGLE_INDENT:
        return this.indentation.getSingleIndent();
      default:
        return e;
    }
  }
};
const jY = (i) => i === M.SPACE || i === M.SINGLE_INDENT, KY = (i) => i === M.SPACE || i === M.SINGLE_INDENT || i === M.NEWLINE;
function JY(i, e) {
  if (e === "standard")
    return i;
  let t = [];
  return i.length >= 10 && i.includes(" ") && ([i, ...t] = i.split(" ")), e === "tabularLeft" ? i = i.padEnd(9, " ") : i = i.padStart(9, " "), i + ["", ...t].join(" ");
}
function eB(i) {
  return NV(i) || i === k.RESERVED_CLAUSE || i === k.RESERVED_SELECT || i === k.RESERVED_SET_OPERATION || i === k.RESERVED_JOIN || i === k.LIMIT;
}
const ad = "top-level", tB = "block-level";
class KI {
  /**
   * @param {string} indent A string to indent with
   */
  constructor(e) {
    Rt(this, "indentTypes", []);
    this.indent = e;
  }
  /**
   * Returns indentation string for single indentation step.
   */
  getSingleIndent() {
    return this.indent;
  }
  /**
   * Returns current indentation level
   */
  getLevel() {
    return this.indentTypes.length;
  }
  /**
   * Increases indentation by one top-level indent.
   */
  increaseTopLevel() {
    this.indentTypes.push(ad);
  }
  /**
   * Increases indentation by one block-level indent.
   */
  increaseBlockLevel() {
    this.indentTypes.push(tB);
  }
  /**
   * Decreases indentation by one top-level indent.
   * Does nothing when the previous indent is not top-level.
   */
  decreaseTopLevel() {
    this.indentTypes.length > 0 && ha(this.indentTypes) === ad && this.indentTypes.pop();
  }
  /**
   * Decreases indentation by one block-level indent.
   * If there are top-level indents within the block-level indent,
   * throws away these as well.
   */
  decreaseBlockLevel() {
    for (; this.indentTypes.length > 0 && this.indentTypes.pop() === ad; )
      ;
  }
}
class iB extends jI {
  constructor(t) {
    super(new KI(""));
    Rt(this, "length", 0);
    // Keeps track of the trailing whitespace,
    // so that we can decrease length when encountering WS.NO_SPACE,
    // but only when there actually is a space to remove.
    Rt(this, "trailingSpace", !1);
    this.expressionWidth = t;
  }
  add(...t) {
    if (t.forEach((r) => this.addToLength(r)), this.length > this.expressionWidth)
      throw new Bf();
    super.add(...t);
  }
  addToLength(t) {
    if (typeof t == "string")
      this.length += t.length, this.trailingSpace = !1;
    else {
      if (t === M.MANDATORY_NEWLINE || t === M.NEWLINE)
        throw new Bf();
      t === M.INDENT || t === M.SINGLE_INDENT || t === M.SPACE ? this.trailingSpace || (this.length++, this.trailingSpace = !0) : (t === M.NO_NEWLINE || t === M.NO_SPACE) && this.trailingSpace && (this.trailingSpace = !1, this.length--);
    }
  }
}
class Bf extends Error {
}
class lh {
  constructor({
    cfg: e,
    dialectCfg: t,
    params: r,
    layout: o,
    inline: s = !1
  }) {
    Rt(this, "inline", !1);
    Rt(this, "nodes", []);
    Rt(this, "index", -1);
    this.cfg = e, this.dialectCfg = t, this.inline = s, this.params = r, this.layout = o;
  }
  format(e) {
    for (this.nodes = e, this.index = 0; this.index < this.nodes.length; this.index++)
      this.formatNode(this.nodes[this.index]);
    return this.layout;
  }
  formatNode(e) {
    this.formatComments(e.leadingComments), this.formatNodeWithoutComments(e), this.formatComments(e.trailingComments);
  }
  formatNodeWithoutComments(e) {
    switch (e.type) {
      case ne.function_call:
        return this.formatFunctionCall(e);
      case ne.array_subscript:
        return this.formatArraySubscript(e);
      case ne.property_access:
        return this.formatPropertyAccess(e);
      case ne.parenthesis:
        return this.formatParenthesis(e);
      case ne.between_predicate:
        return this.formatBetweenPredicate(e);
      case ne.case_expression:
        return this.formatCaseExpression(e);
      case ne.case_when:
        return this.formatCaseWhen(e);
      case ne.case_else:
        return this.formatCaseElse(e);
      case ne.clause:
        return this.formatClause(e);
      case ne.set_operation:
        return this.formatSetOperation(e);
      case ne.limit_clause:
        return this.formatLimitClause(e);
      case ne.all_columns_asterisk:
        return this.formatAllColumnsAsterisk(e);
      case ne.literal:
        return this.formatLiteral(e);
      case ne.identifier:
        return this.formatIdentifier(e);
      case ne.parameter:
        return this.formatParameter(e);
      case ne.operator:
        return this.formatOperator(e);
      case ne.comma:
        return this.formatComma(e);
      case ne.line_comment:
        return this.formatLineComment(e);
      case ne.block_comment:
        return this.formatBlockComment(e);
      case ne.keyword:
        return this.formatKeywordNode(e);
    }
  }
  formatFunctionCall(e) {
    this.withComments(e.nameKw, () => {
      this.layout.add(this.showKw(e.nameKw));
    }), this.formatNode(e.parenthesis);
  }
  formatArraySubscript(e) {
    this.withComments(e.array, () => {
      this.layout.add(e.array.type === ne.keyword ? this.showKw(e.array) : e.array.text);
    }), this.formatNode(e.parenthesis);
  }
  formatPropertyAccess(e) {
    this.formatNode(e.object), this.layout.add(M.NO_SPACE, "."), this.formatNode(e.property);
  }
  formatParenthesis(e) {
    const t = this.formatInlineExpression(e.children);
    t ? (this.layout.add(e.openParen), this.layout.add(...t.getLayoutItems()), this.layout.add(M.NO_SPACE, e.closeParen, M.SPACE)) : (this.layout.add(e.openParen, M.NEWLINE), $n(this.cfg) ? (this.layout.add(M.INDENT), this.layout = this.formatSubExpression(e.children)) : (this.layout.indentation.increaseBlockLevel(), this.layout.add(M.INDENT), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseBlockLevel()), this.layout.add(M.NEWLINE, M.INDENT, e.closeParen, M.SPACE));
  }
  formatBetweenPredicate(e) {
    this.layout.add(this.showKw(e.betweenKw), M.SPACE), this.layout = this.formatSubExpression(e.expr1), this.layout.add(M.NO_SPACE, M.SPACE, this.showNonTabularKw(e.andKw), M.SPACE), this.layout = this.formatSubExpression(e.expr2), this.layout.add(M.SPACE);
  }
  formatCaseExpression(e) {
    this.formatNode(e.caseKw), this.layout.indentation.increaseBlockLevel(), this.layout = this.formatSubExpression(e.expr), this.layout = this.formatSubExpression(e.clauses), this.layout.indentation.decreaseBlockLevel(), this.layout.add(M.NEWLINE, M.INDENT), this.formatNode(e.endKw);
  }
  formatCaseWhen(e) {
    this.layout.add(M.NEWLINE, M.INDENT), this.formatNode(e.whenKw), this.layout = this.formatSubExpression(e.condition), this.formatNode(e.thenKw), this.layout = this.formatSubExpression(e.result);
  }
  formatCaseElse(e) {
    this.layout.add(M.NEWLINE, M.INDENT), this.formatNode(e.elseKw), this.layout = this.formatSubExpression(e.result);
  }
  formatClause(e) {
    this.isOnelineClause(e) ? this.formatClauseInOnelineStyle(e) : $n(this.cfg) ? this.formatClauseInTabularStyle(e) : this.formatClauseInIndentedStyle(e);
  }
  isOnelineClause(e) {
    return this.dialectCfg.onelineClauses[e.nameKw.text];
  }
  formatClauseInIndentedStyle(e) {
    this.layout.add(M.NEWLINE, M.INDENT, this.showKw(e.nameKw), M.NEWLINE), this.layout.indentation.increaseTopLevel(), this.layout.add(M.INDENT), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseTopLevel();
  }
  formatClauseInOnelineStyle(e) {
    this.layout.add(M.NEWLINE, M.INDENT, this.showKw(e.nameKw), M.SPACE), this.layout = this.formatSubExpression(e.children);
  }
  formatClauseInTabularStyle(e) {
    this.layout.add(M.NEWLINE, M.INDENT, this.showKw(e.nameKw), M.SPACE), this.layout.indentation.increaseTopLevel(), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseTopLevel();
  }
  formatSetOperation(e) {
    this.layout.add(M.NEWLINE, M.INDENT, this.showKw(e.nameKw), M.NEWLINE), this.layout.add(M.INDENT), this.layout = this.formatSubExpression(e.children);
  }
  formatLimitClause(e) {
    this.withComments(e.limitKw, () => {
      this.layout.add(M.NEWLINE, M.INDENT, this.showKw(e.limitKw));
    }), this.layout.indentation.increaseTopLevel(), $n(this.cfg) ? this.layout.add(M.SPACE) : this.layout.add(M.NEWLINE, M.INDENT), e.offset ? (this.layout = this.formatSubExpression(e.offset), this.layout.add(M.NO_SPACE, ",", M.SPACE), this.layout = this.formatSubExpression(e.count)) : this.layout = this.formatSubExpression(e.count), this.layout.indentation.decreaseTopLevel();
  }
  formatAllColumnsAsterisk(e) {
    this.layout.add("*", M.SPACE);
  }
  formatLiteral(e) {
    this.layout.add(e.text, M.SPACE);
  }
  formatIdentifier(e) {
    this.layout.add(e.text, M.SPACE);
  }
  formatParameter(e) {
    this.layout.add(this.params.get(e), M.SPACE);
  }
  formatOperator({
    text: e
  }) {
    this.cfg.denseOperators || this.dialectCfg.alwaysDenseOperators.includes(e) ? this.layout.add(M.NO_SPACE, e) : e === ":" ? this.layout.add(M.NO_SPACE, e, M.SPACE) : this.layout.add(e, M.SPACE);
  }
  formatComma(e) {
    this.inline ? this.layout.add(M.NO_SPACE, ",", M.SPACE) : this.layout.add(M.NO_SPACE, ",", M.NEWLINE, M.INDENT);
  }
  withComments(e, t) {
    this.formatComments(e.leadingComments), t(), this.formatComments(e.trailingComments);
  }
  formatComments(e) {
    e && e.forEach((t) => {
      t.type === ne.line_comment ? this.formatLineComment(t) : this.formatBlockComment(t);
    });
  }
  formatLineComment(e) {
    od(e.precedingWhitespace || "") ? this.layout.add(M.NEWLINE, M.INDENT, e.text, M.MANDATORY_NEWLINE, M.INDENT) : this.layout.getLayoutItems().length > 0 ? this.layout.add(M.NO_NEWLINE, M.SPACE, e.text, M.MANDATORY_NEWLINE, M.INDENT) : this.layout.add(e.text, M.MANDATORY_NEWLINE, M.INDENT);
  }
  formatBlockComment(e) {
    this.isMultilineBlockComment(e) ? (this.splitBlockComment(e.text).forEach((t) => {
      this.layout.add(M.NEWLINE, M.INDENT, t);
    }), this.layout.add(M.NEWLINE, M.INDENT)) : this.layout.add(e.text, M.SPACE);
  }
  isMultilineBlockComment(e) {
    return od(e.text) || od(e.precedingWhitespace || "");
  }
  isDocComment(e) {
    const t = e.split(/\n/);
    return (
      // first line starts with /* or /**
      /^\/\*\*?$/.test(t[0]) && // intermediate lines start with *
      t.slice(1, t.length - 1).every((r) => /^\s*\*/.test(r)) && // last line ends with */
      /^\s*\*\/$/.test(ha(t))
    );
  }
  // Breaks up block comment to multiple lines.
  // For example this doc-comment (dots representing leading whitespace):
  //
  //   ..../**
  //   .....* Some description here
  //   .....* and here too
  //   .....*/
  //
  // gets broken to this array (note the leading single spaces):
  //
  //   [ '/**',
  //     '.* Some description here',
  //     '.* and here too',
  //     '.*/' ]
  //
  // However, a normal comment (non-doc-comment) like this:
  //
  //   ..../*
  //   ....Some description here
  //   ....*/
  //
  // gets broken to this array (no leading spaces):
  //
  //   [ '/*',
  //     'Some description here',
  //     '*/' ]
  //
  splitBlockComment(e) {
    return this.isDocComment(e) ? e.split(/\n/).map((t) => /^\s*\*/.test(t) ? " " + t.replace(/^\s*/, "") : t) : e.split(/\n/).map((t) => t.replace(/^\s*/, ""));
  }
  formatSubExpression(e) {
    return new lh({
      cfg: this.cfg,
      dialectCfg: this.dialectCfg,
      params: this.params,
      layout: this.layout,
      inline: this.inline
    }).format(e);
  }
  formatInlineExpression(e) {
    const t = this.params.getPositionalParameterIndex();
    try {
      return new lh({
        cfg: this.cfg,
        dialectCfg: this.dialectCfg,
        params: this.params,
        layout: new iB(this.cfg.expressionWidth),
        inline: !0
      }).format(e);
    } catch (r) {
      if (r instanceof Bf) {
        this.params.setPositionalParameterIndex(t);
        return;
      } else
        throw r;
    }
  }
  formatKeywordNode(e) {
    switch (e.tokenType) {
      case k.RESERVED_JOIN:
        return this.formatJoin(e);
      case k.AND:
      case k.OR:
      case k.XOR:
        return this.formatLogicalOperator(e);
      default:
        return this.formatKeyword(e);
    }
  }
  formatJoin(e) {
    $n(this.cfg) ? (this.layout.indentation.decreaseTopLevel(), this.layout.add(M.NEWLINE, M.INDENT, this.showKw(e), M.SPACE), this.layout.indentation.increaseTopLevel()) : this.layout.add(M.NEWLINE, M.INDENT, this.showKw(e), M.SPACE);
  }
  formatKeyword(e) {
    this.layout.add(this.showKw(e), M.SPACE);
  }
  formatLogicalOperator(e) {
    this.cfg.logicalOperatorNewline === "before" ? $n(this.cfg) ? (this.layout.indentation.decreaseTopLevel(), this.layout.add(M.NEWLINE, M.INDENT, this.showKw(e), M.SPACE), this.layout.indentation.increaseTopLevel()) : this.layout.add(M.NEWLINE, M.INDENT, this.showKw(e), M.SPACE) : this.layout.add(this.showKw(e), M.NEWLINE, M.INDENT);
  }
  showKw(e) {
    return eB(e.tokenType) ? JY(this.showNonTabularKw(e), this.cfg.indentStyle) : this.showNonTabularKw(e);
  }
  // Like showKw(), but skips tabular formatting
  showNonTabularKw(e) {
    switch (this.cfg.keywordCase) {
      case "preserve":
        return XI(e.raw);
      case "upper":
        return e.text;
      case "lower":
        return e.text.toLowerCase();
    }
  }
}
class rB {
  constructor(e, t) {
    this.dialect = e, this.cfg = t, this.params = new RY(this.cfg.params);
  }
  /**
   * Formats an SQL query.
   * @param {string} query - The SQL query string to be formatted
   * @return {string} The formatter query
   */
  format(e) {
    const t = this.parse(e), r = this.formatAst(t);
    return this.postFormat(r).trimEnd();
  }
  parse(e) {
    return GY(this.dialect.tokenizer).parse(e, this.cfg.paramTypes || {});
  }
  formatAst(e) {
    return e.map((t) => this.formatStatement(t)).join(`
`.repeat(this.cfg.linesBetweenQueries + 1));
  }
  formatStatement(e) {
    const t = new lh({
      cfg: this.cfg,
      dialectCfg: this.dialect.formatOptions,
      params: this.params,
      layout: new jI(new KI(fT(this.cfg)))
    }).format(e.children);
    return e.hasSemicolon && (this.cfg.newlineBeforeSemicolon ? t.add(M.NEWLINE, ";") : t.add(M.NO_NEWLINE, ";")), t.toString();
  }
  postFormat(e) {
    return this.cfg.tabulateAlias && (e = qY(e)), (this.cfg.commaPosition === "before" || this.cfg.commaPosition === "tabular") && (e = HY(e, this.cfg.commaPosition, fT(this.cfg))), e;
  }
}
class wo extends Error {
}
function oB(i) {
  if ("multilineLists" in i)
    throw new wo("multilineLists config is no more supported.");
  if ("newlineBeforeOpenParen" in i)
    throw new wo("newlineBeforeOpenParen config is no more supported.");
  if ("newlineBeforeCloseParen" in i)
    throw new wo("newlineBeforeCloseParen config is no more supported.");
  if ("aliasAs" in i)
    throw new wo("aliasAs config is no more supported.");
  if (i.expressionWidth <= 0)
    throw new wo(`expressionWidth config must be positive number. Received ${i.expressionWidth} instead.`);
  if (i.commaPosition === "before" && i.useTabs)
    throw new wo("commaPosition: before does not work when tabs are used for indentation.");
  return i.params && !sB(i.params) && console.warn('WARNING: All "params" option values should be strings.'), i;
}
function sB(i) {
  return (i instanceof Array ? i : Object.values(i)).every((t) => typeof t == "string");
}
const JI = {
  bigquery: "bigquery",
  db2: "db2",
  hive: "hive",
  mariadb: "mariadb",
  mysql: "mysql",
  n1ql: "n1ql",
  plsql: "plsql",
  postgresql: "postgresql",
  redshift: "redshift",
  spark: "spark",
  sqlite: "sqlite",
  sql: "sql",
  trino: "trino",
  transactsql: "transactsql",
  tsql: "transactsql",
  // alias for transactsq
  singlestoredb: "singlestoredb",
  snowflake: "snowflake"
}, nB = Object.keys(JI), aB = {
  tabWidth: 2,
  useTabs: !1,
  keywordCase: "preserve",
  indentStyle: "standard",
  logicalOperatorNewline: "before",
  tabulateAlias: !1,
  commaPosition: "after",
  expressionWidth: 50,
  linesBetweenQueries: 1,
  denseOperators: !1,
  newlineBeforeSemicolon: !1
}, lB = (i, e = {}) => {
  if (typeof e.language == "string" && !nB.includes(e.language))
    throw new wo(`Unsupported SQL dialect: ${e.language}`);
  const t = JI[e.language || "sql"];
  return uB(i, {
    ...e,
    dialect: oY[t]
  });
}, uB = (i, {
  dialect: e,
  ...t
}) => {
  if (typeof i != "string")
    throw new Error("Invalid query argument. Expected string, instead got " + typeof i);
  const r = oB({
    ...aB,
    ...t
  });
  return new rB(bY(e), r).format(i);
}, hB = (i) => (KT("data-v-4fa50bd3"), i = i(), JT(), i), cB = { class: "ns-codeide-option-box" }, dB = { class: "ns-codeide-optionleft-box" }, fB = ["src"], pB = ["src"], OB = { class: "ns-codeide-optionright-box" }, EB = /* @__PURE__ */ hB(() => /* @__PURE__ */ ke("div", { id: "code" }, null, -1)), mB = { class: "ns-codeide-hide" }, gB = /* @__PURE__ */ fi({
  __name: "codeide",
  props: {
    code: {
      type: String,
      default: ""
    },
    language: {
      type: String,
      default: "javascript"
    }
  },
  emits: ["change", "keypress", "keydown"],
  setup(i, { emit: e }) {
    const t = i, r = it(), o = it();
    let s = null;
    function n(c) {
      switch (c) {
        case "java":
          return [qk()];
        case "javascript":
          return [ou()];
        case "css":
          return [kf()];
        case "html":
          return [kf(), MG(), ou()];
        case "json":
          return [GG()];
        case "sql":
          return [CV()];
        default:
          return [ou()];
      }
    }
    function a(c, d) {
      if (!s)
        return;
      const f = s.state.update({
        selection: d,
        changes: c
      });
      s.dispatch(f);
    }
    function l() {
      o.value && o.value.click();
    }
    function u() {
      if (!o.value) {
        setTimeout(() => {
          u();
        }, 200);
        return;
      }
      o.value.addEventListener("change", (c) => {
        const d = c.target.files;
        if (!d)
          return;
        const f = d[0], p = new FileReader();
        p.onload = (O) => {
          var E;
          const m = (E = O.target) == null ? void 0 : E.result;
          if (m && s) {
            const { selection: g, doc: A } = s == null ? void 0 : s.state, S = { from: 0, to: A ? A.length : 0, insert: m };
            a(S, g);
          }
        }, p.readAsText(f);
      });
    }
    function h() {
      if (!s)
        return;
      const { selection: c, doc: d } = s.state, f = d.toString();
      let p = "";
      switch (t.language) {
        case "sql":
          p = lB(f, { language: "sql" });
          break;
      }
      const O = { from: 0, to: f ? f.length : 0, insert: p };
      a(O, c);
    }
    return Mi(() => t.code, (c, d) => {
      if (s && c !== d) {
        const { selection: f, doc: p } = s.state, O = { from: 0, to: p ? p.length : 0, insert: c };
        a(O, f);
      }
    }), yr(() => {
      var d;
      u();
      const c = Re.create({
        doc: `${t.code}`,
        extensions: [
          Ik,
          Ka.of(yN),
          rI({
            defaultKeymap: !0
          }),
          ...n(t.language),
          Qk
        ]
      });
      s = new q({
        state: c,
        parent: ((d = r.value) == null ? void 0 : d.children).code
      }), s == null || s.dom.addEventListener("keyup", (f) => {
        e("change", s == null ? void 0 : s.state.doc.toString());
      });
    }), (c, d) => (Pe(), ht("div", {
      class: "ns-code-ide-box",
      ref_key: "RefMainBox",
      ref: r
    }, [
      ke("div", cB, [
        ke("div", dB, [
          ke("img", {
            src: Zs(zy),
            onClick: h
          }, null, 8, fB),
          ke("img", {
            src: Zs(Zy),
            onClick: l
          }, null, 8, pB),
          ui(c.$slots, "left-option", {}, void 0, !0)
        ]),
        ke("div", OB, [
          ui(c.$slots, "right-option", {}, void 0, !0)
        ])
      ]),
      EB,
      ke("div", mB, [
        ke("input", {
          type: "file",
          ref_key: "RefInput",
          ref: o
        }, null, 512)
      ])
    ], 512));
  }
}), bB = `.ns-code-ide-box[data-v-4fa50bd3]{width:100%;height:100%;overflow:hidden;box-sizing:border-box;overflow-y:auto}.ns-code-ide-box .ns-codeide-option-box[data-v-4fa50bd3]{width:100%;height:24px;overflow:hidden;box-sizing:border-box;display:flex;justify-content:space-between;align-items:center;border:1px solid var(--ns-border-color);border-bottom:0;background-color:var(--ns-background-gray)}.ns-code-ide-box .ns-codeide-option-box[data-v-4fa50bd3] img{width:16px;height:16px;margin:0 5px}.ns-code-ide-box .ns-codeide-option-box[data-v-4fa50bd3] img:hover{cursor:pointer;filter:drop-shadow(0 0 1px var(--ns-primary-light-1))}.ns-code-ide-box .ns-codeide-option-box .ns-codeide-optionleft-box[data-v-4fa50bd3]{width:50%;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:flex-start;align-items:center}.ns-code-ide-box .ns-codeide-option-box .ns-codeide-optionright-box[data-v-4fa50bd3]{width:50%;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:flex-end;align-items:center}.ns-code-ide-box #code[data-v-4fa50bd3]{width:100%;height:calc(100% - 24px);overflow:hidden;box-sizing:border-box;overflow-y:auto;text-align:left}
`, TB = `#code{background-color:#f7f7f7}#code .cm-editor{height:100%!important;width:100%}#code .cm-editor .cm-scroller{height:100%;overflow-y:auto}
`, SB = /* @__PURE__ */ xr(gB, [["styles", [bB, TB]], ["__scopeId", "data-v-4fa50bd3"]]);
class Zt {
  constructor(e) {
    this.table = e;
  }
  //////////////////////////////////////////
  /////////////// DataLoad /////////////////
  //////////////////////////////////////////
  reloadData(e, t, r) {
    return this.table.dataLoader.load(e, void 0, void 0, void 0, t, r);
  }
  //////////////////////////////////////////
  ///////////// Localization ///////////////
  //////////////////////////////////////////
  langText() {
    return this.table.modules.localize.getText(...arguments);
  }
  langBind() {
    return this.table.modules.localize.bind(...arguments);
  }
  langLocale() {
    return this.table.modules.localize.getLocale(...arguments);
  }
  //////////////////////////////////////////
  ////////// Inter Table Comms /////////////
  //////////////////////////////////////////
  commsConnections() {
    return this.table.modules.comms.getConnections(...arguments);
  }
  commsSend() {
    return this.table.modules.comms.send(...arguments);
  }
  //////////////////////////////////////////
  //////////////// Layout  /////////////////
  //////////////////////////////////////////
  layoutMode() {
    return this.table.modules.layout.getMode();
  }
  layoutRefresh(e) {
    return this.table.modules.layout.layout(e);
  }
  //////////////////////////////////////////
  /////////////// Event Bus ////////////////
  //////////////////////////////////////////
  subscribe() {
    return this.table.eventBus.subscribe(...arguments);
  }
  unsubscribe() {
    return this.table.eventBus.unsubscribe(...arguments);
  }
  subscribed(e) {
    return this.table.eventBus.subscribed(e);
  }
  subscriptionChange() {
    return this.table.eventBus.subscriptionChange(...arguments);
  }
  dispatch() {
    return this.table.eventBus.dispatch(...arguments);
  }
  chain() {
    return this.table.eventBus.chain(...arguments);
  }
  confirm() {
    return this.table.eventBus.confirm(...arguments);
  }
  dispatchExternal() {
    return this.table.externalEvents.dispatch(...arguments);
  }
  subscribedExternal(e) {
    return this.table.externalEvents.subscribed(e);
  }
  subscriptionChangeExternal() {
    return this.table.externalEvents.subscriptionChange(...arguments);
  }
  //////////////////////////////////////////
  //////////////// Options /////////////////
  //////////////////////////////////////////
  options(e) {
    return this.table.options[e];
  }
  setOption(e, t) {
    return typeof t < "u" && (this.table.options[e] = t), this.table.options[e];
  }
  //////////////////////////////////////////
  /////////// Deprecation Checks ///////////
  //////////////////////////////////////////
  deprecationCheck(e, t) {
    return this.table.deprecationAdvisor.check(e, t);
  }
  deprecationCheckMsg(e, t) {
    return this.table.deprecationAdvisor.checkMsg(e, t);
  }
  deprecationMsg(e) {
    return this.table.deprecationAdvisor.msg(e);
  }
  //////////////////////////////////////////
  //////////////// Modules /////////////////
  //////////////////////////////////////////
  module(e) {
    return this.table.module(e);
  }
}
class Ge {
  static elVisible(e) {
    return !(e.offsetWidth <= 0 && e.offsetHeight <= 0);
  }
  static elOffset(e) {
    var t = e.getBoundingClientRect();
    return {
      top: t.top + window.pageYOffset - document.documentElement.clientTop,
      left: t.left + window.pageXOffset - document.documentElement.clientLeft
    };
  }
  static deepClone(e, t, r = []) {
    var o = {}.__proto__, s = [].__proto__;
    t || (t = Object.assign(Array.isArray(e) ? [] : {}, e));
    for (var n in e) {
      let a = e[n], l, u;
      a != null && typeof a == "object" && (a.__proto__ === o || a.__proto__ === s) && (l = r.findIndex((h) => h.subject === a), l > -1 ? t[n] = r[l].copy : (u = Object.assign(Array.isArray(a) ? [] : {}, a), r.unshift({ subject: a, copy: u }), t[n] = this.deepClone(a, u, r)));
    }
    return t;
  }
}
class DO extends Zt {
  constructor(e, t, r) {
    super(e), this.element = t, this.container = this._lookupContainer(), this.parent = r, this.reversedX = !1, this.childPopup = null, this.blurable = !1, this.blurCallback = null, this.blurEventsBound = !1, this.renderedCallback = null, this.visible = !1, this.hideable = !0, this.element.classList.add("tabulator-popup-container"), this.blurEvent = this.hide.bind(this, !1), this.escEvent = this._escapeCheck.bind(this), this.destroyBinding = this.tableDestroyed.bind(this), this.destroyed = !1;
  }
  tableDestroyed() {
    this.destroyed = !0, this.hide(!0);
  }
  _lookupContainer() {
    var e = this.table.options.popupContainer;
    return typeof e == "string" ? (e = document.querySelector(e), e || console.warn("Menu Error - no container element found matching selector:", this.table.options.popupContainer, "(defaulting to document body)")) : e === !0 && (e = this.table.element), e && !this._checkContainerIsParent(e) && (e = !1, console.warn("Menu Error - container element does not contain this table:", this.table.options.popupContainer, "(defaulting to document body)")), e || (e = document.body), e;
  }
  _checkContainerIsParent(e, t = this.table.element) {
    return e === t ? !0 : t.parentNode ? this._checkContainerIsParent(e, t.parentNode) : !1;
  }
  renderCallback(e) {
    this.renderedCallback = e;
  }
  containerEventCoords(e) {
    var t = !(e instanceof MouseEvent), r = t ? e.touches[0].pageX : e.pageX, o = t ? e.touches[0].pageY : e.pageY;
    if (this.container !== document.body) {
      let s = Ge.elOffset(this.container);
      r -= s.left, o -= s.top;
    }
    return { x: r, y: o };
  }
  elementPositionCoords(e, t = "right") {
    var r = Ge.elOffset(e), o, s, n;
    switch (this.container !== document.body && (o = Ge.elOffset(this.container), r.left -= o.left, r.top -= o.top), t) {
      case "right":
        s = r.left + e.offsetWidth, n = r.top - 1;
        break;
      case "bottom":
        s = r.left, n = r.top + e.offsetHeight;
        break;
      case "left":
        s = r.left, n = r.top - 1;
        break;
      case "top":
        s = r.left, n = r.top;
        break;
      case "center":
        s = r.left + e.offsetWidth / 2, n = r.top + e.offsetHeight / 2;
        break;
    }
    return { x: s, y: n, offset: r };
  }
  show(e, t) {
    var r, o, s, n, a;
    return this.destroyed || this.table.destroyed ? this : (e instanceof HTMLElement ? (s = e, a = this.elementPositionCoords(e, t), n = a.offset, r = a.x, o = a.y) : typeof e == "number" ? (n = { top: 0, left: 0 }, r = e, o = t) : (a = this.containerEventCoords(e), r = a.x, o = a.y, this.reversedX = !1), this.element.style.top = o + "px", this.element.style.left = r + "px", this.container.appendChild(this.element), typeof this.renderedCallback == "function" && this.renderedCallback(), this._fitToScreen(r, o, s, n, t), this.visible = !0, this.subscribe("table-destroy", this.destroyBinding), this.element.addEventListener("mousedown", (l) => {
      l.stopPropagation();
    }), this);
  }
  _fitToScreen(e, t, r, o, s) {
    var n = this.container === document.body ? document.documentElement.scrollTop : this.container.scrollTop;
    if ((e + this.element.offsetWidth >= this.container.offsetWidth || this.reversedX) && (this.element.style.left = "", r ? this.element.style.right = this.container.offsetWidth - o.left + "px" : this.element.style.right = this.container.offsetWidth - e + "px", this.reversedX = !0), t + this.element.offsetHeight > Math.max(this.container.offsetHeight, n ? this.container.scrollHeight : 0))
      if (r)
        switch (s) {
          case "bottom":
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight - r.offsetHeight - 1 + "px";
            break;
          default:
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + r.offsetHeight + 1 + "px";
        }
      else
        this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + "px";
  }
  isVisible() {
    return this.visible;
  }
  hideOnBlur(e) {
    return this.blurable = !0, this.visible && (setTimeout(() => {
      this.visible && (this.table.rowManager.element.addEventListener("scroll", this.blurEvent), this.subscribe("cell-editing", this.blurEvent), document.body.addEventListener("click", this.blurEvent), document.body.addEventListener("contextmenu", this.blurEvent), document.body.addEventListener("mousedown", this.blurEvent), window.addEventListener("resize", this.blurEvent), document.body.addEventListener("keydown", this.escEvent), this.blurEventsBound = !0);
    }, 100), this.blurCallback = e), this;
  }
  _escapeCheck(e) {
    e.keyCode == 27 && this.hide();
  }
  blockHide() {
    this.hideable = !1;
  }
  restoreHide() {
    this.hideable = !0;
  }
  hide(e = !1) {
    return this.visible && this.hideable && (this.blurable && this.blurEventsBound && (document.body.removeEventListener("keydown", this.escEvent), document.body.removeEventListener("click", this.blurEvent), document.body.removeEventListener("contextmenu", this.blurEvent), document.body.removeEventListener("mousedown", this.blurEvent), window.removeEventListener("resize", this.blurEvent), this.table.rowManager.element.removeEventListener("scroll", this.blurEvent), this.unsubscribe("cell-editing", this.blurEvent), this.blurEventsBound = !1), this.childPopup && this.childPopup.hide(), this.parent && (this.parent.childPopup = null), this.element.parentNode && this.element.parentNode.removeChild(this.element), this.visible = !1, this.blurCallback && !e && this.blurCallback(), this.unsubscribe("table-destroy", this.destroyBinding)), this;
  }
  child(e) {
    return this.childPopup && this.childPopup.hide(), this.childPopup = new DO(this.table, e, this), this.childPopup;
  }
}
class ge extends Zt {
  constructor(e, t) {
    super(e), this._handler = null;
  }
  initialize() {
  }
  ///////////////////////////////////
  ////// Options Registration ///////
  ///////////////////////////////////
  registerTableOption(e, t) {
    this.table.optionsList.register(e, t);
  }
  registerColumnOption(e, t) {
    this.table.columnManager.optionsList.register(e, t);
  }
  ///////////////////////////////////
  /// Public Function Registration ///
  ///////////////////////////////////
  registerTableFunction(e, t) {
    typeof this.table[e] > "u" ? this.table[e] = (...r) => (this.table.initGuard(e), t(...r)) : console.warn("Unable to bind table function, name already in use", e);
  }
  registerComponentFunction(e, t, r) {
    return this.table.componentFunctionBinder.bind(e, t, r);
  }
  ///////////////////////////////////
  ////////// Data Pipeline //////////
  ///////////////////////////////////
  registerDataHandler(e, t) {
    this.table.rowManager.registerDataPipelineHandler(e, t), this._handler = e;
  }
  registerDisplayHandler(e, t) {
    this.table.rowManager.registerDisplayPipelineHandler(e, t), this._handler = e;
  }
  displayRows(e) {
    var t = this.table.rowManager.displayRows.length - 1, r;
    if (this._handler && (r = this.table.rowManager.displayPipeline.findIndex((o) => o.handler === this._handler), r > -1 && (t = r)), e && (t = t + e), this._handler)
      return t > -1 ? this.table.rowManager.getDisplayRows(t) : this.activeRows();
  }
  activeRows() {
    return this.table.rowManager.activeRows;
  }
  refreshData(e, t) {
    t || (t = this._handler), t && this.table.rowManager.refreshActiveData(t, !1, e);
  }
  ///////////////////////////////////
  //////// Footer Management ////////
  ///////////////////////////////////
  footerAppend(e) {
    return this.table.footerManager.append(e);
  }
  footerPrepend(e) {
    return this.table.footerManager.prepend(e);
  }
  footerRemove(e) {
    return this.table.footerManager.remove(e);
  }
  ///////////////////////////////////
  //////// Popups Management ////////
  ///////////////////////////////////
  popup(e, t) {
    return new DO(this.table, e, t);
  }
  ///////////////////////////////////
  //////// Alert Management ////////
  ///////////////////////////////////
  alert(e, t) {
    return this.table.alertManager.alert(e, t);
  }
  clearAlert() {
    return this.table.alertManager.clear();
  }
}
var RB = {};
class os extends ge {
  constructor(e) {
    super(e), this.allowedTypes = ["", "data", "download", "clipboard", "print", "htmlOutput"], this.registerColumnOption("accessor"), this.registerColumnOption("accessorParams"), this.registerColumnOption("accessorData"), this.registerColumnOption("accessorDataParams"), this.registerColumnOption("accessorDownload"), this.registerColumnOption("accessorDownloadParams"), this.registerColumnOption("accessorClipboard"), this.registerColumnOption("accessorClipboardParams"), this.registerColumnOption("accessorPrint"), this.registerColumnOption("accessorPrintParams"), this.registerColumnOption("accessorHtmlOutput"), this.registerColumnOption("accessorHtmlOutputParams");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("row-data-retrieve", this.transformRow.bind(this));
  }
  //initialize column accessor
  initializeColumn(e) {
    var t = !1, r = {};
    this.allowedTypes.forEach((o) => {
      var s = "accessor" + (o.charAt(0).toUpperCase() + o.slice(1)), n;
      e.definition[s] && (n = this.lookupAccessor(e.definition[s]), n && (t = !0, r[s] = {
        accessor: n,
        params: e.definition[s + "Params"] || {}
      }));
    }), t && (e.modules.accessor = r);
  }
  lookupAccessor(e) {
    var t = !1;
    switch (typeof e) {
      case "string":
        os.accessors[e] ? t = os.accessors[e] : console.warn("Accessor Error - No such accessor found, ignoring: ", e);
        break;
      case "function":
        t = e;
        break;
    }
    return t;
  }
  //apply accessor to row
  transformRow(e, t) {
    var r = "accessor" + (t.charAt(0).toUpperCase() + t.slice(1)), o = e.getComponent(), s = Ge.deepClone(e.data || {});
    return this.table.columnManager.traverse(function(n) {
      var a, l, u, h;
      n.modules.accessor && (l = n.modules.accessor[r] || n.modules.accessor.accessor || !1, l && (a = n.getFieldValue(s), a != "undefined" && (h = n.getComponent(), u = typeof l.params == "function" ? l.params(a, s, t, h, o) : l.params, n.setFieldValue(s, l.accessor(a, s, t, u, h, o)))));
    }), s;
  }
}
os.moduleName = "accessor";
os.accessors = RB;
var AB = {
  method: "GET"
};
function Ff(i, e) {
  var t = [];
  if (e = e || "", Array.isArray(i))
    i.forEach((o, s) => {
      t = t.concat(Ff(o, e ? e + "[" + s + "]" : s));
    });
  else if (typeof i == "object")
    for (var r in i)
      t = t.concat(Ff(i[r], e ? e + "[" + r + "]" : r));
  else
    t.push({ key: e, value: i });
  return t;
}
function CB(i) {
  var e = Ff(i), t = [];
  return e.forEach(function(r) {
    t.push(encodeURIComponent(r.key) + "=" + encodeURIComponent(r.value));
  }), t.join("&");
}
function ev(i, e, t) {
  return i && t && Object.keys(t).length && (!e.method || e.method.toLowerCase() == "get") && (e.method = "get", i += (i.includes("?") ? "&" : "?") + CB(t)), i;
}
function NB(i, e, t) {
  var r;
  return new Promise((o, s) => {
    if (i = this.urlGenerator.call(this.table, i, e, t), e.method.toUpperCase() != "GET")
      if (r = typeof this.table.options.ajaxContentType == "object" ? this.table.options.ajaxContentType : this.contentTypeFormatters[this.table.options.ajaxContentType], r) {
        for (var n in r.headers)
          e.headers || (e.headers = {}), typeof e.headers[n] > "u" && (e.headers[n] = r.headers[n]);
        e.body = r.body.call(this, i, e, t);
      } else
        console.warn("Ajax Error - Invalid ajaxContentType value:", this.table.options.ajaxContentType);
    i ? (typeof e.headers > "u" && (e.headers = {}), typeof e.headers.Accept > "u" && (e.headers.Accept = "application/json"), typeof e.headers["X-Requested-With"] > "u" && (e.headers["X-Requested-With"] = "XMLHttpRequest"), typeof e.mode > "u" && (e.mode = "cors"), e.mode == "cors" ? (typeof e.headers.Origin > "u" && (e.headers.Origin = window.location.origin), typeof e.credentials > "u" && (e.credentials = "same-origin")) : typeof e.credentials > "u" && (e.credentials = "include"), fetch(i, e).then((a) => {
      a.ok ? a.json().then((l) => {
        o(l);
      }).catch((l) => {
        s(l), console.warn("Ajax Load Error - Invalid JSON returned", l);
      }) : (console.error("Ajax Load Error - Connection Error: " + a.status, a.statusText), s(a));
    }).catch((a) => {
      console.error("Ajax Load Error - Connection Error: ", a), s(a);
    })) : (console.warn("Ajax Load Error - No URL Set"), o([]));
  });
}
function Wf(i, e) {
  var t = [];
  if (e = e || "", Array.isArray(i))
    i.forEach((o, s) => {
      t = t.concat(Wf(o, e ? e + "[" + s + "]" : s));
    });
  else if (typeof i == "object")
    for (var r in i)
      t = t.concat(Wf(i[r], e ? e + "[" + r + "]" : r));
  else
    t.push({ key: e, value: i });
  return t;
}
var IB = {
  json: {
    headers: {
      "Content-Type": "application/json"
    },
    body: function(i, e, t) {
      return JSON.stringify(t);
    }
  },
  form: {
    headers: {},
    body: function(i, e, t) {
      var r = Wf(t), o = new FormData();
      return r.forEach(function(s) {
        o.append(s.key, s.value);
      }), o;
    }
  }
};
class xi extends ge {
  constructor(e) {
    super(e), this.config = {}, this.url = "", this.urlGenerator = !1, this.params = !1, this.loaderPromise = !1, this.registerTableOption("ajaxURL", !1), this.registerTableOption("ajaxURLGenerator", !1), this.registerTableOption("ajaxParams", {}), this.registerTableOption("ajaxConfig", "get"), this.registerTableOption("ajaxContentType", "form"), this.registerTableOption("ajaxRequestFunc", !1), this.registerTableOption("ajaxRequesting", function() {
    }), this.registerTableOption("ajaxResponse", !1), this.contentTypeFormatters = xi.contentTypeFormatters;
  }
  //initialize setup options
  initialize() {
    this.loaderPromise = this.table.options.ajaxRequestFunc || xi.defaultLoaderPromise, this.urlGenerator = this.table.options.ajaxURLGenerator || xi.defaultURLGenerator, this.table.options.ajaxURL && this.setUrl(this.table.options.ajaxURL), this.setDefaultConfig(this.table.options.ajaxConfig), this.registerTableFunction("getAjaxUrl", this.getUrl.bind(this)), this.subscribe("data-loading", this.requestDataCheck.bind(this)), this.subscribe("data-params", this.requestParams.bind(this)), this.subscribe("data-load", this.requestData.bind(this));
  }
  requestParams(e, t, r, o) {
    var s = this.table.options.ajaxParams;
    return s && (typeof s == "function" && (s = s.call(this.table)), o = Object.assign(o, s)), o;
  }
  requestDataCheck(e, t, r, o) {
    return !!(!e && this.url || typeof e == "string");
  }
  requestData(e, t, r, o, s) {
    var n;
    return !s && this.requestDataCheck(e) ? (e && this.setUrl(e), n = this.generateConfig(r), this.sendRequest(this.url, t, n)) : s;
  }
  setDefaultConfig(e = {}) {
    this.config = Object.assign({}, xi.defaultConfig), typeof e == "string" ? this.config.method = e : Object.assign(this.config, e);
  }
  //load config object
  generateConfig(e = {}) {
    var t = Object.assign({}, this.config);
    return typeof e == "string" ? t.method = e : Object.assign(t, e), t;
  }
  //set request url
  setUrl(e) {
    this.url = e;
  }
  //get request url
  getUrl() {
    return this.url;
  }
  //send ajax request
  sendRequest(e, t, r) {
    return this.table.options.ajaxRequesting.call(this.table, e, t) !== !1 ? this.loaderPromise(e, r, t).then((o) => (this.table.options.ajaxResponse && (o = this.table.options.ajaxResponse.call(this.table, e, t, o)), o)) : Promise.reject();
  }
}
xi.moduleName = "ajax";
xi.defaultConfig = AB;
xi.defaultURLGenerator = ev;
xi.defaultLoaderPromise = NB;
xi.contentTypeFormatters = IB;
var vB = {
  replace: function(i) {
    return this.table.setData(i);
  },
  update: function(i) {
    return this.table.updateOrAddData(i);
  },
  insert: function(i) {
    return this.table.addData(i);
  }
}, _B = {
  table: function(i) {
    var e = [], t = !0, r = this.table.columnManager.columns, o = [], s = [];
    return i = i.split(`
`), i.forEach(function(n) {
      e.push(n.split("	"));
    }), e.length && !(e.length === 1 && e[0].length < 2) ? (e[0].forEach(function(n) {
      var a = r.find(function(l) {
        return n && l.definition.title && n.trim() && l.definition.title.trim() === n.trim();
      });
      a ? o.push(a) : t = !1;
    }), t || (t = !0, o = [], e[0].forEach(function(n) {
      var a = r.find(function(l) {
        return n && l.field && n.trim() && l.field.trim() === n.trim();
      });
      a ? o.push(a) : t = !1;
    }), t || (o = this.table.columnManager.columnsByIndex)), t && e.shift(), e.forEach(function(n) {
      var a = {};
      n.forEach(function(l, u) {
        o[u] && (a[o[u].field] = l);
      }), s.push(a);
    }), s) : !1;
  }
};
class Ao extends ge {
  constructor(e) {
    super(e), this.mode = !0, this.pasteParser = function() {
    }, this.pasteAction = function() {
    }, this.customSelection = !1, this.rowRange = !1, this.blocked = !0, this.registerTableOption("clipboard", !1), this.registerTableOption("clipboardCopyStyled", !0), this.registerTableOption("clipboardCopyConfig", !1), this.registerTableOption("clipboardCopyFormatter", !1), this.registerTableOption("clipboardCopyRowRange", "active"), this.registerTableOption("clipboardPasteParser", "table"), this.registerTableOption("clipboardPasteAction", "insert"), this.registerColumnOption("clipboard"), this.registerColumnOption("titleClipboard");
  }
  initialize() {
    this.mode = this.table.options.clipboard, this.rowRange = this.table.options.clipboardCopyRowRange, (this.mode === !0 || this.mode === "copy") && this.table.element.addEventListener("copy", (e) => {
      var t, r, o;
      this.blocked || (e.preventDefault(), this.customSelection ? (t = this.customSelection, this.table.options.clipboardCopyFormatter && (t = this.table.options.clipboardCopyFormatter("plain", t))) : (o = this.table.modules.export.generateExportList(this.table.options.clipboardCopyConfig, this.table.options.clipboardCopyStyled, this.rowRange, "clipboard"), r = this.table.modules.export.generateHTMLTable(o), t = r ? this.generatePlainContent(o) : "", this.table.options.clipboardCopyFormatter && (t = this.table.options.clipboardCopyFormatter("plain", t), r = this.table.options.clipboardCopyFormatter("html", r))), window.clipboardData && window.clipboardData.setData ? window.clipboardData.setData("Text", t) : e.clipboardData && e.clipboardData.setData ? (e.clipboardData.setData("text/plain", t), r && e.clipboardData.setData("text/html", r)) : e.originalEvent && e.originalEvent.clipboardData.setData && (e.originalEvent.clipboardData.setData("text/plain", t), r && e.originalEvent.clipboardData.setData("text/html", r)), this.dispatchExternal("clipboardCopied", t, r), this.reset());
    }), (this.mode === !0 || this.mode === "paste") && this.table.element.addEventListener("paste", (e) => {
      this.paste(e);
    }), this.setPasteParser(this.table.options.clipboardPasteParser), this.setPasteAction(this.table.options.clipboardPasteAction), this.registerTableFunction("copyToClipboard", this.copy.bind(this));
  }
  reset() {
    this.blocked = !0, this.customSelection = !1;
  }
  generatePlainContent(e) {
    var t = [];
    return e.forEach((r) => {
      var o = [];
      r.columns.forEach((s) => {
        var n = "";
        if (s)
          if (r.type === "group" && (s.value = s.component.getKey()), s.value === null)
            n = "";
          else
            switch (typeof s.value) {
              case "object":
                n = JSON.stringify(s.value);
                break;
              case "undefined":
                n = "";
                break;
              default:
                n = s.value;
            }
        o.push(n);
      }), t.push(o.join("	"));
    }), t.join(`
`);
  }
  copy(e, t) {
    var r, o;
    this.blocked = !1, this.customSelection = !1, (this.mode === !0 || this.mode === "copy") && (this.rowRange = e || this.table.options.clipboardCopyRowRange, typeof window.getSelection < "u" && typeof document.createRange < "u" ? (e = document.createRange(), e.selectNodeContents(this.table.element), r = window.getSelection(), r.toString() && t && (this.customSelection = r.toString()), r.removeAllRanges(), r.addRange(e)) : typeof document.selection < "u" && typeof document.body.createTextRange < "u" && (o = document.body.createTextRange(), o.moveToElementText(this.table.element), o.select()), document.execCommand("copy"), r && r.removeAllRanges());
  }
  //PASTE EVENT HANDLING
  setPasteAction(e) {
    switch (typeof e) {
      case "string":
        this.pasteAction = Ao.pasteActions[e], this.pasteAction || console.warn("Clipboard Error - No such paste action found:", e);
        break;
      case "function":
        this.pasteAction = e;
        break;
    }
  }
  setPasteParser(e) {
    switch (typeof e) {
      case "string":
        this.pasteParser = Ao.pasteParsers[e], this.pasteParser || console.warn("Clipboard Error - No such paste parser found:", e);
        break;
      case "function":
        this.pasteParser = e;
        break;
    }
  }
  paste(e) {
    var t, r, o;
    this.checkPaseOrigin(e) && (t = this.getPasteData(e), r = this.pasteParser.call(this, t), r ? (e.preventDefault(), this.table.modExists("mutator") && (r = this.mutateData(r)), o = this.pasteAction.call(this, r), this.dispatchExternal("clipboardPasted", t, r, o)) : this.dispatchExternal("clipboardPasteError", t));
  }
  mutateData(e) {
    var t = [];
    return Array.isArray(e) ? e.forEach((r) => {
      t.push(this.table.modules.mutator.transformRow(r, "clipboard"));
    }) : t = e, t;
  }
  checkPaseOrigin(e) {
    var t = !0;
    return (e.target.tagName != "DIV" || this.table.modules.edit.currentCell) && (t = !1), t;
  }
  getPasteData(e) {
    var t;
    return window.clipboardData && window.clipboardData.getData ? t = window.clipboardData.getData("Text") : e.clipboardData && e.clipboardData.getData ? t = e.clipboardData.getData("text/plain") : e.originalEvent && e.originalEvent.clipboardData.getData && (t = e.originalEvent.clipboardData.getData("text/plain")), t;
  }
}
Ao.moduleName = "clipboard";
Ao.pasteActions = vB;
Ao.pasteParsers = _B;
class PB {
  constructor(e) {
    return this._row = e, new Proxy(this, {
      get: function(t, r, o) {
        return typeof t[r] < "u" ? t[r] : t._row.table.componentFunctionBinder.handle("row", t._row, r);
      }
    });
  }
  getData(e) {
    return this._row.getData(e);
  }
  getElement() {
    return this._row.getElement();
  }
  getTable() {
    return this._row.table;
  }
  getCells() {
    var e = [];
    return this._row.getCells().forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getCell(e) {
    var t = this._row.getCell(e);
    return t ? t.getComponent() : !1;
  }
  _getSelf() {
    return this._row;
  }
}
class tv {
  constructor(e) {
    return this._cell = e, new Proxy(this, {
      get: function(t, r, o) {
        return typeof t[r] < "u" ? t[r] : t._cell.table.componentFunctionBinder.handle("cell", t._cell, r);
      }
    });
  }
  getValue() {
    return this._cell.getValue();
  }
  getOldValue() {
    return this._cell.getOldValue();
  }
  getInitialValue() {
    return this._cell.initialValue;
  }
  getElement() {
    return this._cell.getElement();
  }
  getRow() {
    return this._cell.row.getComponent();
  }
  getData(e) {
    return this._cell.row.getData(e);
  }
  getType() {
    return "cell";
  }
  getField() {
    return this._cell.column.getField();
  }
  getColumn() {
    return this._cell.column.getComponent();
  }
  setValue(e, t) {
    typeof t > "u" && (t = !0), this._cell.setValue(e, t);
  }
  restoreOldValue() {
    this._cell.setValueActual(this._cell.getOldValue());
  }
  restoreInitialValue() {
    this._cell.setValueActual(this._cell.initialValue);
  }
  checkHeight() {
    this._cell.checkHeight();
  }
  getTable() {
    return this._cell.table;
  }
  _getSelf() {
    return this._cell;
  }
}
class ol extends Zt {
  constructor(e, t) {
    super(e.table), this.table = e.table, this.column = e, this.row = t, this.element = null, this.value = null, this.initialValue, this.oldValue = null, this.modules = {}, this.height = null, this.width = null, this.minWidth = null, this.component = null, this.loaded = !1, this.build();
  }
  //////////////// Setup Functions /////////////////
  //generate element
  build() {
    this.generateElement(), this.setWidth(), this._configureCell(), this.setValueActual(this.column.getFieldValue(this.row.data)), this.initialValue = this.value;
  }
  generateElement() {
    this.element = document.createElement("div"), this.element.className = "tabulator-cell", this.element.setAttribute("role", "gridcell");
  }
  _configureCell() {
    var e = this.element, t = this.column.getField(), r = {
      top: "flex-start",
      bottom: "flex-end",
      middle: "center"
    }, o = {
      left: "flex-start",
      right: "flex-end",
      center: "center"
    };
    if (e.style.textAlign = this.column.hozAlign, this.column.vertAlign && (e.style.display = "inline-flex", e.style.alignItems = r[this.column.vertAlign] || "", this.column.hozAlign && (e.style.justifyContent = o[this.column.hozAlign] || "")), t && e.setAttribute("tabulator-field", t), this.column.definition.cssClass) {
      var s = this.column.definition.cssClass.split(" ");
      s.forEach((n) => {
        e.classList.add(n);
      });
    }
    this.dispatch("cell-init", this), this.column.visible || this.hide();
  }
  //generate cell contents
  _generateContents() {
    var e;
    switch (e = this.chain("cell-format", this, null, () => this.element.innerHTML = this.value), typeof e) {
      case "object":
        if (e instanceof Node) {
          for (; this.element.firstChild; )
            this.element.removeChild(this.element.firstChild);
          this.element.appendChild(e);
        } else
          this.element.innerHTML = "", e != null && console.warn("Format Error - Formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", e);
        break;
      case "undefined":
        this.element.innerHTML = "";
        break;
      default:
        this.element.innerHTML = e;
    }
  }
  cellRendered() {
    this.dispatch("cell-rendered", this);
  }
  //////////////////// Getters ////////////////////
  getElement(e) {
    return this.loaded || (this.loaded = !0, e || this.layoutElement()), this.element;
  }
  getValue() {
    return this.value;
  }
  getOldValue() {
    return this.oldValue;
  }
  //////////////////// Actions ////////////////////
  setValue(e, t, r) {
    var o = this.setValueProcessData(e, t, r);
    o && (this.dispatch("cell-value-updated", this), this.cellRendered(), this.column.definition.cellEdited && this.column.definition.cellEdited.call(this.table, this.getComponent()), this.dispatchExternal("cellEdited", this.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()));
  }
  setValueProcessData(e, t, r) {
    var o = !1;
    return (this.value !== e || r) && (o = !0, t && (e = this.chain("cell-value-changing", [this, e], null, e))), this.setValueActual(e), o && this.dispatch("cell-value-changed", this), o;
  }
  setValueActual(e) {
    this.oldValue = this.value, this.value = e, this.dispatch("cell-value-save-before", this), this.column.setFieldValue(this.row.data, e), this.dispatch("cell-value-save-after", this), this.loaded && this.layoutElement();
  }
  layoutElement() {
    this._generateContents(), this.dispatch("cell-layout", this);
  }
  setWidth() {
    this.width = this.column.width, this.element.style.width = this.column.widthStyled;
  }
  clearWidth() {
    this.width = "", this.element.style.width = "";
  }
  getWidth() {
    return this.width || this.element.offsetWidth;
  }
  setMinWidth() {
    this.minWidth = this.column.minWidth, this.element.style.minWidth = this.column.minWidthStyled;
  }
  setMaxWidth() {
    this.maxWidth = this.column.maxWidth, this.element.style.maxWidth = this.column.maxWidthStyled;
  }
  checkHeight() {
    this.row.reinitializeHeight();
  }
  clearHeight() {
    this.element.style.height = "", this.height = null, this.dispatch("cell-height", this, "");
  }
  setHeight() {
    this.height = this.row.height, this.element.style.height = this.row.heightStyled, this.dispatch("cell-height", this, this.row.heightStyled);
  }
  getHeight() {
    return this.height || this.element.offsetHeight;
  }
  show() {
    this.element.style.display = this.column.vertAlign ? "inline-flex" : "";
  }
  hide() {
    this.element.style.display = "none";
  }
  delete() {
    this.dispatch("cell-delete", this), !this.table.rowManager.redrawBlock && this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = !1, this.column.deleteCell(this), this.row.deleteCell(this), this.calcs = {};
  }
  getIndex() {
    return this.row.getCellIndex(this);
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new tv(this)), this.component;
  }
}
class iv {
  constructor(e) {
    return this._column = e, this.type = "ColumnComponent", new Proxy(this, {
      get: function(t, r, o) {
        return typeof t[r] < "u" ? t[r] : t._column.table.componentFunctionBinder.handle("column", t._column, r);
      }
    });
  }
  getElement() {
    return this._column.getElement();
  }
  getDefinition() {
    return this._column.getDefinition();
  }
  getField() {
    return this._column.getField();
  }
  getTitleDownload() {
    return this._column.getTitleDownload();
  }
  getCells() {
    var e = [];
    return this._column.cells.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  isVisible() {
    return this._column.visible;
  }
  show() {
    this._column.isGroup ? this._column.columns.forEach(function(e) {
      e.show();
    }) : this._column.show();
  }
  hide() {
    this._column.isGroup ? this._column.columns.forEach(function(e) {
      e.hide();
    }) : this._column.hide();
  }
  toggle() {
    this._column.visible ? this.hide() : this.show();
  }
  delete() {
    return this._column.delete();
  }
  getSubColumns() {
    var e = [];
    return this._column.columns.length && this._column.columns.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getParentColumn() {
    return this._column.parent instanceof lr ? this._column.parent.getComponent() : !1;
  }
  _getSelf() {
    return this._column;
  }
  scrollTo(e, t) {
    return this._column.table.columnManager.scrollToColumn(this._column, e, t);
  }
  getTable() {
    return this._column.table;
  }
  move(e, t) {
    var r = this._column.table.columnManager.findColumn(e);
    r ? this._column.table.columnManager.moveColumn(this._column, r, t) : console.warn("Move Error - No matching column found:", r);
  }
  getNextColumn() {
    var e = this._column.nextColumn();
    return e ? e.getComponent() : !1;
  }
  getPrevColumn() {
    var e = this._column.prevColumn();
    return e ? e.getComponent() : !1;
  }
  updateDefinition(e) {
    return this._column.updateDefinition(e);
  }
  getWidth() {
    return this._column.getWidth();
  }
  setWidth(e) {
    var t;
    return e === !0 ? t = this._column.reinitializeWidth(!0) : t = this._column.setWidth(e), this._column.table.columnManager.rerenderColumns(!0), t;
  }
}
var rv = {
  title: void 0,
  field: void 0,
  columns: void 0,
  visible: void 0,
  hozAlign: void 0,
  vertAlign: void 0,
  width: void 0,
  minWidth: 40,
  maxWidth: void 0,
  maxInitialWidth: void 0,
  cssClass: void 0,
  variableHeight: void 0,
  headerVertical: void 0,
  headerHozAlign: void 0,
  headerWordWrap: !1,
  editableTitle: void 0
};
class lr extends Zt {
  constructor(e, t) {
    super(t.table), this.definition = e, this.parent = t, this.type = "column", this.columns = [], this.cells = [], this.element = this.createElement(), this.contentElement = !1, this.titleHolderElement = !1, this.titleElement = !1, this.groupElement = this.createGroupElement(), this.isGroup = !1, this.hozAlign = "", this.vertAlign = "", this.field = "", this.fieldStructure = "", this.getFieldValue = "", this.setFieldValue = "", this.titleDownload = null, this.titleFormatterRendered = !1, this.mapDefinitions(), this.setField(this.definition.field), this.modules = {}, this.width = null, this.widthStyled = "", this.maxWidth = null, this.maxWidthStyled = "", this.maxInitialWidth = null, this.minWidth = null, this.minWidthStyled = "", this.widthFixed = !1, this.visible = !0, this.component = null, this.definition.columns ? (this.isGroup = !0, this.definition.columns.forEach((r, o) => {
      var s = new lr(r, this);
      this.attachColumn(s);
    }), this.checkColumnVisibility()) : t.registerColumnField(this), this._initialize();
  }
  createElement() {
    var e = document.createElement("div");
    switch (e.classList.add("tabulator-col"), e.setAttribute("role", "columnheader"), e.setAttribute("aria-sort", "none"), this.table.options.columnHeaderVertAlign) {
      case "middle":
        e.style.justifyContent = "center";
        break;
      case "bottom":
        e.style.justifyContent = "flex-end";
        break;
    }
    return e;
  }
  createGroupElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col-group-cols"), e;
  }
  mapDefinitions() {
    var e = this.table.options.columnDefaults;
    if (e)
      for (let t in e)
        typeof this.definition[t] > "u" && (this.definition[t] = e[t]);
    this.definition = this.table.columnManager.optionsList.generate(lr.defaultOptionList, this.definition);
  }
  checkDefinition() {
    Object.keys(this.definition).forEach((e) => {
      lr.defaultOptionList.indexOf(e) === -1 && console.warn("Invalid column definition option in '" + (this.field || this.definition.title) + "' column:", e);
    });
  }
  setField(e) {
    this.field = e, this.fieldStructure = e ? this.table.options.nestedFieldSeparator ? e.split(this.table.options.nestedFieldSeparator) : [e] : [], this.getFieldValue = this.fieldStructure.length > 1 ? this._getNestedData : this._getFlatData, this.setFieldValue = this.fieldStructure.length > 1 ? this._setNestedData : this._setFlatData;
  }
  //register column position with column manager
  registerColumnPosition(e) {
    this.parent.registerColumnPosition(e);
  }
  //register column position with column manager
  registerColumnField(e) {
    this.parent.registerColumnField(e);
  }
  //trigger position registration
  reRegisterPosition() {
    this.isGroup ? this.columns.forEach(function(e) {
      e.reRegisterPosition();
    }) : this.registerColumnPosition(this);
  }
  //build header element
  _initialize() {
    for (var e = this.definition; this.element.firstChild; )
      this.element.removeChild(this.element.firstChild);
    e.headerVertical && (this.element.classList.add("tabulator-col-vertical"), e.headerVertical === "flip" && this.element.classList.add("tabulator-col-vertical-flip")), this.contentElement = this._buildColumnHeaderContent(), this.element.appendChild(this.contentElement), this.isGroup ? this._buildGroupHeader() : this._buildColumnHeader(), this.dispatch("column-init", this);
  }
  //build header element for header
  _buildColumnHeader() {
    var e = this.definition;
    if (this.dispatch("column-layout", this), typeof e.visible < "u" && (e.visible ? this.show(!0) : this.hide(!0)), e.cssClass) {
      var t = e.cssClass.split(" ");
      t.forEach((r) => {
        this.element.classList.add(r);
      });
    }
    e.field && this.element.setAttribute("tabulator-field", e.field), this.setMinWidth(parseInt(e.minWidth)), e.maxInitialWidth && (this.maxInitialWidth = parseInt(e.maxInitialWidth)), e.maxWidth && this.setMaxWidth(parseInt(e.maxWidth)), this.reinitializeWidth(), this.hozAlign = this.definition.hozAlign, this.vertAlign = this.definition.vertAlign, this.titleElement.style.textAlign = this.definition.headerHozAlign;
  }
  _buildColumnHeaderContent() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col-content"), this.titleHolderElement = document.createElement("div"), this.titleHolderElement.classList.add("tabulator-col-title-holder"), e.appendChild(this.titleHolderElement), this.titleElement = this._buildColumnHeaderTitle(), this.titleHolderElement.appendChild(this.titleElement), e;
  }
  //build title element of column
  _buildColumnHeaderTitle() {
    var e = this.definition, t = document.createElement("div");
    if (t.classList.add("tabulator-col-title"), e.headerWordWrap && t.classList.add("tabulator-col-title-wrap"), e.editableTitle) {
      var r = document.createElement("input");
      r.classList.add("tabulator-title-editor"), r.addEventListener("click", (o) => {
        o.stopPropagation(), r.focus();
      }), r.addEventListener("change", () => {
        e.title = r.value, this.dispatchExternal("columnTitleChanged", this.getComponent());
      }), t.appendChild(r), e.field ? this.langBind("columns|" + e.field, (o) => {
        r.value = o || e.title || "&nbsp;";
      }) : r.value = e.title || "&nbsp;";
    } else
      e.field ? this.langBind("columns|" + e.field, (o) => {
        this._formatColumnHeaderTitle(t, o || e.title || "&nbsp;");
      }) : this._formatColumnHeaderTitle(t, e.title || "&nbsp;");
    return t;
  }
  _formatColumnHeaderTitle(e, t) {
    var r = this.chain("column-format", [this, t, e], null, () => t);
    switch (typeof r) {
      case "object":
        r instanceof Node ? e.appendChild(r) : (e.innerHTML = "", console.warn("Format Error - Title formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", r));
        break;
      case "undefined":
        e.innerHTML = "";
        break;
      default:
        e.innerHTML = r;
    }
  }
  //build header element for column group
  _buildGroupHeader() {
    if (this.element.classList.add("tabulator-col-group"), this.element.setAttribute("role", "columngroup"), this.element.setAttribute("aria-title", this.definition.title), this.definition.cssClass) {
      var e = this.definition.cssClass.split(" ");
      e.forEach((t) => {
        this.element.classList.add(t);
      });
    }
    this.titleElement.style.textAlign = this.definition.headerHozAlign, this.element.appendChild(this.groupElement);
  }
  //flat field lookup
  _getFlatData(e) {
    return e[this.field];
  }
  //nested field lookup
  _getNestedData(e) {
    var t = e, r = this.fieldStructure, o = r.length, s;
    for (let n = 0; n < o && (t = t[r[n]], s = t, !!t); n++)
      ;
    return s;
  }
  //flat field set
  _setFlatData(e, t) {
    this.field && (e[this.field] = t);
  }
  //nested field set
  _setNestedData(e, t) {
    var r = e, o = this.fieldStructure, s = o.length;
    for (let n = 0; n < s; n++)
      if (n == s - 1)
        r[o[n]] = t;
      else {
        if (!r[o[n]])
          if (typeof t < "u")
            r[o[n]] = {};
          else
            break;
        r = r[o[n]];
      }
  }
  //attach column to this group
  attachColumn(e) {
    this.groupElement ? (this.columns.push(e), this.groupElement.appendChild(e.getElement()), e.columnRendered()) : console.warn("Column Warning - Column being attached to another column instead of column group");
  }
  //vertically align header in column
  verticalAlign(e, t) {
    var r = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : t || this.parent.getHeadersElement().clientHeight;
    this.element.style.height = r + "px", this.dispatch("column-height", this, this.element.style.height), this.isGroup && (this.groupElement.style.minHeight = r - this.contentElement.offsetHeight + "px"), this.columns.forEach(function(o) {
      o.verticalAlign(e);
    });
  }
  //clear vertical alignment
  clearVerticalAlign() {
    this.element.style.paddingTop = "", this.element.style.height = "", this.element.style.minHeight = "", this.groupElement.style.minHeight = "", this.columns.forEach(function(e) {
      e.clearVerticalAlign();
    }), this.dispatch("column-height", this, "");
  }
  //// Retrieve Column Information ////
  //return column header element
  getElement() {
    return this.element;
  }
  //return column group element
  getGroupElement() {
    return this.groupElement;
  }
  //return field name
  getField() {
    return this.field;
  }
  getTitleDownload() {
    return this.titleDownload;
  }
  //return the first column in a group
  getFirstColumn() {
    return this.isGroup ? this.columns.length ? this.columns[0].getFirstColumn() : !1 : this;
  }
  //return the last column in a group
  getLastColumn() {
    return this.isGroup ? this.columns.length ? this.columns[this.columns.length - 1].getLastColumn() : !1 : this;
  }
  //return all columns in a group
  getColumns(e) {
    var t = [];
    return e ? this.columns.forEach((r) => {
      t.push(r), t = t.concat(r.getColumns(!0));
    }) : t = this.columns, t;
  }
  //return all columns in a group
  getCells() {
    return this.cells;
  }
  //retrieve the top column in a group of columns
  getTopColumn() {
    return this.parent.isGroup ? this.parent.getTopColumn() : this;
  }
  //return column definition object
  getDefinition(e) {
    var t = [];
    return this.isGroup && e && (this.columns.forEach(function(r) {
      t.push(r.getDefinition(!0));
    }), this.definition.columns = t), this.definition;
  }
  //////////////////// Actions ////////////////////
  checkColumnVisibility() {
    var e = !1;
    this.columns.forEach(function(t) {
      t.visible && (e = !0);
    }), e ? (this.show(), this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !1)) : this.hide();
  }
  //show column
  show(e, t) {
    this.visible || (this.visible = !0, this.element.style.display = "", this.parent.isGroup && this.parent.checkColumnVisibility(), this.cells.forEach(function(r) {
      r.show();
    }), !this.isGroup && this.width === null && this.reinitializeWidth(), this.table.columnManager.verticalAlignHeaders(), this.dispatch("column-show", this, t), e || this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !0), this.parent.isGroup && this.parent.matchChildWidths(), this.silent || this.table.columnManager.rerenderColumns());
  }
  //hide column
  hide(e, t) {
    this.visible && (this.visible = !1, this.element.style.display = "none", this.table.columnManager.verticalAlignHeaders(), this.parent.isGroup && this.parent.checkColumnVisibility(), this.cells.forEach(function(r) {
      r.hide();
    }), this.dispatch("column-hide", this, t), e || this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !1), this.parent.isGroup && this.parent.matchChildWidths(), this.silent || this.table.columnManager.rerenderColumns());
  }
  matchChildWidths() {
    var e = 0;
    this.contentElement && this.columns.length && (this.columns.forEach(function(t) {
      t.visible && (e += t.getWidth());
    }), this.contentElement.style.maxWidth = e - 1 + "px", this.parent.isGroup && this.parent.matchChildWidths());
  }
  removeChild(e) {
    var t = this.columns.indexOf(e);
    t > -1 && this.columns.splice(t, 1), this.columns.length || this.delete();
  }
  setWidth(e) {
    this.widthFixed = !0, this.setWidthActual(e);
  }
  setWidthActual(e) {
    isNaN(e) && (e = Math.floor(this.table.element.clientWidth / 100 * parseInt(e))), e = Math.max(this.minWidth, e), this.maxWidth && (e = Math.min(this.maxWidth, e)), this.width = e, this.widthStyled = e ? e + "px" : "", this.element.style.width = this.widthStyled, this.isGroup || this.cells.forEach(function(t) {
      t.setWidth();
    }), this.parent.isGroup && this.parent.matchChildWidths(), this.dispatch("column-width", this);
  }
  checkCellHeights() {
    var e = [];
    this.cells.forEach(function(t) {
      t.row.heightInitialized && (t.row.getElement().offsetParent !== null ? (e.push(t.row), t.row.clearCellHeight()) : t.row.heightInitialized = !1);
    }), e.forEach(function(t) {
      t.calcHeight();
    }), e.forEach(function(t) {
      t.setCellHeight();
    });
  }
  getWidth() {
    var e = 0;
    return this.isGroup ? this.columns.forEach(function(t) {
      t.visible && (e += t.getWidth());
    }) : e = this.width, e;
  }
  getLeftOffset() {
    var e = this.element.offsetLeft;
    return this.parent.isGroup && (e += this.parent.getLeftOffset()), e;
  }
  getHeight() {
    return Math.ceil(this.element.getBoundingClientRect().height);
  }
  setMinWidth(e) {
    this.maxWidth && e > this.maxWidth && (e = this.maxWidth, console.warn("the minWidth (" + e + "px) for column '" + this.field + "' cannot be bigger that its maxWidth (" + this.maxWidthStyled + ")")), this.minWidth = e, this.minWidthStyled = e ? e + "px" : "", this.element.style.minWidth = this.minWidthStyled, this.cells.forEach(function(t) {
      t.setMinWidth();
    });
  }
  setMaxWidth(e) {
    this.minWidth && e < this.minWidth && (e = this.minWidth, console.warn("the maxWidth (" + e + "px) for column '" + this.field + "' cannot be smaller that its minWidth (" + this.minWidthStyled + ")")), this.maxWidth = e, this.maxWidthStyled = e ? e + "px" : "", this.element.style.maxWidth = this.maxWidthStyled, this.cells.forEach(function(t) {
      t.setMaxWidth();
    });
  }
  delete() {
    return new Promise((e, t) => {
      this.isGroup && this.columns.forEach(function(o) {
        o.delete();
      }), this.dispatch("column-delete", this);
      var r = this.cells.length;
      for (let o = 0; o < r; o++)
        this.cells[0].delete();
      this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = !1, this.contentElement = !1, this.titleElement = !1, this.groupElement = !1, this.parent.isGroup && this.parent.removeChild(this), this.table.columnManager.deregisterColumn(this), this.table.columnManager.rerenderColumns(!0), e();
    });
  }
  columnRendered() {
    this.titleFormatterRendered && this.titleFormatterRendered(), this.dispatch("column-rendered", this);
  }
  //////////////// Cell Management /////////////////
  //generate cell for this column
  generateCell(e) {
    var t = new ol(this, e);
    return this.cells.push(t), t;
  }
  nextColumn() {
    var e = this.table.columnManager.findColumnIndex(this);
    return e > -1 ? this._nextVisibleColumn(e + 1) : !1;
  }
  _nextVisibleColumn(e) {
    var t = this.table.columnManager.getColumnByIndex(e);
    return !t || t.visible ? t : this._nextVisibleColumn(e + 1);
  }
  prevColumn() {
    var e = this.table.columnManager.findColumnIndex(this);
    return e > -1 ? this._prevVisibleColumn(e - 1) : !1;
  }
  _prevVisibleColumn(e) {
    var t = this.table.columnManager.getColumnByIndex(e);
    return !t || t.visible ? t : this._prevVisibleColumn(e - 1);
  }
  reinitializeWidth(e) {
    this.widthFixed = !1, typeof this.definition.width < "u" && !e && this.setWidth(this.definition.width), this.dispatch("column-width-fit-before", this), this.fitToData(e), this.dispatch("column-width-fit-after", this);
  }
  //set column width to maximum cell width for non group columns
  fitToData(e) {
    if (!this.isGroup) {
      this.widthFixed || (this.element.style.width = "", this.cells.forEach((o) => {
        o.clearWidth();
      }));
      var t = this.element.offsetWidth;
      if ((!this.width || !this.widthFixed) && (this.cells.forEach((o) => {
        var s = o.getWidth();
        s > t && (t = s);
      }), t)) {
        var r = t + 1;
        this.maxInitialWidth && !e && (r = Math.min(r, this.maxInitialWidth)), this.setWidthActual(r);
      }
    }
  }
  updateDefinition(e) {
    var t;
    return this.isGroup || this.parent.isGroup ? (console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns"), Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups")) : (t = Object.assign({}, this.getDefinition()), t = Object.assign(t, e), this.table.columnManager.addColumn(t, !1, this).then((r) => (t.field == this.field && (this.field = !1), this.delete().then(() => r.getComponent()))));
  }
  deleteCell(e) {
    var t = this.cells.indexOf(e);
    t > -1 && this.cells.splice(t, 1);
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new iv(this)), this.component;
  }
}
lr.defaultOptionList = rv;
class tc {
  constructor(e) {
    return this._row = e, new Proxy(this, {
      get: function(t, r, o) {
        return typeof t[r] < "u" ? t[r] : t._row.table.componentFunctionBinder.handle("row", t._row, r);
      }
    });
  }
  getData(e) {
    return this._row.getData(e);
  }
  getElement() {
    return this._row.getElement();
  }
  getCells() {
    var e = [];
    return this._row.getCells().forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getCell(e) {
    var t = this._row.getCell(e);
    return t ? t.getComponent() : !1;
  }
  getIndex() {
    return this._row.getData("data")[this._row.table.options.index];
  }
  getPosition() {
    return this._row.getPosition();
  }
  watchPosition(e) {
    return this._row.watchPosition(e);
  }
  delete() {
    return this._row.delete();
  }
  scrollTo(e, t) {
    return this._row.table.rowManager.scrollToRow(this._row, e, t);
  }
  move(e, t) {
    this._row.moveToRow(e, t);
  }
  update(e) {
    return this._row.updateData(e);
  }
  normalizeHeight() {
    this._row.normalizeHeight(!0);
  }
  _getSelf() {
    return this._row;
  }
  reformat() {
    return this._row.reinitialize();
  }
  getTable() {
    return this._row.table;
  }
  getNextRow() {
    var e = this._row.nextRow();
    return e && e.getComponent();
  }
  getPrevRow() {
    var e = this._row.prevRow();
    return e && e.getComponent();
  }
}
class Qt extends Zt {
  constructor(e, t, r = "row") {
    super(t.table), this.parent = t, this.data = {}, this.type = r, this.element = !1, this.modules = {}, this.cells = [], this.height = 0, this.heightStyled = "", this.manualHeight = !1, this.outerHeight = 0, this.initialized = !1, this.heightInitialized = !1, this.position = 0, this.positionWatchers = [], this.component = null, this.created = !1, this.setData(e);
  }
  create() {
    this.created || (this.created = !0, this.generateElement());
  }
  createElement() {
    var e = document.createElement("div");
    e.classList.add("tabulator-row"), e.setAttribute("role", "row"), this.element = e;
  }
  getElement() {
    return this.create(), this.element;
  }
  detachElement() {
    this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
  }
  generateElement() {
    this.createElement(), this.dispatch("row-init", this);
  }
  generateCells() {
    this.cells = this.table.columnManager.generateCells(this);
  }
  //functions to setup on first render
  initialize(e) {
    if (this.create(), !this.initialized || e) {
      for (this.deleteCells(); this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      this.dispatch("row-layout-before", this), this.generateCells(), this.initialized = !0, this.table.columnManager.renderer.renderRowCells(this), e && this.normalizeHeight(), this.dispatch("row-layout", this), this.table.options.rowFormatter && this.table.options.rowFormatter(this.getComponent()), this.dispatch("row-layout-after", this);
    } else
      this.table.columnManager.renderer.rerenderRowCells(this);
  }
  reinitializeHeight() {
    this.heightInitialized = !1, this.element && this.element.offsetParent !== null && this.normalizeHeight(!0);
  }
  deinitialize() {
    this.initialized = !1;
  }
  deinitializeHeight() {
    this.heightInitialized = !1;
  }
  reinitialize(e) {
    this.initialized = !1, this.heightInitialized = !1, this.manualHeight || (this.height = 0, this.heightStyled = ""), this.element && this.element.offsetParent !== null && this.initialize(!0), this.dispatch("row-relayout", this);
  }
  //get heights when doing bulk row style calcs in virtual DOM
  calcHeight(e) {
    var t = 0, r;
    this.table.options.rowHeight ? this.height = this.table.options.rowHeight : (r = this.table.options.resizableRows ? this.element.clientHeight : 0, this.cells.forEach(function(o) {
      var s = o.getHeight();
      s > t && (t = s);
    }), e ? this.height = Math.max(t, r) : this.height = this.manualHeight ? this.height : Math.max(t, r)), this.heightStyled = this.height ? this.height + "px" : "", this.outerHeight = this.element.offsetHeight;
  }
  //set of cells
  setCellHeight() {
    this.cells.forEach(function(e) {
      e.setHeight();
    }), this.heightInitialized = !0;
  }
  clearCellHeight() {
    this.cells.forEach(function(e) {
      e.clearHeight();
    });
  }
  //normalize the height of elements in the row
  normalizeHeight(e) {
    e && !this.table.options.rowHeight && this.clearCellHeight(), this.calcHeight(e), this.setCellHeight();
  }
  //set height of rows
  setHeight(e, t) {
    (this.height != e || t) && (this.manualHeight = !0, this.height = e, this.heightStyled = e ? e + "px" : "", this.setCellHeight(), this.outerHeight = this.element.offsetHeight);
  }
  //return rows outer height
  getHeight() {
    return this.outerHeight;
  }
  //return rows outer Width
  getWidth() {
    return this.element.offsetWidth;
  }
  //////////////// Cell Management /////////////////
  deleteCell(e) {
    var t = this.cells.indexOf(e);
    t > -1 && this.cells.splice(t, 1);
  }
  //////////////// Data Management /////////////////
  setData(e) {
    this.data = this.chain("row-data-init-before", [this, e], void 0, e), this.dispatch("row-data-init-after", this);
  }
  //update the rows data
  updateData(e) {
    var t = this.element && Ge.elVisible(this.element), r = {}, o;
    return new Promise((s, n) => {
      typeof e == "string" && (e = JSON.parse(e)), this.dispatch("row-data-save-before", this), this.subscribed("row-data-changing") && (r = Object.assign(r, this.data), r = Object.assign(r, e)), o = this.chain("row-data-changing", [this, r, e], null, e);
      for (let a in o)
        this.data[a] = o[a];
      this.dispatch("row-data-save-after", this);
      for (let a in e)
        this.table.columnManager.getColumnsByFieldRoot(a).forEach((u) => {
          let h = this.getCell(u.getField());
          if (h) {
            let c = u.getFieldValue(o);
            h.getValue() !== c && (h.setValueProcessData(c), t && h.cellRendered());
          }
        });
      t ? (this.normalizeHeight(!0), this.table.options.rowFormatter && this.table.options.rowFormatter(this.getComponent())) : (this.initialized = !1, this.height = 0, this.heightStyled = ""), this.dispatch("row-data-changed", this, t, e), this.dispatchExternal("rowUpdated", this.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()), s();
    });
  }
  getData(e) {
    return e ? this.chain("row-data-retrieve", [this, e], null, this.data) : this.data;
  }
  getCell(e) {
    var t = !1;
    return e = this.table.columnManager.findColumn(e), !this.initialized && this.cells.length === 0 && this.generateCells(), t = this.cells.find(function(r) {
      return r.column === e;
    }), t;
  }
  getCellIndex(e) {
    return this.cells.findIndex(function(t) {
      return t === e;
    });
  }
  findCell(e) {
    return this.cells.find((t) => t.element === e);
  }
  getCells() {
    return !this.initialized && this.cells.length === 0 && this.generateCells(), this.cells;
  }
  nextRow() {
    var e = this.table.rowManager.nextDisplayRow(this, !0);
    return e || !1;
  }
  prevRow() {
    var e = this.table.rowManager.prevDisplayRow(this, !0);
    return e || !1;
  }
  moveToRow(e, t) {
    var r = this.table.rowManager.findRow(e);
    r ? (this.table.rowManager.moveRowActual(this, r, !t), this.table.rowManager.refreshActiveData("display", !1, !0)) : console.warn("Move Error - No matching row found:", e);
  }
  ///////////////////// Actions  /////////////////////
  delete() {
    return this.dispatch("row-delete", this), this.deleteActual(), Promise.resolve();
  }
  deleteActual(e) {
    this.detachModules(), this.table.rowManager.deleteRow(this, e), this.deleteCells(), this.initialized = !1, this.heightInitialized = !1, this.element = !1, this.dispatch("row-deleted", this);
  }
  detachModules() {
    this.dispatch("row-deleting", this);
  }
  deleteCells() {
    var e = this.cells.length;
    for (let t = 0; t < e; t++)
      this.cells[0].delete();
  }
  wipe() {
    if (this.detachModules(), this.deleteCells(), this.element) {
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      this.element.parentNode && this.element.parentNode.removeChild(this.element);
    }
    this.element = !1, this.modules = {};
  }
  isDisplayed() {
    return this.table.rowManager.getDisplayRows().includes(this);
  }
  getPosition() {
    return this.isDisplayed() ? this.position : !1;
  }
  setPosition(e) {
    e != this.position && (this.position = e, this.positionWatchers.forEach((t) => {
      t(this.position);
    }));
  }
  watchPosition(e) {
    this.positionWatchers.push(e), e(this.position);
  }
  getGroup() {
    return this.modules.group || !1;
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new tc(this)), this.component;
  }
}
var LB = {
  avg: function(i, e, t) {
    var r = 0, o = typeof t.precision < "u" ? t.precision : 2;
    return i.length && (r = i.reduce(function(s, n) {
      return Number(s) + Number(n);
    }), r = r / i.length, r = o !== !1 ? r.toFixed(o) : r), parseFloat(r).toString();
  },
  max: function(i, e, t) {
    var r = null, o = typeof t.precision < "u" ? t.precision : !1;
    return i.forEach(function(s) {
      s = Number(s), (s > r || r === null) && (r = s);
    }), r !== null ? o !== !1 ? r.toFixed(o) : r : "";
  },
  min: function(i, e, t) {
    var r = null, o = typeof t.precision < "u" ? t.precision : !1;
    return i.forEach(function(s) {
      s = Number(s), (s < r || r === null) && (r = s);
    }), r !== null ? o !== !1 ? r.toFixed(o) : r : "";
  },
  sum: function(i, e, t) {
    var r = 0, o = typeof t.precision < "u" ? t.precision : !1;
    return i.length && i.forEach(function(s) {
      s = Number(s), r += isNaN(s) ? 0 : Number(s);
    }), o !== !1 ? r.toFixed(o) : r;
  },
  concat: function(i, e, t) {
    var r = 0;
    return i.length && (r = i.reduce(function(o, s) {
      return String(o) + String(s);
    })), r;
  },
  count: function(i, e, t) {
    var r = 0;
    return i.length && i.forEach(function(o) {
      o && r++;
    }), r;
  },
  unique: function(i, e, t) {
    var r = i.filter((o, s) => (i || o === 0) && i.indexOf(o) === s);
    return r.length;
  }
};
class Tr extends ge {
  constructor(e) {
    super(e), this.topCalcs = [], this.botCalcs = [], this.genColumn = !1, this.topElement = this.createElement(), this.botElement = this.createElement(), this.topRow = !1, this.botRow = !1, this.topInitialized = !1, this.botInitialized = !1, this.blocked = !1, this.recalcAfterBlock = !1, this.registerTableOption("columnCalcs", !0), this.registerColumnOption("topCalc"), this.registerColumnOption("topCalcParams"), this.registerColumnOption("topCalcFormatter"), this.registerColumnOption("topCalcFormatterParams"), this.registerColumnOption("bottomCalc"), this.registerColumnOption("bottomCalcParams"), this.registerColumnOption("bottomCalcFormatter"), this.registerColumnOption("bottomCalcFormatterParams");
  }
  createElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-calcs-holder"), e;
  }
  initialize() {
    this.genColumn = new lr({ field: "value" }, this), this.subscribe("cell-value-changed", this.cellValueChanged.bind(this)), this.subscribe("column-init", this.initializeColumnCheck.bind(this)), this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this)), this.subscribe("row-added", this.rowsUpdated.bind(this)), this.subscribe("column-moved", this.recalcActiveRows.bind(this)), this.subscribe("column-add", this.recalcActiveRows.bind(this)), this.subscribe("data-refreshed", this.recalcActiveRowsRefresh.bind(this)), this.subscribe("table-redraw", this.tableRedraw.bind(this)), this.subscribe("rows-visible", this.visibleRows.bind(this)), this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this)), this.subscribe("redraw-blocked", this.blockRedraw.bind(this)), this.subscribe("redraw-restored", this.restoreRedraw.bind(this)), this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this)), this.subscribe("column-resized", this.resizeHolderWidth.bind(this)), this.subscribe("column-show", this.resizeHolderWidth.bind(this)), this.subscribe("column-hide", this.resizeHolderWidth.bind(this)), this.registerTableFunction("getCalcResults", this.getResults.bind(this)), this.registerTableFunction("recalc", this.userRecalc.bind(this)), this.resizeHolderWidth();
  }
  resizeHolderWidth() {
    this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
  }
  tableRedraw(e) {
    this.recalc(this.table.rowManager.activeRows), e && this.redraw();
  }
  blockRedraw() {
    this.blocked = !0, this.recalcAfterBlock = !1;
  }
  restoreRedraw() {
    this.blocked = !1, this.recalcAfterBlock && (this.recalcAfterBlock = !1, this.recalcActiveRowsRefresh());
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userRecalc() {
    this.recalc(this.table.rowManager.activeRows);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  blockCheck() {
    return this.blocked && (this.recalcAfterBlock = !0), this.blocked;
  }
  visibleRows(e, t) {
    return this.topRow && t.unshift(this.topRow), this.botRow && t.push(this.botRow), t;
  }
  rowsUpdated(e) {
    this.table.options.groupBy ? this.recalcRowGroup(e) : this.recalcActiveRows();
  }
  recalcActiveRowsRefresh() {
    this.table.options.groupBy && this.table.options.dataTreeStartExpanded && this.table.options.dataTree ? this.recalcAll() : this.recalcActiveRows();
  }
  recalcActiveRows() {
    this.recalc(this.table.rowManager.activeRows);
  }
  cellValueChanged(e) {
    (e.column.definition.topCalc || e.column.definition.bottomCalc) && (this.table.options.groupBy ? ((this.table.options.columnCalcs == "table" || this.table.options.columnCalcs == "both") && this.recalcActiveRows(), this.table.options.columnCalcs != "table" && this.recalcRowGroup(e.row)) : this.recalcActiveRows());
  }
  initializeColumnCheck(e) {
    (e.definition.topCalc || e.definition.bottomCalc) && this.initializeColumn(e);
  }
  //initialize column calcs
  initializeColumn(e) {
    var t = e.definition, r = {
      topCalcParams: t.topCalcParams || {},
      botCalcParams: t.bottomCalcParams || {}
    };
    if (t.topCalc) {
      switch (typeof t.topCalc) {
        case "string":
          Tr.calculations[t.topCalc] ? r.topCalc = Tr.calculations[t.topCalc] : console.warn("Column Calc Error - No such calculation found, ignoring: ", t.topCalc);
          break;
        case "function":
          r.topCalc = t.topCalc;
          break;
      }
      r.topCalc && (e.modules.columnCalcs = r, this.topCalcs.push(e), this.table.options.columnCalcs != "group" && this.initializeTopRow());
    }
    if (t.bottomCalc) {
      switch (typeof t.bottomCalc) {
        case "string":
          Tr.calculations[t.bottomCalc] ? r.botCalc = Tr.calculations[t.bottomCalc] : console.warn("Column Calc Error - No such calculation found, ignoring: ", t.bottomCalc);
          break;
        case "function":
          r.botCalc = t.bottomCalc;
          break;
      }
      r.botCalc && (e.modules.columnCalcs = r, this.botCalcs.push(e), this.table.options.columnCalcs != "group" && this.initializeBottomRow());
    }
  }
  //dummy functions to handle being mock column manager
  registerColumnField() {
  }
  removeCalcs() {
    var e = !1;
    this.topInitialized && (this.topInitialized = !1, this.topElement.parentNode.removeChild(this.topElement), e = !0), this.botInitialized && (this.botInitialized = !1, this.footerRemove(this.botElement), e = !0), e && this.table.rowManager.adjustTableSize();
  }
  reinitializeCalcs() {
    this.topCalcs.length && this.initializeTopRow(), this.botCalcs.length && this.initializeBottomRow();
  }
  initializeTopRow() {
    this.topInitialized || (this.table.columnManager.getContentsElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling), this.topInitialized = !0);
  }
  initializeBottomRow() {
    this.botInitialized || (this.footerPrepend(this.botElement), this.botInitialized = !0);
  }
  scrollHorizontal(e) {
    this.botInitialized && this.botRow && (this.botElement.scrollLeft = e);
  }
  recalc(e) {
    var t, r;
    if (!this.blockCheck() && (this.topInitialized || this.botInitialized)) {
      if (t = this.rowsToData(e), this.topInitialized) {
        for (this.topRow && this.topRow.deleteCells(), r = this.generateRow("top", t), this.topRow = r; this.topElement.firstChild; )
          this.topElement.removeChild(this.topElement.firstChild);
        this.topElement.appendChild(r.getElement()), r.initialize(!0);
      }
      if (this.botInitialized) {
        for (this.botRow && this.botRow.deleteCells(), r = this.generateRow("bottom", t), this.botRow = r; this.botElement.firstChild; )
          this.botElement.removeChild(this.botElement.firstChild);
        this.botElement.appendChild(r.getElement()), r.initialize(!0);
      }
      this.table.rowManager.adjustTableSize(), this.table.modExists("frozenColumns") && this.table.modules.frozenColumns.layout();
    }
  }
  recalcRowGroup(e) {
    this.recalcGroup(this.table.modules.groupRows.getRowGroup(e));
  }
  recalcAll() {
    if ((this.topCalcs.length || this.botCalcs.length) && (this.table.options.columnCalcs !== "group" && this.recalcActiveRows(), this.table.options.groupBy && this.table.options.columnCalcs !== "table")) {
      var e = this.table.modules.groupRows.getChildGroups();
      e.forEach((t) => {
        this.recalcGroup(t);
      });
    }
  }
  recalcGroup(e) {
    var t, r;
    this.blockCheck() || e && e.calcs && (e.calcs.bottom && (t = this.rowsToData(e.rows), r = this.generateRowData("bottom", t), e.calcs.bottom.updateData(r), e.calcs.bottom.reinitialize()), e.calcs.top && (t = this.rowsToData(e.rows), r = this.generateRowData("top", t), e.calcs.top.updateData(r), e.calcs.top.reinitialize()));
  }
  //generate top stats row
  generateTopRow(e) {
    return this.generateRow("top", this.rowsToData(e));
  }
  //generate bottom stats row
  generateBottomRow(e) {
    return this.generateRow("bottom", this.rowsToData(e));
  }
  rowsToData(e) {
    var t = [];
    return e.forEach((r) => {
      if (t.push(r.getData()), this.table.options.dataTree && this.table.options.dataTreeChildColumnCalcs && r.modules.dataTree && r.modules.dataTree.open) {
        var o = this.rowsToData(this.table.modules.dataTree.getFilteredTreeChildren(r));
        t = t.concat(o);
      }
    }), t;
  }
  //generate stats row
  generateRow(e, t) {
    var r = this.generateRowData(e, t), o;
    return this.table.modExists("mutator") && this.table.modules.mutator.disable(), o = new Qt(r, this, "calc"), this.table.modExists("mutator") && this.table.modules.mutator.enable(), o.getElement().classList.add("tabulator-calcs", "tabulator-calcs-" + e), o.component = !1, o.getComponent = () => (o.component || (o.component = new PB(o)), o.component), o.generateCells = () => {
      var s = [];
      this.table.columnManager.columnsByIndex.forEach((n) => {
        this.genColumn.setField(n.getField()), this.genColumn.hozAlign = n.hozAlign, n.definition[e + "CalcFormatter"] && this.table.modExists("format") ? this.genColumn.modules.format = {
          formatter: this.table.modules.format.getFormatter(n.definition[e + "CalcFormatter"]),
          params: n.definition[e + "CalcFormatterParams"] || {}
        } : this.genColumn.modules.format = {
          formatter: this.table.modules.format.getFormatter("plaintext"),
          params: {}
        }, this.genColumn.definition.cssClass = n.definition.cssClass;
        var a = new ol(this.genColumn, o);
        a.getElement(), a.column = n, a.setWidth(), n.cells.push(a), s.push(a), n.visible || a.hide();
      }), o.cells = s;
    }, o;
  }
  //generate stats row
  generateRowData(e, t) {
    var r = {}, o = e == "top" ? this.topCalcs : this.botCalcs, s = e == "top" ? "topCalc" : "botCalc", n, a;
    return o.forEach(function(l) {
      var u = [];
      l.modules.columnCalcs && l.modules.columnCalcs[s] && (t.forEach(function(h) {
        u.push(l.getFieldValue(h));
      }), a = s + "Params", n = typeof l.modules.columnCalcs[a] == "function" ? l.modules.columnCalcs[a](u, t) : l.modules.columnCalcs[a], l.setFieldValue(r, l.modules.columnCalcs[s](u, t, n)));
    }), r;
  }
  hasTopCalcs() {
    return !!this.topCalcs.length;
  }
  hasBottomCalcs() {
    return !!this.botCalcs.length;
  }
  //handle table redraw
  redraw() {
    this.topRow && this.topRow.normalizeHeight(!0), this.botRow && this.botRow.normalizeHeight(!0);
  }
  //return the calculated
  getResults() {
    var e = {}, t;
    return this.table.options.groupBy && this.table.modExists("groupRows") ? (t = this.table.modules.groupRows.getGroups(!0), t.forEach((r) => {
      e[r.getKey()] = this.getGroupResults(r);
    })) : e = {
      top: this.topRow ? this.topRow.getData() : {},
      bottom: this.botRow ? this.botRow.getData() : {}
    }, e;
  }
  //get results from a group
  getGroupResults(e) {
    var t = e._getSelf(), r = e.getSubGroups(), o = {}, s = {};
    return r.forEach((n) => {
      o[n.getKey()] = this.getGroupResults(n);
    }), s = {
      top: t.calcs.top ? t.calcs.top.getData() : {},
      bottom: t.calcs.bottom ? t.calcs.bottom.getData() : {},
      groups: o
    }, s;
  }
  adjustForScrollbar(e) {
    this.botRow && (this.table.rtl ? this.botElement.style.paddingLeft = e + "px" : this.botElement.style.paddingRight = e + "px");
  }
}
Tr.moduleName = "columnCalcs";
Tr.calculations = LB;
class xO extends ge {
  constructor(e) {
    super(e), this.indent = 10, this.field = "", this.collapseEl = null, this.expandEl = null, this.branchEl = null, this.elementField = !1, this.startOpen = function() {
    }, this.registerTableOption("dataTree", !1), this.registerTableOption("dataTreeFilter", !0), this.registerTableOption("dataTreeSort", !0), this.registerTableOption("dataTreeElementColumn", !1), this.registerTableOption("dataTreeBranchElement", !0), this.registerTableOption("dataTreeChildIndent", 9), this.registerTableOption("dataTreeChildField", "_children"), this.registerTableOption("dataTreeCollapseElement", !1), this.registerTableOption("dataTreeExpandElement", !1), this.registerTableOption("dataTreeStartExpanded", !1), this.registerTableOption("dataTreeChildColumnCalcs", !1), this.registerTableOption("dataTreeSelectPropagate", !1), this.registerComponentFunction("row", "treeCollapse", this.collapseRow.bind(this)), this.registerComponentFunction("row", "treeExpand", this.expandRow.bind(this)), this.registerComponentFunction("row", "treeToggle", this.toggleRow.bind(this)), this.registerComponentFunction("row", "getTreeParent", this.getTreeParent.bind(this)), this.registerComponentFunction("row", "getTreeChildren", this.getRowChildren.bind(this)), this.registerComponentFunction("row", "addTreeChild", this.addTreeChildRow.bind(this)), this.registerComponentFunction("row", "isTreeExpanded", this.isRowExpanded.bind(this));
  }
  initialize() {
    if (this.table.options.dataTree) {
      var e = null, t = this.table.options;
      switch (this.field = t.dataTreeChildField, this.indent = t.dataTreeChildIndent, this.options("movableRows") && console.warn("The movableRows option is not available with dataTree enabled, moving of child rows could result in unpredictable behavior"), t.dataTreeBranchElement && (t.dataTreeBranchElement === !0 ? (this.branchEl = document.createElement("div"), this.branchEl.classList.add("tabulator-data-tree-branch")) : typeof t.dataTreeBranchElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeBranchElement, this.branchEl = e.firstChild) : this.branchEl = t.dataTreeBranchElement), t.dataTreeCollapseElement ? typeof t.dataTreeCollapseElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeCollapseElement, this.collapseEl = e.firstChild) : this.collapseEl = t.dataTreeCollapseElement : (this.collapseEl = document.createElement("div"), this.collapseEl.classList.add("tabulator-data-tree-control"), this.collapseEl.tabIndex = 0, this.collapseEl.innerHTML = "<div class='tabulator-data-tree-control-collapse'></div>"), t.dataTreeExpandElement ? typeof t.dataTreeExpandElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeExpandElement, this.expandEl = e.firstChild) : this.expandEl = t.dataTreeExpandElement : (this.expandEl = document.createElement("div"), this.expandEl.classList.add("tabulator-data-tree-control"), this.expandEl.tabIndex = 0, this.expandEl.innerHTML = "<div class='tabulator-data-tree-control-expand'></div>"), typeof t.dataTreeStartExpanded) {
        case "boolean":
          this.startOpen = function(r, o) {
            return t.dataTreeStartExpanded;
          };
          break;
        case "function":
          this.startOpen = t.dataTreeStartExpanded;
          break;
        default:
          this.startOpen = function(r, o) {
            return t.dataTreeStartExpanded[o];
          };
          break;
      }
      this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-layout-after", this.layoutRow.bind(this)), this.subscribe("row-deleted", this.rowDelete.bind(this), 0), this.subscribe("row-data-changed", this.rowDataChanged.bind(this), 10), this.subscribe("cell-value-updated", this.cellValueChanged.bind(this)), this.subscribe("edit-cancelled", this.cellValueChanged.bind(this)), this.subscribe("column-moving-rows", this.columnMoving.bind(this)), this.subscribe("table-built", this.initializeElementField.bind(this)), this.subscribe("table-redrawing", this.tableRedrawing.bind(this)), this.registerDisplayHandler(this.getRows.bind(this), 30);
    }
  }
  tableRedrawing(e) {
    var t;
    e && (t = this.table.rowManager.getRows(), t.forEach((r) => {
      this.reinitializeRowChildren(r);
    }));
  }
  initializeElementField() {
    var e = this.table.columnManager.getFirstVisibleColumn();
    this.elementField = this.table.options.dataTreeElementColumn || (e ? e.field : !1);
  }
  getRowChildren(e) {
    return this.getTreeChildren(e, !0);
  }
  columnMoving() {
    var e = [];
    return this.table.rowManager.rows.forEach((t) => {
      e = e.concat(this.getTreeChildren(t, !1, !0));
    }), e;
  }
  rowDataChanged(e, t, r) {
    this.redrawNeeded(r) && (this.initializeRow(e), t && (this.layoutRow(e), this.refreshData(!0)));
  }
  cellValueChanged(e) {
    var t = e.column.getField();
    t === this.elementField && this.layoutRow(e.row);
  }
  initializeRow(e) {
    var t = e.getData()[this.field], r = Array.isArray(t), o = r || !r && typeof t == "object" && t !== null;
    !o && e.modules.dataTree && e.modules.dataTree.branchEl && e.modules.dataTree.branchEl.parentNode.removeChild(e.modules.dataTree.branchEl), !o && e.modules.dataTree && e.modules.dataTree.controlEl && e.modules.dataTree.controlEl.parentNode.removeChild(e.modules.dataTree.controlEl), e.modules.dataTree = {
      index: e.modules.dataTree ? e.modules.dataTree.index : 0,
      open: o ? e.modules.dataTree ? e.modules.dataTree.open : this.startOpen(e.getComponent(), 0) : !1,
      controlEl: e.modules.dataTree && o ? e.modules.dataTree.controlEl : !1,
      branchEl: e.modules.dataTree && o ? e.modules.dataTree.branchEl : !1,
      parent: e.modules.dataTree ? e.modules.dataTree.parent : !1,
      children: o
    };
  }
  reinitializeRowChildren(e) {
    var t = this.getTreeChildren(e, !1, !0);
    t.forEach(function(r) {
      r.reinitialize(!0);
    });
  }
  layoutRow(e) {
    var t = this.elementField ? e.getCell(this.elementField) : e.getCells()[0], r = t.getElement(), o = e.modules.dataTree;
    o.branchEl && (o.branchEl.parentNode && o.branchEl.parentNode.removeChild(o.branchEl), o.branchEl = !1), o.controlEl && (o.controlEl.parentNode && o.controlEl.parentNode.removeChild(o.controlEl), o.controlEl = !1), this.generateControlElement(e, r), e.getElement().classList.add("tabulator-tree-level-" + o.index), o.index && (this.branchEl ? (o.branchEl = this.branchEl.cloneNode(!0), r.insertBefore(o.branchEl, r.firstChild), this.table.rtl ? o.branchEl.style.marginRight = (o.branchEl.offsetWidth + o.branchEl.style.marginLeft) * (o.index - 1) + o.index * this.indent + "px" : o.branchEl.style.marginLeft = (o.branchEl.offsetWidth + o.branchEl.style.marginRight) * (o.index - 1) + o.index * this.indent + "px") : this.table.rtl ? r.style.paddingRight = parseInt(window.getComputedStyle(r, null).getPropertyValue("padding-right")) + o.index * this.indent + "px" : r.style.paddingLeft = parseInt(window.getComputedStyle(r, null).getPropertyValue("padding-left")) + o.index * this.indent + "px");
  }
  generateControlElement(e, t) {
    var r = e.modules.dataTree, o = r.controlEl;
    t = t || e.getCells()[0].getElement(), r.children !== !1 && (r.open ? (r.controlEl = this.collapseEl.cloneNode(!0), r.controlEl.addEventListener("click", (s) => {
      s.stopPropagation(), this.collapseRow(e);
    })) : (r.controlEl = this.expandEl.cloneNode(!0), r.controlEl.addEventListener("click", (s) => {
      s.stopPropagation(), this.expandRow(e);
    })), r.controlEl.addEventListener("mousedown", (s) => {
      s.stopPropagation();
    }), o && o.parentNode === t ? o.parentNode.replaceChild(r.controlEl, o) : t.insertBefore(r.controlEl, t.firstChild));
  }
  getRows(e) {
    var t = [];
    return e.forEach((r, o) => {
      var s, n;
      t.push(r), r instanceof Qt && (r.create(), s = r.modules.dataTree, !s.index && s.children !== !1 && (n = this.getChildren(r), n.forEach((a) => {
        a.create(), t.push(a);
      })));
    }), t;
  }
  getChildren(e, t) {
    var r = e.modules.dataTree, o = [], s = [];
    return r.children !== !1 && (r.open || t) && (Array.isArray(r.children) || (r.children = this.generateChildren(e)), this.table.modExists("filter") && this.table.options.dataTreeFilter ? o = this.table.modules.filter.filter(r.children) : o = r.children, this.table.modExists("sort") && this.table.options.dataTreeSort && this.table.modules.sort.sort(o), o.forEach((n) => {
      s.push(n);
      var a = this.getChildren(n);
      a.forEach((l) => {
        s.push(l);
      });
    })), s;
  }
  generateChildren(e) {
    var t = [], r = e.getData()[this.field];
    return Array.isArray(r) || (r = [r]), r.forEach((o) => {
      var s = new Qt(o || {}, this.table.rowManager);
      s.create(), s.modules.dataTree.index = e.modules.dataTree.index + 1, s.modules.dataTree.parent = e, s.modules.dataTree.children && (s.modules.dataTree.open = this.startOpen(s.getComponent(), s.modules.dataTree.index)), t.push(s);
    }), t;
  }
  expandRow(e, t) {
    var r = e.modules.dataTree;
    r.children !== !1 && (r.open = !0, e.reinitialize(), this.refreshData(!0), this.dispatchExternal("dataTreeRowExpanded", e.getComponent(), e.modules.dataTree.index));
  }
  collapseRow(e) {
    var t = e.modules.dataTree;
    t.children !== !1 && (t.open = !1, e.reinitialize(), this.refreshData(!0), this.dispatchExternal("dataTreeRowCollapsed", e.getComponent(), e.modules.dataTree.index));
  }
  toggleRow(e) {
    var t = e.modules.dataTree;
    t.children !== !1 && (t.open ? this.collapseRow(e) : this.expandRow(e));
  }
  isRowExpanded(e) {
    return e.modules.dataTree.open;
  }
  getTreeParent(e) {
    return e.modules.dataTree.parent ? e.modules.dataTree.parent.getComponent() : !1;
  }
  getTreeParentRoot(e) {
    return e.modules.dataTree && e.modules.dataTree.parent ? this.getTreeParentRoot(e.modules.dataTree.parent) : e;
  }
  getFilteredTreeChildren(e) {
    var t = e.modules.dataTree, r = [], o;
    return t.children && (Array.isArray(t.children) || (t.children = this.generateChildren(e)), this.table.modExists("filter") && this.table.options.dataTreeFilter ? o = this.table.modules.filter.filter(t.children) : o = t.children, o.forEach((s) => {
      s instanceof Qt && r.push(s);
    })), r;
  }
  rowDelete(e) {
    var t = e.modules.dataTree.parent, r;
    t && (r = this.findChildIndex(e, t), r !== !1 && t.data[this.field].splice(r, 1), t.data[this.field].length || delete t.data[this.field], this.initializeRow(t), this.layoutRow(t)), this.refreshData(!0);
  }
  addTreeChildRow(e, t, r, o) {
    var s = !1;
    typeof t == "string" && (t = JSON.parse(t)), Array.isArray(e.data[this.field]) || (e.data[this.field] = [], e.modules.dataTree.open = this.startOpen(e.getComponent(), e.modules.dataTree.index)), typeof o < "u" && (s = this.findChildIndex(o, e), s !== !1 && e.data[this.field].splice(r ? s : s + 1, 0, t)), s === !1 && (r ? e.data[this.field].unshift(t) : e.data[this.field].push(t)), this.initializeRow(e), this.layoutRow(e), this.refreshData(!0);
  }
  findChildIndex(e, t) {
    var r = !1;
    return typeof e == "object" ? e instanceof Qt ? r = e.data : e instanceof tc ? r = e._getSelf().data : typeof HTMLElement < "u" && e instanceof HTMLElement ? t.modules.dataTree && (r = t.modules.dataTree.children.find((o) => o instanceof Qt ? o.element === e : !1), r && (r = r.data)) : e === null && (r = !1) : typeof e > "u" ? r = !1 : r = t.data[this.field].find((o) => o.data[this.table.options.index] == e), r && (Array.isArray(t.data[this.field]) && (r = t.data[this.field].indexOf(r)), r == -1 && (r = !1)), r;
  }
  getTreeChildren(e, t, r) {
    var o = e.modules.dataTree, s = [];
    return o.children && (Array.isArray(o.children) || (o.children = this.generateChildren(e)), o.children.forEach((n) => {
      n instanceof Qt && (s.push(t ? n.getComponent() : n), r && (s = s.concat(this.getTreeChildren(n, t, r))));
    })), s;
  }
  getChildField() {
    return this.field;
  }
  redrawNeeded(e) {
    return (this.field ? typeof e[this.field] < "u" : !1) || (this.elementField ? typeof e[this.elementField] < "u" : !1);
  }
}
xO.moduleName = "dataTree";
function wB(i, e = {}, t) {
  var r = e.delimiter ? e.delimiter : ",", o = [], s = [];
  i.forEach((n) => {
    var a = [];
    switch (n.type) {
      case "group":
        console.warn("Download Warning - CSV downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - CSV downloader cannot process column calculations");
        break;
      case "header":
        n.columns.forEach((l, u) => {
          l && l.depth === 1 && (s[u] = typeof l.value > "u" || l.value === null ? "" : '"' + String(l.value).split('"').join('""') + '"');
        });
        break;
      case "row":
        n.columns.forEach((l) => {
          if (l) {
            switch (typeof l.value) {
              case "object":
                l.value = l.value !== null ? JSON.stringify(l.value) : "";
                break;
              case "undefined":
                l.value = "";
                break;
            }
            a.push('"' + String(l.value).split('"').join('""') + '"');
          }
        }), o.push(a.join(r));
        break;
    }
  }), s.length && o.unshift(s.join(r)), o = o.join(`
`), e.bom && (o = "\uFEFF" + o), t(o, "text/csv");
}
function yB(i, e, t) {
  var r = [];
  i.forEach((o) => {
    var s = {};
    switch (o.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        o.columns.forEach((n) => {
          n && (s[n.component.getTitleDownload() || n.component.getField()] = n.value);
        }), r.push(s);
        break;
    }
  }), r = JSON.stringify(r, null, "	"), t(r, "application/json");
}
function DB(i, e = {}, t) {
  var r = [], o = [], s = {}, n = e.rowGroupStyles || {
    fontStyle: "bold",
    fontSize: 12,
    cellPadding: 6,
    fillColor: 220
  }, a = e.rowCalcStyles || {
    fontStyle: "bold",
    fontSize: 10,
    cellPadding: 4,
    fillColor: 232
  }, l = e.jsPDF || {}, u = e.title ? e.title : "";
  l.orientation || (l.orientation = e.orientation || "landscape"), l.unit || (l.unit = "pt"), i.forEach((d) => {
    switch (d.type) {
      case "header":
        r.push(h(d));
        break;
      case "group":
        o.push(h(d, n));
        break;
      case "calc":
        o.push(h(d, a));
        break;
      case "row":
        o.push(h(d));
        break;
    }
  });
  function h(d, f) {
    var p = [];
    return d.columns.forEach((O) => {
      var m;
      if (O) {
        switch (typeof O.value) {
          case "object":
            O.value = O.value !== null ? JSON.stringify(O.value) : "";
            break;
          case "undefined":
            O.value = "";
            break;
        }
        m = {
          content: O.value,
          colSpan: O.width,
          rowSpan: O.height
        }, f && (m.styles = f), p.push(m);
      }
    }), p;
  }
  var c = new jspdf.jsPDF(l);
  e.autoTable && (typeof e.autoTable == "function" ? s = e.autoTable(c) || {} : s = e.autoTable), u && (s.didDrawPage = function(d) {
    c.text(u, 40, 30);
  }), s.head = r, s.body = o, c.autoTable(s), e.documentProcessing && e.documentProcessing(c), t(c.output("arraybuffer"), "application/pdf");
}
function xB(i, e, t) {
  var r = this, o = e.sheetName || "Sheet1", s = XLSX.utils.book_new(), n = new Zt(this), a = "compress" in e ? e.compress : !0, l = e.writeOptions || { bookType: "xlsx", bookSST: !0, compression: a }, u;
  l.type = "binary", s.SheetNames = [], s.Sheets = {};
  function h() {
    var f = [], p = [], O = {}, m = { s: { c: 0, r: 0 }, e: { c: i[0] ? i[0].columns.reduce((E, g) => E + (g && g.width ? g.width : 1), 0) : 0, r: i.length } };
    return i.forEach((E, g) => {
      var A = [];
      E.columns.forEach(function(S, R) {
        S ? (A.push(!(S.value instanceof Date) && typeof S.value == "object" ? JSON.stringify(S.value) : S.value), (S.width > 1 || S.height > -1) && (S.height > 1 || S.width > 1) && p.push({ s: { r: g, c: R }, e: { r: g + S.height - 1, c: R + S.width - 1 } })) : A.push("");
      }), f.push(A);
    }), XLSX.utils.sheet_add_aoa(O, f), O["!ref"] = XLSX.utils.encode_range(m), p.length && (O["!merges"] = p), O;
  }
  if (e.sheetOnly) {
    t(h());
    return;
  }
  if (e.sheets)
    for (var c in e.sheets)
      e.sheets[c] === !0 ? (s.SheetNames.push(c), s.Sheets[c] = h()) : (s.SheetNames.push(c), n.commsSend(e.sheets[c], "download", "intercept", {
        type: "xlsx",
        options: { sheetOnly: !0 },
        active: r.active,
        intercept: function(f) {
          s.Sheets[c] = f;
        }
      }));
  else
    s.SheetNames.push(o), s.Sheets[o] = h();
  e.documentProcessing && (s = e.documentProcessing(s));
  function d(f) {
    for (var p = new ArrayBuffer(f.length), O = new Uint8Array(p), m = 0; m != f.length; ++m)
      O[m] = f.charCodeAt(m) & 255;
    return p;
  }
  u = XLSX.write(s, l), t(d(u), "application/octet-stream");
}
function MB(i, e, t) {
  this.modExists("export", !0) && t(this.modules.export.generateHTMLTable(i), "text/html");
}
function UB(i, e, t) {
  const r = [];
  i.forEach((o) => {
    const s = {};
    switch (o.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        o.columns.forEach((n) => {
          n && (s[n.component.getTitleDownload() || n.component.getField()] = n.value);
        }), r.push(JSON.stringify(s));
        break;
    }
  }), t(r.join(`
`), "application/x-ndjson");
}
var QB = {
  csv: wB,
  json: yB,
  jsonLines: UB,
  pdf: DB,
  xlsx: xB,
  html: MB
};
class ss extends ge {
  constructor(e) {
    super(e), this.registerTableOption("downloadEncoder", function(t, r) {
      return new Blob([t], { type: r });
    }), this.registerTableOption("downloadReady", void 0), this.registerTableOption("downloadConfig", {}), this.registerTableOption("downloadRowRange", "active"), this.registerColumnOption("download"), this.registerColumnOption("titleDownload");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.registerTableFunction("download", this.download.bind(this)), this.registerTableFunction("downloadToTab", this.downloadToTab.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheck("downloadReady", "downloadEncoder");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  downloadToTab(e, t, r, o) {
    this.download(e, t, r, o, !0);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //trigger file download
  download(e, t, r, o, s) {
    var n = !1;
    function a(u, h) {
      s ? s === !0 ? this.triggerDownload(u, h, e, t, !0) : s(u) : this.triggerDownload(u, h, e, t);
    }
    if (typeof e == "function" ? n = e : ss.downloaders[e] ? n = ss.downloaders[e] : console.warn("Download Error - No such download type found: ", e), n) {
      var l = this.generateExportList(o);
      n.call(this.table, l, r || {}, a.bind(this));
    }
  }
  generateExportList(e) {
    var t = this.table.modules.export.generateExportList(this.table.options.downloadConfig, !1, e || this.table.options.downloadRowRange, "download"), r = this.table.options.groupHeaderDownload;
    return r && !Array.isArray(r) && (r = [r]), t.forEach((o) => {
      var s;
      o.type === "group" && (s = o.columns[0], r && r[o.indent] && (s.value = r[o.indent](s.value, o.component._group.getRowCount(), o.component._group.getData(), o.component)));
    }), t;
  }
  triggerDownload(e, t, r, o, s) {
    var n = document.createElement("a"), a = this.table.options.downloadEncoder(e, t);
    a && (s ? window.open(window.URL.createObjectURL(a)) : (o = o || "Tabulator." + (typeof r == "function" ? "txt" : r), navigator.msSaveOrOpenBlob ? navigator.msSaveOrOpenBlob(a, o) : (n.setAttribute("href", window.URL.createObjectURL(a)), n.setAttribute("download", o), n.style.display = "none", document.body.appendChild(n), n.click(), document.body.removeChild(n))), this.dispatchExternal("downloadComplete"));
  }
  commsReceived(e, t, r) {
    switch (t) {
      case "intercept":
        this.download(r.type, "", r.options, r.active, r.intercept);
        break;
    }
  }
}
ss.moduleName = "download";
ss.downloaders = QB;
function ic(i, e) {
  var t = e.mask, r = typeof e.maskLetterChar < "u" ? e.maskLetterChar : "A", o = typeof e.maskNumberChar < "u" ? e.maskNumberChar : "9", s = typeof e.maskWildcardChar < "u" ? e.maskWildcardChar : "*";
  function n(a) {
    var l = t[a];
    typeof l < "u" && l !== s && l !== r && l !== o && (i.value = i.value + "" + l, n(a + 1));
  }
  i.addEventListener("keydown", (a) => {
    var l = i.value.length, u = a.key;
    if (a.keyCode > 46 && !a.ctrlKey && !a.metaKey) {
      if (l >= t.length)
        return a.preventDefault(), a.stopPropagation(), !1;
      switch (t[l]) {
        case r:
          if (u.toUpperCase() == u.toLowerCase())
            return a.preventDefault(), a.stopPropagation(), !1;
          break;
        case o:
          if (isNaN(u))
            return a.preventDefault(), a.stopPropagation(), !1;
          break;
        case s:
          break;
        default:
          if (u !== t[l])
            return a.preventDefault(), a.stopPropagation(), !1;
      }
    }
  }), i.addEventListener("keyup", (a) => {
    a.keyCode > 46 && e.maskAutoFill && n(i.value.length);
  }), i.placeholder || (i.placeholder = t), e.maskAutoFill && n(i.value.length);
}
function kB(i, e, t, r, o) {
  var s = i.getValue(), n = document.createElement("input");
  if (n.setAttribute("type", o.search ? "search" : "text"), n.style.padding = "4px", n.style.width = "100%", n.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let l in o.elementAttributes)
      l.charAt(0) == "+" ? (l = l.slice(1), n.setAttribute(l, n.getAttribute(l) + o.elementAttributes["+" + l])) : n.setAttribute(l, o.elementAttributes[l]);
  n.value = typeof s < "u" ? s : "", e(function() {
    i.getType() === "cell" && (n.focus({ preventScroll: !0 }), n.style.height = "100%", o.selectContents && n.select());
  });
  function a(l) {
    (s === null || typeof s > "u") && n.value !== "" || n.value !== s ? t(n.value) && (s = n.value) : r();
  }
  return n.addEventListener("change", a), n.addEventListener("blur", a), n.addEventListener("keydown", function(l) {
    switch (l.keyCode) {
      case 13:
        a();
        break;
      case 27:
        r();
        break;
      case 35:
      case 36:
        l.stopPropagation();
        break;
    }
  }), o.mask && ic(n, o), n;
}
function $B(i, e, t, r, o) {
  var s = i.getValue(), n = o.verticalNavigation || "hybrid", a = String(s !== null && typeof s < "u" ? s : ""), l = document.createElement("textarea"), u = 0;
  if (l.style.display = "block", l.style.padding = "2px", l.style.height = "100%", l.style.width = "100%", l.style.boxSizing = "border-box", l.style.whiteSpace = "pre-wrap", l.style.resize = "none", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let c in o.elementAttributes)
      c.charAt(0) == "+" ? (c = c.slice(1), l.setAttribute(c, l.getAttribute(c) + o.elementAttributes["+" + c])) : l.setAttribute(c, o.elementAttributes[c]);
  l.value = a, e(function() {
    i.getType() === "cell" && (l.focus({ preventScroll: !0 }), l.style.height = "100%", l.scrollHeight, l.style.height = l.scrollHeight + "px", i.getRow().normalizeHeight(), o.selectContents && l.select());
  });
  function h(c) {
    (s === null || typeof s > "u") && l.value !== "" || l.value !== s ? (t(l.value) && (s = l.value), setTimeout(function() {
      i.getRow().normalizeHeight();
    }, 300)) : r();
  }
  return l.addEventListener("change", h), l.addEventListener("blur", h), l.addEventListener("keyup", function() {
    l.style.height = "";
    var c = l.scrollHeight;
    l.style.height = c + "px", c != u && (u = c, i.getRow().normalizeHeight());
  }), l.addEventListener("keydown", function(c) {
    switch (c.keyCode) {
      case 13:
        c.shiftKey && o.shiftEnterSubmit && h();
        break;
      case 27:
        r();
        break;
      case 38:
        (n == "editor" || n == "hybrid" && l.selectionStart) && (c.stopImmediatePropagation(), c.stopPropagation());
        break;
      case 40:
        (n == "editor" || n == "hybrid" && l.selectionStart !== l.value.length) && (c.stopImmediatePropagation(), c.stopPropagation());
        break;
      case 35:
      case 36:
        c.stopPropagation();
        break;
    }
  }), o.mask && ic(l, o), l;
}
function GB(i, e, t, r, o) {
  var s = i.getValue(), n = o.verticalNavigation || "editor", a = document.createElement("input");
  if (a.setAttribute("type", "number"), typeof o.max < "u" && a.setAttribute("max", o.max), typeof o.min < "u" && a.setAttribute("min", o.min), typeof o.step < "u" && a.setAttribute("step", o.step), a.style.padding = "4px", a.style.width = "100%", a.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let h in o.elementAttributes)
      h.charAt(0) == "+" ? (h = h.slice(1), a.setAttribute(h, a.getAttribute(h) + o.elementAttributes["+" + h])) : a.setAttribute(h, o.elementAttributes[h]);
  a.value = s;
  var l = function(h) {
    u();
  };
  e(function() {
    i.getType() === "cell" && (a.removeEventListener("blur", l), a.focus({ preventScroll: !0 }), a.style.height = "100%", a.addEventListener("blur", l), o.selectContents && a.select());
  });
  function u() {
    var h = a.value;
    !isNaN(h) && h !== "" && (h = Number(h)), h !== s ? t(h) && (s = h) : r();
  }
  return a.addEventListener("keydown", function(h) {
    switch (h.keyCode) {
      case 13:
        u();
        break;
      case 27:
        r();
        break;
      case 38:
      case 40:
        n == "editor" && (h.stopImmediatePropagation(), h.stopPropagation());
        break;
      case 35:
      case 36:
        h.stopPropagation();
        break;
    }
  }), o.mask && ic(a, o), a;
}
function VB(i, e, t, r, o) {
  var s = i.getValue(), n = document.createElement("input");
  if (n.setAttribute("type", "range"), typeof o.max < "u" && n.setAttribute("max", o.max), typeof o.min < "u" && n.setAttribute("min", o.min), typeof o.step < "u" && n.setAttribute("step", o.step), n.style.padding = "4px", n.style.width = "100%", n.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let l in o.elementAttributes)
      l.charAt(0) == "+" ? (l = l.slice(1), n.setAttribute(l, n.getAttribute(l) + o.elementAttributes["+" + l])) : n.setAttribute(l, o.elementAttributes[l]);
  n.value = s, e(function() {
    i.getType() === "cell" && (n.focus({ preventScroll: !0 }), n.style.height = "100%");
  });
  function a() {
    var l = n.value;
    !isNaN(l) && l !== "" && (l = Number(l)), l != s ? t(l) && (s = l) : r();
  }
  return n.addEventListener("blur", function(l) {
    a();
  }), n.addEventListener("keydown", function(l) {
    switch (l.keyCode) {
      case 13:
        a();
        break;
      case 27:
        r();
        break;
    }
  }), n;
}
function HB(i, e, t, r, o) {
  var s = o.format, n = o.verticalNavigation || "editor", a = s ? window.DateTime || luxon.DateTime : null, l = i.getValue(), u = document.createElement("input");
  function h(d) {
    var f;
    return a.isDateTime(d) ? f = d : s === "iso" ? f = a.fromISO(String(d)) : f = a.fromFormat(String(d), s), f.toFormat("yyyy-MM-dd");
  }
  if (u.type = "date", u.style.padding = "4px", u.style.width = "100%", u.style.boxSizing = "border-box", o.max && u.setAttribute("max", s ? h(o.max) : o.max), o.min && u.setAttribute("min", s ? h(o.min) : o.min), o.elementAttributes && typeof o.elementAttributes == "object")
    for (let d in o.elementAttributes)
      d.charAt(0) == "+" ? (d = d.slice(1), u.setAttribute(d, u.getAttribute(d) + o.elementAttributes["+" + d])) : u.setAttribute(d, o.elementAttributes[d]);
  l = typeof l < "u" ? l : "", s && (a ? l = h(l) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), u.value = l, e(function() {
    i.getType() === "cell" && (u.focus({ preventScroll: !0 }), u.style.height = "100%", o.selectContents && u.select());
  });
  function c() {
    var d = u.value, f;
    if ((l === null || typeof l > "u") && d !== "" || d !== l) {
      if (d && s)
        switch (f = a.fromFormat(String(d), "yyyy-MM-dd"), s) {
          case !0:
            d = f;
            break;
          case "iso":
            d = f.toISO();
            break;
          default:
            d = f.toFormat(s);
        }
      t(d) && (l = u.value);
    } else
      r();
  }
  return u.addEventListener("blur", function(d) {
    (d.relatedTarget || d.rangeParent || d.explicitOriginalTarget !== u) && c();
  }), u.addEventListener("keydown", function(d) {
    switch (d.keyCode) {
      case 13:
        c();
        break;
      case 27:
        r();
        break;
      case 35:
      case 36:
        d.stopPropagation();
        break;
      case 38:
      case 40:
        n == "editor" && (d.stopImmediatePropagation(), d.stopPropagation());
        break;
    }
  }), u;
}
function XB(i, e, t, r, o) {
  var s = o.format, n = o.verticalNavigation || "editor", a = s ? window.DateTime || luxon.DateTime : null, l, u = i.getValue(), h = document.createElement("input");
  if (h.type = "time", h.style.padding = "4px", h.style.width = "100%", h.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let d in o.elementAttributes)
      d.charAt(0) == "+" ? (d = d.slice(1), h.setAttribute(d, h.getAttribute(d) + o.elementAttributes["+" + d])) : h.setAttribute(d, o.elementAttributes[d]);
  u = typeof u < "u" ? u : "", s && (a ? (a.isDateTime(u) ? l = u : s === "iso" ? l = a.fromISO(String(u)) : l = a.fromFormat(String(u), s), u = l.toFormat("hh:mm")) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), h.value = u, e(function() {
    i.getType() == "cell" && (h.focus({ preventScroll: !0 }), h.style.height = "100%", o.selectContents && h.select());
  });
  function c() {
    var d = h.value, f;
    if ((u === null || typeof u > "u") && d !== "" || d !== u) {
      if (d && s)
        switch (f = a.fromFormat(String(d), "hh:mm"), s) {
          case !0:
            d = f;
            break;
          case "iso":
            d = f.toISO();
            break;
          default:
            d = f.toFormat(s);
        }
      t(d) && (u = h.value);
    } else
      r();
  }
  return h.addEventListener("blur", function(d) {
    (d.relatedTarget || d.rangeParent || d.explicitOriginalTarget !== h) && c();
  }), h.addEventListener("keydown", function(d) {
    switch (d.keyCode) {
      case 13:
        c();
        break;
      case 27:
        r();
        break;
      case 35:
      case 36:
        d.stopPropagation();
        break;
      case 38:
      case 40:
        n == "editor" && (d.stopImmediatePropagation(), d.stopPropagation());
        break;
    }
  }), h;
}
function YB(i, e, t, r, o) {
  var s = o.format, n = o.verticalNavigation || "editor", a = s ? window.DateTime || luxon.DateTime : null, l, u = i.getValue(), h = document.createElement("input");
  if (h.type = "datetime-local", h.style.padding = "4px", h.style.width = "100%", h.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let d in o.elementAttributes)
      d.charAt(0) == "+" ? (d = d.slice(1), h.setAttribute(d, h.getAttribute(d) + o.elementAttributes["+" + d])) : h.setAttribute(d, o.elementAttributes[d]);
  u = typeof u < "u" ? u : "", s && (a ? (a.isDateTime(u) ? l = u : s === "iso" ? l = a.fromISO(String(u)) : l = a.fromFormat(String(u), s), u = l.toFormat("yyyy-MM-dd") + "T" + l.toFormat("hh:mm")) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), h.value = u, e(function() {
    i.getType() === "cell" && (h.focus({ preventScroll: !0 }), h.style.height = "100%", o.selectContents && h.select());
  });
  function c() {
    var d = h.value, f;
    if ((u === null || typeof u > "u") && d !== "" || d !== u) {
      if (d && s)
        switch (f = a.fromISO(String(d)), s) {
          case !0:
            d = f;
            break;
          case "iso":
            d = f.toISO();
            break;
          default:
            d = f.toFormat(s);
        }
      t(d) && (u = h.value);
    } else
      r();
  }
  return h.addEventListener("blur", function(d) {
    (d.relatedTarget || d.rangeParent || d.explicitOriginalTarget !== h) && c();
  }), h.addEventListener("keydown", function(d) {
    switch (d.keyCode) {
      case 13:
        c();
        break;
      case 27:
        r();
        break;
      case 35:
      case 36:
        d.stopPropagation();
        break;
      case 38:
      case 40:
        n == "editor" && (d.stopImmediatePropagation(), d.stopPropagation());
        break;
    }
  }), h;
}
class MO {
  constructor(e, t, r, o, s, n) {
    this.edit = e, this.table = e.table, this.cell = t, this.params = this._initializeParams(n), this.data = [], this.displayItems = [], this.currentItems = [], this.focusedItem = null, this.input = this._createInputElement(), this.listEl = this._createListElement(), this.initialValues = null, this.isFilter = t.getType() === "header", this.filterTimeout = null, this.filtered = !1, this.typing = !1, this.values = [], this.popup = null, this.listIteration = 0, this.lastAction = "", this.filterTerm = "", this.blurable = !0, this.actions = {
      success: o,
      cancel: s
    }, this._deprecatedOptionsCheck(), this._initializeValue(), r(this._onRendered.bind(this));
  }
  _deprecatedOptionsCheck() {
    this.params.listItemFormatter && this.cell.getTable().deprecationAdvisor.msg("The listItemFormatter editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.sortValuesList && this.cell.getTable().deprecationAdvisor.msg("The sortValuesList editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.searchFunc && this.cell.getTable().deprecationAdvisor.msg("The searchFunc editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.searchingPlaceholder && this.cell.getTable().deprecationAdvisor.msg("The searchingPlaceholder editor param has been deprecated, please see the latest editor documentation for updated options");
  }
  _initializeValue() {
    var e = this.cell.getValue();
    typeof e > "u" && typeof this.params.defaultValue < "u" && (e = this.params.defaultValue), this.initialValues = this.params.multiselect ? e : [e], this.isFilter && (this.input.value = this.initialValues ? this.initialValues.join(",") : "", this.headerFilterInitialListGen());
  }
  _onRendered() {
    var e = this.cell.getElement();
    function t(r) {
      r.stopPropagation();
    }
    this.isFilter || (this.input.style.height = "100%", this.input.focus({ preventScroll: !0 })), e.addEventListener("click", t), setTimeout(() => {
      e.removeEventListener("click", t);
    }, 1e3), this.input.addEventListener("mousedown", this._preventPopupBlur.bind(this));
  }
  _createListElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-edit-list"), e.addEventListener("mousedown", this._preventBlur.bind(this)), e.addEventListener("keydown", this._inputKeyDown.bind(this)), e;
  }
  _setListWidth() {
    var e = this.isFilter ? this.input : this.cell.getElement();
    this.listEl.style.minWidth = e.offsetWidth + "px", this.params.maxWidth && (this.params.maxWidth === !0 ? this.listEl.style.maxWidth = e.offsetWidth + "px" : typeof this.params.maxWidth == "number" ? this.listEl.style.maxWidth = this.params.maxWidth + "px" : this.listEl.style.maxWidth = this.params.maxWidth);
  }
  _createInputElement() {
    var e = this.params.elementAttributes, t = document.createElement("input");
    if (t.setAttribute("type", this.params.clearable ? "search" : "text"), t.style.padding = "4px", t.style.width = "100%", t.style.boxSizing = "border-box", this.params.autocomplete || (t.style.cursor = "default", t.style.caretColor = "transparent"), e && typeof e == "object")
      for (let r in e)
        r.charAt(0) == "+" ? (r = r.slice(1), t.setAttribute(r, t.getAttribute(r) + e["+" + r])) : t.setAttribute(r, e[r]);
    return this.params.mask && ic(t, this.params), this._bindInputEvents(t), t;
  }
  _initializeParams(e) {
    var t = ["values", "valuesURL", "valuesLookup"], r;
    return e = Object.assign({}, e), e.verticalNavigation = e.verticalNavigation || "editor", e.placeholderLoading = typeof e.placeholderLoading > "u" ? "Searching ..." : e.placeholderLoading, e.placeholderEmpty = typeof e.placeholderEmpty > "u" ? "No Results Found" : e.placeholderEmpty, e.filterDelay = typeof e.filterDelay > "u" ? 300 : e.filterDelay, e.emptyValue = Object.keys(e).includes("emptyValue") ? e.emptyValue : "", r = Object.keys(e).filter((o) => t.includes(o)).length, r ? r > 1 && console.warn("list editor config error - only one of the values, valuesURL, or valuesLookup options can be set on the same editor") : console.warn("list editor config error - either the values, valuesURL, or valuesLookup option must be set"), e.autocomplete ? e.multiselect && (e.multiselect = !1, console.warn("list editor config error - multiselect option is not available when autocomplete is enabled")) : (e.freetext && (e.freetext = !1, console.warn("list editor config error - freetext option is only available when autocomplete is enabled")), e.filterFunc && (e.filterFunc = !1, console.warn("list editor config error - filterFunc option is only available when autocomplete is enabled")), e.filterRemote && (e.filterRemote = !1, console.warn("list editor config error - filterRemote option is only available when autocomplete is enabled")), e.mask && (e.mask = !1, console.warn("list editor config error - mask option is only available when autocomplete is enabled")), e.allowEmpty && (e.allowEmpty = !1, console.warn("list editor config error - allowEmpty option is only available when autocomplete is enabled")), e.listOnEmpty && (e.listOnEmpty = !1, console.warn("list editor config error - listOnEmpty option is only available when autocomplete is enabled"))), e.filterRemote && !(typeof e.valuesLookup == "function" || e.valuesURL) && (e.filterRemote = !1, console.warn("list editor config error - filterRemote option should only be used when values list is populated from a remote source")), e;
  }
  //////////////////////////////////////
  ////////// Event Handling ////////////
  //////////////////////////////////////
  _bindInputEvents(e) {
    e.addEventListener("focus", this._inputFocus.bind(this)), e.addEventListener("click", this._inputClick.bind(this)), e.addEventListener("blur", this._inputBlur.bind(this)), e.addEventListener("keydown", this._inputKeyDown.bind(this)), e.addEventListener("search", this._inputSearch.bind(this)), this.params.autocomplete && e.addEventListener("keyup", this._inputKeyUp.bind(this));
  }
  _inputFocus(e) {
    this.rebuildOptionsList();
  }
  _filter() {
    this.params.filterRemote ? (clearTimeout(this.filterTimeout), this.filterTimeout = setTimeout(() => {
      this.rebuildOptionsList();
    }, this.params.filterDelay)) : this._filterList();
  }
  _inputClick(e) {
    e.stopPropagation();
  }
  _inputBlur(e) {
    this.blurable && (this.popup ? this.popup.hide() : this._resolveValue(!0));
  }
  _inputSearch() {
    this._clearChoices();
  }
  _inputKeyDown(e) {
    switch (e.keyCode) {
      case 38:
        this._keyUp(e);
        break;
      case 40:
        this._keyDown(e);
        break;
      case 37:
      case 39:
        this._keySide(e);
        break;
      case 13:
        this._keyEnter();
        break;
      case 27:
        this._keyEsc();
        break;
      case 36:
      case 35:
        this._keyHomeEnd(e);
        break;
      case 9:
        this._keyTab(e);
        break;
      default:
        this._keySelectLetter(e);
    }
  }
  _inputKeyUp(e) {
    switch (e.keyCode) {
      case 38:
      case 37:
      case 39:
      case 40:
      case 13:
      case 27:
        break;
      default:
        this._keyAutoCompLetter(e);
    }
  }
  _preventPopupBlur() {
    this.popup && this.popup.blockHide(), setTimeout(() => {
      this.popup && this.popup.restoreHide();
    }, 10);
  }
  _preventBlur() {
    this.blurable = !1, setTimeout(() => {
      this.blurable = !0;
    }, 10);
  }
  //////////////////////////////////////
  //////// Keyboard Navigation /////////
  //////////////////////////////////////
  _keyTab(e) {
    this.params.autocomplete && this.lastAction === "typing" ? this._resolveValue(!0) : this.focusedItem && this._chooseItem(this.focusedItem, !0);
  }
  _keyUp(e) {
    var t = this.displayItems.indexOf(this.focusedItem);
    (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && t) && (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault(), t > 0 && this._focusItem(this.displayItems[t - 1]));
  }
  _keyDown(e) {
    var t = this.displayItems.indexOf(this.focusedItem);
    (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && t < this.displayItems.length - 1) && (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault(), t < this.displayItems.length - 1 && (t == -1 ? this._focusItem(this.displayItems[0]) : this._focusItem(this.displayItems[t + 1])));
  }
  _keySide(e) {
    this.params.autocomplete || (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault());
  }
  _keyEnter(e) {
    this.params.autocomplete && this.lastAction === "typing" ? this._resolveValue(!0) : this.focusedItem && this._chooseItem(this.focusedItem);
  }
  _keyEsc(e) {
    this._cancel();
  }
  _keyHomeEnd(e) {
    this.params.autocomplete && e.stopImmediatePropagation();
  }
  _keySelectLetter(e) {
    this.params.autocomplete || (e.preventDefault(), e.keyCode >= 38 && e.keyCode <= 90 && this._scrollToValue(e.keyCode));
  }
  _keyAutoCompLetter(e) {
    this._filter(), this.lastAction = "typing", this.typing = !0;
  }
  _scrollToValue(e) {
    clearTimeout(this.filterTimeout);
    var t = String.fromCharCode(e).toLowerCase();
    this.filterTerm += t.toLowerCase();
    var r = this.displayItems.find((o) => typeof o.label < "u" && o.label.toLowerCase().startsWith(this.filterTerm));
    r && this._focusItem(r), this.filterTimeout = setTimeout(() => {
      this.filterTerm = "";
    }, 800);
  }
  _focusItem(e) {
    this.lastAction = "focus", this.focusedItem && this.focusedItem.element && this.focusedItem.element.classList.remove("focused"), this.focusedItem = e, e && e.element && (e.element.classList.add("focused"), e.element.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" }));
  }
  //////////////////////////////////////
  /////// Data List Generation /////////
  //////////////////////////////////////
  headerFilterInitialListGen() {
    this._generateOptions(!0);
  }
  rebuildOptionsList() {
    this._generateOptions().then(this._sortOptions.bind(this)).then(this._buildList.bind(this)).then(this._showList.bind(this)).catch((e) => {
      Number.isInteger(e) || console.error("List generation error", e);
    });
  }
  _filterList() {
    this._buildList(this._filterOptions()), this._showList();
  }
  _generateOptions(e) {
    var t = [], r = ++this.listIteration;
    return this.filtered = !1, this.params.values ? t = this.params.values : this.params.valuesURL ? t = this._ajaxRequest(this.params.valuesURL, this.input.value) : typeof this.params.valuesLookup == "function" ? t = this.params.valuesLookup(this.cell, this.input.value) : this.params.valuesLookup && (t = this._uniqueColumnValues(this.params.valuesLookupField)), t instanceof Promise ? (e || this._addPlaceholder(this.params.placeholderLoading), t.then().then((o) => this.listIteration === r ? this._parseList(o) : Promise.reject(r))) : Promise.resolve(this._parseList(t));
  }
  _addPlaceholder(e) {
    var t = document.createElement("div");
    typeof e == "function" && (e = e(this.cell.getComponent(), this.listEl)), e && (this._clearList(), e instanceof HTMLElement ? t = e : (t.classList.add("tabulator-edit-list-placeholder"), t.innerHTML = e), this.listEl.appendChild(t), this._showList());
  }
  _ajaxRequest(e, t) {
    var r = this.params.filterRemote ? { term: t } : {};
    return e = ev(e, {}, r), fetch(e).then((o) => o.ok ? o.json().catch((s) => (console.warn("List Ajax Load Error - Invalid JSON returned", s), Promise.reject(s))) : (console.error("List Ajax Load Error - Connection Error: " + o.status, o.statusText), Promise.reject(o))).catch((o) => (console.error("List Ajax Load Error - Connection Error: ", o), Promise.reject(o)));
  }
  _uniqueColumnValues(e) {
    var t = {}, r = this.table.getData(this.params.valuesLookup), o;
    return e ? o = this.table.columnManager.getColumnByField(e) : o = this.cell.getColumn()._getSelf(), o ? r.forEach((s) => {
      var n = o.getFieldValue(s);
      n !== null && typeof n < "u" && n !== "" && (t[n] = !0);
    }) : (console.warn("unable to find matching column to create select lookup list:", e), t = []), Object.keys(t);
  }
  _parseList(e) {
    var t = [];
    return Array.isArray(e) || (e = Object.entries(e).map(([r, o]) => ({
      label: o,
      value: r
    }))), e.forEach((r) => {
      typeof r != "object" && (r = {
        label: r,
        value: r
      }), this._parseListItem(r, t, 0);
    }), !this.currentItems.length && this.params.freetext && (this.input.value = this.initialValues, this.typing = !0, this.lastAction = "typing"), this.data = t, t;
  }
  _parseListItem(e, t, r) {
    var o = {};
    e.options ? o = this._parseListGroup(e, r + 1) : (o = {
      label: e.label,
      value: e.value,
      itemParams: e.itemParams,
      elementAttributes: e.elementAttributes,
      element: !1,
      selected: !1,
      visible: !0,
      level: r,
      original: e
    }, this.initialValues && this.initialValues.indexOf(e.value) > -1 && this._chooseItem(o, !0)), t.push(o);
  }
  _parseListGroup(e, t) {
    var r = {
      label: e.label,
      group: !0,
      itemParams: e.itemParams,
      elementAttributes: e.elementAttributes,
      element: !1,
      visible: !0,
      level: t,
      options: [],
      original: e
    };
    return e.options.forEach((o) => {
      this._parseListItem(o, r.options, t);
    }), r;
  }
  _sortOptions(e) {
    var t;
    return this.params.sort && (t = typeof this.params.sort == "function" ? this.params.sort : this._defaultSortFunction.bind(this), this._sortGroup(t, e)), e;
  }
  _sortGroup(e, t) {
    t.sort((r, o) => e(r.label, o.label, r.value, o.value, r.original, o.original)), t.forEach((r) => {
      r.group && this._sortGroup(e, r.options);
    });
  }
  _defaultSortFunction(e, t) {
    var r, o, s, n, a = 0, l, u = /(\d+)|(\D+)/g, h = /\d/, c = 0;
    if (this.params.sort === "desc" && ([e, t] = [t, e]), !e && e !== 0)
      c = !t && t !== 0 ? 0 : -1;
    else if (!t && t !== 0)
      c = 1;
    else {
      if (isFinite(e) && isFinite(t))
        return e - t;
      if (r = String(e).toLowerCase(), o = String(t).toLowerCase(), r === o)
        return 0;
      if (!(h.test(r) && h.test(o)))
        return r > o ? 1 : -1;
      for (r = r.match(u), o = o.match(u), l = r.length > o.length ? o.length : r.length; a < l; )
        if (s = r[a], n = o[a++], s !== n)
          return isFinite(s) && isFinite(n) ? (s.charAt(0) === "0" && (s = "." + s), n.charAt(0) === "0" && (n = "." + n), s - n) : s > n ? 1 : -1;
      return r.length > o.length;
    }
    return c;
  }
  _filterOptions() {
    var e = this.params.filterFunc || this._defaultFilterFunc, t = this.input.value;
    return t ? (this.filtered = !0, this.data.forEach((r) => {
      this._filterItem(e, t, r);
    })) : this.filtered = !1, this.data;
  }
  _filterItem(e, t, r) {
    var o = !1;
    return r.group ? (r.options.forEach((s) => {
      this._filterItem(e, t, s) && (o = !0);
    }), r.visible = o) : r.visible = e(t, r.label, r.value, r.original), r.visible;
  }
  _defaultFilterFunc(e, t, r, o) {
    return e = String(e).toLowerCase(), t !== null && typeof t < "u" && (String(t).toLowerCase().indexOf(e) > -1 || String(r).toLowerCase().indexOf(e) > -1);
  }
  //////////////////////////////////////
  /////////// Display List /////////////
  //////////////////////////////////////
  _clearList() {
    for (; this.listEl.firstChild; )
      this.listEl.removeChild(this.listEl.firstChild);
    this.displayItems = [];
  }
  _buildList(e) {
    this._clearList(), e.forEach((t) => {
      this._buildItem(t);
    }), this.displayItems.length || this._addPlaceholder(this.params.placeholderEmpty);
  }
  _buildItem(e) {
    var t = e.element, r;
    if (!this.filtered || e.visible) {
      if (!t) {
        if (t = document.createElement("div"), t.tabIndex = 0, r = this.params.itemFormatter ? this.params.itemFormatter(e.label, e.value, e.original, t) : e.label, r instanceof HTMLElement ? t.appendChild(r) : t.innerHTML = r, e.group ? t.classList.add("tabulator-edit-list-group") : t.classList.add("tabulator-edit-list-item"), t.classList.add("tabulator-edit-list-group-level-" + e.level), e.elementAttributes && typeof e.elementAttributes == "object")
          for (let o in e.elementAttributes)
            o.charAt(0) == "+" ? (o = o.slice(1), t.setAttribute(o, this.input.getAttribute(o) + e.elementAttributes["+" + o])) : t.setAttribute(o, e.elementAttributes[o]);
        e.group ? t.addEventListener("click", this._groupClick.bind(this, e)) : t.addEventListener("click", this._itemClick.bind(this, e)), t.addEventListener("mousedown", this._preventBlur.bind(this)), e.element = t;
      }
      this._styleItem(e), this.listEl.appendChild(t), e.group ? e.options.forEach((o) => {
        this._buildItem(o);
      }) : this.displayItems.push(e);
    }
  }
  _showList() {
    var e = this.popup && this.popup.isVisible();
    if (this.input.parentNode) {
      if (this.params.autocomplete && this.input.value === "" && !this.params.listOnEmpty) {
        this.popup && this.popup.hide(!0);
        return;
      }
      this._setListWidth(), this.popup || (this.popup = this.edit.popup(this.listEl)), this.popup.show(this.cell.getElement(), "bottom"), e || setTimeout(() => {
        this.popup.hideOnBlur(this._resolveValue.bind(this, !0));
      }, 10);
    }
  }
  _styleItem(e) {
    e && e.element && (e.selected ? e.element.classList.add("active") : e.element.classList.remove("active"));
  }
  //////////////////////////////////////
  ///////// User Interaction ///////////
  //////////////////////////////////////
  _itemClick(e, t) {
    t.stopPropagation(), this._chooseItem(e);
  }
  _groupClick(e, t) {
    t.stopPropagation();
  }
  //////////////////////////////////////
  ////// Current Item Management ///////
  //////////////////////////////////////
  _cancel() {
    this.popup.hide(!0), this.actions.cancel();
  }
  _clearChoices() {
    this.typing = !0, this.currentItems.forEach((e) => {
      e.selected = !1, this._styleItem(e);
    }), this.currentItems = [], this.focusedItem = null;
  }
  _chooseItem(e, t) {
    var r;
    this.typing = !1, this.params.multiselect ? (r = this.currentItems.indexOf(e), r > -1 ? (this.currentItems.splice(r, 1), e.selected = !1) : (this.currentItems.push(e), e.selected = !0), this.input.value = this.currentItems.map((o) => o.label).join(","), this._styleItem(e)) : (this.currentItems = [e], e.selected = !0, this.input.value = e.label, this._styleItem(e), t || this._resolveValue()), this._focusItem(e);
  }
  _resolveValue(e) {
    var t, r;
    if (this.popup && this.popup.hide(!0), this.params.multiselect)
      t = this.currentItems.map((o) => o.value);
    else if (e && this.params.autocomplete && this.typing)
      if (this.params.freetext || this.params.allowEmpty && this.input.value === "")
        t = this.input.value;
      else {
        this.actions.cancel();
        return;
      }
    else
      this.currentItems[0] ? t = this.currentItems[0].value : (r = Array.isArray(this.initialValues) ? this.initialValues[0] : this.initialValues, r === null || typeof r > "u" || r === "" ? t = r : t = this.params.emptyValue);
    t === "" && (t = this.params.emptyValue), this.actions.success(t), this.isFilter && (this.initialValues = t && !Array.isArray(t) ? [t] : t, this.currentItems = []);
  }
}
function BB(i, e, t, r, o) {
  this.deprecationMsg("The select editor has been deprecated, please use the new list editor");
  var s = new MO(this, i, e, t, r, o);
  return s.input;
}
function FB(i, e, t, r, o) {
  var s = new MO(this, i, e, t, r, o);
  return s.input;
}
function WB(i, e, t, r, o) {
  this.deprecationMsg("The autocomplete editor has been deprecated, please use the new list editor with the 'autocomplete' editorParam"), o.autocomplete = !0;
  var s = new MO(this, i, e, t, r, o);
  return s.input;
}
function zB(i, e, t, r, o) {
  var s = this, n = i.getElement(), a = i.getValue(), l = n.getElementsByTagName("svg").length || 5, u = n.getElementsByTagName("svg")[0] ? n.getElementsByTagName("svg")[0].getAttribute("width") : 14, h = [], c = document.createElement("div"), d = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  function f(E) {
    h.forEach(function(g, A) {
      A < E ? (s.table.browser == "ie" ? g.setAttribute("class", "tabulator-star-active") : g.classList.replace("tabulator-star-inactive", "tabulator-star-active"), g.innerHTML = '<polygon fill="#488CE9" stroke="#014AAE" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>') : (s.table.browser == "ie" ? g.setAttribute("class", "tabulator-star-inactive") : g.classList.replace("tabulator-star-active", "tabulator-star-inactive"), g.innerHTML = '<polygon fill="#010155" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>');
    });
  }
  function p(E) {
    var g = document.createElement("span"), A = d.cloneNode(!0);
    h.push(A), g.addEventListener("mouseenter", function(S) {
      S.stopPropagation(), S.stopImmediatePropagation(), f(E);
    }), g.addEventListener("mousemove", function(S) {
      S.stopPropagation(), S.stopImmediatePropagation();
    }), g.addEventListener("click", function(S) {
      S.stopPropagation(), S.stopImmediatePropagation(), t(E), n.blur();
    }), g.appendChild(A), c.appendChild(g);
  }
  function O(E) {
    a = E, f(E);
  }
  if (n.style.whiteSpace = "nowrap", n.style.overflow = "hidden", n.style.textOverflow = "ellipsis", c.style.verticalAlign = "middle", c.style.display = "inline-block", c.style.padding = "4px", d.setAttribute("width", u), d.setAttribute("height", u), d.setAttribute("viewBox", "0 0 512 512"), d.setAttribute("xml:space", "preserve"), d.style.padding = "0 1px", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let E in o.elementAttributes)
      E.charAt(0) == "+" ? (E = E.slice(1), c.setAttribute(E, c.getAttribute(E) + o.elementAttributes["+" + E])) : c.setAttribute(E, o.elementAttributes[E]);
  for (var m = 1; m <= l; m++)
    p(m);
  return a = Math.min(parseInt(a), l), f(a), c.addEventListener("mousemove", function(E) {
    f(0);
  }), c.addEventListener("click", function(E) {
    t(0);
  }), n.addEventListener("blur", function(E) {
    r();
  }), n.addEventListener("keydown", function(E) {
    switch (E.keyCode) {
      case 39:
        O(a + 1);
        break;
      case 37:
        O(a - 1);
        break;
      case 13:
        t(a);
        break;
      case 27:
        r();
        break;
    }
  }), c;
}
function ZB(i, e, t, r, o) {
  var s = i.getElement(), n = typeof o.max > "u" ? s.getElementsByTagName("div")[0] && s.getElementsByTagName("div")[0].getAttribute("max") || 100 : o.max, a = typeof o.min > "u" ? s.getElementsByTagName("div")[0] && s.getElementsByTagName("div")[0].getAttribute("min") || 0 : o.min, l = (n - a) / 100, u = i.getValue() || 0, h = document.createElement("div"), c = document.createElement("div"), d, f;
  function p() {
    var O = window.getComputedStyle(s, null), m = l * Math.round(c.offsetWidth / ((s.clientWidth - parseInt(O.getPropertyValue("padding-left")) - parseInt(O.getPropertyValue("padding-right"))) / 100)) + a;
    t(m), s.setAttribute("aria-valuenow", m), s.setAttribute("aria-label", u);
  }
  if (h.style.position = "absolute", h.style.right = "0", h.style.top = "0", h.style.bottom = "0", h.style.width = "5px", h.classList.add("tabulator-progress-handle"), c.style.display = "inline-block", c.style.position = "relative", c.style.height = "100%", c.style.backgroundColor = "#488CE9", c.style.maxWidth = "100%", c.style.minWidth = "0%", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let O in o.elementAttributes)
      O.charAt(0) == "+" ? (O = O.slice(1), c.setAttribute(O, c.getAttribute(O) + o.elementAttributes["+" + O])) : c.setAttribute(O, o.elementAttributes[O]);
  return s.style.padding = "4px 4px", u = Math.min(parseFloat(u), n), u = Math.max(parseFloat(u), a), u = Math.round((u - a) / l), c.style.width = u + "%", s.setAttribute("aria-valuemin", a), s.setAttribute("aria-valuemax", n), c.appendChild(h), h.addEventListener("mousedown", function(O) {
    d = O.screenX, f = c.offsetWidth;
  }), h.addEventListener("mouseover", function() {
    h.style.cursor = "ew-resize";
  }), s.addEventListener("mousemove", function(O) {
    d && (c.style.width = f + O.screenX - d + "px");
  }), s.addEventListener("mouseup", function(O) {
    d && (O.stopPropagation(), O.stopImmediatePropagation(), d = !1, f = !1, p());
  }), s.addEventListener("keydown", function(O) {
    switch (O.keyCode) {
      case 39:
        O.preventDefault(), c.style.width = c.clientWidth + s.clientWidth / 100 + "px";
        break;
      case 37:
        O.preventDefault(), c.style.width = c.clientWidth - s.clientWidth / 100 + "px";
        break;
      case 9:
      case 13:
        p();
        break;
      case 27:
        r();
        break;
    }
  }), s.addEventListener("blur", function() {
    r();
  }), c;
}
function qB(i, e, t, r, o) {
  var s = i.getValue(), n = document.createElement("input"), a = o.tristate, l = typeof o.indeterminateValue > "u" ? null : o.indeterminateValue, u = !1, h = Object.keys(o).includes("trueValue"), c = Object.keys(o).includes("falseValue");
  if (n.setAttribute("type", "checkbox"), n.style.marginTop = "5px", n.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let f in o.elementAttributes)
      f.charAt(0) == "+" ? (f = f.slice(1), n.setAttribute(f, n.getAttribute(f) + o.elementAttributes["+" + f])) : n.setAttribute(f, o.elementAttributes[f]);
  n.value = s, a && (typeof s > "u" || s === l || s === "") && (u = !0, n.indeterminate = !0), this.table.browser != "firefox" && this.table.browser != "safari" && e(function() {
    i.getType() === "cell" && n.focus({ preventScroll: !0 });
  }), n.checked = h ? s === o.trueValue : s === !0 || s === "true" || s === "True" || s === 1;
  function d(f) {
    var p = n.checked;
    return h && p ? p = o.trueValue : c && !p && (p = o.falseValue), a ? f ? u ? l : p : n.checked && !u ? (n.checked = !1, n.indeterminate = !0, u = !0, l) : (u = !1, p) : p;
  }
  return n.addEventListener("change", function(f) {
    t(d());
  }), n.addEventListener("blur", function(f) {
    t(d(!0));
  }), n.addEventListener("keydown", function(f) {
    f.keyCode == 13 && t(d()), f.keyCode == 27 && r();
  }), n;
}
var jB = {
  input: kB,
  textarea: $B,
  number: GB,
  range: VB,
  date: HB,
  time: XB,
  datetime: YB,
  select: BB,
  list: FB,
  autocomplete: WB,
  star: zB,
  progress: ZB,
  tickCross: qB
};
class Sn extends ge {
  constructor(e) {
    super(e), this.currentCell = !1, this.mouseClick = !1, this.recursionBlock = !1, this.invalidEdit = !1, this.editedCells = [], this.editors = Sn.editors, this.registerColumnOption("editable"), this.registerColumnOption("editor"), this.registerColumnOption("editorParams"), this.registerColumnOption("cellEditing"), this.registerColumnOption("cellEdited"), this.registerColumnOption("cellEditCancelled"), this.registerTableFunction("getEditedCells", this.getEditedCells.bind(this)), this.registerTableFunction("clearCellEdited", this.clearCellEdited.bind(this)), this.registerTableFunction("navigatePrev", this.navigatePrev.bind(this)), this.registerTableFunction("navigateNext", this.navigateNext.bind(this)), this.registerTableFunction("navigateLeft", this.navigateLeft.bind(this)), this.registerTableFunction("navigateRight", this.navigateRight.bind(this)), this.registerTableFunction("navigateUp", this.navigateUp.bind(this)), this.registerTableFunction("navigateDown", this.navigateDown.bind(this)), this.registerComponentFunction("cell", "isEdited", this.cellIsEdited.bind(this)), this.registerComponentFunction("cell", "clearEdited", this.clearEdited.bind(this)), this.registerComponentFunction("cell", "edit", this.editCell.bind(this)), this.registerComponentFunction("cell", "cancelEdit", this.cellCancelEdit.bind(this)), this.registerComponentFunction("cell", "navigatePrev", this.navigatePrev.bind(this)), this.registerComponentFunction("cell", "navigateNext", this.navigateNext.bind(this)), this.registerComponentFunction("cell", "navigateLeft", this.navigateLeft.bind(this)), this.registerComponentFunction("cell", "navigateRight", this.navigateRight.bind(this)), this.registerComponentFunction("cell", "navigateUp", this.navigateUp.bind(this)), this.registerComponentFunction("cell", "navigateDown", this.navigateDown.bind(this));
  }
  initialize() {
    this.subscribe("cell-init", this.bindEditor.bind(this)), this.subscribe("cell-delete", this.clearEdited.bind(this)), this.subscribe("cell-value-changed", this.updateCellClass.bind(this)), this.subscribe("column-layout", this.initializeColumnCheck.bind(this)), this.subscribe("column-delete", this.columnDeleteCheck.bind(this)), this.subscribe("row-deleting", this.rowDeleteCheck.bind(this)), this.subscribe("row-layout", this.rowEditableCheck.bind(this)), this.subscribe("data-refreshing", this.cancelEdit.bind(this)), this.subscribe("keybinding-nav-prev", this.navigatePrev.bind(this, void 0)), this.subscribe("keybinding-nav-next", this.keybindingNavigateNext.bind(this)), this.subscribe("keybinding-nav-left", this.navigateLeft.bind(this, void 0)), this.subscribe("keybinding-nav-right", this.navigateRight.bind(this, void 0)), this.subscribe("keybinding-nav-up", this.navigateUp.bind(this, void 0)), this.subscribe("keybinding-nav-down", this.navigateDown.bind(this, void 0));
  }
  ///////////////////////////////////
  ////// Keybinding Functions ///////
  ///////////////////////////////////
  keybindingNavigateNext(e) {
    var t = this.currentCell, r = this.options("tabEndNewRow");
    t && (this.navigateNext(t, e) || r && (t.getElement().firstChild.blur(), r === !0 ? r = this.table.addRow({}) : typeof r == "function" ? r = this.table.addRow(r(t.row.getComponent())) : r = this.table.addRow(Object.assign({}, r)), r.then(() => {
      setTimeout(() => {
        t.getComponent().navigateNext();
      });
    })));
  }
  ///////////////////////////////////
  ///////// Cell Functions //////////
  ///////////////////////////////////
  cellIsEdited(e) {
    return !!e.modules.edit && e.modules.edit.edited;
  }
  cellCancelEdit(e) {
    e === this.currentCell ? this.table.modules.edit.cancelEdit() : console.warn("Cancel Editor Error - This cell is not currently being edited ");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  updateCellClass(e) {
    this.allowEdit(e) ? e.getElement().classList.add("tabulator-editable") : e.getElement().classList.remove("tabulator-editable");
  }
  clearCellEdited(e) {
    e || (e = this.table.modules.edit.getEditedCells()), Array.isArray(e) || (e = [e]), e.forEach((t) => {
      this.table.modules.edit.clearEdited(t._getSelf());
    });
  }
  navigatePrev(e = this.currentCell, t) {
    var r, o;
    if (e) {
      if (t && t.preventDefault(), r = this.navigateLeft(), r)
        return !0;
      if (o = this.table.rowManager.prevDisplayRow(e.row, !0), o && (r = this.findPrevEditableCell(o, o.cells.length), r))
        return r.getComponent().edit(), !0;
    }
    return !1;
  }
  navigateNext(e = this.currentCell, t) {
    var r, o;
    if (e) {
      if (t && t.preventDefault(), r = this.navigateRight(), r)
        return !0;
      if (o = this.table.rowManager.nextDisplayRow(e.row, !0), o && (r = this.findNextEditableCell(o, -1), r))
        return r.getComponent().edit(), !0;
    }
    return !1;
  }
  navigateLeft(e = this.currentCell, t) {
    var r, o;
    return e && (t && t.preventDefault(), r = e.getIndex(), o = this.findPrevEditableCell(e.row, r), o) ? (o.getComponent().edit(), !0) : !1;
  }
  navigateRight(e = this.currentCell, t) {
    var r, o;
    return e && (t && t.preventDefault(), r = e.getIndex(), o = this.findNextEditableCell(e.row, r), o) ? (o.getComponent().edit(), !0) : !1;
  }
  navigateUp(e = this.currentCell, t) {
    var r, o;
    return e && (t && t.preventDefault(), r = e.getIndex(), o = this.table.rowManager.prevDisplayRow(e.row, !0), o) ? (o.cells[r].getComponent().edit(), !0) : !1;
  }
  navigateDown(e = this.currentCell, t) {
    var r, o;
    return e && (t && t.preventDefault(), r = e.getIndex(), o = this.table.rowManager.nextDisplayRow(e.row, !0), o) ? (o.cells[r].getComponent().edit(), !0) : !1;
  }
  findNextEditableCell(e, t) {
    var r = !1;
    if (t < e.cells.length - 1)
      for (var o = t + 1; o < e.cells.length; o++) {
        let s = e.cells[o];
        if (s.column.modules.edit && Ge.elVisible(s.getElement()) && this.allowEdit(s)) {
          r = s;
          break;
        }
      }
    return r;
  }
  findPrevEditableCell(e, t) {
    var r = !1;
    if (t > 0)
      for (var o = t - 1; o >= 0; o--) {
        let s = e.cells[o];
        if (s.column.modules.edit && Ge.elVisible(s.getElement()) && this.allowEdit(s)) {
          r = s;
          break;
        }
      }
    return r;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnCheck(e) {
    typeof e.definition.editor < "u" && this.initializeColumn(e);
  }
  columnDeleteCheck(e) {
    this.currentCell && this.currentCell.column === e && this.cancelEdit();
  }
  rowDeleteCheck(e) {
    this.currentCell && this.currentCell.row === e && this.cancelEdit();
  }
  rowEditableCheck(e) {
    e.getCells().forEach((t) => {
      t.column.modules.edit && typeof t.column.modules.edit.check == "function" && this.updateCellClass(t);
    });
  }
  //initialize column editor
  initializeColumn(e) {
    var t = {
      editor: !1,
      blocked: !1,
      check: e.definition.editable,
      params: e.definition.editorParams || {}
    };
    switch (typeof e.definition.editor) {
      case "string":
        this.editors[e.definition.editor] ? t.editor = this.editors[e.definition.editor] : console.warn("Editor Error - No such editor found: ", e.definition.editor);
        break;
      case "function":
        t.editor = e.definition.editor;
        break;
      case "boolean":
        e.definition.editor === !0 && (typeof e.definition.formatter != "function" ? this.editors[e.definition.formatter] ? t.editor = this.editors[e.definition.formatter] : t.editor = this.editors.input : console.warn("Editor Error - Cannot auto lookup editor for a custom formatter: ", e.definition.formatter));
        break;
    }
    t.editor && (e.modules.edit = t);
  }
  getCurrentCell() {
    return this.currentCell ? this.currentCell.getComponent() : !1;
  }
  clearEditor(e) {
    var t = this.currentCell, r;
    if (this.invalidEdit = !1, t) {
      for (this.currentCell = !1, r = t.getElement(), this.dispatch("edit-editor-clear", t, e), r.classList.remove("tabulator-editing"); r.firstChild; )
        r.removeChild(r.firstChild);
      t.row.getElement().classList.remove("tabulator-editing"), t.table.element.classList.remove("tabulator-editing");
    }
  }
  cancelEdit() {
    if (this.currentCell) {
      var e = this.currentCell, t = this.currentCell.getComponent();
      this.clearEditor(!0), e.setValueActual(e.getValue()), e.cellRendered(), (e.column.definition.editor == "textarea" || e.column.definition.variableHeight) && e.row.normalizeHeight(!0), e.column.definition.cellEditCancelled && e.column.definition.cellEditCancelled.call(this.table, t), this.dispatch("edit-cancelled", e), this.dispatchExternal("cellEditCancelled", t);
    }
  }
  //return a formatted value for a cell
  bindEditor(e) {
    if (e.column.modules.edit) {
      var t = this, r = e.getElement(!0);
      this.updateCellClass(e), r.setAttribute("tabindex", 0), r.addEventListener("click", function(o) {
        r.classList.contains("tabulator-editing") || r.focus({ preventScroll: !0 });
      }), r.addEventListener("mousedown", function(o) {
        o.button === 2 ? o.preventDefault() : t.mouseClick = !0;
      }), r.addEventListener("focus", function(o) {
        t.recursionBlock || t.edit(e, o, !1);
      });
    }
  }
  focusCellNoEvent(e, t) {
    this.recursionBlock = !0, t && this.table.browser === "ie" || e.getElement().focus({ preventScroll: !0 }), this.recursionBlock = !1;
  }
  editCell(e, t) {
    this.focusCellNoEvent(e), this.edit(e, !1, t);
  }
  focusScrollAdjust(e) {
    if (this.table.rowManager.getRenderMode() == "virtual") {
      var t = this.table.rowManager.element.scrollTop, r = this.table.rowManager.element.clientHeight + this.table.rowManager.element.scrollTop, o = e.row.getElement();
      o.offsetTop < t ? this.table.rowManager.element.scrollTop -= t - o.offsetTop : o.offsetTop + o.offsetHeight > r && (this.table.rowManager.element.scrollTop += o.offsetTop + o.offsetHeight - r);
      var s = this.table.rowManager.element.scrollLeft, n = this.table.rowManager.element.clientWidth + this.table.rowManager.element.scrollLeft, a = e.getElement();
      this.table.modExists("frozenColumns") && (s += parseInt(this.table.modules.frozenColumns.leftMargin || 0), n -= parseInt(this.table.modules.frozenColumns.rightMargin || 0)), this.table.options.renderHorizontal === "virtual" && (s -= parseInt(this.table.columnManager.renderer.vDomPadLeft), n -= parseInt(this.table.columnManager.renderer.vDomPadLeft)), a.offsetLeft < s ? this.table.rowManager.element.scrollLeft -= s - a.offsetLeft : a.offsetLeft + a.offsetWidth > n && (this.table.rowManager.element.scrollLeft += a.offsetLeft + a.offsetWidth - n);
    }
  }
  allowEdit(e) {
    var t = !!e.column.modules.edit;
    if (e.column.modules.edit)
      switch (typeof e.column.modules.edit.check) {
        case "function":
          e.row.initialized && (t = e.column.modules.edit.check(e.getComponent()));
          break;
        case "string":
          t = !!e.row.data[e.column.modules.edit.check];
          break;
        case "boolean":
          t = e.column.modules.edit.check;
          break;
      }
    return t;
  }
  edit(e, t, r) {
    var o = this, s = !0, n = function() {
    }, a = e.getElement(), l, u, h;
    if (this.currentCell) {
      !this.invalidEdit && this.currentCell !== e && this.cancelEdit();
      return;
    }
    function c(m) {
      if (o.currentCell === e) {
        var E = o.chain("edit-success", [e, m], !0, !0);
        return E === !0 || o.table.options.validationMode === "highlight" ? (o.clearEditor(), e.modules.edit || (e.modules.edit = {}), e.modules.edit.edited = !0, o.editedCells.indexOf(e) == -1 && o.editedCells.push(e), e.setValue(m, !0), E === !0) : (o.invalidEdit = !0, o.focusCellNoEvent(e, !0), n(), !1);
      }
    }
    function d() {
      o.currentCell === e && o.cancelEdit();
    }
    function f(m) {
      n = m;
    }
    if (e.column.modules.edit.blocked)
      return this.mouseClick = !1, a.blur(), !1;
    if (t && t.stopPropagation(), s = this.allowEdit(e), s || r) {
      if (o.cancelEdit(), o.currentCell = e, this.focusScrollAdjust(e), u = e.getComponent(), this.mouseClick && (this.mouseClick = !1, e.column.definition.cellClick && e.column.definition.cellClick.call(this.table, t, u)), e.column.definition.cellEditing && e.column.definition.cellEditing.call(this.table, u), this.dispatch("cell-editing", e), this.dispatchExternal("cellEditing", u), h = typeof e.column.modules.edit.params == "function" ? e.column.modules.edit.params(u) : e.column.modules.edit.params, l = e.column.modules.edit.editor.call(o, u, f, c, d, h), this.currentCell && l !== !1)
        if (l instanceof Node) {
          for (a.classList.add("tabulator-editing"), e.row.getElement().classList.add("tabulator-editing"), e.table.element.classList.add("tabulator-editing"); a.firstChild; )
            a.removeChild(a.firstChild);
          a.appendChild(l), n();
          for (var p = a.children, O = 0; O < p.length; O++)
            p[O].addEventListener("click", function(m) {
              m.stopPropagation();
            });
        } else
          return console.warn("Edit Error - Editor should return an instance of Node, the editor returned:", l), a.blur(), !1;
      else
        return a.blur(), !1;
      return !0;
    } else
      return this.mouseClick = !1, a.blur(), !1;
  }
  getEditedCells() {
    var e = [];
    return this.editedCells.forEach((t) => {
      e.push(t.getComponent());
    }), e;
  }
  clearEdited(e) {
    var t;
    e.modules.edit && e.modules.edit.edited && (e.modules.edit.edited = !1, this.dispatch("edit-edited-clear", e)), t = this.editedCells.indexOf(e), t > -1 && this.editedCells.splice(t, 1);
  }
}
Sn.moduleName = "edit";
Sn.editors = jB;
class pT {
  constructor(e, t, r, o) {
    this.type = e, this.columns = t, this.component = r || !1, this.indent = o || 0;
  }
}
class ld {
  constructor(e, t, r, o, s) {
    this.value = e, this.component = t || !1, this.width = r, this.height = o, this.depth = s;
  }
}
class UO extends ge {
  constructor(e) {
    super(e), this.config = {}, this.cloneTableStyle = !0, this.colVisProp = "", this.registerTableOption("htmlOutputConfig", !1), this.registerColumnOption("htmlOutput"), this.registerColumnOption("titleHtmlOutput");
  }
  initialize() {
    this.registerTableFunction("getHtml", this.getHtml.bind(this));
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  generateExportList(e, t, r, o) {
    this.cloneTableStyle = t, this.config = e || {}, this.colVisProp = o;
    var s = this.config.columnHeaders !== !1 ? this.headersToExportRows(this.generateColumnGroupHeaders()) : [], n = this.bodyToExportRows(this.rowLookup(r));
    return s.concat(n);
  }
  generateTable(e, t, r, o) {
    var s = this.generateExportList(e, t, r, o);
    return this.generateTableElement(s);
  }
  rowLookup(e) {
    var t = [];
    if (typeof e == "function")
      e.call(this.table).forEach((r) => {
        r = this.table.rowManager.findRow(r), r && t.push(r);
      });
    else
      switch (e) {
        case !0:
        case "visible":
          t = this.table.rowManager.getVisibleRows(!1, !0);
          break;
        case "all":
          t = this.table.rowManager.rows;
          break;
        case "selected":
          t = this.table.modules.selectRow.selectedRows;
          break;
        case "active":
        default:
          this.table.options.pagination ? t = this.table.rowManager.getDisplayRows(this.table.rowManager.displayRows.length - 2) : t = this.table.rowManager.getDisplayRows();
      }
    return Object.assign([], t);
  }
  generateColumnGroupHeaders() {
    var e = [], t = this.config.columnGroups !== !1 ? this.table.columnManager.columns : this.table.columnManager.columnsByIndex;
    return t.forEach((r) => {
      var o = this.processColumnGroup(r);
      o && e.push(o);
    }), e;
  }
  processColumnGroup(e) {
    var t = e.columns, r = 0, o = e.definition["title" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))] || e.definition.title, s = {
      title: o,
      column: e,
      depth: 1
    };
    if (t.length) {
      if (s.subGroups = [], s.width = 0, t.forEach((n) => {
        var a = this.processColumnGroup(n);
        a && (s.width += a.width, s.subGroups.push(a), a.depth > r && (r = a.depth));
      }), s.depth += r, !s.width)
        return !1;
    } else if (this.columnVisCheck(e))
      s.width = 1;
    else
      return !1;
    return s;
  }
  columnVisCheck(e) {
    var t = e.definition[this.colVisProp];
    return typeof t == "function" && (t = t.call(this.table, e.getComponent())), t !== !1 && (e.visible || !e.visible && t);
  }
  headersToExportRows(e) {
    var t = [], r = 0, o = [];
    function s(n, a) {
      var l = r - a;
      if (typeof t[a] > "u" && (t[a] = []), n.height = n.subGroups ? 1 : l - n.depth + 1, t[a].push(n), n.height > 1)
        for (let u = 1; u < n.height; u++)
          typeof t[a + u] > "u" && (t[a + u] = []), t[a + u].push(!1);
      if (n.width > 1)
        for (let u = 1; u < n.width; u++)
          t[a].push(!1);
      n.subGroups && n.subGroups.forEach(function(u) {
        s(u, a + 1);
      });
    }
    return e.forEach(function(n) {
      n.depth > r && (r = n.depth);
    }), e.forEach(function(n) {
      s(n, 0);
    }), t.forEach((n) => {
      var a = [];
      n.forEach((l) => {
        if (l) {
          let u = typeof l.title > "u" ? "" : l.title;
          a.push(new ld(u, l.column.getComponent(), l.width, l.height, l.depth));
        } else
          a.push(null);
      }), o.push(new pT("header", a));
    }), o;
  }
  bodyToExportRows(e) {
    var t = [], r = [];
    return this.table.columnManager.columnsByIndex.forEach((o) => {
      this.columnVisCheck(o) && t.push(o.getComponent());
    }), this.config.columnCalcs !== !1 && this.table.modExists("columnCalcs") && (this.table.modules.columnCalcs.topInitialized && e.unshift(this.table.modules.columnCalcs.topRow), this.table.modules.columnCalcs.botInitialized && e.push(this.table.modules.columnCalcs.botRow)), e = e.filter((o) => {
      switch (o.type) {
        case "group":
          return this.config.rowGroups !== !1;
        case "calc":
          return this.config.columnCalcs !== !1;
        case "row":
          return !(this.table.options.dataTree && this.config.dataTree === !1 && o.modules.dataTree.parent);
      }
      return !0;
    }), e.forEach((o, s) => {
      var n = o.getData(this.colVisProp), a = [], l = 0;
      switch (o.type) {
        case "group":
          l = o.level, a.push(new ld(o.key, o.getComponent(), t.length, 1));
          break;
        case "calc":
        case "row":
          t.forEach((u) => {
            a.push(new ld(u._column.getFieldValue(n), u, 1, 1));
          }), this.table.options.dataTree && this.config.dataTree !== !1 && (l = o.modules.dataTree.index);
          break;
      }
      r.push(new pT(o.type, a, o.getComponent(), l));
    }), r;
  }
  generateTableElement(e) {
    var t = document.createElement("table"), r = document.createElement("thead"), o = document.createElement("tbody"), s = this.lookupTableStyles(), n = this.table.options["rowFormatter" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))], a = {};
    return a.rowFormatter = n !== null ? n : this.table.options.rowFormatter, this.table.options.dataTree && this.config.dataTree !== !1 && this.table.modExists("columnCalcs") && (a.treeElementField = this.table.modules.dataTree.elementField), a.groupHeader = this.table.options["groupHeader" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))], a.groupHeader && !Array.isArray(a.groupHeader) && (a.groupHeader = [a.groupHeader]), t.classList.add("tabulator-print-table"), this.mapElementStyles(this.table.columnManager.getHeadersElement(), r, ["border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]), e.length > 1e3 && console.warn("It may take a long time to render an HTML table with more than 1000 rows"), e.forEach((l, u) => {
      let h;
      switch (l.type) {
        case "header":
          r.appendChild(this.generateHeaderElement(l, a, s));
          break;
        case "group":
          o.appendChild(this.generateGroupElement(l, a, s));
          break;
        case "calc":
          o.appendChild(this.generateCalcElement(l, a, s));
          break;
        case "row":
          h = this.generateRowElement(l, a, s), this.mapElementStyles(u % 2 && s.evenRow ? s.evenRow : s.oddRow, h, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), o.appendChild(h);
          break;
      }
    }), r.innerHTML && t.appendChild(r), t.appendChild(o), this.mapElementStyles(this.table.element, t, ["border-top", "border-left", "border-right", "border-bottom"]), t;
  }
  lookupTableStyles() {
    var e = {};
    return this.cloneTableStyle && window.getComputedStyle && (e.oddRow = this.table.element.querySelector(".tabulator-row-odd:not(.tabulator-group):not(.tabulator-calcs)"), e.evenRow = this.table.element.querySelector(".tabulator-row-even:not(.tabulator-group):not(.tabulator-calcs)"), e.calcRow = this.table.element.querySelector(".tabulator-row.tabulator-calcs"), e.firstRow = this.table.element.querySelector(".tabulator-row:not(.tabulator-group):not(.tabulator-calcs)"), e.firstGroup = this.table.element.getElementsByClassName("tabulator-group")[0], e.firstRow && (e.styleCells = e.firstRow.getElementsByClassName("tabulator-cell"), e.firstCell = e.styleCells[0], e.lastCell = e.styleCells[e.styleCells.length - 1])), e;
  }
  generateHeaderElement(e, t, r) {
    var o = document.createElement("tr");
    return e.columns.forEach((s) => {
      if (s) {
        var n = document.createElement("th"), a = s.component._column.definition.cssClass ? s.component._column.definition.cssClass.split(" ") : [];
        n.colSpan = s.width, n.rowSpan = s.height, n.innerHTML = s.value, this.cloneTableStyle && (n.style.boxSizing = "border-box"), a.forEach(function(l) {
          n.classList.add(l);
        }), this.mapElementStyles(s.component.getElement(), n, ["text-align", "border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]), this.mapElementStyles(s.component._column.contentElement, n, ["padding-top", "padding-left", "padding-right", "padding-bottom"]), s.component._column.visible ? this.mapElementStyles(s.component.getElement(), n, ["width"]) : s.component._column.definition.width && (n.style.width = s.component._column.definition.width + "px"), s.component._column.parent && this.mapElementStyles(s.component._column.parent.groupElement, n, ["border-top"]), o.appendChild(n);
      }
    }), o;
  }
  generateGroupElement(e, t, r) {
    var o = document.createElement("tr"), s = document.createElement("td"), n = e.columns[0];
    return o.classList.add("tabulator-print-table-row"), t.groupHeader && t.groupHeader[e.indent] ? n.value = t.groupHeader[e.indent](n.value, e.component._group.getRowCount(), e.component._group.getData(), e.component) : t.groupHeader !== !1 && (n.value = e.component._group.generator(n.value, e.component._group.getRowCount(), e.component._group.getData(), e.component)), s.colSpan = n.width, s.innerHTML = n.value, o.classList.add("tabulator-print-table-group"), o.classList.add("tabulator-group-level-" + e.indent), n.component.isVisible() && o.classList.add("tabulator-group-visible"), this.mapElementStyles(r.firstGroup, o, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), this.mapElementStyles(r.firstGroup, s, ["padding-top", "padding-left", "padding-right", "padding-bottom"]), o.appendChild(s), o;
  }
  generateCalcElement(e, t, r) {
    var o = this.generateRowElement(e, t, r);
    return o.classList.add("tabulator-print-table-calcs"), this.mapElementStyles(r.calcRow, o, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), o;
  }
  generateRowElement(e, t, r) {
    var o = document.createElement("tr");
    if (o.classList.add("tabulator-print-table-row"), e.columns.forEach((s, n) => {
      if (s) {
        var a = document.createElement("td"), l = s.component._column, u = this.table.columnManager.findColumnIndex(l), h = s.value, c, d = {
          modules: {},
          getValue: function() {
            return h;
          },
          getField: function() {
            return l.definition.field;
          },
          getElement: function() {
            return a;
          },
          getType: function() {
            return "cell";
          },
          getColumn: function() {
            return l.getComponent();
          },
          getData: function() {
            return e.component.getData();
          },
          getRow: function() {
            return e.component;
          },
          getComponent: function() {
            return d;
          },
          column: l
        }, f = l.definition.cssClass ? l.definition.cssClass.split(" ") : [];
        if (f.forEach(function(p) {
          a.classList.add(p);
        }), this.table.modExists("format") && this.config.formatCells !== !1)
          h = this.table.modules.format.formatExportValue(d, this.colVisProp);
        else
          switch (typeof h) {
            case "object":
              h = h !== null ? JSON.stringify(h) : "";
              break;
            case "undefined":
              h = "";
              break;
          }
        h instanceof Node ? a.appendChild(h) : a.innerHTML = h, c = r.styleCells && r.styleCells[u] ? r.styleCells[u] : r.firstCell, c && (this.mapElementStyles(c, a, ["padding-top", "padding-left", "padding-right", "padding-bottom", "border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "text-align"]), l.definition.align && (a.style.textAlign = l.definition.align)), this.table.options.dataTree && this.config.dataTree !== !1 && (t.treeElementField && t.treeElementField == l.field || !t.treeElementField && n == 0) && (e.component._row.modules.dataTree.controlEl && a.insertBefore(e.component._row.modules.dataTree.controlEl.cloneNode(!0), a.firstChild), e.component._row.modules.dataTree.branchEl && a.insertBefore(e.component._row.modules.dataTree.branchEl.cloneNode(!0), a.firstChild)), o.appendChild(a), d.modules.format && d.modules.format.renderedCallback && d.modules.format.renderedCallback();
      }
    }), t.rowFormatter && e.type === "row" && this.config.formatCells !== !1) {
      let s = Object.assign(e.component);
      s.getElement = function() {
        return o;
      }, t.rowFormatter(e.component);
    }
    return o;
  }
  generateHTMLTable(e) {
    var t = document.createElement("div");
    return t.appendChild(this.generateTableElement(e)), t.innerHTML;
  }
  getHtml(e, t, r, o) {
    var s = this.generateExportList(r || this.table.options.htmlOutputConfig, t, e, o || "htmlOutput");
    return this.generateHTMLTable(s);
  }
  mapElementStyles(e, t, r) {
    if (this.cloneTableStyle && e && t) {
      var o = {
        "background-color": "backgroundColor",
        color: "fontColor",
        width: "width",
        "font-weight": "fontWeight",
        "font-family": "fontFamily",
        "font-size": "fontSize",
        "text-align": "textAlign",
        "border-top": "borderTop",
        "border-left": "borderLeft",
        "border-right": "borderRight",
        "border-bottom": "borderBottom",
        "padding-top": "paddingTop",
        "padding-left": "paddingLeft",
        "padding-right": "paddingRight",
        "padding-bottom": "paddingBottom"
      };
      if (window.getComputedStyle) {
        var s = window.getComputedStyle(e);
        r.forEach(function(n) {
          t.style[o[n]] || (t.style[o[n]] = s.getPropertyValue(n));
        });
      }
    }
  }
}
UO.moduleName = "export";
var KB = {
  //equal to
  "=": function(i, e, t, r) {
    return e == i;
  },
  //less than
  "<": function(i, e, t, r) {
    return e < i;
  },
  //less than or equal to
  "<=": function(i, e, t, r) {
    return e <= i;
  },
  //greater than
  ">": function(i, e, t, r) {
    return e > i;
  },
  //greater than or equal to
  ">=": function(i, e, t, r) {
    return e >= i;
  },
  //not equal to
  "!=": function(i, e, t, r) {
    return e != i;
  },
  regex: function(i, e, t, r) {
    return typeof i == "string" && (i = new RegExp(i)), i.test(e);
  },
  //contains the string
  like: function(i, e, t, r) {
    return i === null || typeof i > "u" ? e === i : typeof e < "u" && e !== null ? String(e).toLowerCase().indexOf(i.toLowerCase()) > -1 : !1;
  },
  //contains the keywords
  keywords: function(i, e, t, r) {
    var o = i.toLowerCase().split(typeof r.separator > "u" ? " " : r.separator), s = String(e === null || typeof e > "u" ? "" : e).toLowerCase(), n = [];
    return o.forEach((a) => {
      s.includes(a) && n.push(!0);
    }), r.matchAll ? n.length === o.length : !!n.length;
  },
  //starts with the string
  starts: function(i, e, t, r) {
    return i === null || typeof i > "u" ? e === i : typeof e < "u" && e !== null ? String(e).toLowerCase().startsWith(i.toLowerCase()) : !1;
  },
  //ends with the string
  ends: function(i, e, t, r) {
    return i === null || typeof i > "u" ? e === i : typeof e < "u" && e !== null ? String(e).toLowerCase().endsWith(i.toLowerCase()) : !1;
  },
  //in array
  in: function(i, e, t, r) {
    return Array.isArray(i) ? i.length ? i.indexOf(e) > -1 : !0 : (console.warn("Filter Error - filter value is not an array:", i), !1);
  }
};
class Ji extends ge {
  constructor(e) {
    super(e), this.filterList = [], this.headerFilters = {}, this.headerFilterColumns = [], this.prevHeaderFilterChangeCheck = "", this.prevHeaderFilterChangeCheck = "{}", this.changed = !1, this.tableInitialized = !1, this.registerTableOption("filterMode", "local"), this.registerTableOption("initialFilter", !1), this.registerTableOption("initialHeaderFilter", !1), this.registerTableOption("headerFilterLiveFilterDelay", 300), this.registerTableOption("placeholderHeaderFilter", !1), this.registerColumnOption("headerFilter"), this.registerColumnOption("headerFilterPlaceholder"), this.registerColumnOption("headerFilterParams"), this.registerColumnOption("headerFilterEmptyCheck"), this.registerColumnOption("headerFilterFunc"), this.registerColumnOption("headerFilterFuncParams"), this.registerColumnOption("headerFilterLiveFilter"), this.registerTableFunction("searchRows", this.searchRows.bind(this)), this.registerTableFunction("searchData", this.searchData.bind(this)), this.registerTableFunction("setFilter", this.userSetFilter.bind(this)), this.registerTableFunction("refreshFilter", this.userRefreshFilter.bind(this)), this.registerTableFunction("addFilter", this.userAddFilter.bind(this)), this.registerTableFunction("getFilters", this.getFilters.bind(this)), this.registerTableFunction("setHeaderFilterFocus", this.userSetHeaderFilterFocus.bind(this)), this.registerTableFunction("getHeaderFilterValue", this.userGetHeaderFilterValue.bind(this)), this.registerTableFunction("setHeaderFilterValue", this.userSetHeaderFilterValue.bind(this)), this.registerTableFunction("getHeaderFilters", this.getHeaderFilters.bind(this)), this.registerTableFunction("removeFilter", this.userRemoveFilter.bind(this)), this.registerTableFunction("clearFilter", this.userClearFilter.bind(this)), this.registerTableFunction("clearHeaderFilter", this.userClearHeaderFilter.bind(this)), this.registerComponentFunction("column", "headerFilterFocus", this.setHeaderFilterFocus.bind(this)), this.registerComponentFunction("column", "reloadHeaderFilter", this.reloadHeaderFilter.bind(this)), this.registerComponentFunction("column", "getHeaderFilterValue", this.getHeaderFilterValue.bind(this)), this.registerComponentFunction("column", "setHeaderFilterValue", this.setHeaderFilterValue.bind(this));
  }
  initialize() {
    this.subscribe("column-init", this.initializeColumnHeaderFilter.bind(this)), this.subscribe("column-width-fit-before", this.hideHeaderFilterElements.bind(this)), this.subscribe("column-width-fit-after", this.showHeaderFilterElements.bind(this)), this.subscribe("table-built", this.tableBuilt.bind(this)), this.subscribe("placeholder", this.generatePlaceholder.bind(this)), this.table.options.filterMode === "remote" && this.subscribe("data-params", this.remoteFilterParams.bind(this)), this.registerDataHandler(this.filter.bind(this), 10);
  }
  tableBuilt() {
    this.table.options.initialFilter && this.setFilter(this.table.options.initialFilter), this.table.options.initialHeaderFilter && this.table.options.initialHeaderFilter.forEach((e) => {
      var t = this.table.columnManager.findColumn(e.field);
      if (t)
        this.setHeaderFilterValue(t, e.value);
      else
        return console.warn("Column Filter Error - No matching column found:", e.field), !1;
    }), this.tableInitialized = !0;
  }
  remoteFilterParams(e, t, r, o) {
    return o.filter = this.getFilters(!0, !0), o;
  }
  generatePlaceholder(e) {
    if (this.table.options.placeholderHeaderFilter && Object.keys(this.headerFilters).length)
      return this.table.options.placeholderHeaderFilter;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  //set standard filters
  userSetFilter(e, t, r, o) {
    this.setFilter(e, t, r, o), this.refreshFilter();
  }
  //set standard filters
  userRefreshFilter() {
    this.refreshFilter();
  }
  //add filter to array
  userAddFilter(e, t, r, o) {
    this.addFilter(e, t, r, o), this.refreshFilter();
  }
  userSetHeaderFilterFocus(e) {
    var t = this.table.columnManager.findColumn(e);
    if (t)
      this.setHeaderFilterFocus(t);
    else
      return console.warn("Column Filter Focus Error - No matching column found:", e), !1;
  }
  userGetHeaderFilterValue(e) {
    var t = this.table.columnManager.findColumn(e);
    if (t)
      return this.getHeaderFilterValue(t);
    console.warn("Column Filter Error - No matching column found:", e);
  }
  userSetHeaderFilterValue(e, t) {
    var r = this.table.columnManager.findColumn(e);
    if (r)
      this.setHeaderFilterValue(r, t);
    else
      return console.warn("Column Filter Error - No matching column found:", e), !1;
  }
  //remove filter from array
  userRemoveFilter(e, t, r) {
    this.removeFilter(e, t, r), this.refreshFilter();
  }
  //clear filters
  userClearFilter(e) {
    this.clearFilter(e), this.refreshFilter();
  }
  //clear header filters
  userClearHeaderFilter() {
    this.clearHeaderFilter(), this.refreshFilter();
  }
  //search for specific row components
  searchRows(e, t, r) {
    return this.search("rows", e, t, r);
  }
  //search for specific data
  searchData(e, t, r) {
    return this.search("data", e, t, r);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnHeaderFilter(e) {
    var t = e.definition;
    t.headerFilter && this.initializeColumn(e);
  }
  //initialize column header filter
  initializeColumn(e, t) {
    var r = this, o = e.getField();
    function s(n) {
      var a = e.modules.filter.tagType == "input" && e.modules.filter.attrType == "text" || e.modules.filter.tagType == "textarea" ? "partial" : "match", l = "", u = "", h;
      if (typeof e.modules.filter.prevSuccess > "u" || e.modules.filter.prevSuccess !== n) {
        if (e.modules.filter.prevSuccess = n, e.modules.filter.emptyFunc(n))
          delete r.headerFilters[o];
        else {
          switch (e.modules.filter.value = n, typeof e.definition.headerFilterFunc) {
            case "string":
              Ji.filters[e.definition.headerFilterFunc] ? (l = e.definition.headerFilterFunc, h = function(c) {
                var d = e.definition.headerFilterFuncParams || {}, f = e.getFieldValue(c);
                return d = typeof d == "function" ? d(n, f, c) : d, Ji.filters[e.definition.headerFilterFunc](n, f, c, d);
              }) : console.warn("Header Filter Error - Matching filter function not found: ", e.definition.headerFilterFunc);
              break;
            case "function":
              h = function(c) {
                var d = e.definition.headerFilterFuncParams || {}, f = e.getFieldValue(c);
                return d = typeof d == "function" ? d(n, f, c) : d, e.definition.headerFilterFunc(n, f, c, d);
              }, l = h;
              break;
          }
          if (!h)
            switch (a) {
              case "partial":
                h = function(c) {
                  var d = e.getFieldValue(c);
                  return typeof d < "u" && d !== null ? String(d).toLowerCase().indexOf(String(n).toLowerCase()) > -1 : !1;
                }, l = "like";
                break;
              default:
                h = function(c) {
                  return e.getFieldValue(c) == n;
                }, l = "=";
            }
          r.headerFilters[o] = { value: n, func: h, type: l };
        }
        e.modules.filter.value = n, u = JSON.stringify(r.headerFilters), r.prevHeaderFilterChangeCheck !== u && (r.prevHeaderFilterChangeCheck = u, r.trackChanges(), r.refreshFilter());
      }
      return !0;
    }
    e.modules.filter = {
      success: s,
      attrType: !1,
      tagType: !1,
      emptyFunc: !1
    }, this.generateHeaderFilterElement(e);
  }
  generateHeaderFilterElement(e, t, r) {
    var o = this, s = e.modules.filter.success, n = e.getField(), a, l, u, h, c, d, f, p;
    e.modules.filter.value = t;
    function O() {
    }
    function m(E) {
      p = E;
    }
    if (e.modules.filter.headerElement && e.modules.filter.headerElement.parentNode && e.contentElement.removeChild(e.modules.filter.headerElement.parentNode), n) {
      switch (e.modules.filter.emptyFunc = e.definition.headerFilterEmptyCheck || function(E) {
        return !E && E !== 0;
      }, a = document.createElement("div"), a.classList.add("tabulator-header-filter"), typeof e.definition.headerFilter) {
        case "string":
          o.table.modules.edit.editors[e.definition.headerFilter] ? (l = o.table.modules.edit.editors[e.definition.headerFilter], (e.definition.headerFilter === "tick" || e.definition.headerFilter === "tickCross") && !e.definition.headerFilterEmptyCheck && (e.modules.filter.emptyFunc = function(E) {
            return E !== !0 && E !== !1;
          })) : console.warn("Filter Error - Cannot build header filter, No such editor found: ", e.definition.editor);
          break;
        case "function":
          l = e.definition.headerFilter;
          break;
        case "boolean":
          e.modules.edit && e.modules.edit.editor ? l = e.modules.edit.editor : e.definition.formatter && o.table.modules.edit.editors[e.definition.formatter] ? (l = o.table.modules.edit.editors[e.definition.formatter], (e.definition.formatter === "tick" || e.definition.formatter === "tickCross") && !e.definition.headerFilterEmptyCheck && (e.modules.filter.emptyFunc = function(E) {
            return E !== !0 && E !== !1;
          })) : l = o.table.modules.edit.editors.input;
          break;
      }
      if (l) {
        if (h = {
          getValue: function() {
            return typeof t < "u" ? t : "";
          },
          getField: function() {
            return e.definition.field;
          },
          getElement: function() {
            return a;
          },
          getColumn: function() {
            return e.getComponent();
          },
          getTable: () => this.table,
          getType: () => "header",
          getRow: function() {
            return {
              normalizeHeight: function() {
              }
            };
          }
        }, f = e.definition.headerFilterParams || {}, f = typeof f == "function" ? f.call(o.table, h) : f, u = l.call(this.table.modules.edit, h, m, s, O, f), !u) {
          console.warn("Filter Error - Cannot add filter to " + n + " column, editor returned a value of false");
          return;
        }
        if (!(u instanceof Node)) {
          console.warn("Filter Error - Cannot add filter to " + n + " column, editor should return an instance of Node, the editor returned:", u);
          return;
        }
        o.langBind("headerFilters|columns|" + e.definition.field, function(E) {
          u.setAttribute("placeholder", typeof E < "u" && E ? E : e.definition.headerFilterPlaceholder || o.langText("headerFilters|default"));
        }), u.addEventListener("click", function(E) {
          E.stopPropagation(), u.focus();
        }), u.addEventListener("focus", (E) => {
          var g = this.table.columnManager.contentsElement.scrollLeft, A = this.table.rowManager.element.scrollLeft;
          g !== A && (this.table.rowManager.scrollHorizontal(g), this.table.columnManager.scrollHorizontal(g));
        }), c = !1, d = function(E) {
          c && clearTimeout(c), c = setTimeout(function() {
            s(u.value);
          }, o.table.options.headerFilterLiveFilterDelay);
        }, e.modules.filter.headerElement = u, e.modules.filter.attrType = u.hasAttribute("type") ? u.getAttribute("type").toLowerCase() : "", e.modules.filter.tagType = u.tagName.toLowerCase(), e.definition.headerFilterLiveFilter !== !1 && (e.definition.headerFilter === "autocomplete" || e.definition.headerFilter === "tickCross" || (e.definition.editor === "autocomplete" || e.definition.editor === "tickCross") && e.definition.headerFilter === !0 || (u.addEventListener("keyup", d), u.addEventListener("search", d), e.modules.filter.attrType == "number" && u.addEventListener("change", function(E) {
          s(u.value);
        }), e.modules.filter.attrType == "text" && this.table.browser !== "ie" && u.setAttribute("type", "search")), (e.modules.filter.tagType == "input" || e.modules.filter.tagType == "select" || e.modules.filter.tagType == "textarea") && u.addEventListener("mousedown", function(E) {
          E.stopPropagation();
        })), a.appendChild(u), e.contentElement.appendChild(a), r || o.headerFilterColumns.push(e), p && p();
      }
    } else
      console.warn("Filter Error - Cannot add header filter, column has no field set:", e.definition.title);
  }
  //hide all header filter elements (used to ensure correct column widths in "fitData" layout mode)
  hideHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(e) {
      e.modules.filter && e.modules.filter.headerElement && (e.modules.filter.headerElement.style.display = "none");
    });
  }
  //show all header filter elements (used to ensure correct column widths in "fitData" layout mode)
  showHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(e) {
      e.modules.filter && e.modules.filter.headerElement && (e.modules.filter.headerElement.style.display = "");
    });
  }
  //programmatically set focus of header filter
  setHeaderFilterFocus(e) {
    e.modules.filter && e.modules.filter.headerElement ? e.modules.filter.headerElement.focus() : console.warn("Column Filter Focus Error - No header filter set on column:", e.getField());
  }
  //programmatically get value of header filter
  getHeaderFilterValue(e) {
    if (e.modules.filter && e.modules.filter.headerElement)
      return e.modules.filter.value;
    console.warn("Column Filter Error - No header filter set on column:", e.getField());
  }
  //programmatically set value of header filter
  setHeaderFilterValue(e, t) {
    e && (e.modules.filter && e.modules.filter.headerElement ? (this.generateHeaderFilterElement(e, t, !0), e.modules.filter.success(t)) : console.warn("Column Filter Error - No header filter set on column:", e.getField()));
  }
  reloadHeaderFilter(e) {
    e && (e.modules.filter && e.modules.filter.headerElement ? this.generateHeaderFilterElement(e, e.modules.filter.value, !0) : console.warn("Column Filter Error - No header filter set on column:", e.getField()));
  }
  refreshFilter() {
    this.tableInitialized && (this.table.options.filterMode === "remote" ? this.reloadData(null, !1, !1) : this.refreshData(!0));
  }
  //check if the filters has changed since last use
  trackChanges() {
    this.changed = !0, this.dispatch("filter-changed");
  }
  //check if the filters has changed since last use
  hasChanged() {
    var e = this.changed;
    return this.changed = !1, e;
  }
  //set standard filters
  setFilter(e, t, r, o) {
    this.filterList = [], Array.isArray(e) || (e = [{ field: e, type: t, value: r, params: o }]), this.addFilter(e);
  }
  //add filter to array
  addFilter(e, t, r, o) {
    var s = !1;
    Array.isArray(e) || (e = [{ field: e, type: t, value: r, params: o }]), e.forEach((n) => {
      n = this.findFilter(n), n && (this.filterList.push(n), s = !0);
    }), s && this.trackChanges();
  }
  findFilter(e) {
    var t;
    if (Array.isArray(e))
      return this.findSubFilters(e);
    var r = !1;
    return typeof e.field == "function" ? r = function(o) {
      return e.field(o, e.type || {});
    } : Ji.filters[e.type] ? (t = this.table.columnManager.getColumnByField(e.field), t ? r = function(o) {
      return Ji.filters[e.type](e.value, t.getFieldValue(o), o, e.params || {});
    } : r = function(o) {
      return Ji.filters[e.type](e.value, o[e.field], o, e.params || {});
    }) : console.warn("Filter Error - No such filter type found, ignoring: ", e.type), e.func = r, e.func ? e : !1;
  }
  findSubFilters(e) {
    var t = [];
    return e.forEach((r) => {
      r = this.findFilter(r), r && t.push(r);
    }), t.length ? t : !1;
  }
  //get all filters
  getFilters(e, t) {
    var r = [];
    return e && (r = this.getHeaderFilters()), t && r.forEach(function(o) {
      typeof o.type == "function" && (o.type = "function");
    }), r = r.concat(this.filtersToArray(this.filterList, t)), r;
  }
  //filter to Object
  filtersToArray(e, t) {
    var r = [];
    return e.forEach((o) => {
      var s;
      Array.isArray(o) ? r.push(this.filtersToArray(o, t)) : (s = { field: o.field, type: o.type, value: o.value }, t && typeof s.type == "function" && (s.type = "function"), r.push(s));
    }), r;
  }
  //get all filters
  getHeaderFilters() {
    var e = [];
    for (var t in this.headerFilters)
      e.push({ field: t, type: this.headerFilters[t].type, value: this.headerFilters[t].value });
    return e;
  }
  //remove filter from array
  removeFilter(e, t, r) {
    Array.isArray(e) || (e = [{ field: e, type: t, value: r }]), e.forEach((o) => {
      var s = -1;
      typeof o.field == "object" ? s = this.filterList.findIndex((n) => o === n) : s = this.filterList.findIndex((n) => o.field === n.field && o.type === n.type && o.value === n.value), s > -1 ? this.filterList.splice(s, 1) : console.warn("Filter Error - No matching filter type found, ignoring: ", o.type);
    }), this.trackChanges();
  }
  //clear filters
  clearFilter(e) {
    this.filterList = [], e && this.clearHeaderFilter(), this.trackChanges();
  }
  //clear header filters
  clearHeaderFilter() {
    this.headerFilters = {}, this.prevHeaderFilterChangeCheck = "{}", this.headerFilterColumns.forEach((e) => {
      typeof e.modules.filter.value < "u" && delete e.modules.filter.value, e.modules.filter.prevSuccess = void 0, this.reloadHeaderFilter(e);
    }), this.trackChanges();
  }
  //search data and return matching rows
  search(e, t, r, o) {
    var s = [], n = [];
    return Array.isArray(t) || (t = [{ field: t, type: r, value: o }]), t.forEach((a) => {
      a = this.findFilter(a), a && n.push(a);
    }), this.table.rowManager.rows.forEach((a) => {
      var l = !0;
      n.forEach((u) => {
        this.filterRecurse(u, a.getData()) || (l = !1);
      }), l && s.push(e === "data" ? a.getData("data") : a.getComponent());
    }), s;
  }
  //filter row array
  filter(e, t) {
    var r = [], o = [];
    return this.subscribedExternal("dataFiltering") && this.dispatchExternal("dataFiltering", this.getFilters(!0)), this.table.options.filterMode !== "remote" && (this.filterList.length || Object.keys(this.headerFilters).length) ? e.forEach((s) => {
      this.filterRow(s) && r.push(s);
    }) : r = e.slice(0), this.subscribedExternal("dataFiltered") && (r.forEach((s) => {
      o.push(s.getComponent());
    }), this.dispatchExternal("dataFiltered", this.getFilters(!0), o)), r;
  }
  //filter individual row
  filterRow(e, t) {
    var r = !0, o = e.getData();
    this.filterList.forEach((n) => {
      this.filterRecurse(n, o) || (r = !1);
    });
    for (var s in this.headerFilters)
      this.headerFilters[s].func(o) || (r = !1);
    return r;
  }
  filterRecurse(e, t) {
    var r = !1;
    return Array.isArray(e) ? e.forEach((o) => {
      this.filterRecurse(o, t) && (r = !0);
    }) : r = e.func(t), r;
  }
}
Ji.moduleName = "filter";
Ji.filters = KB;
function JB(i, e, t) {
  return this.emptyToSpace(this.sanitizeHTML(i.getValue()));
}
function e2(i, e, t) {
  return i.getValue();
}
function t2(i, e, t) {
  return i.getElement().style.whiteSpace = "pre-wrap", this.emptyToSpace(this.sanitizeHTML(i.getValue()));
}
function i2(i, e, t) {
  var r = parseFloat(i.getValue()), o = "", s, n, a, l, u, h = e.decimal || ".", c = e.thousand || ",", d = e.negativeSign || "-", f = e.symbol || "", p = !!e.symbolAfter, O = typeof e.precision < "u" ? e.precision : 2;
  if (isNaN(r))
    return this.emptyToSpace(this.sanitizeHTML(i.getValue()));
  if (r < 0 && (r = Math.abs(r), o = d), s = O !== !1 ? r.toFixed(O) : r, s = String(s).split("."), n = s[0], a = s.length > 1 ? h + s[1] : "", e.thousand !== !1)
    for (l = /(\d+)(\d{3})/; l.test(n); )
      n = n.replace(l, "$1" + c + "$2");
  return u = n + a, o === !0 ? (u = "(" + u + ")", p ? u + f : f + u) : p ? o + u + f : o + f + u;
}
function r2(i, e, t) {
  var r = i.getValue(), o = e.urlPrefix || "", s = e.download, n = r, a = document.createElement("a"), l;
  function u(h, c) {
    var d = h.shift(), f = c[d];
    return h.length && typeof f == "object" ? u(h, f) : f;
  }
  if (e.labelField && (l = i.getData(), n = u(e.labelField.split(this.table.options.nestedFieldSeparator), l)), e.label)
    switch (typeof e.label) {
      case "string":
        n = e.label;
        break;
      case "function":
        n = e.label(i);
        break;
    }
  if (n) {
    if (e.urlField && (l = i.getData(), r = l[e.urlField]), e.url)
      switch (typeof e.url) {
        case "string":
          r = e.url;
          break;
        case "function":
          r = e.url(i);
          break;
      }
    return a.setAttribute("href", o + r), e.target && a.setAttribute("target", e.target), e.download && (typeof s == "function" ? s = s(i) : s = s === !0 ? "" : s, a.setAttribute("download", s)), a.innerHTML = this.emptyToSpace(this.sanitizeHTML(n)), a;
  } else
    return "&nbsp;";
}
function o2(i, e, t) {
  var r = document.createElement("img"), o = i.getValue();
  switch (e.urlPrefix && (o = e.urlPrefix + i.getValue()), e.urlSuffix && (o = o + e.urlSuffix), r.setAttribute("src", o), typeof e.height) {
    case "number":
      r.style.height = e.height + "px";
      break;
    case "string":
      r.style.height = e.height;
      break;
  }
  switch (typeof e.width) {
    case "number":
      r.style.width = e.width + "px";
      break;
    case "string":
      r.style.width = e.width;
      break;
  }
  return r.addEventListener("load", function() {
    i.getRow().normalizeHeight();
  }), r;
}
function s2(i, e, t) {
  var r = i.getValue(), o = i.getElement(), s = e.allowEmpty, n = e.allowTruthy, a = Object.keys(e).includes("trueValue"), l = typeof e.tickElement < "u" ? e.tickElement : '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>', u = typeof e.crossElement < "u" ? e.crossElement : '<svg enable-background="new 0 0 24 24" height="14" width="14"  viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
  return a && r === e.trueValue || !a && (n && r || r === !0 || r === "true" || r === "True" || r === 1 || r === "1") ? (o.setAttribute("aria-checked", !0), l || "") : s && (r === "null" || r === "" || r === null || typeof r > "u") ? (o.setAttribute("aria-checked", "mixed"), "") : (o.setAttribute("aria-checked", !1), u || "");
}
function n2(i, e, t) {
  var r = window.DateTime || luxon.DateTime, o = e.inputFormat || "yyyy-MM-dd HH:mm:ss", s = e.outputFormat || "dd/MM/yyyy HH:mm:ss", n = typeof e.invalidPlaceholder < "u" ? e.invalidPlaceholder : "", a = i.getValue();
  if (typeof r < "u") {
    var l;
    return r.isDateTime(a) ? l = a : o === "iso" ? l = r.fromISO(String(a)) : l = r.fromFormat(String(a), o), l.isValid ? (e.timezone && (l = l.setZone(e.timezone)), l.toFormat(s)) : n === !0 || !a ? a : typeof n == "function" ? n(a) : n;
  } else
    console.error("Format Error - 'datetime' formatter is dependant on luxon.js");
}
function a2(i, e, t) {
  var r = window.DateTime || luxon.DateTime, o = e.inputFormat || "yyyy-MM-dd HH:mm:ss", s = typeof e.invalidPlaceholder < "u" ? e.invalidPlaceholder : "", n = typeof e.suffix < "u" ? e.suffix : !1, a = typeof e.unit < "u" ? e.unit : "days", l = typeof e.humanize < "u" ? e.humanize : !1, u = typeof e.date < "u" ? e.date : r.now(), h = i.getValue();
  if (typeof r < "u") {
    var c;
    return r.isDateTime(h) ? c = h : o === "iso" ? c = r.fromISO(String(h)) : c = r.fromFormat(String(h), o), c.isValid ? l ? c.diff(u, a).toHuman() + (n ? " " + n : "") : parseInt(c.diff(u, a)[a]) + (n ? " " + n : "") : s === !0 ? h : typeof s == "function" ? s(h) : s;
  } else
    console.error("Format Error - 'datetimediff' formatter is dependant on luxon.js");
}
function l2(i, e, t) {
  var r = i.getValue();
  return typeof e[r] > "u" ? (console.warn("Missing display value for " + r), r) : e[r];
}
function u2(i, e, t) {
  var r = i.getValue(), o = i.getElement(), s = e && e.stars ? e.stars : 5, n = document.createElement("span"), a = document.createElementNS("http://www.w3.org/2000/svg", "svg"), l = '<polygon fill="#FFEA00" stroke="#C1AB60" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>', u = '<polygon fill="#D2D2D2" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
  n.style.verticalAlign = "middle", a.setAttribute("width", "14"), a.setAttribute("height", "14"), a.setAttribute("viewBox", "0 0 512 512"), a.setAttribute("xml:space", "preserve"), a.style.padding = "0 1px", r = r && !isNaN(r) ? parseInt(r) : 0, r = Math.max(0, Math.min(r, s));
  for (var h = 1; h <= s; h++) {
    var c = a.cloneNode(!0);
    c.innerHTML = h <= r ? l : u, n.appendChild(c);
  }
  return o.style.whiteSpace = "nowrap", o.style.overflow = "hidden", o.style.textOverflow = "ellipsis", o.setAttribute("aria-label", r), n;
}
function h2(i, e, t) {
  var r = this.sanitizeHTML(i.getValue()) || 0, o = document.createElement("span"), s = e && e.max ? e.max : 100, n = e && e.min ? e.min : 0, a = e && typeof e.color < "u" ? e.color : ["red", "orange", "green"], l = "#666666", u, h;
  if (!(isNaN(r) || typeof i.getValue() > "u")) {
    switch (o.classList.add("tabulator-traffic-light"), h = parseFloat(r) <= s ? parseFloat(r) : s, h = parseFloat(h) >= n ? parseFloat(h) : n, u = (s - n) / 100, h = Math.round((h - n) / u), typeof a) {
      case "string":
        l = a;
        break;
      case "function":
        l = a(r);
        break;
      case "object":
        if (Array.isArray(a)) {
          var c = 100 / a.length, d = Math.floor(h / c);
          d = Math.min(d, a.length - 1), d = Math.max(d, 0), l = a[d];
          break;
        }
    }
    return o.style.backgroundColor = l, o;
  }
}
function c2(i, e = {}, t) {
  var r = this.sanitizeHTML(i.getValue()) || 0, o = i.getElement(), s = e.max ? e.max : 100, n = e.min ? e.min : 0, a = e.legendAlign ? e.legendAlign : "center", l, u, h, c, d;
  switch (u = parseFloat(r) <= s ? parseFloat(r) : s, u = parseFloat(u) >= n ? parseFloat(u) : n, l = (s - n) / 100, u = Math.round((u - n) / l), typeof e.color) {
    case "string":
      h = e.color;
      break;
    case "function":
      h = e.color(r);
      break;
    case "object":
      if (Array.isArray(e.color)) {
        let m = 100 / e.color.length, E = Math.floor(u / m);
        E = Math.min(E, e.color.length - 1), E = Math.max(E, 0), h = e.color[E];
        break;
      }
    default:
      h = "#2DC214";
  }
  switch (typeof e.legend) {
    case "string":
      c = e.legend;
      break;
    case "function":
      c = e.legend(r);
      break;
    case "boolean":
      c = r;
      break;
    default:
      c = !1;
  }
  switch (typeof e.legendColor) {
    case "string":
      d = e.legendColor;
      break;
    case "function":
      d = e.legendColor(r);
      break;
    case "object":
      if (Array.isArray(e.legendColor)) {
        let m = 100 / e.legendColor.length, E = Math.floor(u / m);
        E = Math.min(E, e.legendColor.length - 1), E = Math.max(E, 0), d = e.legendColor[E];
      }
      break;
    default:
      d = "#000";
  }
  o.style.minWidth = "30px", o.style.position = "relative", o.setAttribute("aria-label", u);
  var f = document.createElement("div");
  f.style.display = "inline-block", f.style.width = u + "%", f.style.backgroundColor = h, f.style.height = "100%", f.setAttribute("data-max", s), f.setAttribute("data-min", n);
  var p = document.createElement("div");
  if (p.style.position = "relative", p.style.width = "100%", p.style.height = "100%", c) {
    var O = document.createElement("div");
    O.style.position = "absolute", O.style.top = 0, O.style.left = 0, O.style.textAlign = a, O.style.width = "100%", O.style.color = d, O.innerHTML = c;
  }
  return t(function() {
    if (!(i instanceof tv)) {
      var m = document.createElement("div");
      m.style.position = "absolute", m.style.top = "4px", m.style.bottom = "4px", m.style.left = "4px", m.style.right = "4px", o.appendChild(m), o = m;
    }
    o.appendChild(p), p.appendChild(f), c && p.appendChild(O);
  }), "";
}
function d2(i, e, t) {
  return i.getElement().style.backgroundColor = this.sanitizeHTML(i.getValue()), "";
}
function f2(i, e, t) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>';
}
function p2(i, e, t) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
}
function O2(i, e, t) {
  var r = document.createElement("span"), o = i.getRow();
  return o.watchPosition((s) => {
    r.innerText = s;
  }), r;
}
function E2(i, e, t) {
  return i.getElement().classList.add("tabulator-row-handle"), "<div class='tabulator-row-handle-box'><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div></div>";
}
function m2(i, e, t) {
  var r = document.createElement("div"), o = i.getRow()._row.modules.responsiveLayout;
  r.classList.add("tabulator-responsive-collapse-toggle"), r.innerHTML = `<svg class='tabulator-responsive-collapse-toggle-open' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12" fill="none" stroke-width="3" stroke-linecap="round" />
  <line y1="7" x1="12" y2="17" x2="12" fill="none" stroke-width="3" stroke-linecap="round" />
</svg>

<svg class='tabulator-responsive-collapse-toggle-close' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12"  fill="none" stroke-width="3" stroke-linecap="round" />
</svg>`, i.getElement().classList.add("tabulator-row-handle");
  function s(n) {
    var a = o.element;
    o.open = n, a && (o.open ? (r.classList.add("open"), a.style.display = "") : (r.classList.remove("open"), a.style.display = "none"));
  }
  return r.addEventListener("click", function(n) {
    n.stopImmediatePropagation(), s(!o.open), i.getTable().rowManager.adjustTableSize();
  }), s(o.open), r;
}
function g2(i, e, t) {
  var r = document.createElement("input"), o = !1;
  if (r.type = "checkbox", r.setAttribute("aria-label", "Select Row"), this.table.modExists("selectRow", !0))
    if (r.addEventListener("click", (n) => {
      n.stopPropagation();
    }), typeof i.getRow == "function") {
      var s = i.getRow();
      s instanceof tc ? (r.addEventListener("change", (n) => {
        this.table.options.selectableRangeMode === "click" && o ? o = !1 : s.toggleSelect();
      }), this.table.options.selectableRangeMode === "click" && r.addEventListener("click", (n) => {
        o = !0, this.table.modules.selectRow.handleComplexRowClick(s._row, n);
      }), r.checked = s.isSelected && s.isSelected(), this.table.modules.selectRow.registerRowSelectCheckbox(s, r)) : r = "";
    } else
      r.addEventListener("change", (n) => {
        this.table.modules.selectRow.selectedRows.length ? this.table.deselectRow() : this.table.selectRow(e.rowRange);
      }), this.table.modules.selectRow.registerHeaderSelectCheckbox(r);
  return r;
}
var b2 = {
  plaintext: JB,
  html: e2,
  textarea: t2,
  money: i2,
  link: r2,
  image: o2,
  tickCross: s2,
  datetime: n2,
  datetimediff: a2,
  lookup: l2,
  star: u2,
  traffic: h2,
  progress: c2,
  color: d2,
  buttonTick: f2,
  buttonCross: p2,
  rownum: O2,
  handle: E2,
  responsiveCollapse: m2,
  rowSelection: g2
};
class ri extends ge {
  constructor(e) {
    super(e), this.registerColumnOption("formatter"), this.registerColumnOption("formatterParams"), this.registerColumnOption("formatterPrint"), this.registerColumnOption("formatterPrintParams"), this.registerColumnOption("formatterClipboard"), this.registerColumnOption("formatterClipboardParams"), this.registerColumnOption("formatterHtmlOutput"), this.registerColumnOption("formatterHtmlOutputParams"), this.registerColumnOption("titleFormatter"), this.registerColumnOption("titleFormatterParams");
  }
  initialize() {
    this.subscribe("cell-format", this.formatValue.bind(this)), this.subscribe("cell-rendered", this.cellRendered.bind(this)), this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("column-format", this.formatHeader.bind(this));
  }
  //initialize column formatter
  initializeColumn(e) {
    e.modules.format = this.lookupFormatter(e, ""), typeof e.definition.formatterPrint < "u" && (e.modules.format.print = this.lookupFormatter(e, "Print")), typeof e.definition.formatterClipboard < "u" && (e.modules.format.clipboard = this.lookupFormatter(e, "Clipboard")), typeof e.definition.formatterHtmlOutput < "u" && (e.modules.format.htmlOutput = this.lookupFormatter(e, "HtmlOutput"));
  }
  lookupFormatter(e, t) {
    var r = { params: e.definition["formatter" + t + "Params"] || {} }, o = e.definition["formatter" + t];
    switch (typeof o) {
      case "string":
        ri.formatters[o] ? r.formatter = ri.formatters[o] : (console.warn("Formatter Error - No such formatter found: ", o), r.formatter = ri.formatters.plaintext);
        break;
      case "function":
        r.formatter = o;
        break;
      default:
        r.formatter = ri.formatters.plaintext;
        break;
    }
    return r;
  }
  cellRendered(e) {
    e.modules.format && e.modules.format.renderedCallback && !e.modules.format.rendered && (e.modules.format.renderedCallback(), e.modules.format.rendered = !0);
  }
  //return a formatted value for a column header
  formatHeader(e, t, r) {
    var o, s, n, a;
    return e.definition.titleFormatter ? (o = this.getFormatter(e.definition.titleFormatter), n = (l) => {
      e.titleFormatterRendered = l;
    }, a = {
      getValue: function() {
        return t;
      },
      getElement: function() {
        return r;
      },
      getType: function() {
        return "header";
      },
      getColumn: function() {
        return e.getComponent();
      },
      getTable: () => this.table
    }, s = e.definition.titleFormatterParams || {}, s = typeof s == "function" ? s() : s, o.call(this, a, s, n)) : t;
  }
  //return a formatted value for a cell
  formatValue(e) {
    var t = e.getComponent(), r = typeof e.column.modules.format.params == "function" ? e.column.modules.format.params(t) : e.column.modules.format.params;
    function o(s) {
      e.modules.format || (e.modules.format = {}), e.modules.format.renderedCallback = s, e.modules.format.rendered = !1;
    }
    return e.column.modules.format.formatter.call(this, t, r, o);
  }
  formatExportValue(e, t) {
    var r = e.column.modules.format[t], o;
    if (r) {
      let n = function(a) {
        e.modules.format || (e.modules.format = {}), e.modules.format.renderedCallback = a, e.modules.format.rendered = !1;
      };
      var s = n;
      return o = typeof r.params == "function" ? r.params(e.getComponent()) : r.params, r.formatter.call(this, e.getComponent(), o, n);
    } else
      return this.formatValue(e);
  }
  sanitizeHTML(e) {
    if (e) {
      var t = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      return String(e).replace(/[&<>"'`=/]/g, function(r) {
        return t[r];
      });
    } else
      return e;
  }
  emptyToSpace(e) {
    return e === null || typeof e > "u" || e === "" ? "&nbsp;" : e;
  }
  //get formatter for cell
  getFormatter(e) {
    switch (typeof e) {
      case "string":
        ri.formatters[e] ? e = ri.formatters[e] : (console.warn("Formatter Error - No such formatter found: ", e), e = ri.formatters.plaintext);
        break;
      case "function":
        break;
      default:
        e = ri.formatters.plaintext;
        break;
    }
    return e;
  }
}
ri.moduleName = "format";
ri.formatters = b2;
class QO extends ge {
  constructor(e) {
    super(e), this.leftColumns = [], this.rightColumns = [], this.initializationMode = "left", this.active = !1, this.blocked = !0, this.registerColumnOption("frozen");
  }
  //reset initial state
  reset() {
    this.initializationMode = "left", this.leftColumns = [], this.rightColumns = [], this.active = !1;
  }
  initialize() {
    this.subscribe("cell-layout", this.layoutCell.bind(this)), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("column-width", this.layout.bind(this)), this.subscribe("row-layout-after", this.layoutRow.bind(this)), this.subscribe("table-layout", this.layout.bind(this)), this.subscribe("columns-loading", this.reset.bind(this)), this.subscribe("column-add", this.reinitializeColumns.bind(this)), this.subscribe("column-delete", this.reinitializeColumns.bind(this)), this.subscribe("table-redraw", this.layout.bind(this)), this.subscribe("layout-refreshing", this.blockLayout.bind(this)), this.subscribe("layout-refreshed", this.unblockLayout.bind(this)), this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this));
  }
  blockLayout() {
    this.blocked = !0;
  }
  unblockLayout() {
    this.blocked = !1;
  }
  layoutCell(e) {
    this.layoutElement(e.element, e.column);
  }
  reinitializeColumns() {
    this.reset(), this.table.columnManager.columnsByIndex.forEach((e) => {
      this.initializeColumn(e);
    });
  }
  //initialize specific column
  initializeColumn(e) {
    var t = { margin: 0, edge: !1 };
    e.isGroup || (this.frozenCheck(e) ? (t.position = this.initializationMode, this.initializationMode == "left" ? this.leftColumns.push(e) : this.rightColumns.unshift(e), this.active = !0, e.modules.frozen = t) : this.initializationMode = "right");
  }
  frozenCheck(e) {
    return e.parent.isGroup && e.definition.frozen && console.warn("Frozen Column Error - Parent column group must be frozen, not individual columns or sub column groups"), e.parent.isGroup ? this.frozenCheck(e.parent) : e.definition.frozen;
  }
  //layout calculation rows
  layoutCalcRows() {
    this.table.modExists("columnCalcs") && (this.table.modules.columnCalcs.topInitialized && this.table.modules.columnCalcs.topRow && this.layoutRow(this.table.modules.columnCalcs.topRow), this.table.modules.columnCalcs.botInitialized && this.table.modules.columnCalcs.botRow && this.layoutRow(this.table.modules.columnCalcs.botRow), this.table.modExists("groupRows") && this.layoutGroupCalcs(this.table.modules.groupRows.getGroups()));
  }
  layoutGroupCalcs(e) {
    e.forEach((t) => {
      t.calcs.top && this.layoutRow(t.calcs.top), t.calcs.bottom && this.layoutRow(t.calcs.bottom), t.groupList && t.groupList.length && this.layoutGroupCalcs(t.groupList);
    });
  }
  //calculate column positions and layout headers
  layoutColumnPosition(e) {
    var t = [], r = 0, o = 0;
    this.leftColumns.forEach((s, n) => {
      if (s.modules.frozen.marginValue = r, s.modules.frozen.margin = s.modules.frozen.marginValue + "px", s.visible && (r += s.getWidth()), n == this.leftColumns.length - 1 ? s.modules.frozen.edge = !0 : s.modules.frozen.edge = !1, s.parent.isGroup) {
        var a = this.getColGroupParentElement(s);
        t.includes(a) || (this.layoutElement(a, s), t.push(a)), s.modules.frozen.edge && a.classList.add("tabulator-frozen-" + s.modules.frozen.position);
      } else
        this.layoutElement(s.getElement(), s);
      e && s.cells.forEach((l) => {
        this.layoutElement(l.getElement(!0), s);
      });
    }), this.rightColumns.forEach((s, n) => {
      s.modules.frozen.marginValue = o, s.modules.frozen.margin = s.modules.frozen.marginValue + "px", s.visible && (o += s.getWidth()), n == this.rightColumns.length - 1 ? s.modules.frozen.edge = !0 : s.modules.frozen.edge = !1, s.parent.isGroup ? this.layoutElement(this.getColGroupParentElement(s), s) : this.layoutElement(s.getElement(), s), e && s.cells.forEach((a) => {
        this.layoutElement(a.getElement(!0), s);
      });
    });
  }
  getColGroupParentElement(e) {
    return e.parent.isGroup ? this.getColGroupParentElement(e.parent) : e.getElement();
  }
  //layout columns appropriately
  layout() {
    this.active && !this.blocked && (this.layoutColumnPosition(), this.reinitializeRows(), this.layoutCalcRows());
  }
  reinitializeRows() {
    var e = this.table.rowManager.getVisibleRows(!0), t = this.table.rowManager.getRows().filter((r) => !e.includes(r));
    t.forEach((r) => {
      r.deinitialize();
    }), e.forEach((r) => {
      r.type === "row" && this.layoutRow(r);
    });
  }
  layoutRow(e) {
    this.table.options.layout === "fitDataFill" && this.rightColumns.length && (this.table.rowManager.getTableElement().style.minWidth = "calc(100% - " + this.rightMargin + ")"), this.leftColumns.forEach((t) => {
      var r = e.getCell(t);
      r && this.layoutElement(r.getElement(!0), t);
    }), this.rightColumns.forEach((t) => {
      var r = e.getCell(t);
      r && this.layoutElement(r.getElement(!0), t);
    });
  }
  layoutElement(e, t) {
    var r;
    t.modules.frozen && e && (e.style.position = "sticky", this.table.rtl ? r = t.modules.frozen.position === "left" ? "right" : "left" : r = t.modules.frozen.position, e.style[r] = t.modules.frozen.margin, e.classList.add("tabulator-frozen"), t.modules.frozen.edge && e.classList.add("tabulator-frozen-" + t.modules.frozen.position));
  }
  adjustForScrollbar(e) {
    this.rightColumns.length && (this.table.columnManager.getContentsElement().style.width = "calc(100% - " + e + "px)");
  }
  _calcSpace(e, t) {
    var r = 0;
    for (let o = 0; o < t; o++)
      e[o].visible && (r += e[o].getWidth());
    return r;
  }
}
QO.moduleName = "frozenColumns";
class kO extends ge {
  constructor(e) {
    super(e), this.topElement = document.createElement("div"), this.rows = [], this.registerComponentFunction("row", "freeze", this.freezeRow.bind(this)), this.registerComponentFunction("row", "unfreeze", this.unfreezeRow.bind(this)), this.registerComponentFunction("row", "isFrozen", this.isRowFrozen.bind(this)), this.registerTableOption("frozenRowsField", "id"), this.registerTableOption("frozenRows", !1);
  }
  initialize() {
    this.rows = [], this.topElement.classList.add("tabulator-frozen-rows-holder"), this.table.columnManager.getContentsElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling), this.subscribe("row-deleting", this.detachRow.bind(this)), this.subscribe("rows-visible", this.visibleRows.bind(this)), this.registerDisplayHandler(this.getRows.bind(this), 10), this.table.options.frozenRows && (this.subscribe("data-processed", this.initializeRows.bind(this)), this.subscribe("row-added", this.initializeRow.bind(this)), this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this)), this.subscribe("column-resized", this.resizeHolderWidth.bind(this)), this.subscribe("column-show", this.resizeHolderWidth.bind(this)), this.subscribe("column-hide", this.resizeHolderWidth.bind(this))), this.resizeHolderWidth();
  }
  resizeHolderWidth() {
    this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
  }
  initializeRows() {
    this.table.rowManager.getRows().forEach((e) => {
      this.initializeRow(e);
    });
  }
  initializeRow(e) {
    var t = this.table.options.frozenRows, r = typeof t;
    r === "number" ? e.getPosition() && e.getPosition() + this.rows.length <= t && this.freezeRow(e) : r === "function" ? t.call(this.table, e.getComponent()) && this.freezeRow(e) : Array.isArray(t) && t.includes(e.data[this.options("frozenRowsField")]) && this.freezeRow(e);
  }
  isRowFrozen(e) {
    var t = this.rows.indexOf(e);
    return t > -1;
  }
  isFrozen() {
    return !!this.rows.length;
  }
  visibleRows(e, t) {
    return this.rows.forEach((r) => {
      t.push(r);
    }), t;
  }
  //filter frozen rows out of display data
  getRows(e) {
    var t = e.slice(0);
    return this.rows.forEach(function(r) {
      var o = t.indexOf(r);
      o > -1 && t.splice(o, 1);
    }), t;
  }
  freezeRow(e) {
    e.modules.frozen ? console.warn("Freeze Error - Row is already frozen") : (e.modules.frozen = !0, this.topElement.appendChild(e.getElement()), e.initialize(), e.normalizeHeight(), this.rows.push(e), this.refreshData(!1, "display"), this.table.rowManager.adjustTableSize(), this.styleRows());
  }
  unfreezeRow(e) {
    e.modules.frozen ? (e.modules.frozen = !1, this.detachRow(e), this.table.rowManager.adjustTableSize(), this.refreshData(!1, "display"), this.rows.length && this.styleRows()) : console.warn("Freeze Error - Row is already unfrozen");
  }
  detachRow(e) {
    var t = this.rows.indexOf(e);
    if (t > -1) {
      var r = e.getElement();
      r.parentNode && r.parentNode.removeChild(r), this.rows.splice(t, 1);
    }
  }
  styleRows(e) {
    this.rows.forEach((t, r) => {
      this.table.rowManager.styleRow(t, r);
    });
  }
}
kO.moduleName = "frozenRows";
class T2 {
  constructor(e) {
    return this._group = e, this.type = "GroupComponent", new Proxy(this, {
      get: function(t, r, o) {
        return typeof t[r] < "u" ? t[r] : t._group.groupManager.table.componentFunctionBinder.handle("group", t._group, r);
      }
    });
  }
  getKey() {
    return this._group.key;
  }
  getField() {
    return this._group.field;
  }
  getElement() {
    return this._group.element;
  }
  getRows() {
    return this._group.getRows(!0);
  }
  getSubGroups() {
    return this._group.getSubGroups(!0);
  }
  getParentGroup() {
    return this._group.parent ? this._group.parent.getComponent() : !1;
  }
  isVisible() {
    return this._group.visible;
  }
  show() {
    this._group.show();
  }
  hide() {
    this._group.hide();
  }
  toggle() {
    this._group.toggleVisibility();
  }
  scrollTo(e, t) {
    return this._group.groupManager.table.rowManager.scrollToRow(this._group, e, t);
  }
  _getSelf() {
    return this._group;
  }
  getTable() {
    return this._group.groupManager.table;
  }
}
class Us {
  constructor(e, t, r, o, s, n, a) {
    this.groupManager = e, this.parent = t, this.key = o, this.level = r, this.field = s, this.hasSubGroups = r < e.groupIDLookups.length - 1, this.addRow = this.hasSubGroups ? this._addRowToGroup : this._addRow, this.type = "group", this.old = a, this.rows = [], this.groups = [], this.groupList = [], this.generator = n, this.element = !1, this.elementContents = !1, this.height = 0, this.outerHeight = 0, this.initialized = !1, this.calcs = {}, this.initialized = !1, this.modules = {}, this.arrowElement = !1, this.visible = a ? a.visible : typeof e.startOpen[r] < "u" ? e.startOpen[r] : e.startOpen[0], this.component = null, this.createElements(), this.addBindings(), this.createValueGroups();
  }
  wipe(e) {
    e || (this.groupList.length ? this.groupList.forEach(function(t) {
      t.wipe();
    }) : this.rows.forEach((t) => {
      t.modules && delete t.modules.group;
    })), this.element = !1, this.arrowElement = !1, this.elementContents = !1;
  }
  createElements() {
    var e = document.createElement("div");
    e.classList.add("tabulator-arrow"), this.element = document.createElement("div"), this.element.classList.add("tabulator-row"), this.element.classList.add("tabulator-group"), this.element.classList.add("tabulator-group-level-" + this.level), this.element.setAttribute("role", "rowgroup"), this.arrowElement = document.createElement("div"), this.arrowElement.classList.add("tabulator-group-toggle"), this.arrowElement.appendChild(e), this.groupManager.table.options.movableRows !== !1 && this.groupManager.table.modExists("moveRow") && this.groupManager.table.modules.moveRow.initializeGroupHeader(this);
  }
  createValueGroups() {
    var e = this.level + 1;
    this.groupManager.allowedValues && this.groupManager.allowedValues[e] && this.groupManager.allowedValues[e].forEach((t) => {
      this._createGroup(t, e);
    });
  }
  addBindings() {
    var e;
    this.groupManager.table.options.groupToggleElement && (e = this.groupManager.table.options.groupToggleElement == "arrow" ? this.arrowElement : this.element, e.addEventListener("click", (t) => {
      t.stopPropagation(), t.stopImmediatePropagation(), this.toggleVisibility();
    }));
  }
  _createGroup(e, t) {
    var r = t + "_" + e, o = new Us(this.groupManager, this, t, e, this.groupManager.groupIDLookups[t].field, this.groupManager.headerGenerator[t] || this.groupManager.headerGenerator[0], this.old ? this.old.groups[r] : !1);
    this.groups[r] = o, this.groupList.push(o);
  }
  _addRowToGroup(e) {
    var t = this.level + 1;
    if (this.hasSubGroups) {
      var r = this.groupManager.groupIDLookups[t].func(e.getData()), o = t + "_" + r;
      this.groupManager.allowedValues && this.groupManager.allowedValues[t] ? this.groups[o] && this.groups[o].addRow(e) : (this.groups[o] || this._createGroup(r, t), this.groups[o].addRow(e));
    }
  }
  _addRow(e) {
    this.rows.push(e), e.modules.group = this;
  }
  insertRow(e, t, r) {
    var o = this.conformRowData({});
    e.updateData(o);
    var s = this.rows.indexOf(t);
    s > -1 ? r ? this.rows.splice(s + 1, 0, e) : this.rows.splice(s, 0, e) : r ? this.rows.push(e) : this.rows.unshift(e), e.modules.group = this, this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modules.columnCalcs.recalcGroup(this), this.groupManager.updateGroupRows(!0);
  }
  scrollHeader(e) {
    this.arrowElement && (this.arrowElement.style.marginLeft = e, this.groupList.forEach(function(t) {
      t.scrollHeader(e);
    }));
  }
  getRowIndex(e) {
  }
  //update row data to match grouping constraints
  conformRowData(e) {
    return this.field ? e[this.field] = this.key : console.warn("Data Conforming Error - Cannot conform row data to match new group as groupBy is a function"), this.parent && (e = this.parent.conformRowData(e)), e;
  }
  removeRow(e) {
    var t = this.rows.indexOf(e), r = e.getElement();
    t > -1 && this.rows.splice(t, 1), !this.groupManager.table.options.groupValues && !this.rows.length ? (this.parent ? this.parent.removeGroup(this) : this.groupManager.removeGroup(this), this.groupManager.updateGroupRows(!0)) : (r.parentNode && r.parentNode.removeChild(r), this.groupManager.blockRedraw || (this.generateGroupHeaderContents(), this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modules.columnCalcs.recalcGroup(this)));
  }
  removeGroup(e) {
    var t = e.level + "_" + e.key, r;
    this.groups[t] && (delete this.groups[t], r = this.groupList.indexOf(e), r > -1 && this.groupList.splice(r, 1), this.groupList.length || (this.parent ? this.parent.removeGroup(this) : this.groupManager.removeGroup(this)));
  }
  getHeadersAndRows() {
    var e = [];
    return e.push(this), this._visSet(), this.calcs.top && (this.calcs.top.detachElement(), this.calcs.top.deleteCells()), this.calcs.bottom && (this.calcs.bottom.detachElement(), this.calcs.bottom.deleteCells()), this.visible ? this.groupList.length ? this.groupList.forEach(function(t) {
      e = e.concat(t.getHeadersAndRows());
    }) : (this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasTopCalcs() && (this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows), e.push(this.calcs.top)), e = e.concat(this.rows), this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasBottomCalcs() && (this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows), e.push(this.calcs.bottom))) : !this.groupList.length && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && (this.groupManager.table.modules.columnCalcs.hasTopCalcs() && this.groupManager.table.options.groupClosedShowCalcs && (this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows), e.push(this.calcs.top)), this.groupManager.table.modules.columnCalcs.hasBottomCalcs() && this.groupManager.table.options.groupClosedShowCalcs && (this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows), e.push(this.calcs.bottom))), e;
  }
  getData(e, t) {
    var r = [];
    return this._visSet(), (!e || e && this.visible) && this.rows.forEach((o) => {
      r.push(o.getData(t || "data"));
    }), r;
  }
  getRowCount() {
    var e = 0;
    return this.groupList.length ? this.groupList.forEach((t) => {
      e += t.getRowCount();
    }) : e = this.rows.length, e;
  }
  toggleVisibility() {
    this.visible ? this.hide() : this.show();
  }
  hide() {
    this.visible = !1, this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination ? (this.element.classList.remove("tabulator-group-visible"), this.groupList.length ? this.groupList.forEach((e) => {
      var t = e.getHeadersAndRows();
      t.forEach((r) => {
        r.detachElement();
      });
    }) : this.rows.forEach((e) => {
      var t = e.getElement();
      t.parentNode.removeChild(t);
    }), this.groupManager.updateGroupRows(!0)) : this.groupManager.updateGroupRows(!0), this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), !1);
  }
  show() {
    if (this.visible = !0, this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination) {
      this.element.classList.add("tabulator-group-visible");
      var e = this.generateElement();
      this.groupList.length ? this.groupList.forEach((t) => {
        var r = t.getHeadersAndRows();
        r.forEach((o) => {
          var s = o.getElement();
          e.parentNode.insertBefore(s, e.nextSibling), o.initialize(), e = s;
        });
      }) : this.rows.forEach((t) => {
        var r = t.getElement();
        e.parentNode.insertBefore(r, e.nextSibling), t.initialize(), e = r;
      }), this.groupManager.updateGroupRows(!0);
    } else
      this.groupManager.updateGroupRows(!0);
    this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), !0);
  }
  _visSet() {
    var e = [];
    typeof this.visible == "function" && (this.rows.forEach(function(t) {
      e.push(t.getData());
    }), this.visible = this.visible(this.key, this.getRowCount(), e, this.getComponent()));
  }
  getRowGroup(e) {
    var t = !1;
    return this.groupList.length ? this.groupList.forEach(function(r) {
      var o = r.getRowGroup(e);
      o && (t = o);
    }) : this.rows.find(function(r) {
      return r === e;
    }) && (t = this), t;
  }
  getSubGroups(e) {
    var t = [];
    return this.groupList.forEach(function(r) {
      t.push(e ? r.getComponent() : r);
    }), t;
  }
  getRows(e) {
    var t = [];
    return this.rows.forEach(function(r) {
      t.push(e ? r.getComponent() : r);
    }), t;
  }
  generateGroupHeaderContents() {
    var e = [];
    for (this.rows.forEach(function(t) {
      e.push(t.getData());
    }), this.elementContents = this.generator(this.key, this.getRowCount(), e, this.getComponent()); this.element.firstChild; )
      this.element.removeChild(this.element.firstChild);
    typeof this.elementContents == "string" ? this.element.innerHTML = this.elementContents : this.element.appendChild(this.elementContents), this.element.insertBefore(this.arrowElement, this.element.firstChild);
  }
  getPath(e = []) {
    return e.unshift(this.key), this.parent && this.parent.getPath(e), e;
  }
  ////////////// Standard Row Functions //////////////
  getElement() {
    return this.elementContents ? this.element : this.generateElement();
  }
  generateElement() {
    this.addBindings = !1, this._visSet(), this.visible ? this.element.classList.add("tabulator-group-visible") : this.element.classList.remove("tabulator-group-visible");
    for (var e = 0; e < this.element.childNodes.length; ++e)
      this.element.childNodes[e].parentNode.removeChild(this.element.childNodes[e]);
    return this.generateGroupHeaderContents(), this.element;
  }
  detachElement() {
    this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
  }
  //normalize the height of elements in the row
  normalizeHeight() {
    this.setHeight(this.element.clientHeight);
  }
  initialize(e) {
    (!this.initialized || e) && (this.normalizeHeight(), this.initialized = !0);
  }
  reinitialize() {
    this.initialized = !1, this.height = 0, Ge.elVisible(this.element) && this.initialize(!0);
  }
  setHeight(e) {
    this.height != e && (this.height = e, this.outerHeight = this.element.offsetHeight);
  }
  //return rows outer height
  getHeight() {
    return this.outerHeight;
  }
  getGroup() {
    return this;
  }
  reinitializeHeight() {
  }
  calcHeight() {
  }
  setCellHeight() {
  }
  clearCellHeight() {
  }
  deinitializeHeight() {
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new T2(this)), this.component;
  }
}
class $O extends ge {
  constructor(e) {
    super(e), this.groupIDLookups = !1, this.startOpen = [function() {
      return !1;
    }], this.headerGenerator = [function() {
      return "";
    }], this.groupList = [], this.allowedValues = !1, this.groups = {}, this.displayHandler = this.getRows.bind(this), this.blockRedraw = !1, this.registerTableOption("groupBy", !1), this.registerTableOption("groupStartOpen", !0), this.registerTableOption("groupValues", !1), this.registerTableOption("groupUpdateOnCellEdit", !1), this.registerTableOption("groupHeader", !1), this.registerTableOption("groupHeaderPrint", null), this.registerTableOption("groupHeaderClipboard", null), this.registerTableOption("groupHeaderHtmlOutput", null), this.registerTableOption("groupHeaderDownload", null), this.registerTableOption("groupToggleElement", "arrow"), this.registerTableOption("groupClosedShowCalcs", !1), this.registerTableFunction("setGroupBy", this.setGroupBy.bind(this)), this.registerTableFunction("setGroupValues", this.setGroupValues.bind(this)), this.registerTableFunction("setGroupStartOpen", this.setGroupStartOpen.bind(this)), this.registerTableFunction("setGroupHeader", this.setGroupHeader.bind(this)), this.registerTableFunction("getGroups", this.userGetGroups.bind(this)), this.registerTableFunction("getGroupedData", this.userGetGroupedData.bind(this)), this.registerComponentFunction("row", "getGroup", this.rowGetGroup.bind(this));
  }
  //initialize group configuration
  initialize() {
    this.subscribe("table-destroy", this._blockRedrawing.bind(this)), this.subscribe("rows-wipe", this._blockRedrawing.bind(this)), this.subscribe("rows-wiped", this._restore_redrawing.bind(this)), this.table.options.groupBy && (this.table.options.groupUpdateOnCellEdit && (this.subscribe("cell-value-updated", this.cellUpdated.bind(this)), this.subscribe("row-data-changed", this.reassignRowToGroup.bind(this), 0)), this.subscribe("table-built", this.configureGroupSetup.bind(this)), this.subscribe("row-deleting", this.rowDeleting.bind(this)), this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("scroll-horizontal", this.scrollHeaders.bind(this)), this.subscribe("rows-wipe", this.wipe.bind(this)), this.subscribe("rows-added", this.rowsUpdated.bind(this)), this.subscribe("row-moving", this.rowMoving.bind(this)), this.subscribe("row-adding-index", this.rowAddingIndex.bind(this)), this.subscribe("rows-sample", this.rowSample.bind(this)), this.subscribe("render-virtual-fill", this.virtualRenderFill.bind(this)), this.registerDisplayHandler(this.displayHandler, 20), this.initialized = !0);
  }
  _blockRedrawing() {
    this.blockRedraw = !0;
  }
  _restore_redrawing() {
    this.blockRedraw = !1;
  }
  configureGroupSetup() {
    if (this.table.options.groupBy) {
      var e = this.table.options.groupBy, t = this.table.options.groupStartOpen, r = this.table.options.groupHeader;
      if (this.allowedValues = this.table.options.groupValues, Array.isArray(e) && Array.isArray(r) && e.length > r.length && console.warn("Error creating group headers, groupHeader array is shorter than groupBy array"), this.headerGenerator = [function() {
        return "";
      }], this.startOpen = [function() {
        return !1;
      }], this.langBind("groups|item", (s, n) => {
        this.headerGenerator[0] = (a, l, u) => (typeof a > "u" ? "" : a) + "<span>(" + l + " " + (l === 1 ? s : n.groups.items) + ")</span>";
      }), this.groupIDLookups = [], e)
        this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "table" && this.table.options.columnCalcs != "both" && this.table.modules.columnCalcs.removeCalcs();
      else if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "group") {
        var o = this.table.columnManager.getRealColumns();
        o.forEach((s) => {
          s.definition.topCalc && this.table.modules.columnCalcs.initializeTopRow(), s.definition.bottomCalc && this.table.modules.columnCalcs.initializeBottomRow();
        });
      }
      Array.isArray(e) || (e = [e]), e.forEach((s, n) => {
        var a, l;
        typeof s == "function" ? a = s : (l = this.table.columnManager.getColumnByField(s), l ? a = function(u) {
          return l.getFieldValue(u);
        } : a = function(u) {
          return u[s];
        }), this.groupIDLookups.push({
          field: typeof s == "function" ? !1 : s,
          func: a,
          values: this.allowedValues ? this.allowedValues[n] : !1
        });
      }), t && (Array.isArray(t) || (t = [t]), t.forEach((s) => {
      }), this.startOpen = t), r && (this.headerGenerator = Array.isArray(r) ? r : [r]);
    } else
      this.groupList = [], this.groups = {};
  }
  rowSample(e, t) {
    if (this.table.options.groupBy) {
      var r = this.getGroups(!1)[0];
      t.push(r.getRows(!1)[0]);
    }
    return t;
  }
  virtualRenderFill() {
    var e = this.table.rowManager.tableElement, t = this.table.rowManager.getVisibleRows();
    if (this.table.options.groupBy)
      t = t.filter((r) => r.type !== "group"), e.style.minWidth = t.length ? "" : this.table.columnManager.getWidth() + "px";
    else
      return t;
  }
  rowAddingIndex(e, t, r) {
    if (this.table.options.groupBy) {
      this.assignRowToGroup(e);
      var o = e.modules.group.rows;
      return o.length > 1 && (!t || t && o.indexOf(t) == -1 ? r ? o[0] !== e && (t = o[0], this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !r)) : o[o.length - 1] !== e && (t = o[o.length - 1], this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !r)) : this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !r)), t;
    }
  }
  trackChanges() {
    this.dispatch("group-changed");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  setGroupBy(e) {
    this.table.options.groupBy = e, this.initialized || this.initialize(), this.configureGroupSetup(), !e && this.table.modExists("columnCalcs") && this.table.options.columnCalcs === !0 && this.table.modules.columnCalcs.reinitializeCalcs(), this.refreshData(), this.trackChanges();
  }
  setGroupValues(e) {
    this.table.options.groupValues = e, this.configureGroupSetup(), this.refreshData(), this.trackChanges();
  }
  setGroupStartOpen(e) {
    this.table.options.groupStartOpen = e, this.configureGroupSetup(), this.table.options.groupBy ? (this.refreshData(), this.trackChanges()) : console.warn("Grouping Update - cant refresh view, no groups have been set");
  }
  setGroupHeader(e) {
    this.table.options.groupHeader = e, this.configureGroupSetup(), this.table.options.groupBy ? (this.refreshData(), this.trackChanges()) : console.warn("Grouping Update - cant refresh view, no groups have been set");
  }
  userGetGroups(e) {
    return this.getGroups(!0);
  }
  // get grouped table data in the same format as getData()
  userGetGroupedData() {
    return this.table.options.groupBy ? this.getGroupedData() : this.getData();
  }
  ///////////////////////////////////////
  ///////// Component Functions /////////
  ///////////////////////////////////////
  rowGetGroup(e) {
    return e.modules.group ? e.modules.group.getComponent() : !1;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  rowMoving(e, t, r) {
    if (this.table.options.groupBy) {
      !r && t instanceof Us && (t = this.table.rowManager.prevDisplayRow(e) || t);
      var o = t instanceof Us ? t : t.modules.group, s = e instanceof Us ? e : e.modules.group;
      o === s ? this.table.rowManager.moveRowInArray(o.rows, e, t, r) : (s && s.removeRow(e), o.insertRow(e, t, r));
    }
  }
  rowDeleting(e) {
    this.table.options.groupBy && e.modules.group && e.modules.group.removeRow(e);
  }
  rowsUpdated(e) {
    this.table.options.groupBy && this.updateGroupRows(!0);
  }
  cellUpdated(e) {
    this.table.options.groupBy && this.reassignRowToGroup(e.row);
  }
  //return appropriate rows with group headers
  getRows(e) {
    return this.table.options.groupBy && this.groupIDLookups.length ? (this.dispatchExternal("dataGrouping"), this.generateGroups(e), this.subscribedExternal("dataGrouped") && this.dispatchExternal("dataGrouped", this.getGroups(!0)), this.updateGroupRows()) : e.slice(0);
  }
  getGroups(e) {
    var t = [];
    return this.groupList.forEach(function(r) {
      t.push(e ? r.getComponent() : r);
    }), t;
  }
  getChildGroups(e) {
    var t = [];
    return e || (e = this), e.groupList.forEach((r) => {
      r.groupList.length ? t = t.concat(this.getChildGroups(r)) : t.push(r);
    }), t;
  }
  wipe() {
    this.table.options.groupBy && (this.groupList.forEach(function(e) {
      e.wipe();
    }), this.groupList = [], this.groups = {});
  }
  pullGroupListData(e) {
    var t = [];
    return e.forEach((r) => {
      var o = {};
      o.level = 0, o.rowCount = 0, o.headerContent = "";
      var s = [];
      r.hasSubGroups ? (s = this.pullGroupListData(r.groupList), o.level = r.level, o.rowCount = s.length - r.groupList.length, o.headerContent = r.generator(r.key, o.rowCount, r.rows, r), t.push(o), t = t.concat(s)) : (o.level = r.level, o.headerContent = r.generator(r.key, r.rows.length, r.rows, r), o.rowCount = r.getRows().length, t.push(o), r.getRows().forEach((n) => {
        t.push(n.getData("data"));
      }));
    }), t;
  }
  getGroupedData() {
    return this.pullGroupListData(this.groupList);
  }
  getRowGroup(e) {
    var t = !1;
    return this.options("dataTree") && (e = this.table.modules.dataTree.getTreeParentRoot(e)), this.groupList.forEach((r) => {
      var o = r.getRowGroup(e);
      o && (t = o);
    }), t;
  }
  countGroups() {
    return this.groupList.length;
  }
  generateGroups(e) {
    var t = this.groups;
    this.groups = {}, this.groupList = [], this.allowedValues && this.allowedValues[0] ? (this.allowedValues[0].forEach((r) => {
      this.createGroup(r, 0, t);
    }), e.forEach((r) => {
      this.assignRowToExistingGroup(r, t);
    })) : e.forEach((r) => {
      this.assignRowToGroup(r, t);
    }), Object.values(t).forEach((r) => {
      r.wipe(!0);
    });
  }
  createGroup(e, t, r) {
    var o = t + "_" + e, s;
    r = r || [], s = new Us(this, !1, t, e, this.groupIDLookups[0].field, this.headerGenerator[0], r[o]), this.groups[o] = s, this.groupList.push(s);
  }
  assignRowToExistingGroup(e, t) {
    var r = this.groupIDLookups[0].func(e.getData()), o = "0_" + r;
    this.groups[o] && this.groups[o].addRow(e);
  }
  assignRowToGroup(e, t) {
    var r = this.groupIDLookups[0].func(e.getData()), o = !this.groups["0_" + r];
    return o && this.createGroup(r, 0, t), this.groups["0_" + r].addRow(e), !o;
  }
  reassignRowToGroup(e) {
    if (e.type === "row") {
      var t = e.modules.group, r = t.getPath(), o = this.getExpectedPath(e), s;
      s = r.length == o.length && r.every((n, a) => n === o[a]), s || (t.removeRow(e), this.assignRowToGroup(e, this.groups), this.refreshData(!0));
    }
  }
  getExpectedPath(e) {
    var t = [], r = e.getData();
    return this.groupIDLookups.forEach((o) => {
      t.push(o.func(r));
    }), t;
  }
  updateGroupRows(e) {
    var t = [];
    return this.blockRedraw || (this.groupList.forEach((r) => {
      t = t.concat(r.getHeadersAndRows());
    }), e && this.refreshData(!0)), t;
  }
  scrollHeaders(e) {
    this.table.options.groupBy && (this.table.options.renderHorizontal === "virtual" && (e -= this.table.columnManager.renderer.vDomPadLeft), e = e + "px", this.groupList.forEach((t) => {
      t.scrollHeader(e);
    }));
  }
  removeGroup(e) {
    var t = e.level + "_" + e.key, r;
    this.groups[t] && (delete this.groups[t], r = this.groupList.indexOf(e), r > -1 && this.groupList.splice(r, 1));
  }
  checkBasicModeGroupHeaderWidth() {
    var e = this.table.rowManager.tableElement, t = !0;
    this.table.rowManager.getDisplayRows().forEach((r, o) => {
      this.table.rowManager.styleRow(r, o), e.appendChild(r.getElement()), r.initialize(!0), r.type !== "group" && (t = !1);
    }), t ? e.style.minWidth = this.table.columnManager.getWidth() + "px" : e.style.minWidth = "";
  }
}
$O.moduleName = "groupRows";
var S2 = {
  cellEdit: function(i) {
    i.component.setValueProcessData(i.data.oldValue), i.component.cellRendered();
  },
  rowAdd: function(i) {
    i.component.deleteActual();
  },
  rowDelete: function(i) {
    var e = this.table.rowManager.addRowActual(i.data.data, i.data.pos, i.data.index);
    this.table.options.groupBy && this.table.modExists("groupRows") && this.table.modules.groupRows.updateGroupRows(!0), this._rebindRow(i.component, e);
  },
  rowMove: function(i) {
    this.table.rowManager.moveRowActual(i.component, this.table.rowManager.rows[i.data.posFrom], !i.data.after), this.table.rowManager.redraw();
  }
}, R2 = {
  cellEdit: function(i) {
    i.component.setValueProcessData(i.data.newValue), i.component.cellRendered();
  },
  rowAdd: function(i) {
    var e = this.table.rowManager.addRowActual(i.data.data, i.data.pos, i.data.index);
    this.table.options.groupBy && this.table.modExists("groupRows") && this.table.modules.groupRows.updateGroupRows(!0), this._rebindRow(i.component, e);
  },
  rowDelete: function(i) {
    i.component.deleteActual();
  },
  rowMove: function(i) {
    this.table.rowManager.moveRowActual(i.component, this.table.rowManager.rows[i.data.posTo], i.data.after), this.table.rowManager.redraw();
  }
};
class Co extends ge {
  constructor(e) {
    super(e), this.history = [], this.index = -1, this.registerTableOption("history", !1);
  }
  initialize() {
    this.table.options.history && (this.subscribe("cell-value-updated", this.cellUpdated.bind(this)), this.subscribe("cell-delete", this.clearComponentHistory.bind(this)), this.subscribe("row-delete", this.rowDeleted.bind(this)), this.subscribe("rows-wipe", this.clear.bind(this)), this.subscribe("row-added", this.rowAdded.bind(this)), this.subscribe("row-move", this.rowMoved.bind(this))), this.registerTableFunction("undo", this.undo.bind(this)), this.registerTableFunction("redo", this.redo.bind(this)), this.registerTableFunction("getHistoryUndoSize", this.getHistoryUndoSize.bind(this)), this.registerTableFunction("getHistoryRedoSize", this.getHistoryRedoSize.bind(this)), this.registerTableFunction("clearHistory", this.clear.bind(this));
  }
  rowMoved(e, t, r) {
    this.action("rowMove", e, { posFrom: e.getPosition(), posTo: t.getPosition(), to: t, after: r });
  }
  rowAdded(e, t, r, o) {
    this.action("rowAdd", e, { data: t, pos: r, index: o });
  }
  rowDeleted(e) {
    var t, r;
    this.table.options.groupBy ? (r = e.getComponent().getGroup()._getSelf().rows, t = r.indexOf(e), t && (t = r[t - 1])) : (t = e.table.rowManager.getRowIndex(e), t && (t = e.table.rowManager.rows[t - 1])), this.action("rowDelete", e, { data: e.getData(), pos: !t, index: t });
  }
  cellUpdated(e) {
    this.action("cellEdit", e, { oldValue: e.oldValue, newValue: e.value });
  }
  clear() {
    this.history = [], this.index = -1;
  }
  action(e, t, r) {
    this.history = this.history.slice(0, this.index + 1), this.history.push({
      type: e,
      component: t,
      data: r
    }), this.index++;
  }
  getHistoryUndoSize() {
    return this.index + 1;
  }
  getHistoryRedoSize() {
    return this.history.length - (this.index + 1);
  }
  clearComponentHistory(e) {
    var t = this.history.findIndex(function(r) {
      return r.component === e;
    });
    t > -1 && (this.history.splice(t, 1), t <= this.index && this.index--, this.clearComponentHistory(e));
  }
  undo() {
    if (this.index > -1) {
      let e = this.history[this.index];
      return Co.undoers[e.type].call(this, e), this.index--, this.dispatchExternal("historyUndo", e.type, e.component.getComponent(), e.data), !0;
    } else
      return console.warn("History Undo Error - No more history to undo"), !1;
  }
  redo() {
    if (this.history.length - 1 > this.index) {
      this.index++;
      let e = this.history[this.index];
      return Co.redoers[e.type].call(this, e), this.dispatchExternal("historyRedo", e.type, e.component.getComponent(), e.data), !0;
    } else
      return console.warn("History Redo Error - No more history to redo"), !1;
  }
  //rebind rows to new element after deletion
  _rebindRow(e, t) {
    this.history.forEach(function(r) {
      if (r.component instanceof Qt)
        r.component === e && (r.component = t);
      else if (r.component instanceof ol && r.component.row === e) {
        var o = r.component.column.getField();
        o && (r.component = t.getCell(o));
      }
    });
  }
}
Co.moduleName = "history";
Co.undoers = S2;
Co.redoers = R2;
class GO extends ge {
  constructor(e) {
    super(e), this.fieldIndex = [], this.hasIndex = !1;
  }
  initialize() {
    this.tableElementCheck();
  }
  tableElementCheck() {
    this.table.originalElement && this.table.originalElement.tagName === "TABLE" && (this.table.originalElement.childNodes.length ? this.parseTable() : console.warn("Unable to parse data from empty table tag, Tabulator should be initialized on a div tag unless importing data from a table element."));
  }
  parseTable() {
    var e = this.table.originalElement, t = this.table.options, r = e.getElementsByTagName("th"), o = e.getElementsByTagName("tbody")[0], s = [];
    this.hasIndex = !1, this.dispatchExternal("htmlImporting"), o = o ? o.getElementsByTagName("tr") : [], this._extractOptions(e, t), r.length ? this._extractHeaders(r, o) : this._generateBlankHeaders(r, o);
    for (var n = 0; n < o.length; n++) {
      var a = o[n], l = a.getElementsByTagName("td"), u = {};
      this.hasIndex || (u[t.index] = n);
      for (var h = 0; h < l.length; h++) {
        var c = l[h];
        typeof this.fieldIndex[h] < "u" && (u[this.fieldIndex[h]] = c.innerHTML);
      }
      s.push(u);
    }
    t.data = s, this.dispatchExternal("htmlImported");
  }
  //extract tabulator attribute options
  _extractOptions(e, t, r) {
    var o = e.attributes, s = Object.keys(r || t), n = {};
    s.forEach((h) => {
      n[h.toLowerCase()] = h;
    });
    for (var a in o) {
      var l = o[a], u;
      l && typeof l == "object" && l.name && l.name.indexOf("tabulator-") === 0 && (u = l.name.replace("tabulator-", ""), typeof n[u] < "u" && (t[n[u]] = this._attribValue(l.value)));
    }
  }
  //get value of attribute
  _attribValue(e) {
    return e === "true" ? !0 : e === "false" ? !1 : e;
  }
  //find column if it has already been defined
  _findCol(e) {
    var t = this.table.options.columns.find((r) => r.title === e);
    return t || !1;
  }
  //extract column from headers
  _extractHeaders(e, t) {
    for (var r = 0; r < e.length; r++) {
      var o = e[r], s = !1, n = this._findCol(o.textContent), a;
      n ? s = !0 : n = { title: o.textContent.trim() }, n.field || (n.field = o.textContent.trim().toLowerCase().replace(" ", "_")), a = o.getAttribute("width"), a && !n.width && (n.width = a), this._extractOptions(o, n, this.table.columnManager.optionsList.registeredDefaults), this.fieldIndex[r] = n.field, n.field == this.table.options.index && (this.hasIndex = !0), s || this.table.options.columns.push(n);
    }
  }
  //generate blank headers
  _generateBlankHeaders(e, t) {
    for (var r = 0; r < e.length; r++) {
      var o = e[r], s = { title: "", field: "col" + r };
      this.fieldIndex[r] = s.field;
      var n = o.getAttribute("width");
      n && (s.width = n), this.table.options.columns.push(s);
    }
  }
}
GO.moduleName = "htmlTableImport";
function A2(i) {
  var e = [], t = 0, r = 0, o = !1;
  for (let s = 0; s < i.length; s++) {
    let n = i[s], a = i[s + 1];
    if (e[t] || (e[t] = []), e[t][r] || (e[t][r] = ""), n == '"' && o && a == '"') {
      e[t][r] += n, s++;
      continue;
    }
    if (n == '"') {
      o = !o;
      continue;
    }
    if (n == "," && !o) {
      r++;
      continue;
    }
    if (n == "\r" && a == `
` && !o) {
      r = 0, t++, s++;
      continue;
    }
    if ((n == "\r" || n == `
`) && !o) {
      r = 0, t++;
      continue;
    }
    e[t][r] += n;
  }
  return e;
}
function C2(i) {
  try {
    return JSON.parse(i);
  } catch (e) {
    return console.warn("JSON Import Error - File contents is invalid JSON", e), Promise.reject();
  }
}
function N2(i) {
  return i;
}
var I2 = {
  csv: A2,
  json: C2,
  array: N2
};
class Rn extends ge {
  constructor(e) {
    super(e), this.registerTableOption("importFormat"), this.registerTableOption("importReader", "text");
  }
  initialize() {
    this.registerTableFunction("import", this.importFromFile.bind(this)), this.table.options.importFormat && (this.subscribe("data-loading", this.loadDataCheck.bind(this), 10), this.subscribe("data-load", this.loadData.bind(this), 10));
  }
  loadDataCheck(e) {
    return this.table.options.importFormat && (typeof e == "string" || Array.isArray(e) && e.length && Array.isArray(e));
  }
  loadData(e, t, r, o, s) {
    return this.importData(this.lookupImporter(), e).then(this.structureData.bind(this)).catch((n) => (console.error("Import Error:", n || "Unable to import data"), Promise.reject(n)));
  }
  lookupImporter(e) {
    var t;
    return e || (e = this.table.options.importFormat), typeof e == "string" ? t = Rn.importers[e] : t = e, t || console.error("Import Error - Importer not found:", e), t;
  }
  importFromFile(e, t) {
    var r = this.lookupImporter(e);
    if (r)
      return this.pickFile(t).then(this.importData.bind(this, r)).then(this.structureData.bind(this)).then(this.setData.bind(this)).catch((o) => (console.error("Import Error:", o || "Unable to import file"), Promise.reject(o)));
  }
  pickFile(e) {
    return new Promise((t, r) => {
      var o = document.createElement("input");
      o.type = "file", o.accept = e, o.addEventListener("change", (s) => {
        var n = o.files[0], a = new FileReader();
        switch (this.table.options.importReader) {
          case "buffer":
            a.readAsArrayBuffer(n);
            break;
          case "binary":
            a.readAsBinaryString(n);
            break;
          case "url":
            a.readAsDataURL(n);
            break;
          case "text":
          default:
            a.readAsText(n);
        }
        a.onload = (l) => {
          t(a.result);
        }, a.onerror = (l) => {
          console.warn("File Load Error - Unable to read file"), r();
        };
      }), o.click();
    });
  }
  importData(e, t) {
    var r = e.call(this.table, t);
    return r instanceof Promise ? r : r ? Promise.resolve(r) : Promise.reject();
  }
  structureData(e) {
    var t = [];
    return Array.isArray(e) && e.length && Array.isArray(e[0]) ? (this.table.options.autoColumns ? t = this.structureArrayToObject(e) : t = this.structureArrayToColumns(e), t) : e;
  }
  structureArrayToObject(e) {
    var t = e.shift(), r = e.map((o) => {
      var s = {};
      return t.forEach((n, a) => {
        s[n] = o[a];
      }), s;
    });
    return r;
  }
  structureArrayToColumns(e) {
    var t = [], r = this.table.getColumns();
    return r[0] && e[0][0] && r[0].getDefinition().title === e[0][0] && e.shift(), e.forEach((o) => {
      var s = {};
      o.forEach((n, a) => {
        var l = r[a];
        l && (s[l.getField()] = n);
      }), t.push(s);
    }), t;
  }
  setData(e) {
    return this.table.setData(e);
  }
}
Rn.moduleName = "import";
Rn.importers = I2;
class VO extends ge {
  constructor(e) {
    super(e), this.eventMap = {
      //row events
      rowClick: "row-click",
      rowDblClick: "row-dblclick",
      rowContext: "row-contextmenu",
      rowMouseEnter: "row-mouseenter",
      rowMouseLeave: "row-mouseleave",
      rowMouseOver: "row-mouseover",
      rowMouseOut: "row-mouseout",
      rowMouseMove: "row-mousemove",
      rowMouseDown: "row-mousedown",
      rowMouseUp: "row-mouseup",
      rowTap: "row",
      rowDblTap: "row",
      rowTapHold: "row",
      //cell events
      cellClick: "cell-click",
      cellDblClick: "cell-dblclick",
      cellContext: "cell-contextmenu",
      cellMouseEnter: "cell-mouseenter",
      cellMouseLeave: "cell-mouseleave",
      cellMouseOver: "cell-mouseover",
      cellMouseOut: "cell-mouseout",
      cellMouseMove: "cell-mousemove",
      cellMouseDown: "cell-mousedown",
      cellMouseUp: "cell-mouseup",
      cellTap: "cell",
      cellDblTap: "cell",
      cellTapHold: "cell",
      //column header events
      headerClick: "column-click",
      headerDblClick: "column-dblclick",
      headerContext: "column-contextmenu",
      headerMouseEnter: "column-mouseenter",
      headerMouseLeave: "column-mouseleave",
      headerMouseOver: "column-mouseover",
      headerMouseOut: "column-mouseout",
      headerMouseMove: "column-mousemove",
      headerMouseDown: "column-mousedown",
      headerMouseUp: "column-mouseup",
      headerTap: "column",
      headerDblTap: "column",
      headerTapHold: "column",
      //group header
      groupClick: "group-click",
      groupDblClick: "group-dblclick",
      groupContext: "group-contextmenu",
      groupMouseEnter: "group-mouseenter",
      groupMouseLeave: "group-mouseleave",
      groupMouseOver: "group-mouseover",
      groupMouseOut: "group-mouseout",
      groupMouseMove: "group-mousemove",
      groupMouseDown: "group-mousedown",
      groupMouseUp: "group-mouseup",
      groupTap: "group",
      groupDblTap: "group",
      groupTapHold: "group"
    }, this.subscribers = {}, this.touchSubscribers = {}, this.columnSubscribers = {}, this.touchWatchers = {
      row: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      cell: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      column: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      group: {
        tap: null,
        tapDbl: null,
        tapHold: null
      }
    }, this.registerColumnOption("headerClick"), this.registerColumnOption("headerDblClick"), this.registerColumnOption("headerContext"), this.registerColumnOption("headerMouseEnter"), this.registerColumnOption("headerMouseLeave"), this.registerColumnOption("headerMouseOver"), this.registerColumnOption("headerMouseOut"), this.registerColumnOption("headerMouseMove"), this.registerColumnOption("headerMouseDown"), this.registerColumnOption("headerMouseUp"), this.registerColumnOption("headerTap"), this.registerColumnOption("headerDblTap"), this.registerColumnOption("headerTapHold"), this.registerColumnOption("cellClick"), this.registerColumnOption("cellDblClick"), this.registerColumnOption("cellContext"), this.registerColumnOption("cellMouseEnter"), this.registerColumnOption("cellMouseLeave"), this.registerColumnOption("cellMouseOver"), this.registerColumnOption("cellMouseOut"), this.registerColumnOption("cellMouseMove"), this.registerColumnOption("cellMouseDown"), this.registerColumnOption("cellMouseUp"), this.registerColumnOption("cellTap"), this.registerColumnOption("cellDblTap"), this.registerColumnOption("cellTapHold");
  }
  initialize() {
    this.initializeExternalEvents(), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("cell-dblclick", this.cellContentsSelectionFixer.bind(this)), this.subscribe("scroll-horizontal", this.clearTouchWatchers.bind(this)), this.subscribe("scroll-vertical", this.clearTouchWatchers.bind(this));
  }
  clearTouchWatchers() {
    var e = Object.values(this.touchWatchers);
    e.forEach((t) => {
      for (let r in t)
        t[r] = null;
    });
  }
  cellContentsSelectionFixer(e, t) {
    var r;
    if (!(this.table.modExists("edit") && this.table.modules.edit.currentCell === t)) {
      e.preventDefault();
      try {
        document.selection ? (r = document.body.createTextRange(), r.moveToElementText(t.getElement()), r.select()) : window.getSelection && (r = document.createRange(), r.selectNode(t.getElement()), window.getSelection().removeAllRanges(), window.getSelection().addRange(r));
      } catch {
      }
    }
  }
  initializeExternalEvents() {
    for (let e in this.eventMap)
      this.subscriptionChangeExternal(e, this.subscriptionChanged.bind(this, e));
  }
  subscriptionChanged(e, t) {
    t ? this.subscribers[e] || (this.eventMap[e].includes("-") ? (this.subscribers[e] = this.handle.bind(this, e), this.subscribe(this.eventMap[e], this.subscribers[e])) : this.subscribeTouchEvents(e)) : this.eventMap[e].includes("-") ? this.subscribers[e] && !this.columnSubscribers[e] && !this.subscribedExternal(e) && (this.unsubscribe(this.eventMap[e], this.subscribers[e]), delete this.subscribers[e]) : this.unsubscribeTouchEvents(e);
  }
  subscribeTouchEvents(e) {
    var t = this.eventMap[e];
    this.touchSubscribers[t + "-touchstart"] || (this.touchSubscribers[t + "-touchstart"] = this.handleTouch.bind(this, t, "start"), this.touchSubscribers[t + "-touchend"] = this.handleTouch.bind(this, t, "end"), this.subscribe(t + "-touchstart", this.touchSubscribers[t + "-touchstart"]), this.subscribe(t + "-touchend", this.touchSubscribers[t + "-touchend"])), this.subscribers[e] = !0;
  }
  unsubscribeTouchEvents(e) {
    var t = !0, r = this.eventMap[e];
    if (this.subscribers[e] && !this.subscribedExternal(e)) {
      delete this.subscribers[e];
      for (let o in this.eventMap)
        this.eventMap[o] === r && this.subscribers[o] && (t = !1);
      t && (this.unsubscribe(r + "-touchstart", this.touchSubscribers[r + "-touchstart"]), this.unsubscribe(r + "-touchend", this.touchSubscribers[r + "-touchend"]), delete this.touchSubscribers[r + "-touchstart"], delete this.touchSubscribers[r + "-touchend"]);
    }
  }
  initializeColumn(e) {
    var t = e.definition;
    for (let r in this.eventMap)
      t[r] && (this.subscriptionChanged(r, !0), this.columnSubscribers[r] || (this.columnSubscribers[r] = []), this.columnSubscribers[r].push(e));
  }
  handle(e, t, r) {
    this.dispatchEvent(e, t, r);
  }
  handleTouch(e, t, r, o) {
    var s = this.touchWatchers[e];
    switch (e === "column" && (e = "header"), t) {
      case "start":
        s.tap = !0, clearTimeout(s.tapHold), s.tapHold = setTimeout(() => {
          clearTimeout(s.tapHold), s.tapHold = null, s.tap = null, clearTimeout(s.tapDbl), s.tapDbl = null, this.dispatchEvent(e + "TapHold", r, o);
        }, 1e3);
        break;
      case "end":
        s.tap && (s.tap = null, this.dispatchEvent(e + "Tap", r, o)), s.tapDbl ? (clearTimeout(s.tapDbl), s.tapDbl = null, this.dispatchEvent(e + "DblTap", r, o)) : s.tapDbl = setTimeout(() => {
          clearTimeout(s.tapDbl), s.tapDbl = null;
        }, 300), clearTimeout(s.tapHold), s.tapHold = null;
        break;
    }
  }
  dispatchEvent(e, t, r) {
    var o = r.getComponent(), s;
    this.columnSubscribers[e] && (r instanceof ol ? s = r.column.definition[e] : r instanceof lr && (s = r.definition[e]), s && s(t, o)), this.dispatchExternal(e, t, o);
  }
}
VO.moduleName = "interaction";
var v2 = {
  navPrev: "shift + 9",
  navNext: 9,
  navUp: 38,
  navDown: 40,
  scrollPageUp: 33,
  scrollPageDown: 34,
  scrollToStart: 36,
  scrollToEnd: 35,
  undo: ["ctrl + 90", "meta + 90"],
  redo: ["ctrl + 89", "meta + 89"],
  copyToClipboard: ["ctrl + 67", "meta + 89"]
}, _2 = {
  keyBlock: function(i) {
    i.stopPropagation(), i.preventDefault();
  },
  scrollPageUp: function(i) {
    var e = this.table.rowManager, t = e.scrollTop - e.element.clientHeight;
    i.preventDefault(), e.displayRowsCount && (t >= 0 ? e.element.scrollTop = t : e.scrollToRow(e.getDisplayRows()[0])), this.table.element.focus();
  },
  scrollPageDown: function(i) {
    var e = this.table.rowManager, t = e.scrollTop + e.element.clientHeight, r = e.element.scrollHeight;
    i.preventDefault(), e.displayRowsCount && (t <= r ? e.element.scrollTop = t : e.scrollToRow(e.getDisplayRows()[e.displayRowsCount - 1])), this.table.element.focus();
  },
  scrollToStart: function(i) {
    var e = this.table.rowManager;
    i.preventDefault(), e.displayRowsCount && e.scrollToRow(e.getDisplayRows()[0]), this.table.element.focus();
  },
  scrollToEnd: function(i) {
    var e = this.table.rowManager;
    i.preventDefault(), e.displayRowsCount && e.scrollToRow(e.getDisplayRows()[e.displayRowsCount - 1]), this.table.element.focus();
  },
  navPrev: function(i) {
    this.dispatch("keybinding-nav-prev", i);
  },
  navNext: function(i) {
    this.dispatch("keybinding-nav-next", i);
  },
  navLeft: function(i) {
    this.dispatch("keybinding-nav-left", i);
  },
  navRight: function(i) {
    this.dispatch("keybinding-nav-right", i);
  },
  navUp: function(i) {
    this.dispatch("keybinding-nav-up", i);
  },
  navDown: function(i) {
    this.dispatch("keybinding-nav-down", i);
  },
  undo: function(i) {
    var e = !1;
    this.table.options.history && this.table.modExists("history") && this.table.modExists("edit") && (e = this.table.modules.edit.currentCell, e || (i.preventDefault(), this.table.modules.history.undo()));
  },
  redo: function(i) {
    var e = !1;
    this.table.options.history && this.table.modExists("history") && this.table.modExists("edit") && (e = this.table.modules.edit.currentCell, e || (i.preventDefault(), this.table.modules.history.redo()));
  },
  copyToClipboard: function(i) {
    this.table.modules.edit.currentCell || this.table.modExists("clipboard", !0) && this.table.modules.clipboard.copy(!1, !0);
  }
};
class Rr extends ge {
  constructor(e) {
    super(e), this.watchKeys = null, this.pressedKeys = null, this.keyupBinding = !1, this.keydownBinding = !1, this.registerTableOption("keybindings", {}), this.registerTableOption("tabEndNewRow", !1);
  }
  initialize() {
    var e = this.table.options.keybindings, t = {};
    this.watchKeys = {}, this.pressedKeys = [], e !== !1 && (Object.assign(t, Rr.bindings), Object.assign(t, e), this.mapBindings(t), this.bindEvents()), this.subscribe("table-destroy", this.clearBindings.bind(this));
  }
  mapBindings(e) {
    for (let t in e)
      Rr.actions[t] ? e[t] && (typeof e[t] != "object" && (e[t] = [e[t]]), e[t].forEach((r) => {
        var o = Array.isArray(r) ? r : [r];
        o.forEach((s) => {
          this.mapBinding(t, s);
        });
      })) : console.warn("Key Binding Error - no such action:", t);
  }
  mapBinding(e, t) {
    var r = {
      action: Rr.actions[e],
      keys: [],
      ctrl: !1,
      shift: !1,
      meta: !1
    }, o = t.toString().toLowerCase().split(" ").join("").split("+");
    o.forEach((s) => {
      switch (s) {
        case "ctrl":
          r.ctrl = !0;
          break;
        case "shift":
          r.shift = !0;
          break;
        case "meta":
          r.meta = !0;
          break;
        default:
          s = isNaN(s) ? s.toUpperCase().charCodeAt(0) : parseInt(s), r.keys.push(s), this.watchKeys[s] || (this.watchKeys[s] = []), this.watchKeys[s].push(r);
      }
    });
  }
  bindEvents() {
    var e = this;
    this.keyupBinding = function(t) {
      var r = t.keyCode, o = e.watchKeys[r];
      o && (e.pressedKeys.push(r), o.forEach(function(s) {
        e.checkBinding(t, s);
      }));
    }, this.keydownBinding = function(t) {
      var r = t.keyCode, o = e.watchKeys[r];
      if (o) {
        var s = e.pressedKeys.indexOf(r);
        s > -1 && e.pressedKeys.splice(s, 1);
      }
    }, this.table.element.addEventListener("keydown", this.keyupBinding), this.table.element.addEventListener("keyup", this.keydownBinding);
  }
  clearBindings() {
    this.keyupBinding && this.table.element.removeEventListener("keydown", this.keyupBinding), this.keydownBinding && this.table.element.removeEventListener("keyup", this.keydownBinding);
  }
  checkBinding(e, t) {
    var r = !0;
    return e.ctrlKey == t.ctrl && e.shiftKey == t.shift && e.metaKey == t.meta ? (t.keys.forEach((o) => {
      var s = this.pressedKeys.indexOf(o);
      s == -1 && (r = !1);
    }), r && t.action.call(this, e), !0) : !1;
  }
}
Rr.moduleName = "keybindings";
Rr.bindings = v2;
Rr.actions = _2;
class ov extends ge {
  constructor(e) {
    super(e), this.menuContainer = null, this.nestedMenuBlock = !1, this.currentComponent = null, this.rootPopup = null, this.columnSubscribers = {}, this.registerTableOption("menuContainer", void 0), this.registerTableOption("rowContextMenu", !1), this.registerTableOption("rowClickMenu", !1), this.registerTableOption("rowDblClickMenu", !1), this.registerTableOption("groupContextMenu", !1), this.registerTableOption("groupClickMenu", !1), this.registerTableOption("groupDblClickMenu", !1), this.registerColumnOption("headerContextMenu"), this.registerColumnOption("headerClickMenu"), this.registerColumnOption("headerDblClickMenu"), this.registerColumnOption("headerMenu"), this.registerColumnOption("headerMenuIcon"), this.registerColumnOption("contextMenu"), this.registerColumnOption("clickMenu"), this.registerColumnOption("dblClickMenu");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.initializeRowWatchers(), this.initializeGroupWatchers(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheck("menuContainer", "popupContainer") || (this.table.options.popupContainer = this.table.options.menuContainer);
  }
  initializeRowWatchers() {
    this.table.options.rowContextMenu && (this.subscribe("row-contextmenu", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu)), this.table.on("rowTapHold", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu))), this.table.options.rowClickMenu && this.subscribe("row-click", this.loadMenuEvent.bind(this, this.table.options.rowClickMenu)), this.table.options.rowDblClickMenu && this.subscribe("row-dblclick", this.loadMenuEvent.bind(this, this.table.options.rowDblClickMenu));
  }
  initializeGroupWatchers() {
    this.table.options.groupContextMenu && (this.subscribe("group-contextmenu", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu)), this.table.on("groupTapHold", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu))), this.table.options.groupClickMenu && this.subscribe("group-click", this.loadMenuEvent.bind(this, this.table.options.groupClickMenu)), this.table.options.groupDblClickMenu && this.subscribe("group-dblclick", this.loadMenuEvent.bind(this, this.table.options.groupDblClickMenu));
  }
  initializeColumn(e) {
    var t = e.definition;
    t.headerContextMenu && !this.columnSubscribers.headerContextMenu && (this.columnSubscribers.headerContextMenu = this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"), this.subscribe("column-contextmenu", this.columnSubscribers.headerContextMenu), this.table.on("headerTapHold", this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"))), t.headerClickMenu && !this.columnSubscribers.headerClickMenu && (this.columnSubscribers.headerClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerClickMenu"), this.subscribe("column-click", this.columnSubscribers.headerClickMenu)), t.headerDblClickMenu && !this.columnSubscribers.headerDblClickMenu && (this.columnSubscribers.headerDblClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerDblClickMenu"), this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickMenu)), t.headerMenu && this.initializeColumnHeaderMenu(e), t.contextMenu && !this.columnSubscribers.contextMenu && (this.columnSubscribers.contextMenu = this.loadMenuTableCellEvent.bind(this, "contextMenu"), this.subscribe("cell-contextmenu", this.columnSubscribers.contextMenu), this.table.on("cellTapHold", this.loadMenuTableCellEvent.bind(this, "contextMenu"))), t.clickMenu && !this.columnSubscribers.clickMenu && (this.columnSubscribers.clickMenu = this.loadMenuTableCellEvent.bind(this, "clickMenu"), this.subscribe("cell-click", this.columnSubscribers.clickMenu)), t.dblClickMenu && !this.columnSubscribers.dblClickMenu && (this.columnSubscribers.dblClickMenu = this.loadMenuTableCellEvent.bind(this, "dblClickMenu"), this.subscribe("cell-dblclick", this.columnSubscribers.dblClickMenu));
  }
  initializeColumnHeaderMenu(e) {
    var t = e.definition.headerMenuIcon, r;
    r = document.createElement("span"), r.classList.add("tabulator-header-popup-button"), t ? (typeof t == "function" && (t = t(e.getComponent())), t instanceof HTMLElement ? r.appendChild(t) : r.innerHTML = t) : r.innerHTML = "&vellip;", r.addEventListener("click", (o) => {
      o.stopPropagation(), o.preventDefault(), this.loadMenuEvent(e.definition.headerMenu, o, e);
    }), e.titleElement.insertBefore(r, e.titleElement.firstChild);
  }
  loadMenuTableCellEvent(e, t, r) {
    r._cell && (r = r._cell), r.column.definition[e] && this.loadMenuEvent(r.column.definition[e], t, r);
  }
  loadMenuTableColumnEvent(e, t, r) {
    r._column && (r = r._column), r.definition[e] && this.loadMenuEvent(r.definition[e], t, r);
  }
  loadMenuEvent(e, t, r) {
    r._group ? r = r._group : r._row && (r = r._row), e = typeof e == "function" ? e.call(this.table, t, r.getComponent()) : e, this.loadMenu(t, r, e);
  }
  loadMenu(e, t, r, o, s) {
    var n = !(e instanceof MouseEvent), a = document.createElement("div"), l;
    if (a.classList.add("tabulator-menu"), n || e.preventDefault(), !(!r || !r.length)) {
      if (o)
        l = s.child(a);
      else {
        if (this.nestedMenuBlock) {
          if (this.rootPopup)
            return;
        } else
          this.nestedMenuBlock = setTimeout(() => {
            this.nestedMenuBlock = !1;
          }, 100);
        this.rootPopup && this.rootPopup.hide(), this.rootPopup = l = this.popup(a);
      }
      r.forEach((u) => {
        var h = document.createElement("div"), c = u.label, d = u.disabled;
        u.separator ? h.classList.add("tabulator-menu-separator") : (h.classList.add("tabulator-menu-item"), typeof c == "function" && (c = c.call(this.table, t.getComponent())), c instanceof Node ? h.appendChild(c) : h.innerHTML = c, typeof d == "function" && (d = d.call(this.table, t.getComponent())), d ? (h.classList.add("tabulator-menu-item-disabled"), h.addEventListener("click", (f) => {
          f.stopPropagation();
        })) : u.menu && u.menu.length ? h.addEventListener("click", (f) => {
          f.stopPropagation(), this.loadMenu(f, t, u.menu, h, l);
        }) : u.action && h.addEventListener("click", (f) => {
          u.action(f, t.getComponent());
        }), u.menu && u.menu.length && h.classList.add("tabulator-menu-item-submenu")), a.appendChild(h);
      }), a.addEventListener("click", (u) => {
        this.rootPopup && this.rootPopup.hide();
      }), l.show(o || e), l === this.rootPopup && (this.rootPopup.hideOnBlur(() => {
        this.rootPopup = null, this.currentComponent && (this.dispatchExternal("menuClosed", this.currentComponent.getComponent()), this.currentComponent = null);
      }), this.currentComponent = t, this.dispatchExternal("menuOpened", t.getComponent()));
    }
  }
}
ov.moduleName = "menu";
class HO extends ge {
  constructor(e) {
    super(e), this.placeholderElement = this.createPlaceholderElement(), this.hoverElement = !1, this.checkTimeout = !1, this.checkPeriod = 250, this.moving = !1, this.toCol = !1, this.toColAfter = !1, this.startX = 0, this.autoScrollMargin = 40, this.autoScrollStep = 5, this.autoScrollTimeout = !1, this.touchMove = !1, this.moveHover = this.moveHover.bind(this), this.endMove = this.endMove.bind(this), this.registerTableOption("movableColumns", !1);
  }
  createPlaceholderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col"), e.classList.add("tabulator-col-placeholder"), e;
  }
  initialize() {
    this.table.options.movableColumns && this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  initializeColumn(e) {
    var t = this, r = {}, o;
    !e.modules.frozen && !e.isGroup && (o = e.getElement(), r.mousemove = function(s) {
      e.parent === t.moving.parent && ((t.touchMove ? s.touches[0].pageX : s.pageX) - Ge.elOffset(o).left + t.table.columnManager.contentsElement.scrollLeft > e.getWidth() / 2 ? (t.toCol !== e || !t.toColAfter) && (o.parentNode.insertBefore(t.placeholderElement, o.nextSibling), t.moveColumn(e, !0)) : (t.toCol !== e || t.toColAfter) && (o.parentNode.insertBefore(t.placeholderElement, o), t.moveColumn(e, !1)));
    }.bind(t), o.addEventListener("mousedown", function(s) {
      t.touchMove = !1, s.which === 1 && (t.checkTimeout = setTimeout(function() {
        t.startMove(s, e);
      }, t.checkPeriod));
    }), o.addEventListener("mouseup", function(s) {
      s.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
    }), t.bindTouchEvents(e)), e.modules.moveColumn = r;
  }
  bindTouchEvents(e) {
    var t = e.getElement(), r = !1, o, s, n, a, l, u;
    t.addEventListener("touchstart", (h) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = !0, o = e.nextColumn(), n = o ? o.getWidth() / 2 : 0, s = e.prevColumn(), a = s ? s.getWidth() / 2 : 0, l = 0, u = 0, r = !1, this.startMove(h, e);
      }, this.checkPeriod);
    }, { passive: !0 }), t.addEventListener("touchmove", (h) => {
      var c, d;
      this.moving && (this.moveHover(h), r || (r = h.touches[0].pageX), c = h.touches[0].pageX - r, c > 0 ? o && c - l > n && (d = o, d !== e && (r = h.touches[0].pageX, d.getElement().parentNode.insertBefore(this.placeholderElement, d.getElement().nextSibling), this.moveColumn(d, !0))) : s && -c - u > a && (d = s, d !== e && (r = h.touches[0].pageX, d.getElement().parentNode.insertBefore(this.placeholderElement, d.getElement()), this.moveColumn(d, !1))), d && (o = d.nextColumn(), l = n, n = o ? o.getWidth() / 2 : 0, s = d.prevColumn(), u = a, a = s ? s.getWidth() / 2 : 0));
    }, { passive: !0 }), t.addEventListener("touchend", (h) => {
      this.checkTimeout && clearTimeout(this.checkTimeout), this.moving && this.endMove(h);
    });
  }
  startMove(e, t) {
    var r = t.getElement(), o = this.table.columnManager.getContentsElement(), s = this.table.columnManager.getHeadersElement();
    this.moving = t, this.startX = (this.touchMove ? e.touches[0].pageX : e.pageX) - Ge.elOffset(r).left, this.table.element.classList.add("tabulator-block-select"), this.placeholderElement.style.width = t.getWidth() + "px", this.placeholderElement.style.height = t.getHeight() + "px", r.parentNode.insertBefore(this.placeholderElement, r), r.parentNode.removeChild(r), this.hoverElement = r.cloneNode(!0), this.hoverElement.classList.add("tabulator-moving"), o.appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.bottom = o.clientHeight - s.offsetHeight + "px", this.touchMove || (this._bindMouseMove(), document.body.addEventListener("mousemove", this.moveHover), document.body.addEventListener("mouseup", this.endMove)), this.moveHover(e);
  }
  _bindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(e) {
      e.modules.moveColumn.mousemove && e.getElement().addEventListener("mousemove", e.modules.moveColumn.mousemove);
    });
  }
  _unbindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(e) {
      e.modules.moveColumn.mousemove && e.getElement().removeEventListener("mousemove", e.modules.moveColumn.mousemove);
    });
  }
  moveColumn(e, t) {
    var r = this.moving.getCells();
    this.toCol = e, this.toColAfter = t, t ? e.getCells().forEach(function(o, s) {
      var n = o.getElement(!0);
      n.parentNode && r[s] && n.parentNode.insertBefore(r[s].getElement(), n.nextSibling);
    }) : e.getCells().forEach(function(o, s) {
      var n = o.getElement(!0);
      n.parentNode && r[s] && n.parentNode.insertBefore(r[s].getElement(), n);
    });
  }
  endMove(e) {
    (e.which === 1 || this.touchMove) && (this._unbindMouseMove(), this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling), this.placeholderElement.parentNode.removeChild(this.placeholderElement), this.hoverElement.parentNode.removeChild(this.hoverElement), this.table.element.classList.remove("tabulator-block-select"), this.toCol && this.table.columnManager.moveColumnActual(this.moving, this.toCol, this.toColAfter), this.moving = !1, this.toCol = !1, this.toColAfter = !1, this.touchMove || (document.body.removeEventListener("mousemove", this.moveHover), document.body.removeEventListener("mouseup", this.endMove)));
  }
  moveHover(e) {
    var t = this.table.columnManager.getContentsElement(), r = t.scrollLeft, o = (this.touchMove ? e.touches[0].pageX : e.pageX) - Ge.elOffset(t).left + r, s;
    this.hoverElement.style.left = o - this.startX + "px", o - r < this.autoScrollMargin && (this.autoScrollTimeout || (this.autoScrollTimeout = setTimeout(() => {
      s = Math.max(0, r - 5), this.table.rowManager.getElement().scrollLeft = s, this.autoScrollTimeout = !1;
    }, 1))), r + t.clientWidth - o < this.autoScrollMargin && (this.autoScrollTimeout || (this.autoScrollTimeout = setTimeout(() => {
      s = Math.min(t.clientWidth, r + 5), this.table.rowManager.getElement().scrollLeft = s, this.autoScrollTimeout = !1;
    }, 1)));
  }
}
HO.moduleName = "moveColumn";
class sl extends ge {
  constructor(e) {
    super(e), this.placeholderElement = this.createPlaceholderElement(), this.hoverElement = !1, this.checkTimeout = !1, this.checkPeriod = 150, this.moving = !1, this.toRow = !1, this.toRowAfter = !1, this.hasHandle = !1, this.startY = 0, this.startX = 0, this.moveHover = this.moveHover.bind(this), this.endMove = this.endMove.bind(this), this.tableRowDropEvent = !1, this.touchMove = !1, this.connection = !1, this.connectionSelectorsTables = !1, this.connectionSelectorsElements = !1, this.connectionElements = [], this.connections = [], this.connectedTable = !1, this.connectedRow = !1, this.registerTableOption("movableRows", !1), this.registerTableOption("movableRowsConnectedTables", !1), this.registerTableOption("movableRowsConnectedElements", !1), this.registerTableOption("movableRowsSender", !1), this.registerTableOption("movableRowsReceiver", "insert"), this.registerColumnOption("rowHandle");
  }
  createPlaceholderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-row"), e.classList.add("tabulator-row-placeholder"), e;
  }
  initialize() {
    this.table.options.movableRows && (this.connectionSelectorsTables = this.table.options.movableRowsConnectedTables, this.connectionSelectorsElements = this.table.options.movableRowsConnectedElements, this.connection = this.connectionSelectorsTables || this.connectionSelectorsElements, this.subscribe("cell-init", this.initializeCell.bind(this)), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("row-init", this.initializeRow.bind(this)));
  }
  initializeGroupHeader(e) {
    var t = this, r = {};
    r.mouseup = function(o) {
      t.tableRowDrop(o, e);
    }.bind(t), r.mousemove = function(o) {
      var s;
      o.pageY - Ge.elOffset(e.element).top + t.table.rowManager.element.scrollTop > e.getHeight() / 2 ? (t.toRow !== e || !t.toRowAfter) && (s = e.getElement(), s.parentNode.insertBefore(t.placeholderElement, s.nextSibling), t.moveRow(e, !0)) : (t.toRow !== e || t.toRowAfter) && (s = e.getElement(), s.previousSibling && (s.parentNode.insertBefore(t.placeholderElement, s), t.moveRow(e, !1)));
    }.bind(t), e.modules.moveRow = r;
  }
  initializeRow(e) {
    var t = this, r = {}, o;
    r.mouseup = function(s) {
      t.tableRowDrop(s, e);
    }.bind(t), r.mousemove = function(s) {
      var n = e.getElement();
      s.pageY - Ge.elOffset(n).top + t.table.rowManager.element.scrollTop > e.getHeight() / 2 ? (t.toRow !== e || !t.toRowAfter) && (n.parentNode.insertBefore(t.placeholderElement, n.nextSibling), t.moveRow(e, !0)) : (t.toRow !== e || t.toRowAfter) && (n.parentNode.insertBefore(t.placeholderElement, n), t.moveRow(e, !1));
    }.bind(t), this.hasHandle || (o = e.getElement(), o.addEventListener("mousedown", function(s) {
      s.which === 1 && (t.checkTimeout = setTimeout(function() {
        t.startMove(s, e);
      }, t.checkPeriod));
    }), o.addEventListener("mouseup", function(s) {
      s.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
    }), this.bindTouchEvents(e, e.getElement())), e.modules.moveRow = r;
  }
  initializeColumn(e) {
    e.definition.rowHandle && this.table.options.movableRows !== !1 && (this.hasHandle = !0);
  }
  initializeCell(e) {
    if (e.column.definition.rowHandle && this.table.options.movableRows !== !1) {
      var t = this, r = e.getElement(!0);
      r.addEventListener("mousedown", function(o) {
        o.which === 1 && (t.checkTimeout = setTimeout(function() {
          t.startMove(o, e.row);
        }, t.checkPeriod));
      }), r.addEventListener("mouseup", function(o) {
        o.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
      }), this.bindTouchEvents(e.row, r);
    }
  }
  bindTouchEvents(e, t) {
    var r = !1, o, s, n, a, l, u;
    t.addEventListener("touchstart", (h) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = !0, o = e.nextRow(), n = o ? o.getHeight() / 2 : 0, s = e.prevRow(), a = s ? s.getHeight() / 2 : 0, l = 0, u = 0, r = !1, this.startMove(h, e);
      }, this.checkPeriod);
    }, { passive: !0 }), this.moving, this.toRow, this.toRowAfter, t.addEventListener("touchmove", (h) => {
      var c, d;
      this.moving && (h.preventDefault(), this.moveHover(h), r || (r = h.touches[0].pageY), c = h.touches[0].pageY - r, c > 0 ? o && c - l > n && (d = o, d !== e && (r = h.touches[0].pageY, d.getElement().parentNode.insertBefore(this.placeholderElement, d.getElement().nextSibling), this.moveRow(d, !0))) : s && -c - u > a && (d = s, d !== e && (r = h.touches[0].pageY, d.getElement().parentNode.insertBefore(this.placeholderElement, d.getElement()), this.moveRow(d, !1))), d && (o = d.nextRow(), l = n, n = o ? o.getHeight() / 2 : 0, s = d.prevRow(), u = a, a = s ? s.getHeight() / 2 : 0));
    }), t.addEventListener("touchend", (h) => {
      this.checkTimeout && clearTimeout(this.checkTimeout), this.moving && (this.endMove(h), this.touchMove = !1);
    });
  }
  _bindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((e) => {
      (e.type === "row" || e.type === "group") && e.modules.moveRow && e.modules.moveRow.mousemove && e.getElement().addEventListener("mousemove", e.modules.moveRow.mousemove);
    });
  }
  _unbindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((e) => {
      (e.type === "row" || e.type === "group") && e.modules.moveRow && e.modules.moveRow.mousemove && e.getElement().removeEventListener("mousemove", e.modules.moveRow.mousemove);
    });
  }
  startMove(e, t) {
    var r = t.getElement();
    this.setStartPosition(e, t), this.moving = t, this.table.element.classList.add("tabulator-block-select"), this.placeholderElement.style.width = t.getWidth() + "px", this.placeholderElement.style.height = t.getHeight() + "px", this.connection ? (this.table.element.classList.add("tabulator-movingrow-sending"), this.connectToTables(t)) : (r.parentNode.insertBefore(this.placeholderElement, r), r.parentNode.removeChild(r)), this.hoverElement = r.cloneNode(!0), this.hoverElement.classList.add("tabulator-moving"), this.connection ? (document.body.appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.top = "0", this.hoverElement.style.width = this.table.element.clientWidth + "px", this.hoverElement.style.whiteSpace = "nowrap", this.hoverElement.style.overflow = "hidden", this.hoverElement.style.pointerEvents = "none") : (this.table.rowManager.getTableElement().appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.top = "0", this._bindMouseMove()), document.body.addEventListener("mousemove", this.moveHover), document.body.addEventListener("mouseup", this.endMove), this.dispatchExternal("rowMoving", t.getComponent()), this.moveHover(e);
  }
  setStartPosition(e, t) {
    var r = this.touchMove ? e.touches[0].pageX : e.pageX, o = this.touchMove ? e.touches[0].pageY : e.pageY, s, n;
    s = t.getElement(), this.connection ? (n = s.getBoundingClientRect(), this.startX = n.left - r + window.pageXOffset, this.startY = n.top - o + window.pageYOffset) : this.startY = o - s.getBoundingClientRect().top;
  }
  endMove(e) {
    (!e || e.which === 1 || this.touchMove) && (this._unbindMouseMove(), this.connection || (this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling), this.placeholderElement.parentNode.removeChild(this.placeholderElement)), this.hoverElement.parentNode.removeChild(this.hoverElement), this.table.element.classList.remove("tabulator-block-select"), this.toRow ? this.table.rowManager.moveRow(this.moving, this.toRow, this.toRowAfter) : this.dispatchExternal("rowMoveCancelled", this.moving.getComponent()), this.moving = !1, this.toRow = !1, this.toRowAfter = !1, document.body.removeEventListener("mousemove", this.moveHover), document.body.removeEventListener("mouseup", this.endMove), this.connection && (this.table.element.classList.remove("tabulator-movingrow-sending"), this.disconnectFromTables()));
  }
  moveRow(e, t) {
    this.toRow = e, this.toRowAfter = t;
  }
  moveHover(e) {
    this.connection ? this.moveHoverConnections.call(this, e) : this.moveHoverTable.call(this, e);
  }
  moveHoverTable(e) {
    var t = this.table.rowManager.getElement(), r = t.scrollTop, o = (this.touchMove ? e.touches[0].pageY : e.pageY) - t.getBoundingClientRect().top + r;
    this.hoverElement.style.top = Math.min(o - this.startY, this.table.rowManager.element.scrollHeight - this.hoverElement.offsetHeight) + "px";
  }
  moveHoverConnections(e) {
    this.hoverElement.style.left = this.startX + (this.touchMove ? e.touches[0].pageX : e.pageX) + "px", this.hoverElement.style.top = this.startY + (this.touchMove ? e.touches[0].pageY : e.pageY) + "px";
  }
  elementRowDrop(e, t, r) {
    this.dispatchExternal("movableRowsElementDrop", e, t, r ? r.getComponent() : !1);
  }
  //establish connection with other tables
  connectToTables(e) {
    var t;
    this.connectionSelectorsTables && (t = this.commsConnections(this.connectionSelectorsTables), this.dispatchExternal("movableRowsSendingStart", t), this.commsSend(this.connectionSelectorsTables, "moveRow", "connect", {
      row: e
    })), this.connectionSelectorsElements && (this.connectionElements = [], Array.isArray(this.connectionSelectorsElements) || (this.connectionSelectorsElements = [this.connectionSelectorsElements]), this.connectionSelectorsElements.forEach((r) => {
      typeof r == "string" ? this.connectionElements = this.connectionElements.concat(Array.prototype.slice.call(document.querySelectorAll(r))) : this.connectionElements.push(r);
    }), this.connectionElements.forEach((r) => {
      var o = (s) => {
        this.elementRowDrop(s, r, this.moving);
      };
      r.addEventListener("mouseup", o), r.tabulatorElementDropEvent = o, r.classList.add("tabulator-movingrow-receiving");
    }));
  }
  //disconnect from other tables
  disconnectFromTables() {
    var e;
    this.connectionSelectorsTables && (e = this.commsConnections(this.connectionSelectorsTables), this.dispatchExternal("movableRowsSendingStop", e), this.commsSend(this.connectionSelectorsTables, "moveRow", "disconnect")), this.connectionElements.forEach((t) => {
      t.classList.remove("tabulator-movingrow-receiving"), t.removeEventListener("mouseup", t.tabulatorElementDropEvent), delete t.tabulatorElementDropEvent;
    });
  }
  //accept incomming connection
  connect(e, t) {
    return this.connectedTable ? (console.warn("Move Row Error - Table cannot accept connection, already connected to table:", this.connectedTable), !1) : (this.connectedTable = e, this.connectedRow = t, this.table.element.classList.add("tabulator-movingrow-receiving"), this.table.rowManager.getDisplayRows().forEach((r) => {
      r.type === "row" && r.modules.moveRow && r.modules.moveRow.mouseup && r.getElement().addEventListener("mouseup", r.modules.moveRow.mouseup);
    }), this.tableRowDropEvent = this.tableRowDrop.bind(this), this.table.element.addEventListener("mouseup", this.tableRowDropEvent), this.dispatchExternal("movableRowsReceivingStart", t, e), !0);
  }
  //close incoming connection
  disconnect(e) {
    e === this.connectedTable ? (this.connectedTable = !1, this.connectedRow = !1, this.table.element.classList.remove("tabulator-movingrow-receiving"), this.table.rowManager.getDisplayRows().forEach((t) => {
      t.type === "row" && t.modules.moveRow && t.modules.moveRow.mouseup && t.getElement().removeEventListener("mouseup", t.modules.moveRow.mouseup);
    }), this.table.element.removeEventListener("mouseup", this.tableRowDropEvent), this.dispatchExternal("movableRowsReceivingStop", e)) : console.warn("Move Row Error - trying to disconnect from non connected table");
  }
  dropComplete(e, t, r) {
    var o = !1;
    if (r) {
      switch (typeof this.table.options.movableRowsSender) {
        case "string":
          o = this.senders[this.table.options.movableRowsSender];
          break;
        case "function":
          o = this.table.options.movableRowsSender;
          break;
      }
      o ? o.call(this, this.moving ? this.moving.getComponent() : void 0, t ? t.getComponent() : void 0, e) : this.table.options.movableRowsSender && console.warn("Mover Row Error - no matching sender found:", this.table.options.movableRowsSender), this.dispatchExternal("movableRowsSent", this.moving.getComponent(), t ? t.getComponent() : void 0, e);
    } else
      this.dispatchExternal("movableRowsSentFailed", this.moving.getComponent(), t ? t.getComponent() : void 0, e);
    this.endMove();
  }
  tableRowDrop(e, t) {
    var r = !1, o = !1;
    switch (e.stopImmediatePropagation(), typeof this.table.options.movableRowsReceiver) {
      case "string":
        r = this.receivers[this.table.options.movableRowsReceiver];
        break;
      case "function":
        r = this.table.options.movableRowsReceiver;
        break;
    }
    r ? o = r.call(this, this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable) : console.warn("Mover Row Error - no matching receiver found:", this.table.options.movableRowsReceiver), o ? this.dispatchExternal("movableRowsReceived", this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable) : this.dispatchExternal("movableRowsReceivedFailed", this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable), this.commsSend(this.connectedTable, "moveRow", "dropcomplete", {
      row: t,
      success: o
    });
  }
  commsReceived(e, t, r) {
    switch (t) {
      case "connect":
        return this.connect(e, r.row);
      case "disconnect":
        return this.disconnect(e);
      case "dropcomplete":
        return this.dropComplete(e, r.row, r.success);
    }
  }
}
sl.prototype.receivers = {
  insert: function(i, e, t) {
    return this.table.addRow(i.getData(), void 0, e), !0;
  },
  add: function(i, e, t) {
    return this.table.addRow(i.getData()), !0;
  },
  update: function(i, e, t) {
    return e ? (e.update(i.getData()), !0) : !1;
  },
  replace: function(i, e, t) {
    return e ? (this.table.addRow(i.getData(), void 0, e), e.delete(), !0) : !1;
  }
};
sl.prototype.senders = {
  delete: function(i, e, t) {
    i.delete();
  }
};
sl.moduleName = "moveRow";
var P2 = {};
class ns extends ge {
  constructor(e) {
    super(e), this.allowedTypes = ["", "data", "edit", "clipboard"], this.enabled = !0, this.registerColumnOption("mutator"), this.registerColumnOption("mutatorParams"), this.registerColumnOption("mutatorData"), this.registerColumnOption("mutatorDataParams"), this.registerColumnOption("mutatorEdit"), this.registerColumnOption("mutatorEditParams"), this.registerColumnOption("mutatorClipboard"), this.registerColumnOption("mutatorClipboardParams"), this.registerColumnOption("mutateLink");
  }
  initialize() {
    this.subscribe("cell-value-changing", this.transformCell.bind(this)), this.subscribe("cell-value-changed", this.mutateLink.bind(this)), this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("row-data-init-before", this.rowDataChanged.bind(this)), this.subscribe("row-data-changing", this.rowDataChanged.bind(this));
  }
  rowDataChanged(e, t, r) {
    return this.transformRow(t, "data", r);
  }
  //initialize column mutator
  initializeColumn(e) {
    var t = !1, r = {};
    this.allowedTypes.forEach((o) => {
      var s = "mutator" + (o.charAt(0).toUpperCase() + o.slice(1)), n;
      e.definition[s] && (n = this.lookupMutator(e.definition[s]), n && (t = !0, r[s] = {
        mutator: n,
        params: e.definition[s + "Params"] || {}
      }));
    }), t && (e.modules.mutate = r);
  }
  lookupMutator(e) {
    var t = !1;
    switch (typeof e) {
      case "string":
        ns.mutators[e] ? t = ns.mutators[e] : console.warn("Mutator Error - No such mutator found, ignoring: ", e);
        break;
      case "function":
        t = e;
        break;
    }
    return t;
  }
  //apply mutator to row
  transformRow(e, t, r) {
    var o = "mutator" + (t.charAt(0).toUpperCase() + t.slice(1)), s;
    return this.enabled && this.table.columnManager.traverse((n) => {
      var a, l, u;
      n.modules.mutate && (a = n.modules.mutate[o] || n.modules.mutate.mutator || !1, a && (s = n.getFieldValue(typeof r < "u" ? r : e), (t == "data" && !r || typeof s < "u") && (u = n.getComponent(), l = typeof a.params == "function" ? a.params(s, e, t, u) : a.params, n.setFieldValue(e, a.mutator(s, e, t, l, u)))));
    }), e;
  }
  //apply mutator to new cell value
  transformCell(e, t) {
    if (e.column.modules.mutate) {
      var r = e.column.modules.mutate.mutatorEdit || e.column.modules.mutate.mutator || !1, o = {};
      if (r)
        return o = Object.assign(o, e.row.getData()), e.column.setFieldValue(o, t), r.mutator(t, o, "edit", r.params, e.getComponent());
    }
    return t;
  }
  mutateLink(e) {
    var t = e.column.definition.mutateLink;
    t && (Array.isArray(t) || (t = [t]), t.forEach((r) => {
      var o = e.row.getCell(r);
      o && o.setValue(o.getValue(), !0, !0);
    }));
  }
  enable() {
    this.enabled = !0;
  }
  disable() {
    this.enabled = !1;
  }
}
ns.moduleName = "mutator";
ns.mutators = P2;
function L2(i, e, t, r, o) {
  var s = document.createElement("span"), n = document.createElement("span"), a = document.createElement("span"), l = document.createElement("span"), u = document.createElement("span"), h = document.createElement("span");
  return this.table.modules.localize.langBind("pagination|counter|showing", (c) => {
    n.innerHTML = c;
  }), this.table.modules.localize.langBind("pagination|counter|of", (c) => {
    l.innerHTML = c;
  }), this.table.modules.localize.langBind("pagination|counter|rows", (c) => {
    h.innerHTML = c;
  }), r ? (a.innerHTML = " " + e + "-" + Math.min(e + i - 1, r) + " ", u.innerHTML = " " + r + " ", s.appendChild(n), s.appendChild(a), s.appendChild(l), s.appendChild(u), s.appendChild(h)) : (a.innerHTML = " 0 ", s.appendChild(n), s.appendChild(a), s.appendChild(h)), s;
}
function w2(i, e, t, r, o) {
  var s = document.createElement("span"), n = document.createElement("span"), a = document.createElement("span"), l = document.createElement("span"), u = document.createElement("span"), h = document.createElement("span");
  return this.table.modules.localize.langBind("pagination|counter|showing", (c) => {
    n.innerHTML = c;
  }), a.innerHTML = " " + t + " ", this.table.modules.localize.langBind("pagination|counter|of", (c) => {
    l.innerHTML = c;
  }), u.innerHTML = " " + o + " ", this.table.modules.localize.langBind("pagination|counter|pages", (c) => {
    h.innerHTML = c;
  }), s.appendChild(n), s.appendChild(a), s.appendChild(l), s.appendChild(u), s.appendChild(h), s;
}
var y2 = {
  rows: L2,
  pages: w2
};
class An extends ge {
  constructor(e) {
    super(e), this.mode = "local", this.progressiveLoad = !1, this.element = null, this.pageCounterElement = null, this.pageCounter = null, this.size = 0, this.page = 1, this.count = 5, this.max = 1, this.remoteRowCountEstimate = null, this.initialLoad = !0, this.dataChanging = !1, this.pageSizes = [], this.registerTableOption("pagination", !1), this.registerTableOption("paginationMode", "local"), this.registerTableOption("paginationSize", !1), this.registerTableOption("paginationInitialPage", 1), this.registerTableOption("paginationCounter", !1), this.registerTableOption("paginationCounterElement", !1), this.registerTableOption("paginationButtonCount", 5), this.registerTableOption("paginationSizeSelector", !1), this.registerTableOption("paginationElement", !1), this.registerTableOption("paginationAddRow", "page"), this.registerTableOption("progressiveLoad", !1), this.registerTableOption("progressiveLoadDelay", 0), this.registerTableOption("progressiveLoadScrollMargin", 0), this.registerTableFunction("setMaxPage", this.setMaxPage.bind(this)), this.registerTableFunction("setPage", this.setPage.bind(this)), this.registerTableFunction("setPageToRow", this.userSetPageToRow.bind(this)), this.registerTableFunction("setPageSize", this.userSetPageSize.bind(this)), this.registerTableFunction("getPageSize", this.getPageSize.bind(this)), this.registerTableFunction("previousPage", this.previousPage.bind(this)), this.registerTableFunction("nextPage", this.nextPage.bind(this)), this.registerTableFunction("getPage", this.getPage.bind(this)), this.registerTableFunction("getPageMax", this.getPageMax.bind(this)), this.registerComponentFunction("row", "pageTo", this.setPageToRow.bind(this));
  }
  initialize() {
    this.table.options.pagination ? (this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("row-added", this.rowsUpdated.bind(this)), this.subscribe("data-processed", this.initialLoadComplete.bind(this)), this.subscribe("table-built", this.calculatePageSizes.bind(this)), this.subscribe("footer-redraw", this.footerRedraw.bind(this)), this.table.options.paginationAddRow == "page" && this.subscribe("row-adding-position", this.rowAddingPosition.bind(this)), this.table.options.paginationMode === "remote" && (this.subscribe("data-params", this.remotePageParams.bind(this)), this.subscribe("data-loaded", this._parseRemoteData.bind(this))), this.table.options.progressiveLoad && console.error("Progressive Load Error - Pagination and progressive load cannot be used at the same time"), this.registerDisplayHandler(this.restOnRenderBefore.bind(this), 40), this.registerDisplayHandler(this.getRows.bind(this), 50), this.createElements(), this.initializePageCounter(), this.initializePaginator()) : this.table.options.progressiveLoad && (this.subscribe("data-params", this.remotePageParams.bind(this)), this.subscribe("data-loaded", this._parseRemoteData.bind(this)), this.subscribe("table-built", this.calculatePageSizes.bind(this)), this.subscribe("data-processed", this.initialLoadComplete.bind(this)), this.initializeProgressive(this.table.options.progressiveLoad), this.table.options.progressiveLoad === "scroll" && this.subscribe("scroll-vertical", this.scrollVertical.bind(this)));
  }
  rowAddingPosition(e, t) {
    var r = this.table.rowManager, o = r.getDisplayRows(), s;
    return t ? o.length ? s = o[0] : r.activeRows.length && (s = r.activeRows[r.activeRows.length - 1], t = !1) : o.length && (s = o[o.length - 1], t = !(o.length < this.size)), { index: s, top: t };
  }
  calculatePageSizes() {
    var e, t;
    this.table.options.paginationSize ? this.size = this.table.options.paginationSize : (e = document.createElement("div"), e.classList.add("tabulator-row"), e.style.visibility = "hidden", t = document.createElement("div"), t.classList.add("tabulator-cell"), t.innerHTML = "Page Row Test", e.appendChild(t), this.table.rowManager.getTableElement().appendChild(e), this.size = Math.floor(this.table.rowManager.getElement().clientHeight / e.offsetHeight), this.table.rowManager.getTableElement().removeChild(e)), this.dispatchExternal("pageSizeChanged", this.size), this.generatePageSizeSelectList();
  }
  initialLoadComplete() {
    this.initialLoad = !1;
  }
  remotePageParams(e, t, r, o) {
    return this.initialLoad || (this.progressiveLoad && !r || !this.progressiveLoad && !this.dataChanging) && this.reset(!0), o.page = this.page, this.size && (o.size = this.size), o;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userSetPageToRow(e) {
    return this.table.options.pagination && (e = this.rowManager.findRow(e), e) ? this.setPageToRow(e) : Promise.reject();
  }
  userSetPageSize(e) {
    return this.table.options.pagination ? (this.setPageSize(e), this.setPage(1)) : !1;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  scrollVertical(e, t) {
    var r, o, s;
    !t && !this.table.dataLoader.loading && (r = this.table.rowManager.getElement(), o = r.scrollHeight - r.clientHeight - e, s = this.table.options.progressiveLoadScrollMargin || r.clientHeight * 2, o < s && this.nextPage().catch(() => {
    }));
  }
  restOnRenderBefore(e, t) {
    return t || this.mode === "local" && this.reset(), e;
  }
  rowsUpdated() {
    this.refreshData(!0, "all");
  }
  createElements() {
    var e;
    this.element = document.createElement("span"), this.element.classList.add("tabulator-paginator"), this.pagesElement = document.createElement("span"), this.pagesElement.classList.add("tabulator-pages"), e = document.createElement("button"), e.classList.add("tabulator-page"), e.setAttribute("type", "button"), e.setAttribute("role", "button"), e.setAttribute("aria-label", ""), e.setAttribute("title", ""), this.firstBut = e.cloneNode(!0), this.firstBut.setAttribute("data-page", "first"), this.prevBut = e.cloneNode(!0), this.prevBut.setAttribute("data-page", "prev"), this.nextBut = e.cloneNode(!0), this.nextBut.setAttribute("data-page", "next"), this.lastBut = e.cloneNode(!0), this.lastBut.setAttribute("data-page", "last"), this.table.options.paginationSizeSelector && (this.pageSizeSelect = document.createElement("select"), this.pageSizeSelect.classList.add("tabulator-page-size"));
  }
  generatePageSizeSelectList() {
    var e = [];
    if (this.pageSizeSelect) {
      if (Array.isArray(this.table.options.paginationSizeSelector))
        e = this.table.options.paginationSizeSelector, this.pageSizes = e, this.pageSizes.indexOf(this.size) == -1 && e.unshift(this.size);
      else if (this.pageSizes.indexOf(this.size) == -1) {
        e = [];
        for (let t = 1; t < 5; t++)
          e.push(this.size * t);
        this.pageSizes = e;
      } else
        e = this.pageSizes;
      for (; this.pageSizeSelect.firstChild; )
        this.pageSizeSelect.removeChild(this.pageSizeSelect.firstChild);
      e.forEach((t) => {
        var r = document.createElement("option");
        r.value = t, t === !0 ? this.langBind("pagination|all", function(o) {
          r.innerHTML = o;
        }) : r.innerHTML = t, this.pageSizeSelect.appendChild(r);
      }), this.pageSizeSelect.value = this.size;
    }
  }
  initializePageCounter() {
    var e = this.table.options.paginationCounter, t = null;
    e && (typeof e == "function" ? t = e : t = An.pageCounters[e], t ? (this.pageCounter = t, this.pageCounterElement = document.createElement("span"), this.pageCounterElement.classList.add("tabulator-page-counter")) : console.warn("Pagination Error - No such page counter found: ", e));
  }
  //setup pagination
  initializePaginator(e) {
    var t, r;
    e || (this.langBind("pagination|first", (o) => {
      this.firstBut.innerHTML = o;
    }), this.langBind("pagination|first_title", (o) => {
      this.firstBut.setAttribute("aria-label", o), this.firstBut.setAttribute("title", o);
    }), this.langBind("pagination|prev", (o) => {
      this.prevBut.innerHTML = o;
    }), this.langBind("pagination|prev_title", (o) => {
      this.prevBut.setAttribute("aria-label", o), this.prevBut.setAttribute("title", o);
    }), this.langBind("pagination|next", (o) => {
      this.nextBut.innerHTML = o;
    }), this.langBind("pagination|next_title", (o) => {
      this.nextBut.setAttribute("aria-label", o), this.nextBut.setAttribute("title", o);
    }), this.langBind("pagination|last", (o) => {
      this.lastBut.innerHTML = o;
    }), this.langBind("pagination|last_title", (o) => {
      this.lastBut.setAttribute("aria-label", o), this.lastBut.setAttribute("title", o);
    }), this.firstBut.addEventListener("click", () => {
      this.setPage(1);
    }), this.prevBut.addEventListener("click", () => {
      this.previousPage();
    }), this.nextBut.addEventListener("click", () => {
      this.nextPage();
    }), this.lastBut.addEventListener("click", () => {
      this.setPage(this.max);
    }), this.table.options.paginationElement && (this.element = this.table.options.paginationElement), this.pageSizeSelect && (t = document.createElement("label"), this.langBind("pagination|page_size", (o) => {
      this.pageSizeSelect.setAttribute("aria-label", o), this.pageSizeSelect.setAttribute("title", o), t.innerHTML = o;
    }), this.element.appendChild(t), this.element.appendChild(this.pageSizeSelect), this.pageSizeSelect.addEventListener("change", (o) => {
      this.setPageSize(this.pageSizeSelect.value == "true" ? !0 : this.pageSizeSelect.value), this.setPage(1);
    })), this.element.appendChild(this.firstBut), this.element.appendChild(this.prevBut), this.element.appendChild(this.pagesElement), this.element.appendChild(this.nextBut), this.element.appendChild(this.lastBut), this.table.options.paginationElement || (this.table.options.paginationCounter && (this.table.options.paginationCounterElement ? this.table.options.paginationCounterElement instanceof HTMLElement ? this.table.options.paginationCounterElement.appendChild(this.pageCounterElement) : typeof this.table.options.paginationCounterElement == "string" && (r = document.querySelector(this.table.options.paginationCounterElement), r ? r.appendChild(this.pageCounterElement) : console.warn("Pagination Error - Unable to find element matching paginationCounterElement selector:", this.table.options.paginationCounterElement)) : this.footerAppend(this.pageCounterElement)), this.footerAppend(this.element)), this.page = this.table.options.paginationInitialPage, this.count = this.table.options.paginationButtonCount), this.mode = this.table.options.paginationMode;
  }
  initializeProgressive(e) {
    this.initializePaginator(!0), this.mode = "progressive_" + e, this.progressiveLoad = !0;
  }
  trackChanges() {
    this.dispatch("page-changed");
  }
  //calculate maximum page from number of rows
  setMaxRows(e) {
    e ? this.max = this.size === !0 ? 1 : Math.ceil(e / this.size) : this.max = 1, this.page > this.max && (this.page = this.max);
  }
  //reset to first page without triggering action
  reset(e) {
    this.initialLoad || (this.mode == "local" || e) && (this.page = 1, this.trackChanges());
  }
  //set the maximum page
  setMaxPage(e) {
    e = parseInt(e), this.max = e || 1, this.page > this.max && (this.page = this.max, this.trigger());
  }
  //set current page number
  setPage(e) {
    switch (e) {
      case "first":
        return this.setPage(1);
      case "prev":
        return this.previousPage();
      case "next":
        return this.nextPage();
      case "last":
        return this.setPage(this.max);
    }
    return e = parseInt(e), e > 0 && e <= this.max || this.mode !== "local" ? (this.page = e, this.trackChanges(), this.trigger()) : (console.warn("Pagination Error - Requested page is out of range of 1 - " + this.max + ":", e), Promise.reject());
  }
  setPageToRow(e) {
    var t = this.displayRows(-1), r = t.indexOf(e);
    if (r > -1) {
      var o = this.size === !0 ? 1 : Math.ceil((r + 1) / this.size);
      return this.setPage(o);
    } else
      return console.warn("Pagination Error - Requested row is not visible"), Promise.reject();
  }
  setPageSize(e) {
    e !== !0 && (e = parseInt(e)), e > 0 && (this.size = e, this.dispatchExternal("pageSizeChanged", e)), this.pageSizeSelect && this.generatePageSizeSelectList(), this.trackChanges();
  }
  _setPageCounter(e, t, r) {
    var o;
    if (this.pageCounter)
      switch (this.mode === "remote" && (t = this.size, r = (this.page - 1) * this.size + 1, e = this.remoteRowCountEstimate), o = this.pageCounter.call(this, t, r, this.page, e, this.max), typeof o) {
        case "object":
          if (o instanceof Node) {
            for (; this.pageCounterElement.firstChild; )
              this.pageCounterElement.removeChild(this.pageCounterElement.firstChild);
            this.pageCounterElement.appendChild(o);
          } else
            this.pageCounterElement.innerHTML = "", o != null && console.warn("Page Counter Error - Page Counter has returned a type of object, the only valid page counter object return is an instance of Node, the page counter returned:", o);
          break;
        case "undefined":
          this.pageCounterElement.innerHTML = "";
          break;
        default:
          this.pageCounterElement.innerHTML = o;
      }
  }
  //setup the pagination buttons
  _setPageButtons() {
    let e = Math.floor((this.count - 1) / 2), t = Math.ceil((this.count - 1) / 2), r = this.max - this.page + e + 1 < this.count ? this.max - this.count + 1 : Math.max(this.page - e, 1), o = this.page <= t ? Math.min(this.count, this.max) : Math.min(this.page + t, this.max);
    for (; this.pagesElement.firstChild; )
      this.pagesElement.removeChild(this.pagesElement.firstChild);
    this.page == 1 ? (this.firstBut.disabled = !0, this.prevBut.disabled = !0) : (this.firstBut.disabled = !1, this.prevBut.disabled = !1), this.page == this.max ? (this.lastBut.disabled = !0, this.nextBut.disabled = !0) : (this.lastBut.disabled = !1, this.nextBut.disabled = !1);
    for (let s = r; s <= o; s++)
      s > 0 && s <= this.max && this.pagesElement.appendChild(this._generatePageButton(s));
    this.footerRedraw();
  }
  _generatePageButton(e) {
    var t = document.createElement("button");
    return t.classList.add("tabulator-page"), e == this.page && t.classList.add("active"), t.setAttribute("type", "button"), t.setAttribute("role", "button"), this.langBind("pagination|page_title", (r) => {
      t.setAttribute("aria-label", r + " " + e), t.setAttribute("title", r + " " + e);
    }), t.setAttribute("data-page", e), t.textContent = e, t.addEventListener("click", (r) => {
      this.setPage(e);
    }), t;
  }
  //previous page
  previousPage() {
    return this.page > 1 ? (this.page--, this.trackChanges(), this.trigger()) : (console.warn("Pagination Error - Previous page would be less than page 1:", 0), Promise.reject());
  }
  //next page
  nextPage() {
    return this.page < this.max ? (this.page++, this.trackChanges(), this.trigger()) : (this.progressiveLoad || console.warn("Pagination Error - Next page would be greater than maximum page of " + this.max + ":", this.max + 1), Promise.reject());
  }
  //return current page number
  getPage() {
    return this.page;
  }
  //return max page number
  getPageMax() {
    return this.max;
  }
  getPageSize(e) {
    return this.size;
  }
  getMode() {
    return this.mode;
  }
  //return appropriate rows for current page
  getRows(e) {
    var t = 0, r, o, s, n, a = e.filter((l) => l.type === "row");
    if (this.mode == "local") {
      r = [], this.setMaxRows(e.length), this.size === !0 ? (o = 0, s = e.length) : (o = this.size * (this.page - 1), s = o + parseInt(this.size)), this._setPageButtons();
      for (let l = o; l < s; l++) {
        let u = e[l];
        u && (r.push(u), u.type === "row" && (n || (n = u), t++));
      }
      return this._setPageCounter(a.length, t, n ? a.indexOf(n) + 1 : 0), r;
    } else
      return this._setPageButtons(), this._setPageCounter(a.length), e.slice(0);
  }
  trigger() {
    var e;
    switch (this.mode) {
      case "local":
        return e = this.table.rowManager.scrollLeft, this.refreshData(), this.table.rowManager.scrollHorizontal(e), this.dispatchExternal("pageLoaded", this.getPage()), Promise.resolve();
      case "remote":
        return this.dataChanging = !0, this.reloadData(null).finally(() => {
          this.dataChanging = !1;
        });
      case "progressive_load":
      case "progressive_scroll":
        return this.reloadData(null, !0);
      default:
        return console.warn("Pagination Error - no such pagination mode:", this.mode), Promise.reject();
    }
  }
  _parseRemoteData(e) {
    var t;
    if (typeof e.last_page > "u" && console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").last_page || "last_page") + "' property"), e.data)
      if (this.max = parseInt(e.last_page) || 1, this.remoteRowCountEstimate = typeof e.last_row < "u" ? e.last_row : e.last_page * this.size - (this.page == e.last_page ? this.size - e.data.length : 0), this.progressiveLoad) {
        switch (this.mode) {
          case "progressive_load":
            this.page == 1 ? this.table.rowManager.setData(e.data, !1, this.page == 1) : this.table.rowManager.addRows(e.data), this.page < this.max && setTimeout(() => {
              this.nextPage();
            }, this.table.options.progressiveLoadDelay);
            break;
          case "progressive_scroll":
            e = this.page === 1 ? e.data : this.table.rowManager.getData().concat(e.data), this.table.rowManager.setData(e, this.page !== 1, this.page == 1), t = this.table.options.progressiveLoadScrollMargin || this.table.rowManager.element.clientHeight * 2, this.table.rowManager.element.scrollHeight <= this.table.rowManager.element.clientHeight + t && this.page < this.max && setTimeout(() => {
              this.nextPage();
            });
            break;
        }
        return !1;
      } else
        this.dispatchExternal("pageLoaded", this.getPage());
    else
      console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").data || "data") + "' property");
    return e.data;
  }
  //handle the footer element being redrawn
  footerRedraw() {
    var e = this.table.footerManager.containerElement;
    Math.ceil(e.clientWidth) - e.scrollWidth < 0 ? this.pagesElement.style.display = "none" : (this.pagesElement.style.display = "", Math.ceil(e.clientWidth) - e.scrollWidth < 0 && (this.pagesElement.style.display = "none"));
  }
}
An.moduleName = "page";
An.pageCounters = y2;
var D2 = {
  local: function(i, e) {
    var t = localStorage.getItem(i + "-" + e);
    return t ? JSON.parse(t) : !1;
  },
  cookie: function(i, e) {
    var t = document.cookie, r = i + "-" + e, o = t.indexOf(r + "="), s, n;
    return o > -1 && (t = t.slice(o), s = t.indexOf(";"), s > -1 && (t = t.slice(0, s)), n = t.replace(r + "=", "")), n ? JSON.parse(n) : !1;
  }
}, x2 = {
  local: function(i, e, t) {
    localStorage.setItem(i + "-" + e, JSON.stringify(t));
  },
  cookie: function(i, e, t) {
    var r = /* @__PURE__ */ new Date();
    r.setDate(r.getDate() + 1e4), document.cookie = i + "-" + e + "=" + JSON.stringify(t) + "; expires=" + r.toUTCString();
  }
};
class Mt extends ge {
  constructor(e) {
    super(e), this.mode = "", this.id = "", this.defWatcherBlock = !1, this.config = {}, this.readFunc = !1, this.writeFunc = !1, this.registerTableOption("persistence", !1), this.registerTableOption("persistenceID", ""), this.registerTableOption("persistenceMode", !0), this.registerTableOption("persistenceReaderFunc", !1), this.registerTableOption("persistenceWriterFunc", !1);
  }
  // Test for whether localStorage is available for use.
  localStorageTest() {
    var e = "_tabulator_test";
    try {
      return window.localStorage.setItem(e, e), window.localStorage.removeItem(e), !0;
    } catch {
      return !1;
    }
  }
  //setup parameters
  initialize() {
    if (this.table.options.persistence) {
      var e = this.table.options.persistenceMode, t = this.table.options.persistenceID, r;
      this.mode = e !== !0 ? e : this.localStorageTest() ? "local" : "cookie", this.table.options.persistenceReaderFunc ? typeof this.table.options.persistenceReaderFunc == "function" ? this.readFunc = this.table.options.persistenceReaderFunc : Mt.readers[this.table.options.persistenceReaderFunc] ? this.readFunc = Mt.readers[this.table.options.persistenceReaderFunc] : console.warn("Persistence Read Error - invalid reader set", this.table.options.persistenceReaderFunc) : Mt.readers[this.mode] ? this.readFunc = Mt.readers[this.mode] : console.warn("Persistence Read Error - invalid reader set", this.mode), this.table.options.persistenceWriterFunc ? typeof this.table.options.persistenceWriterFunc == "function" ? this.writeFunc = this.table.options.persistenceWriterFunc : Mt.writers[this.table.options.persistenceWriterFunc] ? this.writeFunc = Mt.writers[this.table.options.persistenceWriterFunc] : console.warn("Persistence Write Error - invalid reader set", this.table.options.persistenceWriterFunc) : Mt.writers[this.mode] ? this.writeFunc = Mt.writers[this.mode] : console.warn("Persistence Write Error - invalid writer set", this.mode), this.id = "tabulator-" + (t || this.table.element.getAttribute("id") || ""), this.config = {
        sort: this.table.options.persistence === !0 || this.table.options.persistence.sort,
        filter: this.table.options.persistence === !0 || this.table.options.persistence.filter,
        headerFilter: this.table.options.persistence === !0 || this.table.options.persistence.headerFilter,
        group: this.table.options.persistence === !0 || this.table.options.persistence.group,
        page: this.table.options.persistence === !0 || this.table.options.persistence.page,
        columns: this.table.options.persistence === !0 ? ["title", "width", "visible"] : this.table.options.persistence.columns
      }, this.config.page && (r = this.retrieveData("page"), r && (typeof r.paginationSize < "u" && (this.config.page === !0 || this.config.page.size) && (this.table.options.paginationSize = r.paginationSize), typeof r.paginationInitialPage < "u" && (this.config.page === !0 || this.config.page.page) && (this.table.options.paginationInitialPage = r.paginationInitialPage))), this.config.group && (r = this.retrieveData("group"), r && (typeof r.groupBy < "u" && (this.config.group === !0 || this.config.group.groupBy) && (this.table.options.groupBy = r.groupBy), typeof r.groupStartOpen < "u" && (this.config.group === !0 || this.config.group.groupStartOpen) && (this.table.options.groupStartOpen = r.groupStartOpen), typeof r.groupHeader < "u" && (this.config.group === !0 || this.config.group.groupHeader) && (this.table.options.groupHeader = r.groupHeader))), this.config.columns && (this.table.options.columns = this.load("columns", this.table.options.columns), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("column-show", this.save.bind(this, "columns")), this.subscribe("column-hide", this.save.bind(this, "columns")), this.subscribe("column-moved", this.save.bind(this, "columns"))), this.subscribe("table-built", this.tableBuilt.bind(this), 0), this.subscribe("table-redraw", this.tableRedraw.bind(this)), this.subscribe("filter-changed", this.eventSave.bind(this, "filter")), this.subscribe("filter-changed", this.eventSave.bind(this, "headerFilter")), this.subscribe("sort-changed", this.eventSave.bind(this, "sort")), this.subscribe("group-changed", this.eventSave.bind(this, "group")), this.subscribe("page-changed", this.eventSave.bind(this, "page")), this.subscribe("column-resized", this.eventSave.bind(this, "columns")), this.subscribe("column-width", this.eventSave.bind(this, "columns")), this.subscribe("layout-refreshed", this.eventSave.bind(this, "columns"));
    }
    this.registerTableFunction("getColumnLayout", this.getColumnLayout.bind(this)), this.registerTableFunction("setColumnLayout", this.setColumnLayout.bind(this));
  }
  eventSave(e) {
    this.config[e] && this.save(e);
  }
  tableBuilt() {
    var e, t, r;
    this.config.sort && (e = this.load("sort"), e && (this.table.options.initialSort = e)), this.config.filter && (t = this.load("filter"), t && (this.table.options.initialFilter = t)), this.config.headerFilter && (r = this.load("headerFilter"), r && (this.table.options.initialHeaderFilter = r));
  }
  tableRedraw(e) {
    e && this.config.columns && this.save("columns");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  getColumnLayout() {
    return this.parseColumns(this.table.columnManager.getColumns());
  }
  setColumnLayout(e) {
    return this.table.columnManager.setColumns(this.mergeDefinition(this.table.options.columns, e)), !0;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumn(e) {
    var t, r;
    this.config.columns && (this.defWatcherBlock = !0, t = e.getDefinition(), r = this.config.columns === !0 ? Object.keys(t) : this.config.columns, r.forEach((o) => {
      var s = Object.getOwnPropertyDescriptor(t, o), n = t[o];
      s && Object.defineProperty(t, o, {
        set: (a) => {
          n = a, this.defWatcherBlock || this.save("columns"), s.set && s.set(a);
        },
        get: () => (s.get && s.get(), n)
      });
    }), this.defWatcherBlock = !1);
  }
  //load saved definitions
  load(e, t) {
    var r = this.retrieveData(e);
    return t && (r = r ? this.mergeDefinition(t, r) : t), r;
  }
  //retrieve data from memory
  retrieveData(e) {
    return this.readFunc ? this.readFunc(this.id, e) : !1;
  }
  //merge old and new column definitions
  mergeDefinition(e, t) {
    var r = [];
    return t = t || [], t.forEach((o, s) => {
      var n = this._findColumn(e, o), a;
      n && (this.config.columns === !0 || this.config.columns == null ? (a = Object.keys(n), a.push("width")) : a = this.config.columns, a.forEach((l) => {
        l !== "columns" && typeof o[l] < "u" && (n[l] = o[l]);
      }), n.columns && (n.columns = this.mergeDefinition(n.columns, o.columns)), r.push(n));
    }), e.forEach((o, s) => {
      var n = this._findColumn(t, o);
      n || (r.length > s ? r.splice(s, 0, o) : r.push(o));
    }), r;
  }
  //find matching columns
  _findColumn(e, t) {
    var r = t.columns ? "group" : t.field ? "field" : "object";
    return e.find(function(o) {
      switch (r) {
        case "group":
          return o.title === t.title && o.columns.length === t.columns.length;
        case "field":
          return o.field === t.field;
        case "object":
          return o === t;
      }
    });
  }
  //save data
  save(e) {
    var t = {};
    switch (e) {
      case "columns":
        t = this.parseColumns(this.table.columnManager.getColumns());
        break;
      case "filter":
        t = this.table.modules.filter.getFilters();
        break;
      case "headerFilter":
        t = this.table.modules.filter.getHeaderFilters();
        break;
      case "sort":
        t = this.validateSorters(this.table.modules.sort.getSort());
        break;
      case "group":
        t = this.getGroupConfig();
        break;
      case "page":
        t = this.getPageConfig();
        break;
    }
    this.writeFunc && this.writeFunc(this.id, e, t);
  }
  //ensure sorters contain no function data
  validateSorters(e) {
    return e.forEach(function(t) {
      t.column = t.field, delete t.field;
    }), e;
  }
  getGroupConfig() {
    var e = {};
    return this.config.group && ((this.config.group === !0 || this.config.group.groupBy) && (e.groupBy = this.table.options.groupBy), (this.config.group === !0 || this.config.group.groupStartOpen) && (e.groupStartOpen = this.table.options.groupStartOpen), (this.config.group === !0 || this.config.group.groupHeader) && (e.groupHeader = this.table.options.groupHeader)), e;
  }
  getPageConfig() {
    var e = {};
    return this.config.page && ((this.config.page === !0 || this.config.page.size) && (e.paginationSize = this.table.modules.page.getPageSize()), (this.config.page === !0 || this.config.page.page) && (e.paginationInitialPage = this.table.modules.page.getPage())), e;
  }
  //parse columns for data to store
  parseColumns(e) {
    var t = [], r = ["headerContextMenu", "headerMenu", "contextMenu", "clickMenu"];
    return e.forEach((o) => {
      var s = {}, n = o.getDefinition(), a;
      o.isGroup ? (s.title = n.title, s.columns = this.parseColumns(o.getColumns())) : (s.field = o.getField(), this.config.columns === !0 || this.config.columns == null ? (a = Object.keys(n), a.push("width"), a.push("visible")) : a = this.config.columns, a.forEach((l) => {
        switch (l) {
          case "width":
            s.width = o.getWidth();
            break;
          case "visible":
            s.visible = o.visible;
            break;
          default:
            typeof n[l] != "function" && r.indexOf(l) === -1 && (s[l] = n[l]);
        }
      })), t.push(s);
    }), t;
  }
}
Mt.moduleName = "persistence";
Mt.moduleInitOrder = -10;
Mt.readers = D2;
Mt.writers = x2;
class XO extends ge {
  constructor(e) {
    super(e), this.columnSubscribers = {}, this.registerTableOption("rowContextPopup", !1), this.registerTableOption("rowClickPopup", !1), this.registerTableOption("rowDblClickPopup", !1), this.registerTableOption("groupContextPopup", !1), this.registerTableOption("groupClickPopup", !1), this.registerTableOption("groupDblClickPopup", !1), this.registerColumnOption("headerContextPopup"), this.registerColumnOption("headerClickPopup"), this.registerColumnOption("headerDblClickPopup"), this.registerColumnOption("headerPopup"), this.registerColumnOption("headerPopupIcon"), this.registerColumnOption("contextPopup"), this.registerColumnOption("clickPopup"), this.registerColumnOption("dblClickPopup"), this.registerComponentFunction("cell", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("column", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("row", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("group", "popup", this._componentPopupCall.bind(this));
  }
  initialize() {
    this.initializeRowWatchers(), this.initializeGroupWatchers(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  _componentPopupCall(e, t, r) {
    this.loadPopupEvent(t, null, e, r);
  }
  initializeRowWatchers() {
    this.table.options.rowContextPopup && (this.subscribe("row-contextmenu", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup)), this.table.on("rowTapHold", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup))), this.table.options.rowClickPopup && this.subscribe("row-click", this.loadPopupEvent.bind(this, this.table.options.rowClickPopup)), this.table.options.rowDblClickPopup && this.subscribe("row-dblclick", this.loadPopupEvent.bind(this, this.table.options.rowDblClickPopup));
  }
  initializeGroupWatchers() {
    this.table.options.groupContextPopup && (this.subscribe("group-contextmenu", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup)), this.table.on("groupTapHold", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup))), this.table.options.groupClickPopup && this.subscribe("group-click", this.loadPopupEvent.bind(this, this.table.options.groupClickPopup)), this.table.options.groupDblClickPopup && this.subscribe("group-dblclick", this.loadPopupEvent.bind(this, this.table.options.groupDblClickPopup));
  }
  initializeColumn(e) {
    var t = e.definition;
    t.headerContextPopup && !this.columnSubscribers.headerContextPopup && (this.columnSubscribers.headerContextPopup = this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"), this.subscribe("column-contextmenu", this.columnSubscribers.headerContextPopup), this.table.on("headerTapHold", this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"))), t.headerClickPopup && !this.columnSubscribers.headerClickPopup && (this.columnSubscribers.headerClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerClickPopup"), this.subscribe("column-click", this.columnSubscribers.headerClickPopup)), t.headerDblClickPopup && !this.columnSubscribers.headerDblClickPopup && (this.columnSubscribers.headerDblClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerDblClickPopup"), this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickPopup)), t.headerPopup && this.initializeColumnHeaderPopup(e), t.contextPopup && !this.columnSubscribers.contextPopup && (this.columnSubscribers.contextPopup = this.loadPopupTableCellEvent.bind(this, "contextPopup"), this.subscribe("cell-contextmenu", this.columnSubscribers.contextPopup), this.table.on("cellTapHold", this.loadPopupTableCellEvent.bind(this, "contextPopup"))), t.clickPopup && !this.columnSubscribers.clickPopup && (this.columnSubscribers.clickPopup = this.loadPopupTableCellEvent.bind(this, "clickPopup"), this.subscribe("cell-click", this.columnSubscribers.clickPopup)), t.dblClickPopup && !this.columnSubscribers.dblClickPopup && (this.columnSubscribers.dblClickPopup = this.loadPopupTableCellEvent.bind(this, "dblClickPopup"), this.subscribe("cell-click", this.columnSubscribers.dblClickPopup));
  }
  initializeColumnHeaderPopup(e) {
    var t = e.definition.headerPopupIcon, r;
    r = document.createElement("span"), r.classList.add("tabulator-header-popup-button"), t ? (typeof t == "function" && (t = t(e.getComponent())), t instanceof HTMLElement ? r.appendChild(t) : r.innerHTML = t) : r.innerHTML = "&vellip;", r.addEventListener("click", (o) => {
      o.stopPropagation(), o.preventDefault(), this.loadPopupEvent(e.definition.headerPopup, o, e);
    }), e.titleElement.insertBefore(r, e.titleElement.firstChild);
  }
  loadPopupTableCellEvent(e, t, r) {
    r._cell && (r = r._cell), r.column.definition[e] && this.loadPopupEvent(r.column.definition[e], t, r);
  }
  loadPopupTableColumnEvent(e, t, r) {
    r._column && (r = r._column), r.definition[e] && this.loadPopupEvent(r.definition[e], t, r);
  }
  loadPopupEvent(e, t, r, o) {
    var s;
    function n(a) {
      s = a;
    }
    r._group ? r = r._group : r._row && (r = r._row), e = typeof e == "function" ? e.call(this.table, t, r.getComponent(), n) : e, this.loadPopup(t, r, e, s, o);
  }
  loadPopup(e, t, r, o, s) {
    var n = !(e instanceof MouseEvent), a, l;
    r instanceof HTMLElement ? a = r : (a = document.createElement("div"), a.innerHTML = r), a.classList.add("tabulator-popup"), a.addEventListener("click", (u) => {
      u.stopPropagation();
    }), n || e.preventDefault(), l = this.popup(a), typeof o == "function" && l.renderCallback(o), e ? l.show(e) : l.show(t.getElement(), s || "center"), l.hideOnBlur(() => {
      this.dispatchExternal("popupClosed", t.getComponent());
    }), this.dispatchExternal("popupOpened", t.getComponent());
  }
}
XO.moduleName = "popup";
class YO extends ge {
  constructor(e) {
    super(e), this.element = !1, this.manualBlock = !1, this.beforeprintEventHandler = null, this.afterprintEventHandler = null, this.registerTableOption("printAsHtml", !1), this.registerTableOption("printFormatter", !1), this.registerTableOption("printHeader", !1), this.registerTableOption("printFooter", !1), this.registerTableOption("printStyled", !0), this.registerTableOption("printRowRange", "visible"), this.registerTableOption("printConfig", {}), this.registerColumnOption("print"), this.registerColumnOption("titlePrint");
  }
  initialize() {
    this.table.options.printAsHtml && (this.beforeprintEventHandler = this.replaceTable.bind(this), this.afterprintEventHandler = this.cleanup.bind(this), window.addEventListener("beforeprint", this.beforeprintEventHandler), window.addEventListener("afterprint", this.afterprintEventHandler), this.subscribe("table-destroy", this.destroy.bind(this))), this.registerTableFunction("print", this.printFullscreen.bind(this));
  }
  destroy() {
    this.table.options.printAsHtml && (window.removeEventListener("beforeprint", this.beforeprintEventHandler), window.removeEventListener("afterprint", this.afterprintEventHandler));
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  replaceTable() {
    this.manualBlock || (this.element = document.createElement("div"), this.element.classList.add("tabulator-print-table"), this.element.appendChild(this.table.modules.export.generateTable(this.table.options.printConfig, this.table.options.printStyled, this.table.options.printRowRange, "print")), this.table.element.style.display = "none", this.table.element.parentNode.insertBefore(this.element, this.table.element));
  }
  cleanup() {
    document.body.classList.remove("tabulator-print-fullscreen-hide"), this.element && this.element.parentNode && (this.element.parentNode.removeChild(this.element), this.table.element.style.display = "");
  }
  printFullscreen(e, t, r) {
    var o = window.scrollX, s = window.scrollY, n = document.createElement("div"), a = document.createElement("div"), l = this.table.modules.export.generateTable(typeof r < "u" ? r : this.table.options.printConfig, typeof t < "u" ? t : this.table.options.printStyled, e || this.table.options.printRowRange, "print"), u, h;
    this.manualBlock = !0, this.element = document.createElement("div"), this.element.classList.add("tabulator-print-fullscreen"), this.table.options.printHeader && (n.classList.add("tabulator-print-header"), u = typeof this.table.options.printHeader == "function" ? this.table.options.printHeader.call(this.table) : this.table.options.printHeader, typeof u == "string" ? n.innerHTML = u : n.appendChild(u), this.element.appendChild(n)), this.element.appendChild(l), this.table.options.printFooter && (a.classList.add("tabulator-print-footer"), h = typeof this.table.options.printFooter == "function" ? this.table.options.printFooter.call(this.table) : this.table.options.printFooter, typeof h == "string" ? a.innerHTML = h : a.appendChild(h), this.element.appendChild(a)), document.body.classList.add("tabulator-print-fullscreen-hide"), document.body.appendChild(this.element), this.table.options.printFormatter && this.table.options.printFormatter(this.element, l), window.print(), this.cleanup(), window.scrollTo(o, s), this.manualBlock = !1;
  }
}
YO.moduleName = "print";
class BO extends ge {
  constructor(e) {
    super(e), this.data = !1, this.blocked = !1, this.origFuncs = {}, this.currentVersion = 0, this.registerTableOption("reactiveData", !1);
  }
  initialize() {
    this.table.options.reactiveData && (this.subscribe("cell-value-save-before", this.block.bind(this, "cellsave")), this.subscribe("cell-value-save-after", this.unblock.bind(this, "cellsave")), this.subscribe("row-data-save-before", this.block.bind(this, "rowsave")), this.subscribe("row-data-save-after", this.unblock.bind(this, "rowsave")), this.subscribe("row-data-init-after", this.watchRow.bind(this)), this.subscribe("data-processing", this.watchData.bind(this)), this.subscribe("table-destroy", this.unwatchData.bind(this)));
  }
  watchData(e) {
    var t = this, r;
    this.currentVersion++, r = this.currentVersion, this.unwatchData(), this.data = e, this.origFuncs.push = e.push, Object.defineProperty(this.data, "push", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var o = Array.from(arguments), s;
        return !t.blocked && r === t.currentVersion && (t.block("data-push"), o.forEach((n) => {
          t.table.rowManager.addRowActual(n, !1);
        }), s = t.origFuncs.push.apply(e, arguments), t.unblock("data-push")), s;
      }
    }), this.origFuncs.unshift = e.unshift, Object.defineProperty(this.data, "unshift", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var o = Array.from(arguments), s;
        return !t.blocked && r === t.currentVersion && (t.block("data-unshift"), o.forEach((n) => {
          t.table.rowManager.addRowActual(n, !0);
        }), s = t.origFuncs.unshift.apply(e, arguments), t.unblock("data-unshift")), s;
      }
    }), this.origFuncs.shift = e.shift, Object.defineProperty(this.data, "shift", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var o, s;
        return !t.blocked && r === t.currentVersion && (t.block("data-shift"), t.data.length && (o = t.table.rowManager.getRowFromDataObject(t.data[0]), o && o.deleteActual()), s = t.origFuncs.shift.call(e), t.unblock("data-shift")), s;
      }
    }), this.origFuncs.pop = e.pop, Object.defineProperty(this.data, "pop", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var o, s;
        return !t.blocked && r === t.currentVersion && (t.block("data-pop"), t.data.length && (o = t.table.rowManager.getRowFromDataObject(t.data[t.data.length - 1]), o && o.deleteActual()), s = t.origFuncs.pop.call(e), t.unblock("data-pop")), s;
      }
    }), this.origFuncs.splice = e.splice, Object.defineProperty(this.data, "splice", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var o = Array.from(arguments), s = o[0] < 0 ? e.length + o[0] : o[0], n = o[1], a = o[2] ? o.slice(2) : !1, l, u;
        if (!t.blocked && r === t.currentVersion) {
          if (t.block("data-splice"), a && (l = e[s] ? t.table.rowManager.getRowFromDataObject(e[s]) : !1, l ? a.forEach((c) => {
            t.table.rowManager.addRowActual(c, !0, l, !0);
          }) : (a = a.slice().reverse(), a.forEach((c) => {
            t.table.rowManager.addRowActual(c, !0, !1, !0);
          }))), n !== 0) {
            var h = e.slice(s, typeof o[1] > "u" ? o[1] : s + n);
            h.forEach((c, d) => {
              var f = t.table.rowManager.getRowFromDataObject(c);
              f && f.deleteActual(d !== h.length - 1);
            });
          }
          (a || n !== 0) && t.table.rowManager.reRenderInPosition(), u = t.origFuncs.splice.apply(e, arguments), t.unblock("data-splice");
        }
        return u;
      }
    });
  }
  unwatchData() {
    if (this.data !== !1)
      for (var e in this.origFuncs)
        Object.defineProperty(this.data, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: this.origFuncs.key
        });
  }
  watchRow(e) {
    var t = e.getData();
    for (var r in t)
      this.watchKey(e, t, r);
    this.table.options.dataTree && this.watchTreeChildren(e);
  }
  watchTreeChildren(e) {
    var t = this, r = e.getData()[this.table.options.dataTreeChildField], o = {};
    r && (o.push = r.push, Object.defineProperty(r, "push", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-push");
          var s = o.push.apply(r, arguments);
          this.rebuildTree(e), t.unblock("tree-push");
        }
        return s;
      }
    }), o.unshift = r.unshift, Object.defineProperty(r, "unshift", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-unshift");
          var s = o.unshift.apply(r, arguments);
          this.rebuildTree(e), t.unblock("tree-unshift");
        }
        return s;
      }
    }), o.shift = r.shift, Object.defineProperty(r, "shift", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-shift");
          var s = o.shift.call(r);
          this.rebuildTree(e), t.unblock("tree-shift");
        }
        return s;
      }
    }), o.pop = r.pop, Object.defineProperty(r, "pop", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-pop");
          var s = o.pop.call(r);
          this.rebuildTree(e), t.unblock("tree-pop");
        }
        return s;
      }
    }), o.splice = r.splice, Object.defineProperty(r, "splice", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-splice");
          var s = o.splice.apply(r, arguments);
          this.rebuildTree(e), t.unblock("tree-splice");
        }
        return s;
      }
    }));
  }
  rebuildTree(e) {
    this.table.modules.dataTree.initializeRow(e), this.table.modules.dataTree.layoutRow(e), this.table.rowManager.refreshActiveData("tree", !1, !0);
  }
  watchKey(e, t, r) {
    var o = this, s = Object.getOwnPropertyDescriptor(t, r), n = t[r], a = this.currentVersion;
    Object.defineProperty(t, r, {
      set: (l) => {
        if (n = l, !o.blocked && a === o.currentVersion) {
          o.block("key");
          var u = {};
          u[r] = l, e.updateData(u), o.unblock("key");
        }
        s.set && s.set(l);
      },
      get: () => (s.get && s.get(), n)
    });
  }
  unwatchRow(e) {
    var t = e.getData();
    for (var r in t)
      Object.defineProperty(t, r, {
        value: t[r]
      });
  }
  block(e) {
    this.blocked || (this.blocked = e);
  }
  unblock(e) {
    this.blocked === e && (this.blocked = !1);
  }
}
BO.moduleName = "reactiveData";
class FO extends ge {
  constructor(e) {
    super(e), this.startColumn = !1, this.startX = !1, this.startWidth = !1, this.latestX = !1, this.handle = null, this.initialNextColumn = null, this.nextColumn = null, this.initialized = !1, this.registerColumnOption("resizable", !0), this.registerTableOption("resizableColumnFit", !1);
  }
  initialize() {
    this.subscribe("column-rendered", this.layoutColumnHeader.bind(this));
  }
  initializeEventWatchers() {
    this.initialized || (this.subscribe("cell-rendered", this.layoutCellHandles.bind(this)), this.subscribe("cell-delete", this.deInitializeComponent.bind(this)), this.subscribe("cell-height", this.resizeHandle.bind(this)), this.subscribe("column-moved", this.columnLayoutUpdated.bind(this)), this.subscribe("column-hide", this.deInitializeColumn.bind(this)), this.subscribe("column-show", this.columnLayoutUpdated.bind(this)), this.subscribe("column-width", this.columnWidthUpdated.bind(this)), this.subscribe("column-delete", this.deInitializeComponent.bind(this)), this.subscribe("column-height", this.resizeHandle.bind(this)), this.initialized = !0);
  }
  layoutCellHandles(e) {
    e.row.type === "row" && (this.deInitializeComponent(e), this.initializeColumn("cell", e, e.column, e.element));
  }
  layoutColumnHeader(e) {
    e.definition.resizable && (this.initializeEventWatchers(), this.deInitializeComponent(e), this.initializeColumn("header", e, e, e.element));
  }
  columnLayoutUpdated(e) {
    var t = e.prevColumn();
    this.reinitializeColumn(e), t && this.reinitializeColumn(t);
  }
  columnWidthUpdated(e) {
    e.modules.frozen && (this.table.modules.frozenColumns.leftColumns.includes(e) ? this.table.modules.frozenColumns.leftColumns.forEach((t) => {
      this.reinitializeColumn(t);
    }) : this.table.modules.frozenColumns.rightColumns.includes(e) && this.table.modules.frozenColumns.rightColumns.forEach((t) => {
      this.reinitializeColumn(t);
    }));
  }
  frozenColumnOffset(e) {
    var t = !1;
    return e.modules.frozen && (t = e.modules.frozen.marginValue, e.modules.frozen.position === "left" ? t += e.getWidth() - 3 : t && (t -= 3)), t !== !1 ? t + "px" : !1;
  }
  reinitializeColumn(e) {
    var t = this.frozenColumnOffset(e);
    e.cells.forEach((r) => {
      r.modules.resize && r.modules.resize.handleEl && (t && (r.modules.resize.handleEl.style[e.modules.frozen.position] = t), r.element.after(r.modules.resize.handleEl));
    }), e.modules.resize && e.modules.resize.handleEl && (t && (e.modules.resize.handleEl.style[e.modules.frozen.position] = t), e.element.after(e.modules.resize.handleEl));
  }
  initializeColumn(e, t, r, o) {
    var s = this, n = !1, a = r.definition.resizable, l = {}, u = r.getLastColumn();
    if (e === "header" && (n = r.definition.formatter == "textarea" || r.definition.variableHeight, l = { variableHeight: n }), (a === !0 || a == e) && this._checkResizability(u)) {
      var h = document.createElement("span");
      h.className = "tabulator-col-resize-handle", h.addEventListener("click", function(d) {
        d.stopPropagation();
      });
      var c = function(d) {
        s.startColumn = r, s.initialNextColumn = s.nextColumn = u.nextColumn(), s._mouseDown(d, u, h);
      };
      h.addEventListener("mousedown", c), h.addEventListener("touchstart", c, { passive: !0 }), h.addEventListener("dblclick", (d) => {
        var f = u.getWidth();
        d.stopPropagation(), u.reinitializeWidth(!0), f !== u.getWidth() && (s.dispatch("column-resized", u), s.table.externalEvents.dispatch("columnResized", u.getComponent()));
      }), r.modules.frozen && (h.style.position = "sticky", h.style[r.modules.frozen.position] = this.frozenColumnOffset(r)), l.handleEl = h, o.parentNode && r.visible && o.after(h);
    }
    t.modules.resize = l;
  }
  deInitializeColumn(e) {
    this.deInitializeComponent(e), e.cells.forEach((t) => {
      this.deInitializeComponent(t);
    });
  }
  deInitializeComponent(e) {
    var t;
    e.modules.resize && (t = e.modules.resize.handleEl, t && t.parentElement && t.parentElement.removeChild(t));
  }
  resizeHandle(e, t) {
    e.modules.resize && e.modules.resize.handleEl && (e.modules.resize.handleEl.style.height = t);
  }
  _checkResizability(e) {
    return e.definition.resizable;
  }
  _mouseDown(e, t, r) {
    var o = this;
    o.table.element.classList.add("tabulator-block-select");
    function s(a) {
      var l = typeof a.screenX > "u" ? a.touches[0].screenX : a.screenX, u = l - o.startX, h = l - o.latestX, c, d;
      if (o.latestX = l, o.table.rtl && (u = -u, h = -h), c = t.width == t.minWidth || t.width == t.maxWidth, t.setWidth(o.startWidth + u), d = t.width == t.minWidth || t.width == t.maxWidth, h < 0 && (o.nextColumn = o.initialNextColumn), o.table.options.resizableColumnFit && o.nextColumn && !(c && d)) {
        let f = o.nextColumn.getWidth();
        h > 0 && f <= o.nextColumn.minWidth && (o.nextColumn = o.nextColumn.nextColumn()), o.nextColumn && o.nextColumn.setWidth(o.nextColumn.getWidth() - h);
      }
      o.table.columnManager.rerenderColumns(!0), !o.table.browserSlow && t.modules.resize && t.modules.resize.variableHeight && t.checkCellHeights();
    }
    function n(a) {
      o.startColumn.modules.edit && (o.startColumn.modules.edit.blocked = !1), o.table.browserSlow && t.modules.resize && t.modules.resize.variableHeight && t.checkCellHeights(), document.body.removeEventListener("mouseup", n), document.body.removeEventListener("mousemove", s), r.removeEventListener("touchmove", s), r.removeEventListener("touchend", n), o.table.element.classList.remove("tabulator-block-select"), o.startWidth !== t.getWidth() && (o.table.columnManager.verticalAlignHeaders(), o.dispatch("column-resized", t), o.table.externalEvents.dispatch("columnResized", t.getComponent()));
    }
    e.stopPropagation(), o.startColumn.modules.edit && (o.startColumn.modules.edit.blocked = !0), o.startX = typeof e.screenX > "u" ? e.touches[0].screenX : e.screenX, o.latestX = o.startX, o.startWidth = t.getWidth(), document.body.addEventListener("mousemove", s), document.body.addEventListener("mouseup", n), r.addEventListener("touchmove", s, { passive: !0 }), r.addEventListener("touchend", n);
  }
}
FO.moduleName = "resizeColumns";
class WO extends ge {
  constructor(e) {
    super(e), this.startColumn = !1, this.startY = !1, this.startHeight = !1, this.handle = null, this.prevHandle = null, this.registerTableOption("resizableRows", !1);
  }
  initialize() {
    this.table.options.resizableRows && this.subscribe("row-layout-after", this.initializeRow.bind(this));
  }
  initializeRow(e) {
    var t = this, r = e.getElement(), o = document.createElement("div");
    o.className = "tabulator-row-resize-handle";
    var s = document.createElement("div");
    s.className = "tabulator-row-resize-handle prev", o.addEventListener("click", function(l) {
      l.stopPropagation();
    });
    var n = function(l) {
      t.startRow = e, t._mouseDown(l, e, o);
    };
    o.addEventListener("mousedown", n), o.addEventListener("touchstart", n, { passive: !0 }), s.addEventListener("click", function(l) {
      l.stopPropagation();
    });
    var a = function(l) {
      var u = t.table.rowManager.prevDisplayRow(e);
      u && (t.startRow = u, t._mouseDown(l, u, s));
    };
    s.addEventListener("mousedown", a), s.addEventListener("touchstart", a, { passive: !0 }), r.appendChild(o), r.appendChild(s);
  }
  _mouseDown(e, t, r) {
    var o = this;
    o.table.element.classList.add("tabulator-block-select");
    function s(a) {
      t.setHeight(o.startHeight + ((typeof a.screenY > "u" ? a.touches[0].screenY : a.screenY) - o.startY));
    }
    function n(a) {
      document.body.removeEventListener("mouseup", s), document.body.removeEventListener("mousemove", s), r.removeEventListener("touchmove", s), r.removeEventListener("touchend", n), o.table.element.classList.remove("tabulator-block-select"), o.dispatchExternal("rowResized", t.getComponent());
    }
    e.stopPropagation(), o.startY = typeof e.screenY > "u" ? e.touches[0].screenY : e.screenY, o.startHeight = t.getHeight(), document.body.addEventListener("mousemove", s), document.body.addEventListener("mouseup", n), r.addEventListener("touchmove", s, { passive: !0 }), r.addEventListener("touchend", n);
  }
}
WO.moduleName = "resizeRows";
class zO extends ge {
  constructor(e) {
    super(e), this.binding = !1, this.visibilityObserver = !1, this.resizeObserver = !1, this.containerObserver = !1, this.tableHeight = 0, this.tableWidth = 0, this.containerHeight = 0, this.containerWidth = 0, this.autoResize = !1, this.visible = !1, this.initialized = !1, this.initialRedraw = !1, this.registerTableOption("autoResize", !0);
  }
  initialize() {
    if (this.table.options.autoResize) {
      var e = this.table, t;
      this.tableHeight = e.element.clientHeight, this.tableWidth = e.element.clientWidth, e.element.parentNode && (this.containerHeight = e.element.parentNode.clientHeight, this.containerWidth = e.element.parentNode.clientWidth), typeof IntersectionObserver < "u" && typeof ResizeObserver < "u" && e.rowManager.getRenderMode() === "virtual" ? (this.initializeVisibilityObserver(), this.autoResize = !0, this.resizeObserver = new ResizeObserver((r) => {
        if (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) {
          var o = Math.floor(r[0].contentRect.height), s = Math.floor(r[0].contentRect.width);
          (this.tableHeight != o || this.tableWidth != s) && (this.tableHeight = o, this.tableWidth = s, e.element.parentNode && (this.containerHeight = e.element.parentNode.clientHeight, this.containerWidth = e.element.parentNode.clientWidth), this.redrawTable());
        }
      }), this.resizeObserver.observe(e.element), t = window.getComputedStyle(e.element), this.table.element.parentNode && !this.table.rowManager.fixedHeight && (t.getPropertyValue("max-height") || t.getPropertyValue("min-height")) && (this.containerObserver = new ResizeObserver((r) => {
        if (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) {
          var o = Math.floor(r[0].contentRect.height), s = Math.floor(r[0].contentRect.width);
          (this.containerHeight != o || this.containerWidth != s) && (this.containerHeight = o, this.containerWidth = s, this.tableHeight = e.element.clientHeight, this.tableWidth = e.element.clientWidth), this.redrawTable();
        }
      }), this.containerObserver.observe(this.table.element.parentNode)), this.subscribe("table-resize", this.tableResized.bind(this))) : (this.binding = function() {
        (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) && (e.columnManager.rerenderColumns(!0), e.redraw());
      }, window.addEventListener("resize", this.binding)), this.subscribe("table-destroy", this.clearBindings.bind(this));
    }
  }
  initializeVisibilityObserver() {
    this.visibilityObserver = new IntersectionObserver((e) => {
      this.visible = e[0].isIntersecting, this.initialized ? this.visible && (this.redrawTable(this.initialRedraw), this.initialRedraw = !1) : (this.initialized = !0, this.initialRedraw = !this.visible);
    }), this.visibilityObserver.observe(this.table.element);
  }
  redrawTable(e) {
    this.initialized && this.visible && (this.table.columnManager.rerenderColumns(!0), this.table.redraw(e));
  }
  tableResized() {
    this.table.rowManager.redraw();
  }
  clearBindings() {
    this.binding && window.removeEventListener("resize", this.binding), this.resizeObserver && this.resizeObserver.unobserve(this.table.element), this.visibilityObserver && this.visibilityObserver.unobserve(this.table.element), this.containerObserver && this.containerObserver.unobserve(this.table.element.parentNode);
  }
}
zO.moduleName = "resizeTable";
class ZO extends ge {
  constructor(e) {
    super(e), this.columns = [], this.hiddenColumns = [], this.mode = "", this.index = 0, this.collapseFormatter = [], this.collapseStartOpen = !0, this.collapseHandleColumn = !1, this.registerTableOption("responsiveLayout", !1), this.registerTableOption("responsiveLayoutCollapseStartOpen", !0), this.registerTableOption("responsiveLayoutCollapseUseFormatters", !0), this.registerTableOption("responsiveLayoutCollapseFormatter", !1), this.registerColumnOption("responsive");
  }
  //generate responsive columns list
  initialize() {
    this.table.options.responsiveLayout && (this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("column-show", this.updateColumnVisibility.bind(this)), this.subscribe("column-hide", this.updateColumnVisibility.bind(this)), this.subscribe("columns-loaded", this.initializeResponsivity.bind(this)), this.subscribe("column-moved", this.initializeResponsivity.bind(this)), this.subscribe("column-add", this.initializeResponsivity.bind(this)), this.subscribe("column-delete", this.initializeResponsivity.bind(this)), this.subscribe("table-redrawing", this.tableRedraw.bind(this)), this.table.options.responsiveLayout === "collapse" && (this.subscribe("row-data-changed", this.generateCollapsedRowContent.bind(this)), this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-layout", this.layoutRow.bind(this))));
  }
  tableRedraw(e) {
    ["fitColumns", "fitDataStretch"].indexOf(this.layoutMode()) === -1 && (e || this.update());
  }
  initializeResponsivity() {
    var e = [];
    this.mode = this.table.options.responsiveLayout, this.collapseFormatter = this.table.options.responsiveLayoutCollapseFormatter || this.formatCollapsedData, this.collapseStartOpen = this.table.options.responsiveLayoutCollapseStartOpen, this.hiddenColumns = [], this.table.columnManager.columnsByIndex.forEach((t, r) => {
      t.modules.responsive && t.modules.responsive.order && t.modules.responsive.visible && (t.modules.responsive.index = r, e.push(t), !t.visible && this.mode === "collapse" && this.hiddenColumns.push(t));
    }), e = e.reverse(), e = e.sort((t, r) => {
      var o = r.modules.responsive.order - t.modules.responsive.order;
      return o || r.modules.responsive.index - t.modules.responsive.index;
    }), this.columns = e, this.mode === "collapse" && this.generateCollapsedContent();
    for (let t of this.table.columnManager.columnsByIndex)
      if (t.definition.formatter == "responsiveCollapse") {
        this.collapseHandleColumn = t;
        break;
      }
    this.collapseHandleColumn && (this.hiddenColumns.length ? this.collapseHandleColumn.show() : this.collapseHandleColumn.hide());
  }
  //define layout information
  initializeColumn(e) {
    var t = e.getDefinition();
    e.modules.responsive = { order: typeof t.responsive > "u" ? 1 : t.responsive, visible: t.visible !== !1 };
  }
  initializeRow(e) {
    var t;
    e.type !== "calc" && (t = document.createElement("div"), t.classList.add("tabulator-responsive-collapse"), e.modules.responsiveLayout = {
      element: t,
      open: this.collapseStartOpen
    }, this.collapseStartOpen || (t.style.display = "none"));
  }
  layoutRow(e) {
    var t = e.getElement();
    e.modules.responsiveLayout && (t.appendChild(e.modules.responsiveLayout.element), this.generateCollapsedRowContent(e));
  }
  //update column visibility
  updateColumnVisibility(e, t) {
    !t && e.modules.responsive && (e.modules.responsive.visible = e.visible, this.initializeResponsivity());
  }
  hideColumn(e) {
    var t = this.hiddenColumns.length;
    e.hide(!1, !0), this.mode === "collapse" && (this.hiddenColumns.unshift(e), this.generateCollapsedContent(), this.collapseHandleColumn && !t && this.collapseHandleColumn.show());
  }
  showColumn(e) {
    var t;
    e.show(!1, !0), e.setWidth(e.getWidth()), this.mode === "collapse" && (t = this.hiddenColumns.indexOf(e), t > -1 && this.hiddenColumns.splice(t, 1), this.generateCollapsedContent(), this.collapseHandleColumn && !this.hiddenColumns.length && this.collapseHandleColumn.hide());
  }
  //redraw columns to fit space
  update() {
    for (var e = !0; e; ) {
      let t = this.table.modules.layout.getMode() == "fitColumns" ? this.table.columnManager.getFlexBaseWidth() : this.table.columnManager.getWidth(), r = (this.table.options.headerVisible ? this.table.columnManager.element.clientWidth : this.table.element.clientWidth) - t;
      if (r < 0) {
        let o = this.columns[this.index];
        o ? (this.hideColumn(o), this.index++) : e = !1;
      } else {
        let o = this.columns[this.index - 1];
        o && r > 0 && r >= o.getWidth() ? (this.showColumn(o), this.index--) : e = !1;
      }
      this.table.rowManager.activeRowsCount || this.table.rowManager.renderEmptyScroll();
    }
  }
  generateCollapsedContent() {
    var e = this.table.rowManager.getDisplayRows();
    e.forEach((t) => {
      this.generateCollapsedRowContent(t);
    });
  }
  generateCollapsedRowContent(e) {
    var t, r;
    if (e.modules.responsiveLayout) {
      for (t = e.modules.responsiveLayout.element; t.firstChild; )
        t.removeChild(t.firstChild);
      r = this.collapseFormatter(this.generateCollapsedRowData(e)), r && t.appendChild(r);
    }
  }
  generateCollapsedRowData(e) {
    var t = e.getData(), r = [], o;
    return this.hiddenColumns.forEach((s) => {
      var n = s.getFieldValue(t);
      if (s.definition.title && s.field)
        if (s.modules.format && this.table.options.responsiveLayoutCollapseUseFormatters) {
          let l = function(u) {
            u();
          };
          var a = l;
          o = {
            value: !1,
            data: {},
            getValue: function() {
              return n;
            },
            getData: function() {
              return t;
            },
            getType: function() {
              return "cell";
            },
            getElement: function() {
              return document.createElement("div");
            },
            getRow: function() {
              return e.getComponent();
            },
            getColumn: function() {
              return s.getComponent();
            },
            getTable: () => this.table
          }, r.push({
            field: s.field,
            title: s.definition.title,
            value: s.modules.format.formatter.call(this.table.modules.format, o, s.modules.format.params, l)
          });
        } else
          r.push({
            field: s.field,
            title: s.definition.title,
            value: n
          });
    }), r;
  }
  formatCollapsedData(e) {
    var t = document.createElement("table");
    return e.forEach(function(r) {
      var o = document.createElement("tr"), s = document.createElement("td"), n = document.createElement("td"), a, l = document.createElement("strong");
      s.appendChild(l), this.langBind("columns|" + r.field, function(u) {
        l.innerHTML = u || r.title;
      }), r.value instanceof Node ? (a = document.createElement("div"), a.appendChild(r.value), n.appendChild(a)) : n.innerHTML = r.value, o.appendChild(s), o.appendChild(n), t.appendChild(o);
    }, this), Object.keys(e).length ? t : "";
  }
}
ZO.moduleName = "responsiveLayout";
class qO extends ge {
  constructor(e) {
    super(e), this.selecting = !1, this.lastClickedRow = !1, this.selectPrev = [], this.selectedRows = [], this.headerCheckboxElement = null, this.registerTableOption("selectable", "highlight"), this.registerTableOption("selectableRangeMode", "drag"), this.registerTableOption("selectableRollingSelection", !0), this.registerTableOption("selectablePersistence", !0), this.registerTableOption("selectableCheck", function(t, r) {
      return !0;
    }), this.registerTableFunction("selectRow", this.selectRows.bind(this)), this.registerTableFunction("deselectRow", this.deselectRows.bind(this)), this.registerTableFunction("toggleSelectRow", this.toggleRow.bind(this)), this.registerTableFunction("getSelectedRows", this.getSelectedRows.bind(this)), this.registerTableFunction("getSelectedData", this.getSelectedData.bind(this)), this.registerComponentFunction("row", "select", this.selectRows.bind(this)), this.registerComponentFunction("row", "deselect", this.deselectRows.bind(this)), this.registerComponentFunction("row", "toggleSelect", this.toggleRow.bind(this)), this.registerComponentFunction("row", "isSelected", this.isRowSelected.bind(this));
  }
  initialize() {
    this.table.options.selectable !== !1 && (this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-deleting", this.rowDeleted.bind(this)), this.subscribe("rows-wipe", this.clearSelectionData.bind(this)), this.subscribe("rows-retrieve", this.rowRetrieve.bind(this)), this.table.options.selectable && !this.table.options.selectablePersistence && this.subscribe("data-refreshing", this.deselectRows.bind(this)));
  }
  rowRetrieve(e, t) {
    return e === "selected" ? this.selectedRows : t;
  }
  rowDeleted(e) {
    this._deselectRow(e, !0);
  }
  clearSelectionData(e) {
    var t = this.selectedRows.length;
    this.selecting = !1, this.lastClickedRow = !1, this.selectPrev = [], this.selectedRows = [], t && e !== !0 && this._rowSelectionChanged();
  }
  initializeRow(e) {
    var t = this, r = e.getElement(), o = function() {
      setTimeout(function() {
        t.selecting = !1;
      }, 50), document.body.removeEventListener("mouseup", o);
    };
    e.modules.select = { selected: !1 }, t.checkRowSelectability(e) ? (r.classList.add("tabulator-selectable"), r.classList.remove("tabulator-unselectable"), t.table.options.selectable && t.table.options.selectable != "highlight" && (t.table.options.selectableRangeMode === "click" ? r.addEventListener("click", this.handleComplexRowClick.bind(this, e)) : (r.addEventListener("click", function(s) {
      (!t.table.modExists("edit") || !t.table.modules.edit.getCurrentCell()) && t.table._clearSelection(), t.selecting || t.toggleRow(e);
    }), r.addEventListener("mousedown", function(s) {
      if (s.shiftKey)
        return t.table._clearSelection(), t.selecting = !0, t.selectPrev = [], document.body.addEventListener("mouseup", o), document.body.addEventListener("keyup", o), t.toggleRow(e), !1;
    }), r.addEventListener("mouseenter", function(s) {
      t.selecting && (t.table._clearSelection(), t.toggleRow(e), t.selectPrev[1] == e && t.toggleRow(t.selectPrev[0]));
    }), r.addEventListener("mouseout", function(s) {
      t.selecting && (t.table._clearSelection(), t.selectPrev.unshift(e));
    })))) : (r.classList.add("tabulator-unselectable"), r.classList.remove("tabulator-selectable"));
  }
  handleComplexRowClick(e, t) {
    if (t.shiftKey) {
      this.table._clearSelection(), this.lastClickedRow = this.lastClickedRow || e;
      var r = this.table.rowManager.getDisplayRowIndex(this.lastClickedRow), o = this.table.rowManager.getDisplayRowIndex(e), s = r <= o ? r : o, n = r >= o ? r : o, a = this.table.rowManager.getDisplayRows().slice(0), l = a.splice(s, n - s + 1);
      t.ctrlKey || t.metaKey ? (l.forEach((u) => {
        u !== this.lastClickedRow && (this.table.options.selectable !== !0 && !this.isRowSelected(e) ? this.selectedRows.length < this.table.options.selectable && this.toggleRow(u) : this.toggleRow(u));
      }), this.lastClickedRow = e) : (this.deselectRows(void 0, !0), this.table.options.selectable !== !0 && l.length > this.table.options.selectable && (l = l.slice(0, this.table.options.selectable)), this.selectRows(l)), this.table._clearSelection();
    } else
      t.ctrlKey || t.metaKey ? (this.toggleRow(e), this.lastClickedRow = e) : (this.deselectRows(void 0, !0), this.selectRows(e), this.lastClickedRow = e);
  }
  checkRowSelectability(e) {
    return e && e.type === "row" ? this.table.options.selectableCheck.call(this.table, e.getComponent()) : !1;
  }
  //toggle row selection
  toggleRow(e) {
    this.checkRowSelectability(e) && (e.modules.select && e.modules.select.selected ? this._deselectRow(e) : this._selectRow(e));
  }
  //select a number of rows
  selectRows(e) {
    var t = [], r, o;
    switch (typeof e) {
      case "undefined":
        r = this.table.rowManager.rows;
        break;
      case "string":
        r = this.table.rowManager.findRow(e), r || (r = this.table.rowManager.getRows(e));
        break;
      default:
        r = e;
        break;
    }
    Array.isArray(r) ? r.length && (r.forEach((s) => {
      o = this._selectRow(s, !0, !0), o && t.push(o);
    }), this._rowSelectionChanged(!1, t)) : r && this._selectRow(r, !1, !0);
  }
  //select an individual row
  _selectRow(e, t, r) {
    if (!isNaN(this.table.options.selectable) && this.table.options.selectable !== !0 && !r && this.selectedRows.length >= this.table.options.selectable)
      if (this.table.options.selectableRollingSelection)
        this._deselectRow(this.selectedRows[0]);
      else
        return !1;
    var o = this.table.rowManager.findRow(e);
    if (o) {
      if (this.selectedRows.indexOf(o) == -1)
        return o.getElement().classList.add("tabulator-selected"), o.modules.select || (o.modules.select = {}), o.modules.select.selected = !0, o.modules.select.checkboxEl && (o.modules.select.checkboxEl.checked = !0), this.selectedRows.push(o), this.table.options.dataTreeSelectPropagate && this.childRowSelection(o, !0), this.dispatchExternal("rowSelected", o.getComponent()), this._rowSelectionChanged(t, o), o;
    } else
      t || console.warn("Selection Error - No such row found, ignoring selection:" + e);
  }
  isRowSelected(e) {
    return this.selectedRows.indexOf(e) !== -1;
  }
  //deselect a number of rows
  deselectRows(e, t) {
    var r = [], o, s;
    switch (typeof e) {
      case "undefined":
        o = Object.assign([], this.selectedRows);
        break;
      case "string":
        o = this.table.rowManager.findRow(e), o || (o = this.table.rowManager.getRows(e));
        break;
      default:
        o = e;
        break;
    }
    Array.isArray(o) ? o.length && (o.forEach((n) => {
      s = this._deselectRow(n, !0, !0), s && r.push(s);
    }), this._rowSelectionChanged(t, [], r)) : o && this._deselectRow(o, t, !0);
  }
  //deselect an individual row
  _deselectRow(e, t) {
    var r = this, o = r.table.rowManager.findRow(e), s, n;
    if (o) {
      if (s = r.selectedRows.findIndex(function(a) {
        return a == o;
      }), s > -1)
        return n = o.getElement(), n && n.classList.remove("tabulator-selected"), o.modules.select || (o.modules.select = {}), o.modules.select.selected = !1, o.modules.select.checkboxEl && (o.modules.select.checkboxEl.checked = !1), r.selectedRows.splice(s, 1), this.table.options.dataTreeSelectPropagate && this.childRowSelection(o, !1), this.dispatchExternal("rowDeselected", o.getComponent()), r._rowSelectionChanged(t, void 0, o), o;
    } else
      t || console.warn("Deselection Error - No such row found, ignoring selection:" + e);
  }
  getSelectedData() {
    var e = [];
    return this.selectedRows.forEach(function(t) {
      e.push(t.getData());
    }), e;
  }
  getSelectedRows() {
    var e = [];
    return this.selectedRows.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  _rowSelectionChanged(e, t = [], r = []) {
    this.headerCheckboxElement && (this.selectedRows.length === 0 ? (this.headerCheckboxElement.checked = !1, this.headerCheckboxElement.indeterminate = !1) : this.table.rowManager.rows.length === this.selectedRows.length ? (this.headerCheckboxElement.checked = !0, this.headerCheckboxElement.indeterminate = !1) : (this.headerCheckboxElement.indeterminate = !0, this.headerCheckboxElement.checked = !1)), e || (Array.isArray(t) || (t = [t]), t = t.map((o) => o.getComponent()), Array.isArray(r) || (r = [r]), r = r.map((o) => o.getComponent()), this.dispatchExternal("rowSelectionChanged", this.getSelectedData(), this.getSelectedRows(), t, r));
  }
  registerRowSelectCheckbox(e, t) {
    e._row.modules.select || (e._row.modules.select = {}), e._row.modules.select.checkboxEl = t;
  }
  registerHeaderSelectCheckbox(e) {
    this.headerCheckboxElement = e;
  }
  childRowSelection(e, t) {
    var r = this.table.modules.dataTree.getChildren(e, !0);
    if (t)
      for (let o of r)
        this._selectRow(o, !0);
    else
      for (let o of r)
        this._deselectRow(o, !0);
  }
}
qO.moduleName = "selectRow";
function M2(i, e, t, r, o, s, n) {
  var a = n.alignEmptyValues, l = n.decimalSeparator, u = n.thousandSeparator, h = 0;
  if (i = String(i), e = String(e), u && (i = i.split(u).join(""), e = e.split(u).join("")), l && (i = i.split(l).join("."), e = e.split(l).join(".")), i = parseFloat(i), e = parseFloat(e), isNaN(i))
    h = isNaN(e) ? 0 : -1;
  else if (isNaN(e))
    h = 1;
  else
    return i - e;
  return (a === "top" && s === "desc" || a === "bottom" && s === "asc") && (h *= -1), h;
}
function U2(i, e, t, r, o, s, n) {
  var a = n.alignEmptyValues, l = 0, u;
  if (!i)
    l = e ? -1 : 0;
  else if (!e)
    l = 1;
  else {
    switch (typeof n.locale) {
      case "boolean":
        n.locale && (u = this.langLocale());
        break;
      case "string":
        u = n.locale;
        break;
    }
    return String(i).toLowerCase().localeCompare(String(e).toLowerCase(), u);
  }
  return (a === "top" && s === "desc" || a === "bottom" && s === "asc") && (l *= -1), l;
}
function jO(i, e, t, r, o, s, n) {
  var a = window.DateTime || luxon.DateTime, l = n.format || "dd/MM/yyyy HH:mm:ss", u = n.alignEmptyValues, h = 0;
  if (typeof a < "u") {
    if (a.isDateTime(i) || (l === "iso" ? i = a.fromISO(String(i)) : i = a.fromFormat(String(i), l)), a.isDateTime(e) || (l === "iso" ? e = a.fromISO(String(e)) : e = a.fromFormat(String(e), l)), !i.isValid)
      h = e.isValid ? -1 : 0;
    else if (!e.isValid)
      h = 1;
    else
      return i - e;
    return (u === "top" && s === "desc" || u === "bottom" && s === "asc") && (h *= -1), h;
  } else
    console.error("Sort Error - 'datetime' sorter is dependant on luxon.js");
}
function Q2(i, e, t, r, o, s, n) {
  return n.format || (n.format = "dd/MM/yyyy"), jO.call(this, i, e, t, r, o, s, n);
}
function k2(i, e, t, r, o, s, n) {
  return n.format || (n.format = "HH:mm"), jO.call(this, i, e, t, r, o, s, n);
}
function $2(i, e, t, r, o, s, n) {
  var a = i === !0 || i === "true" || i === "True" || i === 1 ? 1 : 0, l = e === !0 || e === "true" || e === "True" || e === 1 ? 1 : 0;
  return a - l;
}
function G2(i, e, t, r, o, s, n) {
  var a = n.type || "length", l = n.alignEmptyValues, u = 0;
  function h(c) {
    var d;
    switch (a) {
      case "length":
        d = c.length;
        break;
      case "sum":
        d = c.reduce(function(f, p) {
          return f + p;
        });
        break;
      case "max":
        d = Math.max.apply(null, c);
        break;
      case "min":
        d = Math.min.apply(null, c);
        break;
      case "avg":
        d = c.reduce(function(f, p) {
          return f + p;
        }) / c.length;
        break;
    }
    return d;
  }
  if (!Array.isArray(i))
    u = Array.isArray(e) ? -1 : 0;
  else if (!Array.isArray(e))
    u = 1;
  else
    return h(e) - h(i);
  return (l === "top" && s === "desc" || l === "bottom" && s === "asc") && (u *= -1), u;
}
function V2(i, e, t, r, o, s, n) {
  var a = typeof i > "u" ? 0 : 1, l = typeof e > "u" ? 0 : 1;
  return a - l;
}
function H2(i, e, t, r, o, s, n) {
  var a, l, u, h, c = 0, d, f = /(\d+)|(\D+)/g, p = /\d/, O = n.alignEmptyValues, m = 0;
  if (!i && i !== 0)
    m = !e && e !== 0 ? 0 : -1;
  else if (!e && e !== 0)
    m = 1;
  else {
    if (isFinite(i) && isFinite(e))
      return i - e;
    if (a = String(i).toLowerCase(), l = String(e).toLowerCase(), a === l)
      return 0;
    if (!(p.test(a) && p.test(l)))
      return a > l ? 1 : -1;
    for (a = a.match(f), l = l.match(f), d = a.length > l.length ? l.length : a.length; c < d; )
      if (u = a[c], h = l[c++], u !== h)
        return isFinite(u) && isFinite(h) ? (u.charAt(0) === "0" && (u = "." + u), h.charAt(0) === "0" && (h = "." + h), u - h) : u > h ? 1 : -1;
    return a.length > l.length;
  }
  return (O === "top" && s === "desc" || O === "bottom" && s === "asc") && (m *= -1), m;
}
var X2 = {
  number: M2,
  string: U2,
  date: Q2,
  time: k2,
  datetime: jO,
  boolean: $2,
  array: G2,
  exists: V2,
  alphanum: H2
};
class lo extends ge {
  constructor(e) {
    super(e), this.sortList = [], this.changed = !1, this.registerTableOption("sortMode", "local"), this.registerTableOption("initialSort", !1), this.registerTableOption("columnHeaderSortMulti", !0), this.registerTableOption("sortOrderReverse", !1), this.registerTableOption("headerSortElement", "<div class='tabulator-arrow'></div>"), this.registerTableOption("headerSortClickElement", "header"), this.registerColumnOption("sorter"), this.registerColumnOption("sorterParams"), this.registerColumnOption("headerSort", !0), this.registerColumnOption("headerSortStartingDir"), this.registerColumnOption("headerSortTristate");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("table-built", this.tableBuilt.bind(this)), this.registerDataHandler(this.sort.bind(this), 20), this.registerTableFunction("setSort", this.userSetSort.bind(this)), this.registerTableFunction("getSorters", this.getSort.bind(this)), this.registerTableFunction("clearSort", this.clearSort.bind(this)), this.table.options.sortMode === "remote" && this.subscribe("data-params", this.remoteSortParams.bind(this));
  }
  tableBuilt() {
    this.table.options.initialSort && this.setSort(this.table.options.initialSort);
  }
  remoteSortParams(e, t, r, o) {
    var s = this.getSort();
    return s.forEach((n) => {
      delete n.column;
    }), o.sort = s, o;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userSetSort(e, t) {
    this.setSort(e, t), this.refreshSort();
  }
  clearSort() {
    this.clear(), this.refreshSort();
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //initialize column header for sorting
  initializeColumn(e) {
    var t = !1, r, o;
    switch (typeof e.definition.sorter) {
      case "string":
        lo.sorters[e.definition.sorter] ? t = lo.sorters[e.definition.sorter] : console.warn("Sort Error - No such sorter found: ", e.definition.sorter);
        break;
      case "function":
        t = e.definition.sorter;
        break;
    }
    if (e.modules.sort = {
      sorter: t,
      dir: "none",
      params: e.definition.sorterParams || {},
      startingDir: e.definition.headerSortStartingDir || "asc",
      tristate: e.definition.headerSortTristate
    }, e.definition.headerSort !== !1) {
      switch (r = e.getElement(), r.classList.add("tabulator-sortable"), o = document.createElement("div"), o.classList.add("tabulator-col-sorter"), this.table.options.headerSortClickElement) {
        case "icon":
          o.classList.add("tabulator-col-sorter-element");
          break;
        case "header":
          r.classList.add("tabulator-col-sorter-element");
          break;
        default:
          r.classList.add("tabulator-col-sorter-element");
          break;
      }
      switch (this.table.options.headerSortElement) {
        case "function":
          break;
        case "object":
          o.appendChild(this.table.options.headerSortElement);
          break;
        default:
          o.innerHTML = this.table.options.headerSortElement;
      }
      e.titleHolderElement.appendChild(o), e.modules.sort.element = o, this.setColumnHeaderSortIcon(e, "none"), (this.table.options.headerSortClickElement === "icon" ? o : r).addEventListener("click", (s) => {
        var n = "", a = [], l = !1;
        if (e.modules.sort) {
          if (e.modules.sort.tristate)
            e.modules.sort.dir == "none" ? n = e.modules.sort.startingDir : e.modules.sort.dir == e.modules.sort.startingDir ? n = e.modules.sort.dir == "asc" ? "desc" : "asc" : n = "none";
          else
            switch (e.modules.sort.dir) {
              case "asc":
                n = "desc";
                break;
              case "desc":
                n = "asc";
                break;
              default:
                n = e.modules.sort.startingDir;
            }
          this.table.options.columnHeaderSortMulti && (s.shiftKey || s.ctrlKey) ? (a = this.getSort(), l = a.findIndex((u) => u.field === e.getField()), l > -1 ? (a[l].dir = n, l = a.splice(l, 1)[0], n != "none" && a.push(l)) : n != "none" && a.push({ column: e, dir: n }), this.setSort(a)) : n == "none" ? this.clear() : this.setSort(e, n), this.refreshSort();
        }
      });
    }
  }
  refreshSort() {
    this.table.options.sortMode === "remote" ? this.reloadData(null, !1, !1) : this.refreshData(!0);
  }
  //check if the sorters have changed since last use
  hasChanged() {
    var e = this.changed;
    return this.changed = !1, e;
  }
  //return current sorters
  getSort() {
    var e = this, t = [];
    return e.sortList.forEach(function(r) {
      r.column && t.push({ column: r.column.getComponent(), field: r.column.getField(), dir: r.dir });
    }), t;
  }
  //change sort list and trigger sort
  setSort(e, t) {
    var r = this, o = [];
    Array.isArray(e) || (e = [{ column: e, dir: t }]), e.forEach(function(s) {
      var n;
      n = r.table.columnManager.findColumn(s.column), n ? (s.column = n, o.push(s), r.changed = !0) : console.warn("Sort Warning - Sort field does not exist and is being ignored: ", s.column);
    }), r.sortList = o, this.dispatch("sort-changed");
  }
  //clear sorters
  clear() {
    this.setSort([]);
  }
  //find appropriate sorter for column
  findSorter(e) {
    var t = this.table.rowManager.activeRows[0], r = "string", o, s;
    if (t && (t = t.getData(), o = e.getField(), o))
      switch (s = e.getFieldValue(t), typeof s) {
        case "undefined":
          r = "string";
          break;
        case "boolean":
          r = "boolean";
          break;
        default:
          !isNaN(s) && s !== "" ? r = "number" : s.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i) && (r = "alphanum");
          break;
      }
    return lo.sorters[r];
  }
  //work through sort list sorting data
  sort(e) {
    var t = this, r = this.table.options.sortOrderReverse ? t.sortList.slice().reverse() : t.sortList, o = [], s = [];
    return this.subscribedExternal("dataSorting") && this.dispatchExternal("dataSorting", t.getSort()), t.clearColumnHeaders(), this.table.options.sortMode !== "remote" ? (r.forEach(function(n, a) {
      var l;
      n.column && (l = n.column.modules.sort, l && (l.sorter || (l.sorter = t.findSorter(n.column)), n.params = typeof l.params == "function" ? l.params(n.column.getComponent(), n.dir) : l.params, o.push(n)), t.setColumnHeader(n.column, n.dir));
    }), o.length && t._sortItems(e, o)) : r.forEach(function(n, a) {
      t.setColumnHeader(n.column, n.dir);
    }), this.subscribedExternal("dataSorted") && (e.forEach((n) => {
      s.push(n.getComponent());
    }), this.dispatchExternal("dataSorted", t.getSort(), s)), e;
  }
  //clear sort arrows on columns
  clearColumnHeaders() {
    this.table.columnManager.getRealColumns().forEach((e) => {
      e.modules.sort && (e.modules.sort.dir = "none", e.getElement().setAttribute("aria-sort", "none"), this.setColumnHeaderSortIcon(e, "none"));
    });
  }
  //set the column header sort direction
  setColumnHeader(e, t) {
    e.modules.sort.dir = t, e.getElement().setAttribute("aria-sort", t === "asc" ? "ascending" : "descending"), this.setColumnHeaderSortIcon(e, t);
  }
  setColumnHeaderSortIcon(e, t) {
    var r = e.modules.sort.element, o;
    if (e.definition.headerSort && typeof this.table.options.headerSortElement == "function") {
      for (; r.firstChild; )
        r.removeChild(r.firstChild);
      o = this.table.options.headerSortElement.call(this.table, e.getComponent(), t), typeof o == "object" ? r.appendChild(o) : r.innerHTML = o;
    }
  }
  //sort each item in sort list
  _sortItems(e, t) {
    var r = t.length - 1;
    e.sort((o, s) => {
      for (var n, a = r; a >= 0; a--) {
        let l = t[a];
        if (n = this._sortRow(o, s, l.column, l.dir, l.params), n !== 0)
          break;
      }
      return n;
    });
  }
  //process individual rows for a sort function on active data
  _sortRow(e, t, r, o, s) {
    var n, a, l = o == "asc" ? e : t, u = o == "asc" ? t : e;
    return e = r.getFieldValue(l.getData()), t = r.getFieldValue(u.getData()), e = typeof e < "u" ? e : "", t = typeof t < "u" ? t : "", n = l.getComponent(), a = u.getComponent(), r.modules.sort.sorter.call(this, e, t, n, a, r.getComponent(), o, s);
  }
}
lo.moduleName = "sort";
lo.sorters = X2;
class sv extends ge {
  constructor(e) {
    super(e), this.tooltipSubscriber = null, this.headerSubscriber = null, this.timeout = null, this.popupInstance = null, this.registerTableOption("tooltipGenerationMode", void 0), this.registerTableOption("tooltipDelay", 300), this.registerColumnOption("tooltip"), this.registerColumnOption("headerTooltip");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheckMsg("tooltipGenerationMode", "This option is no longer needed as tooltips are always generated on hover now");
  }
  initializeColumn(e) {
    e.definition.headerTooltip && !this.headerSubscriber && (this.headerSubscriber = !0, this.subscribe("column-mousemove", this.mousemoveCheck.bind(this, "headerTooltip")), this.subscribe("column-mouseout", this.mouseoutCheck.bind(this, "headerTooltip"))), e.definition.tooltip && !this.tooltipSubscriber && (this.tooltipSubscriber = !0, this.subscribe("cell-mousemove", this.mousemoveCheck.bind(this, "tooltip")), this.subscribe("cell-mouseout", this.mouseoutCheck.bind(this, "tooltip")));
  }
  mousemoveCheck(e, t, r) {
    var o = e === "tooltip" ? r.column.definition.tooltip : r.definition.headerTooltip;
    o && (this.clearPopup(), this.timeout = setTimeout(this.loadTooltip.bind(this, t, r, o), this.table.options.tooltipDelay));
  }
  mouseoutCheck(e, t, r) {
    this.popupInstance || this.clearPopup();
  }
  clearPopup(e, t, r) {
    clearTimeout(this.timeout), this.timeout = null, this.popupInstance && this.popupInstance.hide();
  }
  loadTooltip(e, t, r) {
    var o, s, n;
    function a(l) {
      s = l;
    }
    typeof r == "function" && (r = r(e, t.getComponent(), a)), r instanceof HTMLElement ? o = r : (o = document.createElement("div"), r === !0 && (t instanceof ol ? r = t.value : t.definition.field ? this.langBind("columns|" + t.definition.field, (l) => {
      o.innerHTML = r = l || t.definition.title;
    }) : r = t.definition.title), o.innerHTML = r), (r || r === 0 || r === !1) && (o.classList.add("tabulator-tooltip"), o.addEventListener("mousemove", (l) => l.preventDefault()), this.popupInstance = this.popup(o), typeof s == "function" && this.popupInstance.renderCallback(s), n = this.popupInstance.containerEventCoords(e), this.popupInstance.show(n.x + 15, n.y + 15).hideOnBlur(() => {
      this.dispatchExternal("TooltipClosed", t.getComponent()), this.popupInstance = null;
    }), this.dispatchExternal("TooltipOpened", t.getComponent()));
  }
}
sv.moduleName = "tooltip";
var Y2 = {
  //is integer
  integer: function(i, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (e = Number(e), !isNaN(e) && isFinite(e) && Math.floor(e) === e);
  },
  //is float
  float: function(i, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (e = Number(e), !isNaN(e) && isFinite(e) && e % 1 !== 0);
  },
  //must be a number
  numeric: function(i, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : !isNaN(e);
  },
  //must be a string
  string: function(i, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : isNaN(e);
  },
  //maximum value
  max: function(i, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : parseFloat(e) <= t;
  },
  //minimum value
  min: function(i, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : parseFloat(e) >= t;
  },
  //starts with  value
  starts: function(i, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).toLowerCase().startsWith(String(t).toLowerCase());
  },
  //ends with  value
  ends: function(i, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).toLowerCase().endsWith(String(t).toLowerCase());
  },
  //minimum string length
  minLength: function(i, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).length >= t;
  },
  //maximum string length
  maxLength: function(i, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).length <= t;
  },
  //in provided value list
  in: function(i, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (typeof t == "string" && (t = t.split("|")), t.indexOf(e) > -1);
  },
  //must match provided regex
  regex: function(i, e, t) {
    if (e === "" || e === null || typeof e > "u")
      return !0;
    var r = new RegExp(t);
    return r.test(e);
  },
  //value must be unique in this column
  unique: function(i, e, t) {
    if (e === "" || e === null || typeof e > "u")
      return !0;
    var r = !0, o = i.getData(), s = i.getColumn()._getSelf();
    return this.table.rowManager.rows.forEach(function(n) {
      var a = n.getData();
      a !== o && e == s.getFieldValue(a) && (r = !1);
    }), r;
  },
  //must have a value
  required: function(i, e, t) {
    return e !== "" && e !== null && typeof e < "u";
  }
};
class Cn extends ge {
  constructor(e) {
    super(e), this.invalidCells = [], this.registerTableOption("validationMode", "blocking"), this.registerColumnOption("validator"), this.registerTableFunction("getInvalidCells", this.getInvalidCells.bind(this)), this.registerTableFunction("clearCellValidation", this.userClearCellValidation.bind(this)), this.registerTableFunction("validate", this.userValidate.bind(this)), this.registerComponentFunction("cell", "isValid", this.cellIsValid.bind(this)), this.registerComponentFunction("cell", "clearValidation", this.clearValidation.bind(this)), this.registerComponentFunction("cell", "validate", this.cellValidate.bind(this)), this.registerComponentFunction("column", "validate", this.columnValidate.bind(this)), this.registerComponentFunction("row", "validate", this.rowValidate.bind(this));
  }
  initialize() {
    this.subscribe("cell-delete", this.clearValidation.bind(this)), this.subscribe("column-layout", this.initializeColumnCheck.bind(this)), this.subscribe("edit-success", this.editValidate.bind(this)), this.subscribe("edit-editor-clear", this.editorClear.bind(this)), this.subscribe("edit-edited-clear", this.editedClear.bind(this));
  }
  ///////////////////////////////////
  ///////// Event Handling //////////
  ///////////////////////////////////
  editValidate(e, t, r) {
    var o = this.table.options.validationMode !== "manual" ? this.validate(e.column.modules.validate, e, t) : !0;
    return o !== !0 && setTimeout(() => {
      e.getElement().classList.add("tabulator-validation-fail"), this.dispatchExternal("validationFailed", e.getComponent(), t, o);
    }), o;
  }
  editorClear(e, t) {
    t && e.column.modules.validate && this.cellValidate(e), e.getElement().classList.remove("tabulator-validation-fail");
  }
  editedClear(e) {
    e.modules.validate && (e.modules.validate.invalid = !1);
  }
  ///////////////////////////////////
  ////////// Cell Functions /////////
  ///////////////////////////////////
  cellIsValid(e) {
    return e.modules.validate && e.modules.validate.invalid || !0;
  }
  cellValidate(e) {
    return this.validate(e.column.modules.validate, e, e.getValue());
  }
  ///////////////////////////////////
  ///////// Column Functions ////////
  ///////////////////////////////////
  columnValidate(e) {
    var t = [];
    return e.cells.forEach((r) => {
      this.cellValidate(r) !== !0 && t.push(r.getComponent());
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ////////// Row Functions //////////
  ///////////////////////////////////
  rowValidate(e) {
    var t = [];
    return e.cells.forEach((r) => {
      this.cellValidate(r) !== !0 && t.push(r.getComponent());
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userClearCellValidation(e) {
    e || (e = this.getInvalidCells()), Array.isArray(e) || (e = [e]), e.forEach((t) => {
      this.clearValidation(t._getSelf());
    });
  }
  userValidate(e) {
    var t = [];
    return this.table.rowManager.rows.forEach((r) => {
      r = r.getComponent();
      var o = r.validate();
      o !== !0 && (t = t.concat(o));
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnCheck(e) {
    typeof e.definition.validator < "u" && this.initializeColumn(e);
  }
  //validate
  initializeColumn(e) {
    var t = this, r = [], o;
    e.definition.validator && (Array.isArray(e.definition.validator) ? e.definition.validator.forEach((s) => {
      o = t._extractValidator(s), o && r.push(o);
    }) : (o = this._extractValidator(e.definition.validator), o && r.push(o)), e.modules.validate = r.length ? r : !1);
  }
  _extractValidator(e) {
    var t, r, o;
    switch (typeof e) {
      case "string":
        return o = e.indexOf(":"), o > -1 ? (t = e.substring(0, o), r = e.substring(o + 1)) : t = e, this._buildValidator(t, r);
      case "function":
        return this._buildValidator(e);
      case "object":
        return this._buildValidator(e.type, e.parameters);
    }
  }
  _buildValidator(e, t) {
    var r = typeof e == "function" ? e : Cn.validators[e];
    return r ? {
      type: typeof e == "function" ? "function" : e,
      func: r,
      params: t
    } : (console.warn("Validator Setup Error - No matching validator found:", e), !1);
  }
  validate(e, t, r) {
    var o = this, s = [], n = this.invalidCells.indexOf(t);
    return e && e.forEach((a) => {
      a.func.call(o, t.getComponent(), r, a.params) || s.push({
        type: a.type,
        parameters: a.params
      });
    }), t.modules.validate || (t.modules.validate = {}), s.length ? (t.modules.validate.invalid = s, this.table.options.validationMode !== "manual" && t.getElement().classList.add("tabulator-validation-fail"), n == -1 && this.invalidCells.push(t)) : (t.modules.validate.invalid = !1, t.getElement().classList.remove("tabulator-validation-fail"), n > -1 && this.invalidCells.splice(n, 1)), s.length ? s : !0;
  }
  getInvalidCells() {
    var e = [];
    return this.invalidCells.forEach((t) => {
      e.push(t.getComponent());
    }), e;
  }
  clearValidation(e) {
    var t;
    e.modules.validate && e.modules.validate.invalid && (e.getElement().classList.remove("tabulator-validation-fail"), e.modules.validate.invalid = !1, t = this.invalidCells.indexOf(e), t > -1 && this.invalidCells.splice(t, 1));
  }
}
Cn.moduleName = "validate";
Cn.validators = Y2;
var B2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AccessorModule: os,
  AjaxModule: xi,
  ClipboardModule: Ao,
  ColumnCalcsModule: Tr,
  DataTreeModule: xO,
  DownloadModule: ss,
  EditModule: Sn,
  ExportModule: UO,
  FilterModule: Ji,
  FormatModule: ri,
  FrozenColumnsModule: QO,
  FrozenRowsModule: kO,
  GroupRowsModule: $O,
  HistoryModule: Co,
  HtmlTableImportModule: GO,
  ImportModule: Rn,
  InteractionModule: VO,
  KeybindingsModule: Rr,
  MenuModule: ov,
  MoveColumnsModule: HO,
  MoveRowsModule: sl,
  MutatorModule: ns,
  PageModule: An,
  PersistenceModule: Mt,
  PopupModule: XO,
  PrintModule: YO,
  ReactiveDataModule: BO,
  ResizeColumnsModule: FO,
  ResizeRowsModule: WO,
  ResizeTableModule: zO,
  ResponsiveLayoutModule: ZO,
  SelectRowModule: qO,
  SortModule: lo,
  TooltipModule: sv,
  ValidateModule: Cn
}), F2 = {
  debugEventsExternal: !1,
  //flag to console log events
  debugEventsInternal: !1,
  //flag to console log events
  debugInvalidOptions: !0,
  //allow toggling of invalid option warnings
  debugInvalidComponentFuncs: !0,
  //allow toggling of invalid component warnings
  debugInitialization: !0,
  //allow toggling of pre initialization function call warnings
  debugDeprecation: !0,
  //allow toggling of deprecation warnings
  height: !1,
  //height of tabulator
  minHeight: !1,
  //minimum height of tabulator
  maxHeight: !1,
  //maximum height of tabulator
  columnHeaderVertAlign: "top",
  //vertical alignment of column headers
  popupContainer: !1,
  columns: [],
  //store for colum header info
  columnDefaults: {},
  //store column default props
  data: !1,
  //default starting data
  autoColumns: !1,
  //build columns from data row structure
  autoColumnsDefinitions: !1,
  nestedFieldSeparator: ".",
  //separator for nested data
  footerElement: !1,
  //hold footer element
  index: "id",
  //filed for row index
  textDirection: "auto",
  addRowPos: "bottom",
  //position to insert blank rows, top|bottom
  headerVisible: !0,
  //hide header
  renderVertical: "virtual",
  renderHorizontal: "basic",
  renderVerticalBuffer: 0,
  // set virtual DOM buffer size
  scrollToRowPosition: "top",
  scrollToRowIfVisible: !0,
  scrollToColumnPosition: "left",
  scrollToColumnIfVisible: !0,
  rowFormatter: !1,
  rowFormatterPrint: null,
  rowFormatterClipboard: null,
  rowFormatterHtmlOutput: null,
  rowHeight: null,
  placeholder: !1,
  dataLoader: !0,
  dataLoaderLoading: !1,
  dataLoaderError: !1,
  dataLoaderErrorTimeout: 3e3,
  dataSendParams: {},
  dataReceiveParams: {}
};
class nv {
  constructor(e, t, r = {}) {
    this.table = e, this.msgType = t, this.registeredDefaults = Object.assign({}, r);
  }
  register(e, t) {
    this.registeredDefaults[e] = t;
  }
  generate(e, t = {}) {
    var r = Object.assign({}, this.registeredDefaults), o = this.table.options.debugInvalidOptions || t.debugInvalidOptions === !0;
    Object.assign(r, e);
    for (let s in t)
      r.hasOwnProperty(s) || (o && console.warn("Invalid " + this.msgType + " option:", s), r[s] = t.key);
    for (let s in r)
      s in t ? r[s] = t[s] : Array.isArray(r[s]) ? r[s] = Object.assign([], r[s]) : typeof r[s] == "object" && r[s] !== null ? r[s] = Object.assign({}, r[s]) : typeof r[s] > "u" && delete r[s];
    return r;
  }
}
class rc extends Zt {
  constructor(e) {
    super(e), this.elementVertical = e.rowManager.element, this.elementHorizontal = e.columnManager.element, this.tableElement = e.rowManager.tableElement, this.verticalFillMode = "fit";
  }
  ///////////////////////////////////
  /////// Internal Bindings /////////
  ///////////////////////////////////
  initialize() {
  }
  clearRows() {
  }
  clearColumns() {
  }
  reinitializeColumnWidths(e) {
  }
  renderRows() {
  }
  renderColumns() {
  }
  rerenderRows(e) {
    e && e();
  }
  rerenderColumns(e, t) {
  }
  renderRowCells(e) {
  }
  rerenderRowCells(e, t) {
  }
  scrollColumns(e, t) {
  }
  scrollRows(e, t) {
  }
  resize() {
  }
  scrollToRow(e) {
  }
  scrollToRowNearestTop(e) {
  }
  visibleRows(e) {
    return [];
  }
  ///////////////////////////////////
  //////// Helper Functions /////////
  ///////////////////////////////////
  rows() {
    return this.table.rowManager.getDisplayRows();
  }
  styleRow(e, t) {
    var r = e.getElement();
    t % 2 ? (r.classList.add("tabulator-row-even"), r.classList.remove("tabulator-row-odd")) : (r.classList.add("tabulator-row-odd"), r.classList.remove("tabulator-row-even"));
  }
  ///////////////////////////////////
  /////// External Triggers /////////
  /////// (DO NOT OVERRIDE) /////////
  ///////////////////////////////////
  clear() {
    this.clearRows(), this.clearColumns();
  }
  render() {
    this.renderRows(), this.renderColumns();
  }
  rerender(e) {
    this.rerenderRows(), this.rerenderColumns();
  }
  scrollToRowPosition(e, t, r) {
    var o = this.rows().indexOf(e), s = e.getElement(), n = 0;
    return new Promise((a, l) => {
      if (o > -1) {
        if (typeof r > "u" && (r = this.table.options.scrollToRowIfVisible), !r && Ge.elVisible(s) && (n = Ge.elOffset(s).top - Ge.elOffset(this.elementVertical).top, n > 0 && n < this.elementVertical.clientHeight - s.offsetHeight))
          return a(), !1;
        switch (typeof t > "u" && (t = this.table.options.scrollToRowPosition), t === "nearest" && (t = this.scrollToRowNearestTop(e) ? "top" : "bottom"), this.scrollToRow(e), t) {
          case "middle":
          case "center":
            this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight ? this.elementVertical.scrollTop = this.elementVertical.scrollTop + (s.offsetTop - this.elementVertical.scrollTop) - (this.elementVertical.scrollHeight - s.offsetTop) / 2 : this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight / 2;
            break;
          case "bottom":
            this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight ? this.elementVertical.scrollTop = this.elementVertical.scrollTop - (this.elementVertical.scrollHeight - s.offsetTop) + s.offsetHeight : this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight + s.offsetHeight;
            break;
          case "top":
            this.elementVertical.scrollTop = s.offsetTop;
            break;
        }
        a();
      } else
        console.warn("Scroll Error - Row not visible"), l("Scroll Error - Row not visible");
    });
  }
}
class W2 extends rc {
  constructor(e) {
    super(e);
  }
  renderRowCells(e) {
    const t = document.createDocumentFragment();
    e.cells.forEach((r) => {
      t.appendChild(r.getElement());
    }), e.element.appendChild(t), e.cells.forEach((r) => {
      r.cellRendered();
    });
  }
  reinitializeColumnWidths(e) {
    e.forEach(function(t) {
      t.reinitializeWidth();
    });
  }
}
class z2 extends rc {
  constructor(e) {
    super(e), this.leftCol = 0, this.rightCol = 0, this.scrollLeft = 0, this.vDomScrollPosLeft = 0, this.vDomScrollPosRight = 0, this.vDomPadLeft = 0, this.vDomPadRight = 0, this.fitDataColAvg = 0, this.windowBuffer = 200, this.visibleRows = null, this.initialized = !1, this.isFitData = !1, this.columns = [];
  }
  initialize() {
    this.compatibilityCheck(), this.layoutCheck(), this.vertScrollListen();
  }
  compatibilityCheck() {
    this.options("layout") == "fitDataTable" && console.warn("Horizontal Virtual DOM is not compatible with fitDataTable layout mode"), this.options("responsiveLayout") && console.warn("Horizontal Virtual DOM is not compatible with responsive columns"), this.options("rtl") && console.warn("Horizontal Virtual DOM is not currently compatible with RTL text direction");
  }
  layoutCheck() {
    this.isFitData = this.options("layout").startsWith("fitData");
  }
  vertScrollListen() {
    this.subscribe("scroll-vertical", this.clearVisRowCache.bind(this)), this.subscribe("data-refreshed", this.clearVisRowCache.bind(this));
  }
  clearVisRowCache() {
    this.visibleRows = null;
  }
  //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////
  renderColumns(e, t) {
    this.dataChange();
  }
  scrollColumns(e, t) {
    this.scrollLeft != e && (this.scrollLeft = e, this.scroll(e - (this.vDomScrollPosLeft + this.windowBuffer)));
  }
  calcWindowBuffer() {
    var e = this.elementVertical.clientWidth;
    this.table.columnManager.columnsByIndex.forEach((t) => {
      if (t.visible) {
        var r = t.getWidth();
        r > e && (e = r);
      }
    }), this.windowBuffer = e * 2;
  }
  rerenderColumns(e, t) {
    var r = {
      cols: this.columns,
      leftCol: this.leftCol,
      rightCol: this.rightCol
    }, o = 0;
    e && !this.initialized || (this.clear(), this.calcWindowBuffer(), this.scrollLeft = this.elementVertical.scrollLeft, this.vDomScrollPosLeft = this.scrollLeft - this.windowBuffer, this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer, this.table.columnManager.columnsByIndex.forEach((s) => {
      var n = {}, a;
      s.visible && (s.modules.frozen || (a = s.getWidth(), n.leftPos = o, n.rightPos = o + a, n.width = a, this.isFitData && (n.fitDataCheck = s.modules.vdomHoz ? s.modules.vdomHoz.fitDataCheck : !0), o + a > this.vDomScrollPosLeft && o < this.vDomScrollPosRight ? (this.leftCol == -1 && (this.leftCol = this.columns.length, this.vDomPadLeft = o), this.rightCol = this.columns.length) : this.leftCol !== -1 && (this.vDomPadRight += a), this.columns.push(s), s.modules.vdomHoz = n, o += a));
    }), this.tableElement.style.paddingLeft = this.vDomPadLeft + "px", this.tableElement.style.paddingRight = this.vDomPadRight + "px", this.initialized = !0, t || (!e || this.reinitChanged(r)) && this.reinitializeRows(), this.elementVertical.scrollLeft = this.scrollLeft);
  }
  renderRowCells(e) {
    if (this.initialized)
      this.initializeRow(e);
    else {
      const t = document.createDocumentFragment();
      e.cells.forEach((r) => {
        t.appendChild(r.getElement());
      }), e.element.appendChild(t), e.cells.forEach((r) => {
        r.cellRendered();
      });
    }
  }
  rerenderRowCells(e, t) {
    this.reinitializeRow(e, t);
  }
  reinitializeColumnWidths(e) {
    for (let t = this.leftCol; t <= this.rightCol; t++)
      this.columns[t].reinitializeWidth();
  }
  //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////
  deinitialize() {
    this.initialized = !1;
  }
  clear() {
    this.columns = [], this.leftCol = -1, this.rightCol = 0, this.vDomScrollPosLeft = 0, this.vDomScrollPosRight = 0, this.vDomPadLeft = 0, this.vDomPadRight = 0;
  }
  dataChange() {
    var e = !1, t, r;
    if (this.isFitData) {
      if (this.table.columnManager.columnsByIndex.forEach((o) => {
        !o.definition.width && o.visible && (e = !0);
      }), e && this.table.rowManager.getDisplayRows().length && (this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer, t = this.chain("rows-sample", [1], [], () => this.table.rowManager.getDisplayRows())[0], t)) {
        r = t.getElement(), t.generateCells(), this.tableElement.appendChild(r);
        for (let o = 0; o < t.cells.length; o++) {
          let s = t.cells[o];
          r.appendChild(s.getElement()), s.column.reinitializeWidth();
        }
        r.parentNode.removeChild(r), this.rerenderColumns(!1, !0);
      }
    } else
      this.options("layout") === "fitColumns" && (this.layoutRefresh(), this.rerenderColumns(!1, !0));
  }
  reinitChanged(e) {
    var t = !0;
    return e.cols.length !== this.columns.length || e.leftCol !== this.leftCol || e.rightCol !== this.rightCol ? !0 : (e.cols.forEach((r, o) => {
      r !== this.columns[o] && (t = !1);
    }), !t);
  }
  reinitializeRows() {
    var e = this.getVisibleRows(), t = this.table.rowManager.getRows().filter((r) => !e.includes(r));
    e.forEach((r) => {
      this.reinitializeRow(r, !0);
    }), t.forEach((r) => {
      r.deinitialize();
    });
  }
  getVisibleRows() {
    return this.visibleRows || (this.visibleRows = this.table.rowManager.getVisibleRows()), this.visibleRows;
  }
  scroll(e) {
    this.vDomScrollPosLeft += e, this.vDomScrollPosRight += e, Math.abs(e) > this.windowBuffer / 2 ? this.rerenderColumns() : e > 0 ? (this.addColRight(), this.removeColLeft()) : (this.addColLeft(), this.removeColRight());
  }
  colPositionAdjust(e, t, r) {
    for (let o = e; o < t; o++) {
      let s = this.columns[o];
      s.modules.vdomHoz.leftPos += r, s.modules.vdomHoz.rightPos += r;
    }
  }
  addColRight() {
    for (var e = !1, t = !0; t; ) {
      let r = this.columns[this.rightCol + 1];
      r && r.modules.vdomHoz.leftPos <= this.vDomScrollPosRight ? (e = !0, this.getVisibleRows().forEach((o) => {
        if (o.type !== "group") {
          var s = o.getCell(r);
          o.getElement().insertBefore(s.getElement(), o.getCell(this.columns[this.rightCol]).getElement().nextSibling), s.cellRendered();
        }
      }), this.fitDataColActualWidthCheck(r), this.rightCol++, this.getVisibleRows().forEach((o) => {
        o.type !== "group" && (o.modules.vdomHoz.rightCol = this.rightCol);
      }), this.rightCol >= this.columns.length - 1 ? this.vDomPadRight = 0 : this.vDomPadRight -= r.getWidth()) : t = !1;
    }
    e && (this.tableElement.style.paddingRight = this.vDomPadRight + "px");
  }
  addColLeft() {
    for (var e = !1, t = !0; t; ) {
      let r = this.columns[this.leftCol - 1];
      if (r)
        if (r.modules.vdomHoz.rightPos >= this.vDomScrollPosLeft) {
          e = !0, this.getVisibleRows().forEach((s) => {
            if (s.type !== "group") {
              var n = s.getCell(r);
              s.getElement().insertBefore(n.getElement(), s.getCell(this.columns[this.leftCol]).getElement()), n.cellRendered();
            }
          }), this.leftCol--, this.getVisibleRows().forEach((s) => {
            s.type !== "group" && (s.modules.vdomHoz.leftCol = this.leftCol);
          }), this.leftCol <= 0 ? this.vDomPadLeft = 0 : this.vDomPadLeft -= r.getWidth();
          let o = this.fitDataColActualWidthCheck(r);
          o && (this.scrollLeft = this.elementVertical.scrollLeft = this.elementVertical.scrollLeft + o, this.vDomPadRight -= o);
        } else
          t = !1;
      else
        t = !1;
    }
    e && (this.tableElement.style.paddingLeft = this.vDomPadLeft + "px");
  }
  removeColRight() {
    for (var e = !1, t = !0; t; ) {
      let r = this.columns[this.rightCol];
      r && r.modules.vdomHoz.leftPos > this.vDomScrollPosRight ? (e = !0, this.getVisibleRows().forEach((o) => {
        if (o.type !== "group") {
          var s = o.getCell(r);
          try {
            o.getElement().removeChild(s.getElement());
          } catch (n) {
            console.warn("Could not removeColRight", n.message);
          }
        }
      }), this.vDomPadRight += r.getWidth(), this.rightCol--, this.getVisibleRows().forEach((o) => {
        o.type !== "group" && (o.modules.vdomHoz.rightCol = this.rightCol);
      })) : t = !1;
    }
    e && (this.tableElement.style.paddingRight = this.vDomPadRight + "px");
  }
  removeColLeft() {
    for (var e = !1, t = !0; t; ) {
      let r = this.columns[this.leftCol];
      r && r.modules.vdomHoz.rightPos < this.vDomScrollPosLeft ? (e = !0, this.getVisibleRows().forEach((o) => {
        if (o.type !== "group") {
          var s = o.getCell(r);
          try {
            o.getElement().removeChild(s.getElement());
          } catch (n) {
            console.warn("Could not removeColLeft", n.message);
          }
        }
      }), this.vDomPadLeft += r.getWidth(), this.leftCol++, this.getVisibleRows().forEach((o) => {
        o.type !== "group" && (o.modules.vdomHoz.leftCol = this.leftCol);
      })) : t = !1;
    }
    e && (this.tableElement.style.paddingLeft = this.vDomPadLeft + "px");
  }
  fitDataColActualWidthCheck(e) {
    var t, r;
    return e.modules.vdomHoz.fitDataCheck && (e.reinitializeWidth(), t = e.getWidth(), r = t - e.modules.vdomHoz.width, r && (e.modules.vdomHoz.rightPos += r, e.modules.vdomHoz.width = t, this.colPositionAdjust(this.columns.indexOf(e) + 1, this.columns.length, r)), e.modules.vdomHoz.fitDataCheck = !1), r;
  }
  initializeRow(e) {
    if (e.type !== "group") {
      e.modules.vdomHoz = {
        leftCol: this.leftCol,
        rightCol: this.rightCol
      }, this.table.modules.frozenColumns && this.table.modules.frozenColumns.leftColumns.forEach((t) => {
        this.appendCell(e, t);
      });
      for (let t = this.leftCol; t <= this.rightCol; t++)
        this.appendCell(e, this.columns[t]);
      this.table.modules.frozenColumns && this.table.modules.frozenColumns.rightColumns.forEach((t) => {
        this.appendCell(e, t);
      });
    }
  }
  appendCell(e, t) {
    if (t && t.visible) {
      let r = e.getCell(t);
      e.getElement().appendChild(r.getElement()), r.cellRendered();
    }
  }
  reinitializeRow(e, t) {
    if (e.type !== "group" && (t || !e.modules.vdomHoz || e.modules.vdomHoz.leftCol !== this.leftCol || e.modules.vdomHoz.rightCol !== this.rightCol)) {
      for (var r = e.getElement(); r.firstChild; )
        r.removeChild(r.firstChild);
      this.initializeRow(e);
    }
  }
}
class Z2 extends Zt {
  constructor(e) {
    super(e), this.blockHozScrollEvent = !1, this.headersElement = null, this.contentsElement = null, this.element = null, this.columns = [], this.columnsByIndex = [], this.columnsByField = {}, this.scrollLeft = 0, this.optionsList = new nv(this.table, "column definition", rv), this.redrawBlock = !1, this.redrawBlockUpdate = null, this.renderer = null;
  }
  ////////////// Setup Functions /////////////////
  initialize() {
    this.initializeRenderer(), this.headersElement = this.createHeadersElement(), this.contentsElement = this.createHeaderContentsElement(), this.element = this.createHeaderElement(), this.contentsElement.insertBefore(this.headersElement, this.contentsElement.firstChild), this.element.insertBefore(this.contentsElement, this.element.firstChild), this.initializeScrollWheelWatcher(), this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this)), this.subscribe("scrollbar-vertical", this.padVerticalScrollbar.bind(this));
  }
  padVerticalScrollbar(e) {
    this.table.rtl ? this.headersElement.style.marginLeft = e + "px" : this.headersElement.style.marginRight = e + "px";
  }
  initializeRenderer() {
    var e, t = {
      virtual: z2,
      basic: W2
    };
    typeof this.table.options.renderHorizontal == "string" ? e = t[this.table.options.renderHorizontal] : e = this.table.options.renderHorizontal, e ? (this.renderer = new e(this.table, this.element, this.tableElement), this.renderer.initialize()) : console.error("Unable to find matching renderer:", this.table.options.renderHorizontal);
  }
  createHeadersElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-headers"), e.setAttribute("role", "row"), e;
  }
  createHeaderContentsElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-header-contents"), e.setAttribute("role", "rowgroup"), e;
  }
  createHeaderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-header"), e.setAttribute("role", "rowgroup"), this.table.options.headerVisible || e.classList.add("tabulator-header-hidden"), e;
  }
  //return containing element
  getElement() {
    return this.element;
  }
  //return containing contents element
  getContentsElement() {
    return this.contentsElement;
  }
  //return header containing element
  getHeadersElement() {
    return this.headersElement;
  }
  //scroll horizontally to match table body
  scrollHorizontal(e) {
    this.contentsElement.scrollLeft = e, this.scrollLeft = e, this.renderer.scrollColumns(e);
  }
  initializeScrollWheelWatcher() {
    this.contentsElement.addEventListener("wheel", (e) => {
      var t;
      e.deltaX && (t = this.contentsElement.scrollLeft + e.deltaX, this.table.rowManager.scrollHorizontal(t), this.table.columnManager.scrollHorizontal(t));
    });
  }
  ///////////// Column Setup Functions /////////////
  generateColumnsFromRowData(e) {
    var t = [], r = this.table.options.autoColumnsDefinitions, o, s;
    if (e && e.length) {
      o = e[0];
      for (var n in o) {
        let a = {
          field: n,
          title: n
        }, l = o[n];
        switch (typeof l) {
          case "undefined":
            s = "string";
            break;
          case "boolean":
            s = "boolean";
            break;
          case "object":
            Array.isArray(l) ? s = "array" : s = "string";
            break;
          default:
            !isNaN(l) && l !== "" ? s = "number" : l.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i) ? s = "alphanum" : s = "string";
            break;
        }
        a.sorter = s, t.push(a);
      }
      if (r)
        switch (typeof r) {
          case "function":
            this.table.options.columns = r.call(this.table, t);
            break;
          case "object":
            Array.isArray(r) ? t.forEach((a) => {
              var l = r.find((u) => u.field === a.field);
              l && Object.assign(a, l);
            }) : t.forEach((a) => {
              r[a.field] && Object.assign(a, r[a.field]);
            }), this.table.options.columns = t;
            break;
        }
      else
        this.table.options.columns = t;
      this.setColumns(this.table.options.columns);
    }
  }
  setColumns(e, t) {
    for (; this.headersElement.firstChild; )
      this.headersElement.removeChild(this.headersElement.firstChild);
    this.columns = [], this.columnsByIndex = [], this.columnsByField = {}, this.dispatch("columns-loading"), e.forEach((r, o) => {
      this._addColumn(r);
    }), this._reIndexColumns(), this.dispatch("columns-loaded"), this.rerenderColumns(!1, !0), this.redraw(!0);
  }
  _addColumn(e, t, r) {
    var o = new lr(e, this), s = o.getElement(), n = r && this.findColumnIndex(r);
    if (r && n > -1) {
      var a = r.getTopColumn(), l = this.columns.indexOf(a), u = a.getElement();
      t ? (this.columns.splice(l, 0, o), u.parentNode.insertBefore(s, u)) : (this.columns.splice(l + 1, 0, o), u.parentNode.insertBefore(s, u.nextSibling));
    } else
      t ? (this.columns.unshift(o), this.headersElement.insertBefore(o.getElement(), this.headersElement.firstChild)) : (this.columns.push(o), this.headersElement.appendChild(o.getElement()));
    return o.columnRendered(), o;
  }
  registerColumnField(e) {
    e.definition.field && (this.columnsByField[e.definition.field] = e);
  }
  registerColumnPosition(e) {
    this.columnsByIndex.push(e);
  }
  _reIndexColumns() {
    this.columnsByIndex = [], this.columns.forEach(function(e) {
      e.reRegisterPosition();
    });
  }
  //ensure column headers take up the correct amount of space in column groups
  verticalAlignHeaders() {
    var e = 0;
    this.redrawBlock || (this.headersElement.style.height = "", this.columns.forEach((t) => {
      t.clearVerticalAlign();
    }), this.columns.forEach((t) => {
      var r = t.getHeight();
      r > e && (e = r);
    }), this.headersElement.style.height = e + "px", this.columns.forEach((t) => {
      t.verticalAlign(this.table.options.columnHeaderVertAlign, e);
    }), this.table.rowManager.adjustTableSize());
  }
  //////////////// Column Details /////////////////
  findColumn(e) {
    var t;
    if (typeof e == "object") {
      if (e instanceof lr)
        return e;
      if (e instanceof iv)
        return e._getSelf() || !1;
      if (typeof HTMLElement < "u" && e instanceof HTMLElement)
        return t = [], this.columns.forEach((o) => {
          t.push(o), t = t.concat(o.getColumns(!0));
        }), t.find((o) => o.element === e) || !1;
    } else
      return this.columnsByField[e] || !1;
    return !1;
  }
  getColumnByField(e) {
    return this.columnsByField[e];
  }
  getColumnsByFieldRoot(e) {
    var t = [];
    return Object.keys(this.columnsByField).forEach((r) => {
      var o = r.split(".")[0];
      o === e && t.push(this.columnsByField[r]);
    }), t;
  }
  getColumnByIndex(e) {
    return this.columnsByIndex[e];
  }
  getFirstVisibleColumn() {
    var e = this.columnsByIndex.findIndex((t) => t.visible);
    return e > -1 ? this.columnsByIndex[e] : !1;
  }
  getColumns() {
    return this.columns;
  }
  findColumnIndex(e) {
    return this.columnsByIndex.findIndex((t) => e === t);
  }
  //return all columns that are not groups
  getRealColumns() {
    return this.columnsByIndex;
  }
  //traverse across columns and call action
  traverse(e) {
    this.columnsByIndex.forEach((t, r) => {
      e(t, r);
    });
  }
  //get definitions of actual columns
  getDefinitions(e) {
    var t = [];
    return this.columnsByIndex.forEach((r) => {
      (!e || e && r.visible) && t.push(r.getDefinition());
    }), t;
  }
  //get full nested definition tree
  getDefinitionTree() {
    var e = [];
    return this.columns.forEach((t) => {
      e.push(t.getDefinition(!0));
    }), e;
  }
  getComponents(e) {
    var t = [], r = e ? this.columns : this.columnsByIndex;
    return r.forEach((o) => {
      t.push(o.getComponent());
    }), t;
  }
  getWidth() {
    var e = 0;
    return this.columnsByIndex.forEach((t) => {
      t.visible && (e += t.getWidth());
    }), e;
  }
  moveColumn(e, t, r) {
    t.element.parentNode.insertBefore(e.element, t.element), r && t.element.parentNode.insertBefore(t.element, e.element), this.moveColumnActual(e, t, r), this.verticalAlignHeaders(), this.table.rowManager.reinitialize();
  }
  moveColumnActual(e, t, r) {
    e.parent.isGroup ? this._moveColumnInArray(e.parent.columns, e, t, r) : this._moveColumnInArray(this.columns, e, t, r), this._moveColumnInArray(this.columnsByIndex, e, t, r, !0), this.rerenderColumns(!0), this.dispatch("column-moved", e, t, r), this.subscribedExternal("columnMoved") && this.dispatchExternal("columnMoved", e.getComponent(), this.table.columnManager.getComponents());
  }
  _moveColumnInArray(e, t, r, o, s) {
    var n = e.indexOf(t), a, l = [];
    n > -1 && (e.splice(n, 1), a = e.indexOf(r), a > -1 ? o && (a = a + 1) : a = n, e.splice(a, 0, t), s && (l = this.chain("column-moving-rows", [t, r, o], null, []) || [], l = l.concat(this.table.rowManager.rows), l.forEach(function(u) {
      if (u.cells.length) {
        var h = u.cells.splice(n, 1)[0];
        u.cells.splice(a, 0, h);
      }
    })));
  }
  scrollToColumn(e, t, r) {
    var o = 0, s = e.getLeftOffset(), n = 0, a = e.getElement();
    return new Promise((l, u) => {
      if (typeof t > "u" && (t = this.table.options.scrollToColumnPosition), typeof r > "u" && (r = this.table.options.scrollToColumnIfVisible), e.visible) {
        switch (t) {
          case "middle":
          case "center":
            n = -this.element.clientWidth / 2;
            break;
          case "right":
            n = a.clientWidth - this.headersElement.clientWidth;
            break;
        }
        if (!r && s > 0 && s + a.offsetWidth < this.element.clientWidth)
          return !1;
        o = s + n, o = Math.max(Math.min(o, this.table.rowManager.element.scrollWidth - this.table.rowManager.element.clientWidth), 0), this.table.rowManager.scrollHorizontal(o), this.scrollHorizontal(o), l();
      } else
        console.warn("Scroll Error - Column not visible"), u("Scroll Error - Column not visible");
    });
  }
  //////////////// Cell Management /////////////////
  generateCells(e) {
    var t = [];
    return this.columnsByIndex.forEach((r) => {
      t.push(r.generateCell(e));
    }), t;
  }
  //////////////// Column Management /////////////////
  getFlexBaseWidth() {
    var e = this.table.element.clientWidth, t = 0;
    return this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight && (e -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth), this.columnsByIndex.forEach(function(r) {
      var o, s, n;
      r.visible && (o = r.definition.width || 0, s = parseInt(r.minWidth), typeof o == "string" ? o.indexOf("%") > -1 ? n = e / 100 * parseInt(o) : n = parseInt(o) : n = o, t += n > s ? n : s);
    }), t;
  }
  addColumn(e, t, r) {
    return new Promise((o, s) => {
      var n = this._addColumn(e, t, r);
      this._reIndexColumns(), this.dispatch("column-add", e, t, r), this.layoutMode() != "fitColumns" && n.reinitializeWidth(), this.redraw(!0), this.table.rowManager.reinitialize(), this.rerenderColumns(), o(n);
    });
  }
  //remove column from system
  deregisterColumn(e) {
    var t = e.getField(), r;
    t && delete this.columnsByField[t], r = this.columnsByIndex.indexOf(e), r > -1 && this.columnsByIndex.splice(r, 1), r = this.columns.indexOf(e), r > -1 && this.columns.splice(r, 1), this.verticalAlignHeaders(), this.redraw();
  }
  rerenderColumns(e, t) {
    this.redrawBlock ? (e === !1 || e === !0 && this.redrawBlockUpdate === null) && (this.redrawBlockUpdate = e) : this.renderer.rerenderColumns(e, t);
  }
  blockRedraw() {
    this.redrawBlock = !0, this.redrawBlockUpdate = null;
  }
  restoreRedraw() {
    this.redrawBlock = !1, this.verticalAlignHeaders(), this.renderer.rerenderColumns(this.redrawBlockUpdate);
  }
  //redraw columns
  redraw(e) {
    Ge.elVisible(this.element) && this.verticalAlignHeaders(), e && (this.table.rowManager.resetScroll(), this.table.rowManager.reinitialize()), this.confirm("table-redrawing", e) || this.layoutRefresh(e), this.dispatch("table-redraw", e), this.table.footerManager.redraw();
  }
}
class q2 extends rc {
  constructor(e) {
    super(e), this.verticalFillMode = "fill", this.scrollTop = 0, this.scrollLeft = 0, this.scrollTop = 0, this.scrollLeft = 0;
  }
  clearRows() {
    for (var e = this.tableElement; e.firstChild; )
      e.removeChild(e.firstChild);
    e.scrollTop = 0, e.scrollLeft = 0, e.style.minWidth = "", e.style.minHeight = "", e.style.display = "", e.style.visibility = "";
  }
  renderRows() {
    var e = this.tableElement, t = !0, r = document.createDocumentFragment();
    this.rows().forEach((o, s) => {
      this.styleRow(o, s), o.initialize(!0), o.type !== "group" && (t = !1), r.appendChild(o.getElement());
    }), e.appendChild(r), t ? e.style.minWidth = this.table.columnManager.getWidth() + "px" : e.style.minWidth = "";
  }
  rerenderRows(e) {
    this.clearRows(), e && e(), this.renderRows();
  }
  scrollToRowNearestTop(e) {
    var t = Ge.elOffset(e.getElement()).top;
    return !(Math.abs(this.elementVertical.scrollTop - t) > Math.abs(this.elementVertical.scrollTop + this.elementVertical.clientHeight - t));
  }
  scrollToRow(e) {
    var t = e.getElement();
    this.elementVertical.scrollTop = Ge.elOffset(t).top - Ge.elOffset(this.elementVertical).top + this.elementVertical.scrollTop;
  }
  visibleRows(e) {
    return this.rows();
  }
}
class j2 extends rc {
  constructor(e) {
    super(e), this.verticalFillMode = "fill", this.scrollTop = 0, this.scrollLeft = 0, this.vDomRowHeight = 20, this.vDomTop = 0, this.vDomBottom = 0, this.vDomScrollPosTop = 0, this.vDomScrollPosBottom = 0, this.vDomTopPad = 0, this.vDomBottomPad = 0, this.vDomMaxRenderChain = 90, this.vDomWindowBuffer = 0, this.vDomWindowMinTotalRows = 20, this.vDomWindowMinMarginRows = 5, this.vDomTopNewRows = [], this.vDomBottomNewRows = [];
  }
  //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////
  clearRows() {
    for (var e = this.tableElement; e.firstChild; )
      e.removeChild(e.firstChild);
    e.style.paddingTop = "", e.style.paddingBottom = "", e.style.minHeight = "", e.style.display = "", e.style.visibility = "", this.elementVertical.scrollTop = 0, this.elementVertical.scrollLeft = 0, this.scrollTop = 0, this.scrollLeft = 0, this.vDomTop = 0, this.vDomBottom = 0, this.vDomTopPad = 0, this.vDomBottomPad = 0, this.vDomScrollPosTop = 0, this.vDomScrollPosBottom = 0;
  }
  renderRows() {
    this._virtualRenderFill();
  }
  rerenderRows(e) {
    for (var t = this.elementVertical.scrollTop, r = !1, o = !1, s = this.table.rowManager.scrollLeft, n = this.rows(), a = this.vDomTop; a <= this.vDomBottom; a++)
      if (n[a]) {
        var l = t - n[a].getElement().offsetTop;
        if (o === !1 || Math.abs(l) < o)
          o = l, r = a;
        else
          break;
      }
    n.forEach((u) => {
      u.deinitializeHeight();
    }), e && e(), this.rows().length ? this._virtualRenderFill(r === !1 ? this.rows.length - 1 : r, !0, o || 0) : (this.clear(), this.table.rowManager.tableEmpty()), this.scrollColumns(s);
  }
  scrollColumns(e) {
    this.table.rowManager.scrollHorizontal(e);
  }
  scrollRows(e, t) {
    var r = e - this.vDomScrollPosTop, o = e - this.vDomScrollPosBottom, s = this.vDomWindowBuffer * 2, n = this.rows();
    if (this.scrollTop = e, -r > s || o > s) {
      var a = this.table.rowManager.scrollLeft;
      this._virtualRenderFill(Math.floor(this.elementVertical.scrollTop / this.elementVertical.scrollHeight * n.length)), this.scrollColumns(a);
    } else
      t ? (r < 0 && this._addTopRow(n, -r), o < 0 && (this.vDomScrollHeight - this.scrollTop > this.vDomWindowBuffer ? this._removeBottomRow(n, -o) : this.vDomScrollPosBottom = this.scrollTop)) : (o >= 0 && this._addBottomRow(n, o), r >= 0 && (this.scrollTop > this.vDomWindowBuffer ? this._removeTopRow(n, r) : this.vDomScrollPosTop = this.scrollTop));
  }
  resize() {
    this.vDomWindowBuffer = this.table.options.renderVerticalBuffer || this.elementVertical.clientHeight;
  }
  scrollToRowNearestTop(e) {
    var t = this.rows().indexOf(e);
    return !(Math.abs(this.vDomTop - t) > Math.abs(this.vDomBottom - t));
  }
  scrollToRow(e) {
    var t = this.rows().indexOf(e);
    t > -1 && this._virtualRenderFill(t, !0);
  }
  visibleRows(e) {
    var t = this.elementVertical.scrollTop, r = this.elementVertical.clientHeight + t, o = !1, s = 0, n = 0, a = this.rows();
    if (e)
      s = this.vDomTop, n = this.vDomBottom;
    else
      for (var l = this.vDomTop; l <= this.vDomBottom; l++)
        if (a[l])
          if (o)
            if (r - a[l].getElement().offsetTop >= 0)
              n = l;
            else
              break;
          else if (t - a[l].getElement().offsetTop >= 0)
            s = l;
          else if (o = !0, r - a[l].getElement().offsetTop >= 0)
            n = l;
          else
            break;
    return a.slice(s, n + 1);
  }
  //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////
  //full virtual render
  _virtualRenderFill(e, t, r) {
    var o = this.tableElement, s = this.elementVertical, n = 0, a = 0, l = 0, u = 0, h = 0, c = 0, d = this.rows(), f = d.length, p = 0, O, m, E = [], g = 0, A = 0, S = this.table.rowManager.fixedHeight, R = this.elementVertical.clientHeight, v = this.table.options.rowHeight, I = !0;
    if (e = e || 0, r = r || 0, !e)
      this.clear();
    else {
      for (; o.firstChild; )
        o.removeChild(o.firstChild);
      u = (f - e + 1) * this.vDomRowHeight, u < R && (e -= Math.ceil((R - u) / this.vDomRowHeight), e < 0 && (e = 0)), n = Math.min(Math.max(Math.floor(this.vDomWindowBuffer / this.vDomRowHeight), this.vDomWindowMinMarginRows), e), e -= n;
    }
    if (f && Ge.elVisible(this.elementVertical)) {
      for (this.vDomTop = e, this.vDomBottom = e - 1, S || this.table.options.maxHeight ? (v && (A = R / v + this.vDomWindowBuffer / v), A = Math.max(this.vDomWindowMinTotalRows, Math.ceil(A))) : A = f; (A == f || a <= R + this.vDomWindowBuffer || g < this.vDomWindowMinTotalRows) && this.vDomBottom < f - 1; ) {
        for (E = [], m = document.createDocumentFragment(), c = 0; c < A && this.vDomBottom < f - 1; )
          p = this.vDomBottom + 1, O = d[p], this.styleRow(O, p), O.initialize(), !O.heightInitialized && !this.table.options.rowHeight && O.clearCellHeight(), m.appendChild(O.getElement()), E.push(O), this.vDomBottom++, c++;
        if (!E.length)
          break;
        o.appendChild(m), E.forEach((C) => {
          C.heightInitialized || C.calcHeight(!0);
        }), E.forEach((C) => {
          C.heightInitialized || C.setCellHeight();
        }), E.forEach((C) => {
          l = C.getHeight(), g < n ? h += l : a += l, l > this.vDomWindowBuffer && (this.vDomWindowBuffer = l * 2), g++;
        }), I = this.table.rowManager.adjustTableSize(), R = this.elementVertical.clientHeight, I && (S || this.table.options.maxHeight) && (v = a / g, A = Math.max(this.vDomWindowMinTotalRows, Math.ceil(R / v + this.vDomWindowBuffer / v)));
      }
      e ? (this.vDomTopPad = t ? this.vDomRowHeight * this.vDomTop + r : this.scrollTop - h, this.vDomBottomPad = this.vDomBottom == f - 1 ? 0 : Math.max(this.vDomScrollHeight - this.vDomTopPad - a - h, 0)) : (this.vDomTopPad = 0, this.vDomRowHeight = Math.floor((a + h) / g), this.vDomBottomPad = this.vDomRowHeight * (f - this.vDomBottom - 1), this.vDomScrollHeight = h + a + this.vDomBottomPad - R), o.style.paddingTop = this.vDomTopPad + "px", o.style.paddingBottom = this.vDomBottomPad + "px", t && (this.scrollTop = this.vDomTopPad + h + r - (this.elementVertical.scrollWidth > this.elementVertical.clientWidth ? this.elementVertical.offsetHeight - R : 0)), this.scrollTop = Math.min(this.scrollTop, this.elementVertical.scrollHeight - R), this.elementVertical.scrollWidth > this.elementVertical.clientWidth && t && (this.scrollTop += this.elementVertical.offsetHeight - R), this.vDomScrollPosTop = this.scrollTop, this.vDomScrollPosBottom = this.scrollTop, s.scrollTop = this.scrollTop, this.dispatch("render-virtual-fill");
    }
  }
  _addTopRow(e, t) {
    for (var r = this.tableElement, o = [], s = 0, n = this.vDomTop - 1, a = 0, l = !0; l; )
      if (this.vDomTop) {
        let u = e[n], h, c;
        u && a < this.vDomMaxRenderChain ? (h = u.getHeight() || this.vDomRowHeight, c = u.initialized, t >= h ? (this.styleRow(u, n), r.insertBefore(u.getElement(), r.firstChild), (!u.initialized || !u.heightInitialized) && o.push(u), u.initialize(), c || (h = u.getElement().offsetHeight, h > this.vDomWindowBuffer && (this.vDomWindowBuffer = h * 2)), t -= h, s += h, this.vDomTop--, n--, a++) : l = !1) : l = !1;
      } else
        l = !1;
    for (let u of o)
      u.clearCellHeight();
    this._quickNormalizeRowHeight(o), s && (this.vDomTopPad -= s, this.vDomTopPad < 0 && (this.vDomTopPad = n * this.vDomRowHeight), n < 1 && (this.vDomTopPad = 0), r.style.paddingTop = this.vDomTopPad + "px", this.vDomScrollPosTop -= s);
  }
  _removeTopRow(e, t) {
    for (var r = [], o = 0, s = 0, n = !0; n; ) {
      let a = e[this.vDomTop], l;
      a && s < this.vDomMaxRenderChain ? (l = a.getHeight() || this.vDomRowHeight, t >= l ? (this.vDomTop++, t -= l, o += l, r.push(a), s++) : n = !1) : n = !1;
    }
    for (let a of r) {
      let l = a.getElement();
      l.parentNode && l.parentNode.removeChild(l);
    }
    o && (this.vDomTopPad += o, this.tableElement.style.paddingTop = this.vDomTopPad + "px", this.vDomScrollPosTop += this.vDomTop ? o : o + this.vDomWindowBuffer);
  }
  _addBottomRow(e, t) {
    for (var r = this.tableElement, o = [], s = 0, n = this.vDomBottom + 1, a = 0, l = !0; l; ) {
      let u = e[n], h, c;
      u && a < this.vDomMaxRenderChain ? (h = u.getHeight() || this.vDomRowHeight, c = u.initialized, t >= h ? (this.styleRow(u, n), r.appendChild(u.getElement()), (!u.initialized || !u.heightInitialized) && o.push(u), u.initialize(), c || (h = u.getElement().offsetHeight, h > this.vDomWindowBuffer && (this.vDomWindowBuffer = h * 2)), t -= h, s += h, this.vDomBottom++, n++, a++) : l = !1) : l = !1;
    }
    for (let u of o)
      u.clearCellHeight();
    this._quickNormalizeRowHeight(o), s && (this.vDomBottomPad -= s, (this.vDomBottomPad < 0 || n == e.length - 1) && (this.vDomBottomPad = 0), r.style.paddingBottom = this.vDomBottomPad + "px", this.vDomScrollPosBottom += s);
  }
  _removeBottomRow(e, t) {
    for (var r = [], o = 0, s = 0, n = !0; n; ) {
      let a = e[this.vDomBottom], l;
      a && s < this.vDomMaxRenderChain ? (l = a.getHeight() || this.vDomRowHeight, t >= l ? (this.vDomBottom--, t -= l, o += l, r.push(a), s++) : n = !1) : n = !1;
    }
    for (let a of r) {
      let l = a.getElement();
      l.parentNode && l.parentNode.removeChild(l);
    }
    o && (this.vDomBottomPad += o, this.vDomBottomPad < 0 && (this.vDomBottomPad = 0), this.tableElement.style.paddingBottom = this.vDomBottomPad + "px", this.vDomScrollPosBottom -= o);
  }
  _quickNormalizeRowHeight(e) {
    for (let t of e)
      t.calcHeight();
    for (let t of e)
      t.setCellHeight();
  }
}
class K2 extends Zt {
  constructor(e) {
    super(e), this.element = this.createHolderElement(), this.tableElement = this.createTableElement(), this.heightFixer = this.createTableElement(), this.placeholder = null, this.placeholderContents = null, this.firstRender = !1, this.renderMode = "virtual", this.fixedHeight = !1, this.rows = [], this.activeRowsPipeline = [], this.activeRows = [], this.activeRowsCount = 0, this.displayRows = [], this.displayRowsCount = 0, this.scrollTop = 0, this.scrollLeft = 0, this.redrawBlock = !1, this.redrawBlockRestoreConfig = !1, this.redrawBlockRenderInPosition = !1, this.dataPipeline = [], this.displayPipeline = [], this.scrollbarWidth = 0, this.renderer = null;
  }
  //////////////// Setup Functions /////////////////
  createHolderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-tableholder"), e.setAttribute("tabindex", 0), e;
  }
  createTableElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-table"), e.setAttribute("role", "rowgroup"), e;
  }
  initializePlaceholder() {
    var e = this.table.options.placeholder;
    if (typeof e == "function" && (e = e.call(this.table)), e = this.chain("placeholder", [e], e, e) || e, e) {
      let t = document.createElement("div");
      if (t.classList.add("tabulator-placeholder"), typeof e == "string") {
        let r = document.createElement("div");
        r.classList.add("tabulator-placeholder-contents"), r.innerHTML = e, t.appendChild(r), this.placeholderContents = r;
      } else
        typeof HTMLElement < "u" && e instanceof HTMLElement ? (t.appendChild(e), this.placeholderContents = e) : (console.warn("Invalid placeholder provided, must be string or HTML Element", e), this.el = null);
      this.placeholder = t;
    }
  }
  //return containing element
  getElement() {
    return this.element;
  }
  //return table element
  getTableElement() {
    return this.tableElement;
  }
  initialize() {
    this.initializePlaceholder(), this.initializeRenderer(), this.element.appendChild(this.tableElement), this.firstRender = !0, this.element.addEventListener("scroll", () => {
      var e = this.element.scrollLeft, t = this.scrollLeft > e, r = this.element.scrollTop, o = this.scrollTop > r;
      this.scrollLeft != e && (this.scrollLeft = e, this.dispatch("scroll-horizontal", e, t), this.dispatchExternal("scrollHorizontal", e, t), this._positionPlaceholder()), this.scrollTop != r && (this.scrollTop = r, this.renderer.scrollRows(r, o), this.dispatch("scroll-vertical", r, o), this.dispatchExternal("scrollVertical", r, o));
    });
  }
  ////////////////// Row Manipulation //////////////////
  findRow(e) {
    if (typeof e == "object") {
      if (e instanceof Qt)
        return e;
      if (e instanceof tc)
        return e._getSelf() || !1;
      if (typeof HTMLElement < "u" && e instanceof HTMLElement)
        return this.rows.find((r) => r.getElement() === e) || !1;
      if (e === null)
        return !1;
    } else
      return typeof e > "u" ? !1 : this.rows.find((r) => r.data[this.table.options.index] == e) || !1;
    return !1;
  }
  getRowFromDataObject(e) {
    var t = this.rows.find((r) => r.data === e);
    return t || !1;
  }
  getRowFromPosition(e) {
    return this.getDisplayRows().find((t) => t.getPosition() === e && t.isDisplayed());
  }
  scrollToRow(e, t, r) {
    return this.renderer.scrollToRowPosition(e, t, r);
  }
  ////////////////// Data Handling //////////////////
  setData(e, t, r) {
    return new Promise((o, s) => {
      t && this.getDisplayRows().length ? this.table.options.pagination ? this._setDataActual(e, !0) : this.reRenderInPosition(() => {
        this._setDataActual(e);
      }) : (this.table.options.autoColumns && r && this.table.initialized && this.table.columnManager.generateColumnsFromRowData(e), this.resetScroll(), this._setDataActual(e)), o();
    });
  }
  _setDataActual(e, t) {
    this.dispatchExternal("dataProcessing", e), this._wipeElements(), Array.isArray(e) ? (this.dispatch("data-processing", e), e.forEach((r, o) => {
      if (r && typeof r == "object") {
        var s = new Qt(r, this);
        this.rows.push(s);
      } else
        console.warn("Data Loading Warning - Invalid row data detected and ignored, expecting object but received:", r);
    }), this.refreshActiveData(!1, !1, t), this.dispatch("data-processed", e), this.dispatchExternal("dataProcessed", e)) : console.error(`Data Loading Error - Unable to process data due to invalid data type 
Expecting: array 
Received: `, typeof e, `
Data:     `, e);
  }
  _wipeElements() {
    this.dispatch("rows-wipe"), this.destroy(), this.adjustTableSize(), this.dispatch("rows-wiped");
  }
  destroy() {
    this.rows.forEach((e) => {
      e.wipe();
    }), this.rows = [], this.activeRows = [], this.activeRowsPipeline = [], this.activeRowsCount = 0, this.displayRows = [], this.displayRowsCount = 0;
  }
  deleteRow(e, t) {
    var r = this.rows.indexOf(e), o = this.activeRows.indexOf(e);
    o > -1 && this.activeRows.splice(o, 1), r > -1 && this.rows.splice(r, 1), this.setActiveRows(this.activeRows), this.displayRowIterator((s) => {
      var n = s.indexOf(e);
      n > -1 && s.splice(n, 1);
    }), t || this.reRenderInPosition(), this.regenerateRowPositions(), this.dispatchExternal("rowDeleted", e.getComponent()), this.displayRowsCount || this.tableEmpty(), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.getData());
  }
  addRow(e, t, r, o) {
    var s = this.addRowActual(e, t, r, o);
    return s;
  }
  //add multiple rows
  addRows(e, t, r, o) {
    var s = [];
    return new Promise((n, a) => {
      t = this.findAddRowPos(t), Array.isArray(e) || (e = [e]), (typeof r > "u" && t || typeof r < "u" && !t) && e.reverse(), e.forEach((l, u) => {
        var h = this.addRow(l, t, r, !0);
        s.push(h), this.dispatch("row-added", h, l, t, r);
      }), this.refreshActiveData(o ? "displayPipeline" : !1, !1, !0), this.regenerateRowPositions(), s.length && this._clearPlaceholder(), n(s);
    });
  }
  findAddRowPos(e) {
    return typeof e > "u" && (e = this.table.options.addRowPos), e === "pos" && (e = !0), e === "bottom" && (e = !1), e;
  }
  addRowActual(e, t, r, o) {
    var s = e instanceof Qt ? e : new Qt(e || {}, this), n = this.findAddRowPos(t), a = -1, l, u;
    return r || (u = this.chain("row-adding-position", [s, n], null, { index: r, top: n }), r = u.index, n = u.top), typeof r < "u" && (r = this.findRow(r)), r = this.chain("row-adding-index", [s, r, n], null, r), r && (a = this.rows.indexOf(r)), r && a > -1 ? (l = this.activeRows.indexOf(r), this.displayRowIterator(function(h) {
      var c = h.indexOf(r);
      c > -1 && h.splice(n ? c : c + 1, 0, s);
    }), l > -1 && this.activeRows.splice(n ? l : l + 1, 0, s), this.rows.splice(n ? a : a + 1, 0, s)) : n ? (this.displayRowIterator(function(h) {
      h.unshift(s);
    }), this.activeRows.unshift(s), this.rows.unshift(s)) : (this.displayRowIterator(function(h) {
      h.push(s);
    }), this.activeRows.push(s), this.rows.push(s)), this.setActiveRows(this.activeRows), this.dispatchExternal("rowAdded", s.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()), o || this.reRenderInPosition(), s;
  }
  moveRow(e, t, r) {
    this.dispatch("row-move", e, t, r), this.moveRowActual(e, t, r), this.regenerateRowPositions(), this.dispatch("row-moved", e, t, r), this.dispatchExternal("rowMoved", e.getComponent());
  }
  moveRowActual(e, t, r) {
    this.moveRowInArray(this.rows, e, t, r), this.moveRowInArray(this.activeRows, e, t, r), this.displayRowIterator((o) => {
      this.moveRowInArray(o, e, t, r);
    }), this.dispatch("row-moving", e, t, r);
  }
  moveRowInArray(e, t, r, o) {
    var s, n, a, l;
    if (t !== r && (s = e.indexOf(t), s > -1 && (e.splice(s, 1), n = e.indexOf(r), n > -1 ? o ? e.splice(n + 1, 0, t) : e.splice(n, 0, t) : e.splice(s, 0, t)), e === this.getDisplayRows())) {
      a = s < n ? s : n, l = n > s ? n : s + 1;
      for (let u = a; u <= l; u++)
        e[u] && this.styleRow(e[u], u);
    }
  }
  clearData() {
    this.setData([]);
  }
  getRowIndex(e) {
    return this.findRowIndex(e, this.rows);
  }
  getDisplayRowIndex(e) {
    var t = this.getDisplayRows().indexOf(e);
    return t > -1 ? t : !1;
  }
  nextDisplayRow(e, t) {
    var r = this.getDisplayRowIndex(e), o = !1;
    return r !== !1 && r < this.displayRowsCount - 1 && (o = this.getDisplayRows()[r + 1]), o && (!(o instanceof Qt) || o.type != "row") ? this.nextDisplayRow(o, t) : o;
  }
  prevDisplayRow(e, t) {
    var r = this.getDisplayRowIndex(e), o = !1;
    return r && (o = this.getDisplayRows()[r - 1]), t && o && (!(o instanceof Qt) || o.type != "row") ? this.prevDisplayRow(o, t) : o;
  }
  findRowIndex(e, t) {
    var r;
    return e = this.findRow(e), e && (r = t.indexOf(e), r > -1) ? r : !1;
  }
  getData(e, t) {
    var r = [], o = this.getRows(e);
    return o.forEach(function(s) {
      s.type == "row" && r.push(s.getData(t || "data"));
    }), r;
  }
  getComponents(e) {
    var t = [], r = this.getRows(e);
    return r.forEach(function(o) {
      t.push(o.getComponent());
    }), t;
  }
  getDataCount(e) {
    var t = this.getRows(e);
    return t.length;
  }
  scrollHorizontal(e) {
    this.scrollLeft = e, this.element.scrollLeft = e, this.dispatch("scroll-horizontal", e);
  }
  registerDataPipelineHandler(e, t) {
    typeof t < "u" ? (this.dataPipeline.push({ handler: e, priority: t }), this.dataPipeline.sort((r, o) => r.priority - o.priority)) : console.error("Data pipeline handlers must have a priority in order to be registered");
  }
  registerDisplayPipelineHandler(e, t) {
    typeof t < "u" ? (this.displayPipeline.push({ handler: e, priority: t }), this.displayPipeline.sort((r, o) => r.priority - o.priority)) : console.error("Display pipeline handlers must have a priority in order to be registered");
  }
  //set active data set
  refreshActiveData(e, t, r) {
    var o = this.table, s = "", n = 0, a = ["all", "dataPipeline", "display", "displayPipeline", "end"];
    if (!this.table.destroyed) {
      if (typeof e == "function")
        if (n = this.dataPipeline.findIndex((l) => l.handler === e), n > -1)
          s = "dataPipeline", t && (n == this.dataPipeline.length - 1 ? s = "display" : n++);
        else if (n = this.displayPipeline.findIndex((l) => l.handler === e), n > -1)
          s = "displayPipeline", t && (n == this.displayPipeline.length - 1 ? s = "end" : n++);
        else {
          console.error("Unable to refresh data, invalid handler provided", e);
          return;
        }
      else
        s = e || "all", n = 0;
      if (this.redrawBlock) {
        (!this.redrawBlockRestoreConfig || this.redrawBlockRestoreConfig && (this.redrawBlockRestoreConfig.stage === s && n < this.redrawBlockRestoreConfig.index || a.indexOf(s) < a.indexOf(this.redrawBlockRestoreConfig.stage))) && (this.redrawBlockRestoreConfig = {
          handler: e,
          skipStage: t,
          renderInPosition: r,
          stage: s,
          index: n
        });
        return;
      } else
        Ge.elVisible(this.element) ? r ? this.reRenderInPosition(this.refreshPipelines.bind(this, e, s, n, r)) : (this.refreshPipelines(e, s, n, r), e || this.table.columnManager.renderer.renderColumns(), this.renderTable(), o.options.layoutColumnsOnNewData && this.table.columnManager.redraw(!0)) : this.refreshPipelines(e, s, n, r), this.dispatch("data-refreshed");
    }
  }
  refreshPipelines(e, t, r, o) {
    switch (this.dispatch("data-refreshing"), e || (this.activeRowsPipeline[0] = this.rows.slice(0)), t) {
      case "all":
      case "dataPipeline":
        for (let s = r; s < this.dataPipeline.length; s++) {
          let n = this.dataPipeline[s].handler(this.activeRowsPipeline[s].slice(0));
          this.activeRowsPipeline[s + 1] = n || this.activeRowsPipeline[s].slice(0);
        }
        this.setActiveRows(this.activeRowsPipeline[this.dataPipeline.length]);
      case "display":
        r = 0, this.resetDisplayRows();
      case "displayPipeline":
        for (let s = r; s < this.displayPipeline.length; s++) {
          let n = this.displayPipeline[s].handler((s ? this.getDisplayRows(s - 1) : this.activeRows).slice(0), o);
          this.setDisplayRows(n || this.getDisplayRows(s - 1).slice(0), s);
        }
      case "end":
        this.regenerateRowPositions();
    }
    this.getDisplayRows().length && this._clearPlaceholder();
  }
  //regenerate row positions
  regenerateRowPositions() {
    var e = this.getDisplayRows(), t = 1;
    e.forEach((r) => {
      r.type === "row" && (r.setPosition(t), t++);
    });
  }
  setActiveRows(e) {
    this.activeRows = this.activeRows = Object.assign([], e), this.activeRowsCount = this.activeRows.length;
  }
  //reset display rows array
  resetDisplayRows() {
    this.displayRows = [], this.displayRows.push(this.activeRows.slice(0)), this.displayRowsCount = this.displayRows[0].length;
  }
  //set display row pipeline data
  setDisplayRows(e, t) {
    this.displayRows[t] = e, t == this.displayRows.length - 1 && (this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length);
  }
  getDisplayRows(e) {
    return typeof e > "u" ? this.displayRows.length ? this.displayRows[this.displayRows.length - 1] : [] : this.displayRows[e] || [];
  }
  getVisibleRows(e, t) {
    var r = Object.assign([], this.renderer.visibleRows(!t));
    return e && (r = this.chain("rows-visible", [t], r, r)), r;
  }
  //repeat action across display rows
  displayRowIterator(e) {
    this.activeRowsPipeline.forEach(e), this.displayRows.forEach(e), this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
  }
  //return only actual rows (not group headers etc)
  getRows(e) {
    var t = [];
    switch (e) {
      case "active":
        t = this.activeRows;
        break;
      case "display":
        t = this.table.rowManager.getDisplayRows();
        break;
      case "visible":
        t = this.getVisibleRows(!1, !0);
        break;
      default:
        t = this.chain("rows-retrieve", e, null, this.rows) || this.rows;
    }
    return t;
  }
  ///////////////// Table Rendering /////////////////
  //trigger rerender of table in current position
  reRenderInPosition(e) {
    this.redrawBlock ? e ? e() : this.redrawBlockRenderInPosition = !0 : (this.dispatchExternal("renderStarted"), this.renderer.rerenderRows(e), this.fixedHeight || this.adjustTableSize(), this.scrollBarCheck(), this.dispatchExternal("renderComplete"));
  }
  scrollBarCheck() {
    var e = 0;
    this.element.scrollHeight > this.element.clientHeight && (e = this.element.offsetWidth - this.element.clientWidth), e !== this.scrollbarWidth && (this.scrollbarWidth = e, this.dispatch("scrollbar-vertical", e));
  }
  initializeRenderer() {
    var e, t = {
      virtual: j2,
      basic: q2
    };
    typeof this.table.options.renderVertical == "string" ? e = t[this.table.options.renderVertical] : e = this.table.options.renderVertical, e ? (this.renderMode = this.table.options.renderVertical, this.renderer = new e(this.table, this.element, this.tableElement), this.renderer.initialize(), (this.table.element.clientHeight || this.table.options.height) && !(this.table.options.minHeight && this.table.options.maxHeight) ? this.fixedHeight = !0 : this.fixedHeight = !1) : console.error("Unable to find matching renderer:", this.table.options.renderVertical);
  }
  getRenderMode() {
    return this.renderMode;
  }
  renderTable() {
    this.dispatchExternal("renderStarted"), this.element.scrollTop = 0, this._clearTable(), this.displayRowsCount ? (this.renderer.renderRows(), this.firstRender && (this.firstRender = !1, this.fixedHeight || this.adjustTableSize(), this.layoutRefresh(!0))) : this.renderEmptyScroll(), this.fixedHeight || this.adjustTableSize(), this.dispatch("table-layout"), this.displayRowsCount || this._showPlaceholder(), this.scrollBarCheck(), this.dispatchExternal("renderComplete");
  }
  //show scrollbars on empty table div
  renderEmptyScroll() {
    this.placeholder ? this.tableElement.style.display = "none" : this.tableElement.style.minWidth = this.table.columnManager.getWidth() + "px";
  }
  _clearTable() {
    this._clearPlaceholder(), this.scrollTop = 0, this.scrollLeft = 0, this.renderer.clearRows();
  }
  tableEmpty() {
    this.renderEmptyScroll(), this._showPlaceholder();
  }
  _showPlaceholder() {
    this.placeholder && (this.placeholder && this.placeholder.parentNode && this.placeholder.parentNode.removeChild(this.placeholder), this.initializePlaceholder(), this.placeholder.setAttribute("tabulator-render-mode", this.renderMode), this.getElement().appendChild(this.placeholder), this._positionPlaceholder());
  }
  _clearPlaceholder() {
    this.placeholder && this.placeholder.parentNode && this.placeholder.parentNode.removeChild(this.placeholder), this.tableElement.style.minWidth = "", this.tableElement.style.display = "";
  }
  _positionPlaceholder() {
    this.placeholder && this.placeholder.parentNode && (this.placeholder.style.width = this.table.columnManager.getWidth() + "px", this.placeholderContents.style.width = this.table.rowManager.element.clientWidth + "px", this.placeholderContents.style.marginLeft = this.scrollLeft + "px");
  }
  styleRow(e, t) {
    var r = e.getElement();
    t % 2 ? (r.classList.add("tabulator-row-even"), r.classList.remove("tabulator-row-odd")) : (r.classList.add("tabulator-row-odd"), r.classList.remove("tabulator-row-even"));
  }
  //normalize height of active rows
  normalizeHeight() {
    this.activeRows.forEach(function(e) {
      e.normalizeHeight();
    });
  }
  //adjust the height of the table holder to fit in the Tabulator element
  adjustTableSize() {
    let e = this.element.clientHeight, t, r = !1;
    if (this.renderer.verticalFillMode === "fill") {
      let o = Math.floor(this.table.columnManager.getElement().getBoundingClientRect().height + (this.table.footerManager && this.table.footerManager.active && !this.table.footerManager.external ? this.table.footerManager.getElement().getBoundingClientRect().height : 0));
      if (this.fixedHeight) {
        t = isNaN(this.table.options.minHeight) ? this.table.options.minHeight : this.table.options.minHeight + "px";
        const s = "calc(100% - " + o + "px)";
        this.element.style.minHeight = t || "calc(100% - " + o + "px)", this.element.style.height = s, this.element.style.maxHeight = s;
      } else
        this.element.style.height = "", this.element.style.height = this.table.element.clientHeight - o + "px", this.element.scrollTop = this.scrollTop;
      this.renderer.resize(), !this.fixedHeight && e != this.element.clientHeight && (r = !0, this.subscribed("table-resize") ? this.dispatch("table-resize") : this.redraw()), this.scrollBarCheck();
    }
    return this._positionPlaceholder(), r;
  }
  //reinitialize all rows
  reinitialize() {
    this.rows.forEach(function(e) {
      e.reinitialize(!0);
    });
  }
  //prevent table from being redrawn
  blockRedraw() {
    this.redrawBlock = !0, this.redrawBlockRestoreConfig = !1;
  }
  //restore table redrawing
  restoreRedraw() {
    this.redrawBlock = !1, this.redrawBlockRestoreConfig ? (this.refreshActiveData(this.redrawBlockRestoreConfig.handler, this.redrawBlockRestoreConfig.skipStage, this.redrawBlockRestoreConfig.renderInPosition), this.redrawBlockRestoreConfig = !1) : this.redrawBlockRenderInPosition && this.reRenderInPosition(), this.redrawBlockRenderInPosition = !1;
  }
  //redraw table
  redraw(e) {
    const t = this.adjustTableSize();
    this.table.tableWidth = this.table.element.clientWidth, e ? this.renderTable() : (t && this.reRenderInPosition(), this.scrollHorizontal(this.scrollLeft));
  }
  resetScroll() {
    if (this.element.scrollLeft = 0, this.element.scrollTop = 0, this.table.browser === "ie") {
      var e = document.createEvent("Event");
      e.initEvent("scroll", !1, !0), this.element.dispatchEvent(e);
    } else
      this.element.dispatchEvent(new Event("scroll"));
  }
}
class J2 extends Zt {
  constructor(e) {
    super(e), this.active = !1, this.element = this.createElement(), this.containerElement = this.createContainerElement(), this.external = !1;
  }
  initialize() {
    this.initializeElement();
  }
  createElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-footer"), e;
  }
  createContainerElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-footer-contents"), this.element.appendChild(e), e;
  }
  initializeElement() {
    if (this.table.options.footerElement)
      switch (typeof this.table.options.footerElement) {
        case "string":
          this.table.options.footerElement[0] === "<" ? this.containerElement.innerHTML = this.table.options.footerElement : (this.external = !0, this.containerElement = document.querySelector(this.table.options.footerElement));
          break;
        default:
          this.element = this.table.options.footerElement;
          break;
      }
  }
  getElement() {
    return this.element;
  }
  append(e) {
    this.activate(), this.containerElement.appendChild(e), this.table.rowManager.adjustTableSize();
  }
  prepend(e) {
    this.activate(), this.element.insertBefore(e, this.element.firstChild), this.table.rowManager.adjustTableSize();
  }
  remove(e) {
    e.parentNode.removeChild(e), this.deactivate();
  }
  deactivate(e) {
    (!this.element.firstChild || e) && (this.external || this.element.parentNode.removeChild(this.element), this.active = !1);
  }
  activate() {
    this.active || (this.active = !0, this.external || (this.table.element.appendChild(this.getElement()), this.table.element.style.display = ""));
  }
  redraw() {
    this.dispatch("footer-redraw");
  }
}
class eF extends Zt {
  constructor(e) {
    super(e), this.el = null, this.abortClasses = ["tabulator-headers", "tabulator-table"], this.previousTargets = {}, this.listeners = [
      "click",
      "dblclick",
      "contextmenu",
      "mouseenter",
      "mouseleave",
      "mouseover",
      "mouseout",
      "mousemove",
      "mouseup",
      "mousedown",
      "touchstart",
      "touchend"
    ], this.componentMap = {
      "tabulator-cell": "cell",
      "tabulator-row": "row",
      "tabulator-group": "group",
      "tabulator-col": "column"
    }, this.pseudoTrackers = {
      row: {
        subscriber: null,
        target: null
      },
      cell: {
        subscriber: null,
        target: null
      },
      group: {
        subscriber: null,
        target: null
      },
      column: {
        subscriber: null,
        target: null
      }
    }, this.pseudoTracking = !1;
  }
  initialize() {
    this.el = this.table.element, this.buildListenerMap(), this.bindSubscriptionWatchers();
  }
  buildListenerMap() {
    var e = {};
    this.listeners.forEach((t) => {
      e[t] = {
        handler: null,
        components: []
      };
    }), this.listeners = e;
  }
  bindPseudoEvents() {
    Object.keys(this.pseudoTrackers).forEach((e) => {
      this.pseudoTrackers[e].subscriber = this.pseudoMouseEnter.bind(this, e), this.subscribe(e + "-mouseover", this.pseudoTrackers[e].subscriber);
    }), this.pseudoTracking = !0;
  }
  pseudoMouseEnter(e, t, r) {
    this.pseudoTrackers[e].target !== r && (this.pseudoTrackers[e].target && this.dispatch(e + "-mouseleave", t, this.pseudoTrackers[e].target), this.pseudoMouseLeave(e, t), this.pseudoTrackers[e].target = r, this.dispatch(e + "-mouseenter", t, r));
  }
  pseudoMouseLeave(e, t) {
    var r = Object.keys(this.pseudoTrackers), o = {
      row: ["cell"],
      cell: ["row"]
    };
    r = r.filter((s) => {
      var n = o[e];
      return s !== e && (!n || n && !n.includes(s));
    }), r.forEach((s) => {
      var n = this.pseudoTrackers[s].target;
      this.pseudoTrackers[s].target && (this.dispatch(s + "-mouseleave", t, n), this.pseudoTrackers[s].target = null);
    });
  }
  bindSubscriptionWatchers() {
    var e = Object.keys(this.listeners), t = Object.values(this.componentMap);
    for (let r of t)
      for (let o of e) {
        let s = r + "-" + o;
        this.subscriptionChange(s, this.subscriptionChanged.bind(this, r, o));
      }
    this.subscribe("table-destroy", this.clearWatchers.bind(this));
  }
  subscriptionChanged(e, t, r) {
    var o = this.listeners[t].components, s = o.indexOf(e), n = !1;
    r ? s === -1 && (o.push(e), n = !0) : this.subscribed(e + "-" + t) || s > -1 && (o.splice(s, 1), n = !0), (t === "mouseenter" || t === "mouseleave") && !this.pseudoTracking && this.bindPseudoEvents(), n && this.updateEventListeners();
  }
  updateEventListeners() {
    for (let e in this.listeners) {
      let t = this.listeners[e];
      t.components.length ? t.handler || (t.handler = this.track.bind(this, e), this.el.addEventListener(e, t.handler)) : t.handler && (this.el.removeEventListener(e, t.handler), t.handler = null);
    }
  }
  track(e, t) {
    var r = t.composedPath && t.composedPath() || t.path, o = this.findTargets(r);
    o = this.bindComponents(e, o), this.triggerEvents(e, t, o), this.pseudoTracking && (e == "mouseover" || e == "mouseleave") && !Object.keys(o).length && this.pseudoMouseLeave("none", t);
  }
  findTargets(e) {
    var t = {};
    let r = Object.keys(this.componentMap);
    for (let o of e) {
      let s = o.classList ? [...o.classList] : [];
      if (s.filter((l) => this.abortClasses.includes(l)).length)
        break;
      let a = s.filter((l) => r.includes(l));
      for (let l of a)
        t[this.componentMap[l]] || (t[this.componentMap[l]] = o);
    }
    return t.group && t.group === t.row && delete t.row, t;
  }
  bindComponents(e, t) {
    var r = Object.keys(t).reverse(), o = this.listeners[e], s = {}, n = {};
    for (let a of r) {
      let l, u = t[a], h = this.previousTargets[a];
      if (h && h.target === u)
        l = h.component;
      else
        switch (a) {
          case "row":
          case "group":
            (o.components.includes("row") || o.components.includes("cell") || o.components.includes("group")) && (l = this.table.rowManager.getVisibleRows(!0).find((d) => d.getElement() === u), t.row && t.row.parentNode && t.row.parentNode.closest(".tabulator-row") && (t[a] = !1));
            break;
          case "column":
            o.components.includes("column") && (l = this.table.columnManager.findColumn(u));
            break;
          case "cell":
            o.components.includes("cell") && (s.row instanceof Qt ? l = s.row.findCell(u) : t.row && console.warn("Event Target Lookup Error - The row this cell is attached to cannot be found, has the table been reinitialized without being destroyed first?"));
            break;
        }
      l && (s[a] = l, n[a] = {
        target: u,
        component: l
      });
    }
    return this.previousTargets = n, s;
  }
  triggerEvents(e, t, r) {
    var o = this.listeners[e];
    for (let s in r)
      r[s] && o.components.includes(s) && this.dispatch(s + "-" + e, t, r[s]);
  }
  clearWatchers() {
    for (let e in this.listeners) {
      let t = this.listeners[e];
      t.handler && (this.el.removeEventListener(e, t.handler), t.handler = null);
    }
  }
}
class tF {
  constructor(e) {
    this.table = e, this.bindings = {};
  }
  bind(e, t, r) {
    this.bindings[e] || (this.bindings[e] = {}), this.bindings[e][t] ? console.warn("Unable to bind component handler, a matching function name is already bound", e, t, r) : this.bindings[e][t] = r;
  }
  handle(e, t, r) {
    if (this.bindings[e] && this.bindings[e][r] && typeof this.bindings[e][r].bind == "function")
      return this.bindings[e][r].bind(null, t);
    r !== "then" && typeof r == "string" && !r.startsWith("_") && this.table.options.debugInvalidComponentFuncs && console.error("The " + e + " component does not have a " + r + " function, have you checked that you have the correct Tabulator module installed?");
  }
}
class iF extends Zt {
  constructor(e) {
    super(e), this.requestOrder = 0, this.loading = !1;
  }
  initialize() {
  }
  load(e, t, r, o, s, n) {
    var a = ++this.requestOrder;
    if (this.dispatchExternal("dataLoading", e), e && (e.indexOf("{") == 0 || e.indexOf("[") == 0) && (e = JSON.parse(e)), this.confirm("data-loading", [e, t, r, s])) {
      this.loading = !0, s || this.alertLoader(), t = this.chain("data-params", [e, r, s], t || {}, t || {}), t = this.mapParams(t, this.table.options.dataSendParams);
      var l = this.chain("data-load", [e, t, r, s], !1, Promise.resolve([]));
      return l.then((u) => {
        !Array.isArray(u) && typeof u == "object" && (u = this.mapParams(u, this.objectInvert(this.table.options.dataReceiveParams)));
        var h = this.chain("data-loaded", u, null, u);
        a == this.requestOrder ? (this.clearAlert(), h !== !1 && (this.dispatchExternal("dataLoaded", h), this.table.rowManager.setData(h, o, typeof n > "u" ? !o : n))) : console.warn("Data Load Response Blocked - An active data load request was blocked by an attempt to change table data while the request was being made");
      }).catch((u) => {
        console.error("Data Load Error: ", u), this.dispatchExternal("dataLoadError", u), s || this.alertError(), setTimeout(() => {
          this.clearAlert();
        }, this.table.options.dataLoaderErrorTimeout);
      }).finally(() => {
        this.loading = !1;
      });
    } else
      return this.dispatchExternal("dataLoaded", e), e || (e = []), this.table.rowManager.setData(e, o, typeof n > "u" ? !o : n), Promise.resolve();
  }
  mapParams(e, t) {
    var r = {};
    for (let o in e)
      r[t.hasOwnProperty(o) ? t[o] : o] = e[o];
    return r;
  }
  objectInvert(e) {
    var t = {};
    for (let r in e)
      t[e[r]] = r;
    return t;
  }
  blockActiveLoad() {
    this.requestOrder++;
  }
  alertLoader() {
    var e = typeof this.table.options.dataLoader == "function" ? this.table.options.dataLoader() : this.table.options.dataLoader;
    e && this.table.alertManager.alert(this.table.options.dataLoaderLoading || this.langText("data|loading"));
  }
  alertError() {
    this.table.alertManager.alert(this.table.options.dataLoaderError || this.langText("data|error"), "error");
  }
  clearAlert() {
    this.table.alertManager.clear();
  }
}
class rF {
  constructor(e, t, r) {
    this.table = e, this.events = {}, this.optionsList = t || {}, this.subscriptionNotifiers = {}, this.dispatch = r ? this._debugDispatch.bind(this) : this._dispatch.bind(this), this.debug = r;
  }
  subscriptionChange(e, t) {
    this.subscriptionNotifiers[e] || (this.subscriptionNotifiers[e] = []), this.subscriptionNotifiers[e].push(t), this.subscribed(e) && this._notifySubscriptionChange(e, !0);
  }
  subscribe(e, t) {
    this.events[e] || (this.events[e] = []), this.events[e].push(t), this._notifySubscriptionChange(e, !0);
  }
  unsubscribe(e, t) {
    var r;
    if (this.events[e])
      if (t)
        if (r = this.events[e].findIndex((o) => o === t), r > -1)
          this.events[e].splice(r, 1);
        else {
          console.warn("Cannot remove event, no matching event found:", e, t);
          return;
        }
      else
        delete this.events[e];
    else {
      console.warn("Cannot remove event, no events set on:", e);
      return;
    }
    this._notifySubscriptionChange(e, !1);
  }
  subscribed(e) {
    return this.events[e] && this.events[e].length;
  }
  _notifySubscriptionChange(e, t) {
    var r = this.subscriptionNotifiers[e];
    r && r.forEach((o) => {
      o(t);
    });
  }
  _dispatch() {
    var e = Array.from(arguments), t = e.shift(), r;
    return this.events[t] && this.events[t].forEach((o, s) => {
      let n = o.apply(this.table, e);
      s || (r = n);
    }), r;
  }
  _debugDispatch() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "ExternalEvent:" + e[0], (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._dispatch(...arguments);
  }
}
class oF {
  constructor(e) {
    this.events = {}, this.subscriptionNotifiers = {}, this.dispatch = e ? this._debugDispatch.bind(this) : this._dispatch.bind(this), this.chain = e ? this._debugChain.bind(this) : this._chain.bind(this), this.confirm = e ? this._debugConfirm.bind(this) : this._confirm.bind(this), this.debug = e;
  }
  subscriptionChange(e, t) {
    this.subscriptionNotifiers[e] || (this.subscriptionNotifiers[e] = []), this.subscriptionNotifiers[e].push(t), this.subscribed(e) && this._notifySubscriptionChange(e, !0);
  }
  subscribe(e, t, r = 1e4) {
    this.events[e] || (this.events[e] = []), this.events[e].push({ callback: t, priority: r }), this.events[e].sort((o, s) => o.priority - s.priority), this._notifySubscriptionChange(e, !0);
  }
  unsubscribe(e, t) {
    var r;
    if (this.events[e]) {
      if (t)
        if (r = this.events[e].findIndex((o) => o.callback === t), r > -1)
          this.events[e].splice(r, 1);
        else {
          console.warn("Cannot remove event, no matching event found:", e, t);
          return;
        }
    } else {
      console.warn("Cannot remove event, no events set on:", e);
      return;
    }
    this._notifySubscriptionChange(e, !1);
  }
  subscribed(e) {
    return this.events[e] && this.events[e].length;
  }
  _chain(e, t, r, o) {
    var s = r;
    return Array.isArray(t) || (t = [t]), this.subscribed(e) ? (this.events[e].forEach((n, a) => {
      s = n.callback.apply(this, t.concat([s]));
    }), s) : typeof o == "function" ? o() : o;
  }
  _confirm(e, t) {
    var r = !1;
    return Array.isArray(t) || (t = [t]), this.subscribed(e) && this.events[e].forEach((o, s) => {
      o.callback.apply(this, t) && (r = !0);
    }), r;
  }
  _notifySubscriptionChange(e, t) {
    var r = this.subscriptionNotifiers[e];
    r && r.forEach((o) => {
      o(t);
    });
  }
  _dispatch() {
    var e = Array.from(arguments), t = e.shift();
    this.events[t] && this.events[t].forEach((r) => {
      r.callback.apply(this, e);
    });
  }
  _debugDispatch() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._dispatch(...arguments);
  }
  _debugChain() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._chain(...arguments);
  }
  _debugConfirm() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._confirm(...arguments);
  }
}
class sF extends Zt {
  constructor(e) {
    super(e);
  }
  _warnUser() {
    this.options("debugDeprecation") && console.warn(...arguments);
  }
  check(e, t) {
    var r = "";
    return typeof this.options(e) < "u" ? (r = "Deprecated Setup Option - Use of the %c" + e + "%c option is now deprecated", t ? (r = r + ", Please use the %c" + t + "%c option instead", this._warnUser(r, "font-weight: bold;", "font-weight: normal;", "font-weight: bold;", "font-weight: normal;")) : this._warnUser(r, "font-weight: bold;", "font-weight: normal;"), !1) : !0;
  }
  checkMsg(e, t) {
    return typeof this.options(e) < "u" ? (this._warnUser("%cDeprecated Setup Option - Use of the %c" + e + " %c option is now deprecated, " + t, "font-weight: normal;", "font-weight: bold;", "font-weight: normal;"), !1) : !0;
  }
  msg(e) {
    this._warnUser(e);
  }
}
class oi {
  static register(e) {
    oi.tables.push(e);
  }
  static deregister(e) {
    var t = oi.tables.indexOf(e);
    t > -1 && oi.tables.splice(t, 1);
  }
  static lookupTable(e, t) {
    var r = [], o, s;
    if (typeof e == "string") {
      if (o = document.querySelectorAll(e), o.length)
        for (var n = 0; n < o.length; n++)
          s = oi.matchElement(o[n]), s && r.push(s);
    } else
      typeof HTMLElement < "u" && e instanceof HTMLElement || e instanceof Lr ? (s = oi.matchElement(e), s && r.push(s)) : Array.isArray(e) ? e.forEach(function(a) {
        r = r.concat(oi.lookupTable(a));
      }) : t || console.warn("Table Connection Error - Invalid Selector", e);
    return r;
  }
  static matchElement(e) {
    return oi.tables.find(function(t) {
      return e instanceof Lr ? t === e : t.element === e;
    });
  }
}
oi.tables = [];
function nF(i, e) {
  e && this.table.columnManager.renderer.reinitializeColumnWidths(i), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function OT(i, e) {
  i.forEach(function(t) {
    t.reinitializeWidth();
  }), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function aF(i, e) {
  var t = 0, r = this.table.rowManager.element.clientWidth, o = 0, s = !1;
  i.forEach((n, a) => {
    n.widthFixed || n.reinitializeWidth(), (this.table.options.responsiveLayout ? n.modules.responsive.visible : n.visible) && (s = n), n.visible && (t += n.getWidth());
  }), s ? (o = r - t + s.getWidth(), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && (s.setWidth(0), this.table.modules.responsiveLayout.update()), o > 0 ? s.setWidth(o) : s.reinitializeWidth()) : this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function lF(i, e) {
  var t = this.table.rowManager.element.getBoundingClientRect().width, r = 0, o = 0, s = 0, n = 0, a = [], l = [], u = 0, h = 0, c = 0;
  function d(p) {
    var O;
    return typeof p == "string" ? p.indexOf("%") > -1 ? O = t / 100 * parseInt(p) : O = parseInt(p) : O = p, O;
  }
  function f(p, O, m, E) {
    var g = [], A = 0, S = 0, R = 0, v = s, I = 0, C = 0, P = [];
    function w(_) {
      return m * (_.column.definition.widthGrow || 1);
    }
    function x(_) {
      return d(_.width) - m * (_.column.definition.widthShrink || 0);
    }
    return p.forEach(function(_, X) {
      var G = E ? x(_) : w(_);
      _.column.minWidth >= G ? g.push(_) : _.column.maxWidth && _.column.maxWidth < G ? (_.width = _.column.maxWidth, O -= _.column.maxWidth, v -= E ? _.column.definition.widthShrink || 1 : _.column.definition.widthGrow || 1, v && (m = Math.floor(O / v))) : (P.push(_), C += E ? _.column.definition.widthShrink || 1 : _.column.definition.widthGrow || 1);
    }), g.length ? (g.forEach(function(_) {
      A += E ? _.width - _.column.minWidth : _.column.minWidth, _.width = _.column.minWidth;
    }), S = O - A, R = C ? Math.floor(S / C) : S, I = f(P, S, R, E)) : (I = C ? O - Math.floor(O / C) * C : O, P.forEach(function(_) {
      _.width = E ? x(_) : w(_);
    })), I;
  }
  this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update(), this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight && (t -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth), i.forEach(function(p) {
    var O, m, E;
    p.visible && (O = p.definition.width, m = parseInt(p.minWidth), O ? (E = d(O), r += E > m ? E : m, p.definition.widthShrink && (l.push({
      column: p,
      width: E > m ? E : m
    }), u += p.definition.widthShrink)) : (a.push({
      column: p,
      width: 0
    }), s += p.definition.widthGrow || 1));
  }), o = t - r, n = Math.floor(o / s), c = f(a, o, n, !1), a.length && c > 0 && (a[a.length - 1].width += c), a.forEach(function(p) {
    o -= p.width;
  }), h = Math.abs(c) + o, h > 0 && u && (c = f(l, h, Math.floor(h / u), !0)), c && l.length && (l[l.length - 1].width -= c), a.forEach(function(p) {
    p.column.setWidth(p.width);
  }), l.forEach(function(p) {
    p.column.setWidth(p.width);
  });
}
var uF = {
  fitData: nF,
  fitDataFill: OT,
  fitDataTable: OT,
  fitDataStretch: aF,
  fitColumns: lF
};
class fn extends ge {
  constructor(e) {
    super(e, "layout"), this.mode = null, this.registerTableOption("layout", "fitData"), this.registerTableOption("layoutColumnsOnNewData", !1), this.registerColumnOption("widthGrow"), this.registerColumnOption("widthShrink");
  }
  //initialize layout system
  initialize() {
    var e = this.table.options.layout;
    fn.modes[e] ? this.mode = e : (console.warn("Layout Error - invalid mode set, defaulting to 'fitData' : " + e), this.mode = "fitData"), this.table.element.setAttribute("tabulator-layout", this.mode);
  }
  getMode() {
    return this.mode;
  }
  //trigger table layout
  layout(e) {
    this.dispatch("layout-refreshing"), fn.modes[this.mode].call(this, this.table.columnManager.columnsByIndex, e), this.dispatch("layout-refreshed");
  }
}
fn.moduleName = "layout";
fn.modes = uF;
var hF = {
  default: {
    //hold default locale text
    groups: {
      item: "item",
      items: "items"
    },
    columns: {},
    data: {
      loading: "Loading",
      error: "Error"
    },
    pagination: {
      page_size: "Page Size",
      page_title: "Show Page",
      first: "First",
      first_title: "First Page",
      last: "Last",
      last_title: "Last Page",
      prev: "Prev",
      prev_title: "Prev Page",
      next: "Next",
      next_title: "Next Page",
      all: "All",
      counter: {
        showing: "Showing",
        of: "of",
        rows: "rows",
        pages: "pages"
      }
    },
    headerFilters: {
      default: "filter column...",
      columns: {}
    }
  }
};
class nl extends ge {
  constructor(e) {
    super(e), this.locale = "default", this.lang = !1, this.bindings = {}, this.langList = {}, this.registerTableOption("locale", !1), this.registerTableOption("langs", {});
  }
  initialize() {
    this.langList = Ge.deepClone(nl.langs), this.table.options.columnDefaults.headerFilterPlaceholder !== !1 && this.setHeaderFilterPlaceholder(this.table.options.columnDefaults.headerFilterPlaceholder);
    for (let e in this.table.options.langs)
      this.installLang(e, this.table.options.langs[e]);
    this.setLocale(this.table.options.locale), this.registerTableFunction("setLocale", this.setLocale.bind(this)), this.registerTableFunction("getLocale", this.getLocale.bind(this)), this.registerTableFunction("getLang", this.getLang.bind(this));
  }
  //set header placeholder
  setHeaderFilterPlaceholder(e) {
    this.langList.default.headerFilters.default = e;
  }
  //setup a lang description object
  installLang(e, t) {
    this.langList[e] ? this._setLangProp(this.langList[e], t) : this.langList[e] = t;
  }
  _setLangProp(e, t) {
    for (let r in t)
      e[r] && typeof e[r] == "object" ? this._setLangProp(e[r], t[r]) : e[r] = t[r];
  }
  //set current locale
  setLocale(e) {
    e = e || "default";
    function t(r, o) {
      for (var s in r)
        typeof r[s] == "object" ? (o[s] || (o[s] = {}), t(r[s], o[s])) : o[s] = r[s];
    }
    if (e === !0 && navigator.language && (e = navigator.language.toLowerCase()), e && !this.langList[e]) {
      let r = e.split("-")[0];
      this.langList[r] ? (console.warn("Localization Error - Exact matching locale not found, using closest match: ", e, r), e = r) : (console.warn("Localization Error - Matching locale not found, using default: ", e), e = "default");
    }
    this.locale = e, this.lang = Ge.deepClone(this.langList.default || {}), e != "default" && t(this.langList[e], this.lang), this.dispatchExternal("localized", this.locale, this.lang), this._executeBindings();
  }
  //get current locale
  getLocale(e) {
    return this.locale;
  }
  //get lang object for given local or current if none provided
  getLang(e) {
    return e ? this.langList[e] : this.lang;
  }
  //get text for current locale
  getText(e, t) {
    var r = t ? e + "|" + t : e, o = r.split("|"), s = this._getLangElement(o, this.locale);
    return s || "";
  }
  //traverse langs object and find localized copy
  _getLangElement(e, t) {
    var r = this.lang;
    return e.forEach(function(o) {
      var s;
      r && (s = r[o], typeof s < "u" ? r = s : r = !1);
    }), r;
  }
  //set update binding
  bind(e, t) {
    this.bindings[e] || (this.bindings[e] = []), this.bindings[e].push(t), t(this.getText(e), this.lang);
  }
  //iterate through bindings and trigger updates
  _executeBindings() {
    for (let e in this.bindings)
      this.bindings[e].forEach((t) => {
        t(this.getText(e), this.lang);
      });
  }
}
nl.moduleName = "localize";
nl.langs = hF;
class av extends ge {
  constructor(e) {
    super(e);
  }
  initialize() {
    this.registerTableFunction("tableComms", this.receive.bind(this));
  }
  getConnections(e) {
    var t = [], r;
    return r = oi.lookupTable(e), r.forEach((o) => {
      this.table !== o && t.push(o);
    }), t;
  }
  send(e, t, r, o) {
    var s = this.getConnections(e);
    s.forEach((n) => {
      n.tableComms(this.table.element, t, r, o);
    }), !s.length && e && console.warn("Table Connection Error - No tables matching selector found", e);
  }
  receive(e, t, r, o) {
    if (this.table.modExists(t))
      return this.table.modules[t].commsReceived(e, r, o);
    console.warn("Inter-table Comms Error - no such module:", t);
  }
}
av.moduleName = "comms";
var cF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LayoutModule: fn,
  LocalizeModule: nl,
  CommsModule: av
});
class lv {
  constructor(e, t) {
    this.bindStaticFunctionality(e), this.bindModules(e, cF, !0), t && this.bindModules(e, t);
  }
  bindStaticFunctionality(e) {
    e.moduleBindings = {}, e.extendModule = function(t, r, o) {
      if (e.moduleBindings[t]) {
        var s = e.moduleBindings[t][r];
        if (s)
          if (typeof o == "object")
            for (let n in o)
              s[n] = o[n];
          else
            console.warn("Module Error - Invalid value type, it must be an object");
        else
          console.warn("Module Error - property does not exist:", r);
      } else
        console.warn("Module Error - module does not exist:", t);
    }, e.registerModule = function(t) {
      Array.isArray(t) || (t = [t]), t.forEach((r) => {
        e.registerModuleBinding(r);
      });
    }, e.registerModuleBinding = function(t) {
      e.moduleBindings[t.moduleName] = t;
    }, e.findTable = function(t) {
      var r = oi.lookupTable(t, !0);
      return Array.isArray(r) && !r.length ? !1 : r;
    }, e.prototype.bindModules = function() {
      var t = [], r = [], o = [];
      this.modules = {};
      for (var s in e.moduleBindings) {
        let n = e.moduleBindings[s], a = new n(this);
        this.modules[s] = a, n.prototype.moduleCore ? this.modulesCore.push(a) : n.moduleInitOrder ? n.moduleInitOrder < 0 ? t.push(a) : r.push(a) : o.push(a);
      }
      t.sort((n, a) => n.moduleInitOrder > a.moduleInitOrder ? 1 : -1), r.sort((n, a) => n.moduleInitOrder > a.moduleInitOrder ? 1 : -1), this.modulesRegular = t.concat(o.concat(r));
    };
  }
  bindModules(e, t, r) {
    var o = Object.values(t);
    r && o.forEach((s) => {
      s.prototype.moduleCore = !0;
    }), e.registerModule(o);
  }
}
class dF extends Zt {
  constructor(e) {
    super(e), this.element = this._createAlertElement(), this.msgElement = this._createMsgElement(), this.type = null, this.element.appendChild(this.msgElement);
  }
  _createAlertElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-alert"), e;
  }
  _createMsgElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-alert-msg"), e.setAttribute("role", "alert"), e;
  }
  _typeClass() {
    return "tabulator-alert-state-" + this.type;
  }
  alert(e, t = "msg") {
    if (e) {
      for (this.clear(), this.type = t; this.msgElement.firstChild; )
        this.msgElement.removeChild(this.msgElement.firstChild);
      this.msgElement.classList.add(this._typeClass()), typeof e == "function" && (e = e()), e instanceof HTMLElement ? this.msgElement.appendChild(e) : this.msgElement.innerHTML = e, this.table.element.appendChild(this.element);
    }
  }
  clear() {
    this.element.parentNode && this.element.parentNode.removeChild(this.element), this.msgElement.classList.remove(this._typeClass());
  }
}
class Lr {
  constructor(e, t) {
    this.options = {}, this.columnManager = null, this.rowManager = null, this.footerManager = null, this.alertManager = null, this.vdomHoz = null, this.externalEvents = null, this.eventBus = null, this.interactionMonitor = !1, this.browser = "", this.browserSlow = !1, this.browserMobile = !1, this.rtl = !1, this.originalElement = null, this.componentFunctionBinder = new tF(this), this.dataLoader = !1, this.modules = {}, this.modulesCore = [], this.modulesRegular = [], this.deprecationAdvisor = new sF(this), this.optionsList = new nv(this, "table constructor"), this.initialized = !1, this.destroyed = !1, this.initializeElement(e) && (this.initializeCoreSystems(t), setTimeout(() => {
      this._create();
    })), oi.register(this);
  }
  initializeElement(e) {
    return typeof HTMLElement < "u" && e instanceof HTMLElement ? (this.element = e, !0) : typeof e == "string" ? (this.element = document.querySelector(e), this.element ? !0 : (console.error("Tabulator Creation Error - no element found matching selector: ", e), !1)) : (console.error("Tabulator Creation Error - Invalid element provided:", e), !1);
  }
  initializeCoreSystems(e) {
    this.columnManager = new Z2(this), this.rowManager = new K2(this), this.footerManager = new J2(this), this.dataLoader = new iF(this), this.alertManager = new dF(this), this.bindModules(), this.options = this.optionsList.generate(Lr.defaultOptions, e), this._clearObjectPointers(), this._mapDeprecatedFunctionality(), this.externalEvents = new rF(this, this.options, this.options.debugEventsExternal), this.eventBus = new oF(this.options.debugEventsInternal), this.interactionMonitor = new eF(this), this.dataLoader.initialize(), this.footerManager.initialize();
  }
  //convert deprecated functionality to new functions
  _mapDeprecatedFunctionality() {
  }
  _clearSelection() {
    this.element.classList.add("tabulator-block-select"), window.getSelection ? window.getSelection().empty ? window.getSelection().empty() : window.getSelection().removeAllRanges && window.getSelection().removeAllRanges() : document.selection && document.selection.empty(), this.element.classList.remove("tabulator-block-select");
  }
  //create table
  _create() {
    this.externalEvents.dispatch("tableBuilding"), this.eventBus.dispatch("table-building"), this._rtlCheck(), this._buildElement(), this._initializeTable(), this._loadInitialData(), this.initialized = !0, this.externalEvents.dispatch("tableBuilt");
  }
  _rtlCheck() {
    var e = window.getComputedStyle(this.element);
    switch (this.options.textDirection) {
      case "auto":
        if (e.direction !== "rtl")
          break;
      case "rtl":
        this.element.classList.add("tabulator-rtl"), this.rtl = !0;
        break;
      case "ltr":
        this.element.classList.add("tabulator-ltr");
      default:
        this.rtl = !1;
    }
  }
  //clear pointers to objects in default config object
  _clearObjectPointers() {
    this.options.columns = this.options.columns.slice(0), Array.isArray(this.options.data) && !this.options.reactiveData && (this.options.data = this.options.data.slice(0));
  }
  //build tabulator element
  _buildElement() {
    var e = this.element, t = this.options, r;
    if (e.tagName === "TABLE") {
      this.originalElement = this.element, r = document.createElement("div");
      var o = e.attributes;
      for (var s in o)
        typeof o[s] == "object" && r.setAttribute(o[s].name, o[s].value);
      e.parentNode.replaceChild(r, e), this.element = e = r;
    }
    for (e.classList.add("tabulator"), e.setAttribute("role", "grid"); e.firstChild; )
      e.removeChild(e.firstChild);
    t.height && (t.height = isNaN(t.height) ? t.height : t.height + "px", e.style.height = t.height), t.minHeight !== !1 && (t.minHeight = isNaN(t.minHeight) ? t.minHeight : t.minHeight + "px", e.style.minHeight = t.minHeight), t.maxHeight !== !1 && (t.maxHeight = isNaN(t.maxHeight) ? t.maxHeight : t.maxHeight + "px", e.style.maxHeight = t.maxHeight);
  }
  //initialize core systems and modules
  _initializeTable() {
    var e = this.element, t = this.options;
    this.interactionMonitor.initialize(), this.columnManager.initialize(), this.rowManager.initialize(), this._detectBrowser(), this.modulesCore.forEach((r) => {
      r.initialize();
    }), e.appendChild(this.columnManager.getElement()), e.appendChild(this.rowManager.getElement()), t.footerElement && this.footerManager.activate(), t.autoColumns && t.data && this.columnManager.generateColumnsFromRowData(this.options.data), this.modulesRegular.forEach((r) => {
      r.initialize();
    }), this.columnManager.setColumns(t.columns), this.eventBus.dispatch("table-built");
  }
  _loadInitialData() {
    this.dataLoader.load(this.options.data);
  }
  //deconstructor
  destroy() {
    var e = this.element;
    for (this.destroyed = !0, oi.deregister(this), this.eventBus.dispatch("table-destroy"), this.rowManager.destroy(); e.firstChild; )
      e.removeChild(e.firstChild);
    e.classList.remove("tabulator"), this.externalEvents.dispatch("tableDestroyed");
  }
  _detectBrowser() {
    var e = navigator.userAgent || navigator.vendor || window.opera;
    e.indexOf("Trident") > -1 ? (this.browser = "ie", this.browserSlow = !0) : e.indexOf("Edge") > -1 ? (this.browser = "edge", this.browserSlow = !0) : e.indexOf("Firefox") > -1 ? (this.browser = "firefox", this.browserSlow = !1) : e.indexOf("Mac OS") > -1 ? (this.browser = "safari", this.browserSlow = !1) : (this.browser = "other", this.browserSlow = !1), this.browserMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e.slice(0, 4));
  }
  initGuard(e, t) {
    var r, o;
    return this.options.debugInitialization && !this.initialized && (e || (r = new Error().stack.split(`
`), o = r[0] == "Error" ? r[2] : r[1], o[0] == " " ? e = o.trim().split(" ")[1].split(".")[1] : e = o.trim().split("@")[0]), console.warn("Table Not Initialized - Calling the " + e + " function before the table is initialized may result in inconsistent behavior, Please wait for the `tableBuilt` event before calling this function." + (t ? " " + t : ""))), this.initialized;
  }
  ////////////////// Data Handling //////////////////
  //block table redrawing
  blockRedraw() {
    this.initGuard(), this.eventBus.dispatch("redraw-blocking"), this.rowManager.blockRedraw(), this.columnManager.blockRedraw(), this.eventBus.dispatch("redraw-blocked");
  }
  //restore table redrawing
  restoreRedraw() {
    this.initGuard(), this.eventBus.dispatch("redraw-restoring"), this.rowManager.restoreRedraw(), this.columnManager.restoreRedraw(), this.eventBus.dispatch("redraw-restored");
  }
  //load data
  setData(e, t, r) {
    return this.initGuard(!1, "To set initial data please use the 'data' property in the table constructor."), this.dataLoader.load(e, t, r, !1);
  }
  //clear data
  clearData() {
    this.initGuard(), this.dataLoader.blockActiveLoad(), this.rowManager.clearData();
  }
  //get table data array
  getData(e) {
    return this.rowManager.getData(e);
  }
  //get table data array count
  getDataCount(e) {
    return this.rowManager.getDataCount(e);
  }
  //replace data, keeping table in position with same sort
  replaceData(e, t, r) {
    return this.initGuard(), this.dataLoader.load(e, t, r, !0, !0);
  }
  //update table data
  updateData(e) {
    var t = 0;
    return this.initGuard(), new Promise((r, o) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e && e.length > 0 ? e.forEach((s) => {
        var n = this.rowManager.findRow(s[this.options.index]);
        n ? (t++, n.updateData(s).then(() => {
          t--, t || r();
        }).catch((a) => {
          o("Update Error - Unable to update row", s, a);
        })) : o("Update Error - Unable to find row", s);
      }) : (console.warn("Update Error - No data provided"), o("Update Error - No data provided"));
    });
  }
  addData(e, t, r) {
    return this.initGuard(), new Promise((o, s) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e ? this.rowManager.addRows(e, t, r).then((n) => {
        var a = [];
        n.forEach(function(l) {
          a.push(l.getComponent());
        }), o(a);
      }) : (console.warn("Update Error - No data provided"), s("Update Error - No data provided"));
    });
  }
  //update table data
  updateOrAddData(e) {
    var t = [], r = 0;
    return this.initGuard(), new Promise((o, s) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e && e.length > 0 ? e.forEach((n) => {
        var a = this.rowManager.findRow(n[this.options.index]);
        r++, a ? a.updateData(n).then(() => {
          r--, t.push(a.getComponent()), r || o(t);
        }) : this.rowManager.addRows(n).then((l) => {
          r--, t.push(l[0].getComponent()), r || o(t);
        });
      }) : (console.warn("Update Error - No data provided"), s("Update Error - No data provided"));
    });
  }
  //get row object
  getRow(e) {
    var t = this.rowManager.findRow(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching row found:", e), !1);
  }
  //get row object
  getRowFromPosition(e) {
    var t = this.rowManager.getRowFromPosition(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching row found:", e), !1);
  }
  //delete row from table
  deleteRow(e) {
    var t = [];
    this.initGuard(), Array.isArray(e) || (e = [e]);
    for (let r of e) {
      let o = this.rowManager.findRow(r, !0);
      if (o)
        t.push(o);
      else
        return console.error("Delete Error - No matching row found:", r), Promise.reject("Delete Error - No matching row found");
    }
    return t.sort((r, o) => this.rowManager.rows.indexOf(r) > this.rowManager.rows.indexOf(o) ? 1 : -1), t.forEach((r) => {
      r.delete();
    }), this.rowManager.reRenderInPosition(), Promise.resolve();
  }
  //add row to table
  addRow(e, t, r) {
    return this.initGuard(), typeof e == "string" && (e = JSON.parse(e)), this.rowManager.addRows(e, t, r, !0).then((o) => o[0].getComponent());
  }
  //update a row if it exists otherwise create it
  updateOrAddRow(e, t) {
    var r = this.rowManager.findRow(e);
    return this.initGuard(), typeof t == "string" && (t = JSON.parse(t)), r ? r.updateData(t).then(() => r.getComponent()) : this.rowManager.addRows(t).then((o) => o[0].getComponent());
  }
  //update row data
  updateRow(e, t) {
    var r = this.rowManager.findRow(e);
    return this.initGuard(), typeof t == "string" && (t = JSON.parse(t)), r ? r.updateData(t).then(() => Promise.resolve(r.getComponent())) : (console.warn("Update Error - No matching row found:", e), Promise.reject("Update Error - No matching row found"));
  }
  //scroll to row in DOM
  scrollToRow(e, t, r) {
    var o = this.rowManager.findRow(e);
    return o ? this.rowManager.scrollToRow(o, t, r) : (console.warn("Scroll Error - No matching row found:", e), Promise.reject("Scroll Error - No matching row found"));
  }
  moveRow(e, t, r) {
    var o = this.rowManager.findRow(e);
    this.initGuard(), o ? o.moveToRow(t, r) : console.warn("Move Error - No matching row found:", e);
  }
  getRows(e) {
    return this.rowManager.getComponents(e);
  }
  //get position of row in table
  getRowPosition(e) {
    var t = this.rowManager.findRow(e);
    return t ? t.getPosition() : (console.warn("Position Error - No matching row found:", e), !1);
  }
  /////////////// Column Functions  ///////////////
  setColumns(e) {
    this.initGuard(!1, "To set initial columns please use the 'columns' property in the table constructor"), this.columnManager.setColumns(e);
  }
  getColumns(e) {
    return this.columnManager.getComponents(e);
  }
  getColumn(e) {
    var t = this.columnManager.findColumn(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching column found:", e), !1);
  }
  getColumnDefinitions() {
    return this.columnManager.getDefinitionTree();
  }
  showColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.show();
    else
      return console.warn("Column Show Error - No matching column found:", e), !1;
  }
  hideColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.hide();
    else
      return console.warn("Column Hide Error - No matching column found:", e), !1;
  }
  toggleColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.visible ? t.hide() : t.show();
    else
      return console.warn("Column Visibility Toggle Error - No matching column found:", e), !1;
  }
  addColumn(e, t, r) {
    var o = this.columnManager.findColumn(r);
    return this.initGuard(), this.columnManager.addColumn(e, t, o).then((s) => s.getComponent());
  }
  deleteColumn(e) {
    var t = this.columnManager.findColumn(e);
    return this.initGuard(), t ? t.delete() : (console.warn("Column Delete Error - No matching column found:", e), Promise.reject());
  }
  updateColumnDefinition(e, t) {
    var r = this.columnManager.findColumn(e);
    return this.initGuard(), r ? r.updateDefinition(t) : (console.warn("Column Update Error - No matching column found:", e), Promise.reject());
  }
  moveColumn(e, t, r) {
    var o = this.columnManager.findColumn(e), s = this.columnManager.findColumn(t);
    this.initGuard(), o ? s ? this.columnManager.moveColumn(o, s, r) : console.warn("Move Error - No matching column found:", s) : console.warn("Move Error - No matching column found:", e);
  }
  //scroll to column in DOM
  scrollToColumn(e, t, r) {
    return new Promise((o, s) => {
      var n = this.columnManager.findColumn(e);
      return n ? this.columnManager.scrollToColumn(n, t, r) : (console.warn("Scroll Error - No matching column found:", e), Promise.reject("Scroll Error - No matching column found"));
    });
  }
  //////////// General Public Functions ////////////
  //redraw list without updating data
  redraw(e) {
    this.initGuard(), this.columnManager.redraw(e), this.rowManager.redraw(e);
  }
  setHeight(e) {
    this.options.height = isNaN(e) ? e : e + "px", this.element.style.height = this.options.height, this.rowManager.initializeRenderer(), this.rowManager.redraw();
  }
  //////////////////// Event Bus ///////////////////
  on(e, t) {
    this.externalEvents.subscribe(e, t);
  }
  off(e, t) {
    this.externalEvents.unsubscribe(e, t);
  }
  dispatchEvent() {
    var e = Array.from(arguments);
    e.shift(), this.externalEvents.dispatch(...arguments);
  }
  //////////////////// Alerts ///////////////////
  alert(e, t) {
    this.initGuard(), this.alertManager.alert(e, t);
  }
  clearAlert() {
    this.initGuard(), this.alertManager.clear();
  }
  ////////////// Extension Management //////////////
  modExists(e, t) {
    return this.modules[e] ? !0 : (t && console.error("Tabulator Module Not Installed: " + e), !1);
  }
  module(e) {
    var t = this.modules[e];
    return t || console.error("Tabulator module not installed: " + e), t;
  }
}
Lr.defaultOptions = F2;
new lv(Lr);
class fF extends Lr {
}
new lv(fF, B2);
const pF = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: #888;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}
.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}
.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}
.tabulator.tabulator-block-select {
  user-select: none;
}
.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: #e6e6e6;
  color: #555;
  font-weight: 700;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}
.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}
.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}
.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: #e6e6e6;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}
.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: #cdcdcd;
  pointer-events: none;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: 0.6;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: clip;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #cdcdcd;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}
.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}
.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}
.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}
.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: #f3f3f3 !important;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}
.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: #f3f3f3 !important;
}
.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle,
.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}
.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
.tabulator .tabulator-tableholder:focus {
  outline: none;
}
.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}
.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}
.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: 700;
  font-size: 20px;
  white-space: normal;
}
.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: 700;
  background: #e2e2e2 !important;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #aaa;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #aaa;
}
.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #e6e6e6;
  color: #555;
  font-weight: 700;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}
.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}
.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: #f3f3f3 !important;
  border-bottom: 1px solid #aaa;
  border-top: 1px solid #aaa;
  overflow: hidden;
}
.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: #f3f3f3 !important;
}
.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}
.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}
.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}
.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: 400;
}
.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}
.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}
.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}
.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: hsla(0, 0%, 100%, 0.2);
}
.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}
.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: 0.5;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}
.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}
.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}
.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}
.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: 700;
  font-size: 16px;
}
.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}
.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #d00;
  color: #590000;
}
.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}
.tabulator-row.tabulator-row-even {
  background-color: #efefef;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}
.tabulator-row.tabulator-selected {
  background-color: #9abcea;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769bcc;
    cursor: pointer;
  }
}
.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}
.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
  pointer-events: none;
  z-index: 15;
}
.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}
.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}
.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}
.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}
.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}
.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}
.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}
.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #aaa;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}
.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}
.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}
.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1d68cd;
  outline: none;
  padding: 0;
}
.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}
.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #d00;
}
.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #d00;
}
.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}
.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: 700;
  font-size: 1.1em;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: 0.7;
    cursor: pointer;
  }
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}
.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}
.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px 5px 5px 10px;
  background: #ccc;
  font-weight: 700;
  min-width: 100%;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}
.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}
.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}
.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}
.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}
.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}
.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}
.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}
.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}
.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}
.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #aaa;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}
.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}
.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}
.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: 0.5;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #efefef;
  }
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu:after {
  display: inline-block;
  position: absolute;
  top: calc(5px + 0.4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: "";
  border-color: #aaa;
  border-style: solid;
  border-width: 1px 1px 0 0;
  vertical-align: top;
  transform: rotate(45deg);
}
.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #aaa;
}
.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}
.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1d68cd;
}
.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid hsla(0, 0%, 100%, 0.5);
}
.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1d68cd;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1d68cd;
  }
}
.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}
.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #aaa;
  padding: 6px 4px 4px;
  color: #333;
  font-weight: 700;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}
.tabulator.tabulator-ltr {
  direction: ltr;
}
.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: 0;
  margin-left: -1px;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: auto;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: 0;
  margin-left: 5px;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: 0;
  margin-left: 5px;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}
.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}
.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}
body.tabulator-print-fullscreen-hide > :not(.tabulator-print-fullscreen) {
  display: none !important;
}
.tabulator-print-table {
  border-collapse: collapse;
}
.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}
.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px 5px 5px 10px;
  background: #ccc;
  font-weight: 700;
  min-width: 100%;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}
.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}
.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}
.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}
.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
`, OF = {
  setup() {
    const i = No("style", {}, pF);
    return () => i;
  }
}, EF = `
.tabulator {
  position: relative;
  border: 1px solid #ddd;
  background-color: #fff;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #ddd;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #ddd;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #ececec !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #ddd;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #ddd;
  background-color: #e6e6e6;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: #f3f3f3 !important;
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: #f3f3f3 !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}

.tabulator-row.tabulator-row-even {
  background-color: #f9f9f9;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #f5f5f5;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #ddd;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #ddd;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #f9f9f9;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #ddd;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #ddd;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(255, 255, 255, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #ddd;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator {
  background-color: #fff;
  margin-bottom: 20px;
  border: none;
}

.tabulator .tabulator-header {
  border-bottom: 2px solid #ddd;
  background-color: #fff;
  color: inherit;
}

.tabulator .tabulator-header .tabulator-col {
  background-color: #fff;
  border-right: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 8px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  border-top: 1px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  width: 100%;
  border-bottom: 1px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #000;
}

.tabulator .tabulator-tableholder .tabulator-table {
  color: inherit;
}

.tabulator .tabulator-footer {
  border-top: 2px solid #ddd;
  background: inherit;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
}

.tabulator .tabulator-footer .tabulator-paginator {
  color: inherit;
}

.tabulator.table-striped .tabulator-row.tabulator-row-even {
  background-color: #f9f9f9;
}

.tabulator.table-bordered {
  border: 1px solid #ddd;
}

.tabulator.table-bordered .tabulator-header .tabulator-col {
  border-right: 1px solid #ddd;
}

.tabulator.table-bordered .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  border-right: 1px solid #ddd;
}

.tabulator.table-condensed .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 5px;
}

.tabulator.table-condensed .tabulator-tableholder .tabulator-table .tabulator-row {
  min-height: 24px;
}

.tabulator.table-condensed .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  padding: 5px;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.active {
  background: #f5f5f5 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.success {
  background: #dff0d8 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.info {
  background: #d9edf7 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.warning {
  background: #fcf8e3 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.danger {
  background: #f2dede !important;
}

.tabulator-row {
  min-height: 30px;
  border-bottom: 1px solid #ddd;
}

.tabulator-row.tabulator-row-even {
  background-color: transparent;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #f5f5f5 !important;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA !important;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC !important;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell {
  padding: 8px;
  border-right: none;
}

.tabulator-row .tabulator-cell:last-of-type {
  border-right: none;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  border: 1px solid #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  background: #333;
}

.tabulator-row.tabulator-group {
  background: #fafafa;
}

.tabulator-row.tabulator-group span {
  color: #666;
}

.tabulator-edit-select-list .tabulator-edit-select-list-item {
  color: inherit;
}

.tabulator-edit-select-list .tabulator-edit-select-list-notice {
  color: inherit;
}

.tabulator-edit-select-list .tabulator-edit-select-list-group {
  color: inherit;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  border: none;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-print-table-group {
  background: #fafafa;
}

.tabulator-print-table .tabulator-print-table-group span {
  color: #666;
}

.tabulator-print-table .tabulator-data-tree-control {
  border: 1px solid #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  background: #333;
}

`, mF = {
  setup() {
    const i = No("style", {}, EF);
    return () => i;
  }
}, gF = `
.tabulator {
  position: relative;
  border: 1px solid #fff;
  background-color: #fff;
  font-size: 16px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #3759D7;
  background-color: #fff;
  color: #3759D7;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #fff;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #3759D7;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #b7c3f1;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #fff;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #b7c3f1;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #b7c3f1;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #3759D7;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #3759D7;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #3759D7;
  color: #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #fff;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #f3f3f3;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #fff;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #fff;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #fff;
  color: #3759D7;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: white !important;
  border-bottom: 1px solid #fff;
  border-top: 1px solid #fff;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #3759D7;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #3759D7;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 24px;
  background-color: #f3f3f3;
}

.tabulator-row.tabulator-row-even {
  background-color: #fff;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 16px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #fff;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #fff;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #fff;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #fff;
  border-bottom: 2px solid #fff;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #f3f3f3;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #f3f3f3;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #fff;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #3759D7;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #3759D7;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #f3f3f3;
  border: 1px solid #fff;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fff;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #fff;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #fff;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #f3f3f3;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(243, 243, 243, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #f3f3f3;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #fff;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #fff;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #fff;
  border-bottom: 2px solid #fff;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #fff;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #3759D7;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #3759D7;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator .tabulator-header {
  border-bottom: 3px solid #3759D7;
  margin-bottom: 4px;
  padding-left: 10px;
  font-size: 1.1em;
}

.tabulator .tabulator-header .tabulator-col {
  border-right: 2px solid #fff;
  background-color: #fff;
}

.tabulator .tabulator-header .tabulator-col:nth-child(1) {
  padding-left: 10px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  border: 1px solid #3759D7;
  font-size: 1em;
  color: #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  border-top: 2px solid #3759D7;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  padding-left: 10px;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  border-top: 2px solid #3759D7 !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  padding-left: 0 !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  background: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #3759D7;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #3759D7;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #3759D7;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  border-top: 3px solid #3759D7 !important;
  border-bottom: 2px solid #3759D7 !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  background: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell:first-child {
  border-left: 10px solid transparent;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  border-bottom: none !important;
}

.tabulator-row {
  margin-bottom: 2px;
}

.tabulator-row .tabulator-cell:first-child {
  border-left: 10px solid #3759D7;
}

.tabulator-row:nth-child(even) {
  background-color: #627ce0;
}

.tabulator-row:nth-child(even) .tabulator-cell {
  background-color: #fff;
}

.tabulator-row:nth-child(even) .tabulator-cell:first-child {
  border-left: 10px solid #627ce0;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    cursor: pointer;
  }
  .tabulator-row.tabulator-selectable:hover .tabulator-cell {
    background-color: #bbb;
  }
}

.tabulator-row.tabulator-selected .tabulator-cell {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover .tabulator-cell {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-moving {
  pointer-events: none !important;
}

.tabulator-row .tabulator-cell {
  padding: 6px 4px;
  border-right: 2px solid #fff;
  background-color: #f3f3f3;
}

.tabulator-row.tabulator-group {
  min-width: 100%;
  margin-bottom: 2px;
  border-bottom: 2px solid #3759D7;
  border-top: 2px solid #3759D7;
  border-right: none;
  background: #8ca0e8;
}

.tabulator-row.tabulator-group span {
  color: #3759D7;
}

.tabulator-edit-select-list {
  border: 1px solid #1D68CD;
}

.tabulator-print-table .tabulator-print-table-group {
  border-bottom: 2px solid #3759D7;
  border-top: 2px solid #3759D7;
  background: #8ca0e8;
  margin-bottom: 2px;
}

.tabulator-print-table .tabulator-print-table-group span {
  color: #3759D7;
}

`, bF = {
  setup() {
    const i = No("style", {}, gF);
    return () => i;
  }
}, TF = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: white;
  font-size: 16px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: transparent;
  color: #363636;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: transparent;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: rgba(0, 0, 0, 0);
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0);
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #363636;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #363636;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #363636;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #363636;
  color: #363636;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: rgba(13, 13, 13, 0) !important;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: rgba(13, 13, 13, 0) !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: transparent;
  white-space: nowrap;
  overflow: visible;
  color: #363636;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #ededed !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #aaa;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #aaa;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: transparent;
  color: #363636;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: rgba(13, 13, 13, 0) !important;
  border-bottom: 1px solid #aaa;
  border-top: 1px solid #aaa;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: rgba(13, 13, 13, 0) !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #363636;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #dbdbdb;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #dbdbdb;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 24px;
  background-color: transparent;
}

.tabulator-row.tabulator-row-even {
  background-color: #fafafa;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #fafafa;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #00d1b2;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 16px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #aaa;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #363636;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: transparent;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: transparent;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #363636;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #363636;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: transparent;
  border: 1px solid #aaa;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fafafa;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #aaa;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #aaa;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #363636;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: transparent;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(0, 0, 0, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: transparent;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #363636;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #aaa;
  padding: 4px;
  padding-top: 6px;
  color: #363636;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #363636;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #363636;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #363636;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #363636;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator {
  border: none;
}

.tabulator .tabulator-header {
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-header .tabulator-col {
  border-right: none;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  border: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 0.5em 0.75em;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  right: 0px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input {
  border: 1px solid #dbdbdb;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-footer {
  padding: 0.5em 0.75em;
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  margin: -5px -10px 10px -10px;
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-footer .tabulator-page {
  margin: 0 0.1875em;
  padding: calc(0.375em - 1px) 0.75em;
  border: 1px solid #dbdbdb;
  font-size: 16px;
}

.tabulator .tabulator-footer .tabulator-page.active {
  border-color: #4a4a4a;
  color: #363636;
  font-weight: bold;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    border-color: #b5b5b5;
    background: inherit;
    color: inherit;
  }
}

.tabulator.is-striped .tabulator-row:nth-child(even) {
  background-color: #fafafa;
}

.tabulator.is-bordered {
  border: 1px solid #dbdbdb;
}

.tabulator.is-bordered .tabulator-header .tabulator-col {
  border-right: 1px solid #dbdbdb;
}

.tabulator.is-bordered .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  border-right: 1px solid #dbdbdb;
}

.tabulator.is-narrow .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 0.25em 0.5em;
}

.tabulator.is-narrow .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  padding: 0.25em 0.5em;
}

.tabulator-row {
  min-height: 22px;
}

.tabulator-row.tabulator-row-even {
  background-color: inherit;
}

.tabulator-row.tabulator-selected {
  background-color: #00d1b2 !important;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #009e86 !important;
  }
}

.tabulator-row .tabulator-cell {
  padding: 0.5em 0.75em;
  border: 1px solid #dbdbdb;
  border-width: 0 0 1px;
}

.tabulator-row.tabulator-group {
  border-bottom: 1px solid #999;
  border-right: none;
  border-top: 1px solid #999;
  color: #363636;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: none;
  border-top: 1px solid #999;
  color: #363636;
}

.tabulator-popup-container {
  background: white;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: white;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    color: white;
  }
}

`, SF = {
  setup() {
    const i = No("style", {}, TF);
    return () => i;
  }
}, RF = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: #fff;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #ddd;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #ddd;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #ddd;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: white !important;
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}

.tabulator-row.tabulator-row-even {
  background-color: #fff;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #ddd;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #ddd;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fff;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #ddd;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #ddd;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(255, 255, 255, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #ddd;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #ddd;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator {
  border: none;
  background-color: #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  background: #f2f2f2 !important;
  border-bottom: 1px solid #999;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #000;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  background: #f2f2f2 !important;
  border-bottom: 1px solid #fff;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  background: #f2f2f2 !important;
}

.tabulator-row {
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-cell:last-of-type {
  border-right: none;
}

.tabulator-row.tabulator-group span {
  color: #666;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #666;
}

`, AF = {
  setup() {
    const i = No("style", {}, RF);
    return () => i;
  }
}, CF = { class: "ns-table-theme-box" }, NF = /* @__PURE__ */ fi({
  __name: "theme",
  props: {
    theme: {
      type: String,
      default: "default"
    }
  },
  setup(i) {
    return (e, t) => (Pe(), ht("span", CF, [
      i.theme === "default" ? (Pe(), Li(OF, { key: 0 })) : gr("", !0),
      i.theme === "bootstrap3" ? (Pe(), Li(mF, { key: 1 })) : gr("", !0),
      i.theme === "modern" ? (Pe(), Li(bF, { key: 2 })) : gr("", !0),
      i.theme === "bulma" ? (Pe(), Li(SF, { key: 3 })) : gr("", !0),
      i.theme === "sample" ? (Pe(), Li(AF, { key: 4 })) : gr("", !0)
    ]));
  }
}), IF = ["id"], vF = /* @__PURE__ */ fi({
  __name: "table",
  props: {
    columns: {
      type: Array,
      default: () => []
    },
    data: {
      type: Array,
      default: () => []
    },
    options: {
      type: Object,
      default: () => ({})
    },
    theme: {
      type: String,
      default: "default"
    }
  },
  emits: [
    "loaded"
  ],
  setup(i, { emit: e }) {
    const t = i;
    let r = null;
    const o = wu.v4(), s = it(null), n = it(null), a = it(!1);
    function l() {
      n.value || setTimeout(() => {
        l();
      }, 1e3), delete t.options.data, delete t.options.columns;
      const c = {
        height: "100%",
        layout: "fitColumns",
        columns: t.columns,
        reactiveData: !0,
        ...t.options
      };
      r = new Lr(n.value, {
        ...c,
        data: t.data
      }), a.value = !0, e("loaded", o, r);
    }
    function u(c) {
      if (!r) {
        setTimeout(() => {
          u(c);
        }, 100);
        return;
      }
      r.setData(c);
    }
    function h(c) {
      if (!r) {
        setTimeout(() => {
          h(c);
        }, 100);
        return;
      }
      r.setColumns(c);
    }
    return Mi(() => t.columns, (c, d) => {
      c && h(c);
    }, {
      deep: !0
    }), Mi(() => t.data, (c, d) => {
      c && u(c);
    }, {
      deep: !0
    }), yr(() => {
      [
        ri,
        Sn,
        HO,
        sl,
        Cn,
        os,
        Ao,
        Tr,
        xO,
        ss,
        UO,
        Ji,
        QO,
        kO,
        $O,
        Co,
        GO,
        Rn,
        VO,
        Rr,
        ns,
        An,
        Mt,
        XO,
        YO,
        BO,
        FO,
        WO,
        zO,
        ZO,
        qO,
        lo
      ].forEach((c) => {
        Lr.registerModule(c);
      }), zo(() => {
        l();
      });
    }), (c, d) => (Pe(), ht("div", {
      class: "ns-table-box",
      ref_key: "RefMain",
      ref: s
    }, [
      xe(NF, { theme: i.theme }, null, 8, ["theme"]),
      ke("div", {
        class: "ns-table-body",
        id: Zs(o),
        ref_key: "RefBox",
        ref: n
      }, null, 8, IF)
    ], 512));
  }
}), _F = `.ns-table-box[data-v-ccebc78a],.ns-table-box .ns-table-body[data-v-ccebc78a]{width:100%;height:100%;overflow:hidden;box-sizing:border-box}
`, PF = /* @__PURE__ */ xr(vF, [["styles", [_F]], ["__scopeId", "data-v-ccebc78a"]]), LF = ["id"], wF = /* @__PURE__ */ fi({
  __name: "floatingbox",
  props: {
    width: {
      type: String,
      default: "100px"
    },
    id: {
      type: String,
      default: () => wu.v4()
    },
    style: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["loaded", "mouseleave", "update:show"],
  setup(i, { emit: e }) {
    const t = i, { NsFloatingbox: r } = window, o = it(), s = it(wu.v4());
    function n() {
      r.close(t.id), e("mouseleave", !1);
    }
    function a() {
      n();
    }
    return yr(() => {
      e("loaded", s.value);
    }), (l, u) => (Pe(), ht("div", {
      class: "ns-floating-box",
      id: i.id,
      style: ki({ width: `${t.width}`, ...t.style }),
      onMouseleave: n,
      ref_key: "RefBox",
      ref: o
    }, [
      ke("div", {
        class: "ns-floating-box-content",
        onClick: a
      }, [
        ui(l.$slots, "items")
      ])
    ], 44, LF));
  }
}), yF = `:root,:host{--ns-primary: #28415a;--ns-primary-light-1: #3c5a7d;--ns-success: #5f785a;--ns-success-light-1: #73917d;--ns-warning: #dc8c50;--ns-warning-light-1: #f5a573;--ns-error: #aa5032;--ns-warning-light-1: #c36955;--ns-info: #b9beb4;--ns-text: #1d1d1d;--ns-border-shadow-color: #6c686e;--ns-border-color: #58545a;--ns-background-gray: #dfdfdf;--ns-size-text-normal: 14px;--ns-size-top-title: 22px;--ns-size-text-title: 18px;--ns-size-text-subtitle: 16px;--ns-weight-text: 900;--ns-border-radius: 4px;--ns-border-width: 1px;--ns-text-color-normal: var(--ns-text);--ns-text-color-primary: var(--ns-primary);--ns-text-color-success: var(--ns-success);--ns-text-color-warning: var(--ns-warning);--ns-text-color-error: var(--ns-error);--ns-text-color-info: var(--ns-info)}.ns-floating-box{position:fixed;top:0;left:0;z-index:9999;box-shadow:1px 1px 5px var(--ns-border-shadow-color);border-radius:var(--ns-border-radius);background-color:#f7f7f7;padding:0;min-height:30px;display:flex;justify-content:flex-start;align-items:center;flex-direction:column;opacity:0;transition:opacity .2s}.ns-floating-box .ns-floating-box-content{width:100%;height:100%;overflow:hidden;box-sizing:border-box;min-height:30px}
`, DF = /* @__PURE__ */ xr(wF, [["styles", [yF]]]), xF = fi({
  name: "",
  props: {
    hideHeader: {
      type: Boolean,
      default: !1
    },
    hideMenu: {
      type: Boolean,
      default: !1
    },
    menuWidth: {
      type: String,
      default: "200px"
    },
    expandMenu: {
      type: Boolean,
      default: !0
    }
  },
  setup(i, { emit: e }) {
    return {};
  }
}), MF = `:root,:host{--ns-primary: #28415a;--ns-primary-light-1: #3c5a7d;--ns-success: #5f785a;--ns-success-light-1: #73917d;--ns-warning: #dc8c50;--ns-warning-light-1: #f5a573;--ns-error: #aa5032;--ns-warning-light-1: #c36955;--ns-info: #b9beb4;--ns-text: #1d1d1d;--ns-border-shadow-color: #6c686e;--ns-border-color: #58545a;--ns-background-gray: #dfdfdf;--ns-size-text-normal: 14px;--ns-size-top-title: 22px;--ns-size-text-title: 18px;--ns-size-text-subtitle: 16px;--ns-weight-text: 900;--ns-border-radius: 4px;--ns-border-width: 1px;--ns-text-color-normal: var(--ns-text);--ns-text-color-primary: var(--ns-primary);--ns-text-color-success: var(--ns-success);--ns-text-color-warning: var(--ns-warning);--ns-text-color-error: var(--ns-error);--ns-text-color-info: var(--ns-info)}.ns-frame-main{width:100%;height:100%;overflow:hidden;box-sizing:border-box}.ns-frame-main .ns-frame-header{width:100%;height:70px;overflow:hidden;box-sizing:border-box;position:relative;z-index:10;box-shadow:1px 1px 5px var(--ns-border-shadow-color);border:1px solid var(--ns-border-color);background-color:var(--ns-primary)}.ns-frame-main .ns-frame-body{width:100%;height:calc(100% - 70px);overflow:hidden;box-sizing:border-box;position:relative;z-index:5}.ns-frame-main .ns-frame-body .ns-frame-body-menu,.ns-frame-main .ns-frame-body .ns-frame-body-content{float:left;height:100%;overflow:hidden;box-sizing:border-box}.ns-none-header .ns-frame-body{height:100%!important}.ns-none-menu .ns-frame-body .ns-frame-body-content{width:100%!important}
`, UF = {
  key: 0,
  class: "ns-frame-header"
}, QF = { class: "ns-frame-body" };
function kF(i, e, t, r, o, s) {
  return Pe(), ht("div", {
    class: On(`ns-frame-main ns-none-${i.hideHeader ? "header" : ""} ns-none-${i.hideMenu ? "menu" : ""}`)
  }, [
    i.hideHeader ? gr("", !0) : (Pe(), ht("div", UF, [
      ui(i.$slots, "header")
    ])),
    ke("div", QF, [
      i.hideMenu ? gr("", !0) : (Pe(), ht("div", {
        key: 0,
        class: "ns-frame-body-menu",
        style: ki(`width: ${i.menuWidth}`)
      }, [
        ui(i.$slots, "menu")
      ], 4)),
      ke("div", {
        class: "ns-frame-body-content",
        style: ki(`width: ${i.hideMenu ? "100%" : `calc(100% - ${i.menuWidth})`}`)
      }, [
        ui(i.$slots, "content")
      ], 4)
    ])
  ], 2);
}
const $F = /* @__PURE__ */ xr(xF, [["render", kF], ["styles", [MF]]]), GF = fi({
  name: "",
  props: {
    hideHeader: {
      type: Boolean,
      default: !1
    },
    keys: {
      type: Array,
      default: () => ["default"]
    },
    sizes: {
      type: Array,
      default: () => ["100%"]
    }
  },
  setup(i, { emit: e }) {
    return {};
  }
}), VF = `.ns-content-box{width:100%;height:100%;overflow:hidden;box-sizing:border-box}.ns-content-box .ns-content-header{width:100%;height:50px;overflow:hidden;box-sizing:border-box}.ns-content-box .ns-content-columns{width:100%;height:calc(100% - 50px);overflow:hidden;box-sizing:border-box;display:flex;justify-content:space-around;align-items:center}.ns-content-box .ns-content-columns .ns-content-column-item{height:100%;overflow:hidden;box-sizing:border-box}
`, HF = { class: "ns-content-box" }, XF = { class: "ns-content-header" }, YF = { class: "ns-content-columns" };
function BF(i, e, t, r, o, s) {
  return Pe(), ht("div", HF, [
    ke("div", XF, [
      ui(i.$slots, "header")
    ]),
    ke("div", YF, [
      (Pe(!0), ht(et, null, Ep(i.keys, (n, a) => (Pe(), ht("div", {
        class: "ns-content-column-item",
        style: ki(`width: ${i.sizes[a]};`)
      }, [
        ui(i.$slots, n)
      ], 4))), 256))
    ])
  ]);
}
const FF = /* @__PURE__ */ xr(GF, [["render", BF], ["styles", [VF]]]), WF = ["width", "height"], zF = ["fill"], ZF = /* @__PURE__ */ fi({
  __name: "star",
  props: {
    size: {
      type: [Number, String],
      default: 16
    },
    fill: {
      type: String,
      default: "#CA2188"
    }
  },
  setup(i) {
    return (e, t) => (Pe(), ht("svg", {
      t: "1688548412453",
      class: "icon",
      viewBox: "0 0 1024 1024",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      "p-id": "1611",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      width: i.size,
      height: i.size
    }, [
      ke("path", {
        d: "M894.91197 513.709945c0-33.604352-78.328973-62.839187-194.192817-78.305437 70.981634-92.947925 105.664551-169.093163 81.875752-192.829773-23.763217-23.789823-99.884918 10.891048-192.832843 81.899288-15.489786-115.863844-44.701085-194.219423-78.302367-194.219423-33.654494 0-62.892399 78.252225-78.434373 194.116069-92.921319-70.955028-168.964226-105.585757-192.703907-81.795934-23.789823 23.736611 10.9197 99.832729 81.875752 192.727443-115.913986 15.518438-194.192817 44.753273-194.192817 78.407768s78.328973 62.839187 194.192817 78.355579c-71.00824 92.897783-105.691157 168.990832-81.875752 192.779631 23.763217 23.789823 99.884918-10.891048 192.806237-81.899288 15.491833 115.860774 44.677549 194.219423 78.332043 194.219423 33.602306 0 62.889329-78.305437 78.381162-194.116069 92.894713 70.904886 168.990832 105.585757 192.754049 81.795934 23.788799-23.736611-10.917654-99.779517-81.875752-192.727443C816.609603 576.599274 894.91197 547.311227 894.91197 513.709945zM707.835224 316.665173c17.159822 17.107633 3.699252 61.040215-31.060413 115.758444-24.583908-2.723018-50.430576-4.982478-77.584006-6.471388-1.515516-27.541263-3.774977-53.745065-6.603395-78.613452C647.052882 312.811402 690.751127 299.555493 707.835224 316.665173zM600.784092 551.422871c8.528234-8.94165 16.851806-17.828041 24.944112-26.717502 14.873756 17.983583 28.774347 35.709293 40.333614 52.510958-20.296255 3.748371-42.569538 6.729262-66.151629 8.886391C600.450495 574.85249 600.474031 562.982138 600.784092 551.422871zM601.297792 530.049075c0.076748-5.550413 0.410346-10.738575 0.410346-16.33913 0-5.960759-0.152473-11.714809-0.231267-17.573237 5.216815 5.806239 9.633405 11.406794 14.542204 17.10968C611.214652 518.846942 606.332459 524.44852 601.297792 530.049075zM436.366416 566.016241c3.774977 3.853771 7.397481 7.655354 11.277858 11.509125 3.853771 3.853771 7.705496 7.449669 11.585873 11.251252-7.29515-0.410346-14.411221-0.873903-21.450545-1.38658C437.262832 580.350714 436.776761 573.260226 436.366416 566.016241zM439.08841 602.340541c11.585873 0.515746 23.326265 0.926092 35.298947 1.183965 8.707312 8.323573 17.288758 15.876596 25.946952 23.789823-17.983583 14.950504-35.605939 28.361955-52.408627 39.97341C444.276572 647.298476 441.24554 625.514333 439.08841 602.340541zM495.580029 603.77931c5.293563 0.052189 10.532891 0.205685 15.878642 0.205685 5.573949 0 10.788717-0.308015 16.260335-0.410346-5.395894 4.882194-10.765181 9.606799-16.158005 14.232143C506.268462 613.181447 500.92578 608.609315 495.580029 603.77931zM511.35634 590.163197c-10.532891 0-20.914332-0.152473-31.113625-0.512676-7.68196-7.142677-15.284101-14.284331-22.939455-21.939685-7.502881-7.499811-14.747889-15.052834-21.810748-22.555715-0.333598-10.378371-0.515746-20.86112-0.515746-31.547507 0-11.20111 0.310062-22.145369 0.694825-32.936133 6.78145-7.245008 13.745049-14.486946 20.964474-21.681812 7.603165-7.603165 15.260565-14.950504 22.889313-22.092158 10.480702-0.360204 21.013593-0.668219 31.830963-0.668219 10.738575 0 21.348214 0.254803 31.778774 0.565888 7.68196 7.192819 15.360849 14.384615 23.01825 22.092158 7.655354 7.605212 15.029298 15.260565 22.195511 22.968108 0.333598 10.428513 0.565888 21.013593 0.565888 31.752168 0 10.43056-0.308015 20.551058-0.641613 30.621415-7.373944 7.863085-14.926968 15.776312-22.813588 23.636327-7.449669 7.449669-14.95255 14.642488-22.426779 21.681812C532.602224 589.907371 522.094916 590.163197 511.35634 590.163197zM421.208181 513.709945c0 5.446036 0.102331 10.738575 0.155543 16.081257-5.163603-5.753027-9.583263-11.353582-14.490016-17.10968 4.777817-5.600555 9.710153-11.20111 14.771425-16.799618C421.541779 501.942947 421.208181 507.59569 421.208181 513.709945zM422.826028 586.103742c-23.63428-2.157129-45.702901-5.240351-66.049299-9.041934 11.688203-16.95516 25.252127-34.733059 40.383756-52.921303 8.094352 8.939603 15.876596 17.777899 24.483624 26.76969C421.901982 562.829665 422.312328 574.594617 422.826028 586.103742zM422.134273 476.048183c-8.326643 8.68173-16.365736 17.365506-24.252357 25.996071-15.002692-18.136056-29.006637-35.967166-40.641629-52.869115 20.216437-3.751441 42.311665-6.732331 65.791425-8.889461C422.465824 451.845968 422.441265 464.126666 422.134273 476.048183zM587.528184 462.482213c-4.086062-4.211928-8.068769-8.373715-12.280698-12.58769-4.213975-4.211928-8.402367-8.16803-12.590759-12.279674 7.939833 0.410346 15.724123 0.926092 23.379477 1.541099C586.655304 446.76116 587.141374 454.568986 587.528184 462.482213zM584.803119 425.181679c-11.892865-0.565888-23.967878-0.978281-36.248575-1.286296-8.965186-8.578376-17.777899-16.286941-26.717502-24.40483 18.470677-15.362896 36.582173-29.184693 53.795207-41.001833C579.48602 378.988614 582.569242 401.289526 584.803119 425.181679zM528.926508 423.689698c-5.831822-0.102331-11.559267-0.205685-17.467837-0.205685-6.089695 0-11.766998 0.308015-17.804505 0.410346 5.935176-5.342682 11.843746-10.532891 17.752316-15.568581C517.186116 413.311327 523.044544 418.347017 528.926508 423.689698zM601.271186 476.508671c-0.281409-12.227486-0.718361-24.302499-1.284249-36.22197 23.505343 2.209318 45.471634 5.240351 65.691141 8.991792-11.714809 17.057491-25.409716 34.990932-40.618093 53.28253C617.147782 493.877247 609.621365 485.245659 601.271186 476.508671zM511.919159 235.329726c24.150026 0 45.600571 40.383756 59.705823 103.375415-19.628036 15.620769-39.820937 32.67826-60.398602 51.075259-20.063965-18.035772-39.975457-35.195593-59.243289-50.559513C466.113927 275.918143 487.693408 235.329726 511.919159 235.329726zM447.951265 358.951255c16.905018 11.611455 34.630728 25.278733 52.690036 40.333614-8.889461 8.117888-17.801435 16.441461-26.793226 25.022906-11.587919 0.308015-23.508413 0.308015-34.759665 0.820692C441.272145 401.544329 444.199825 379.194298 447.951265 358.951255zM460.07642 437.769368c-4.13518 4.059456-8.271384 8.015557-12.406564 12.125155-3.777023 3.801583-7.373944 7.553023-11.072173 11.356652 0.410346-7.452739 0.77055-14.95255 1.333368-22.197558C445.125917 438.487729 452.652334 438.179714 460.07642 437.769368zM314.927599 316.50963c17.084097-17.057491 60.83453-3.801583 115.321492 30.726815-2.825348 24.868387-5.059226 51.224662-6.626931 78.715783-27.077705 1.488911-52.974515 3.64604-77.481675 6.421246C311.328631 377.653199 297.791313 333.620333 314.927599 316.50963zM233.05287 513.246387c0-24.200168 40.307008-45.676295 103.249549-59.806107 15.516392 19.472494 32.907481 39.665395 51.17452 60.114123-18.188244 20.246113-34.964326 40.181141-50.40397 59.551304C273.744641 558.975894 233.076406 537.446555 233.05287 513.246387zM314.233797 710.241017c-17.057491-17.10968-3.778046-60.83453 30.80254-115.351168 24.868387 2.828418 51.122331 5.087878 78.662571 6.628978 1.49198 27.127847 3.751441 52.974515 6.500041 77.531817C375.428531 713.890126 331.393619 727.350696 314.233797 710.241017zM511.919159 791.93769c-24.173562 0-45.702901-40.644699-59.753919-103.84102 19.343557-15.46625 39.228443-32.267914 59.521628-50.40397 20.37505 18.238386 40.541345 35.605939 60.013839 51.122331C557.572942 751.706407 536.069185 791.93769 511.919159 791.93769zM575.940265 667.954935c-16.928554-11.611455-34.759665-25.38311-52.895721-40.489156 8.631588-7.913227 17.315364-16.031115 26.049283-24.354688 11.895935-0.308015 24.12342-0.308015 35.684734-0.820692C582.595848 625.668853 579.691705 647.812175 575.940265 667.954935zM563.970652 588.570933c3.774977-3.699252 7.553023-7.245008 11.301394-11.04659 4.111644-4.111644 8.015557-8.1711 12.048407-12.279674-0.410346 7.347339-0.744967 14.84715-1.309832 22.043039C578.844407 587.853595 571.368132 588.160587 563.970652 588.570933zM708.503443 710.085474c-17.084097 17.10968-61.040215 3.701299-115.734908-31.03483 2.77316-24.557302 4.958942-50.506301 6.447852-77.584006 27.488051-1.488911 53.745065-3.699252 78.586846-6.5246C712.254883 649.353274 725.58754 693.027983 708.503443 710.085474zM685.895539 573.157895c-15.337313-19.269879-32.473599-39.152718-50.430576-59.243289 18.393929-20.551058 35.427884-40.74396 51.022047-60.371996 62.862723 14.0766 103.172801 35.553751 103.172801 59.703777C789.68437 537.446555 749.171678 559.026036 685.895539 573.157895z",
        fill: i.fill,
        "p-id": "1612"
      }, null, 8, zF)
    ], 8, WF));
  }
}), qF = fi({
  name: "",
  components: {
    star: ZF
  },
  props: {
    icon: {
      default: ""
    },
    logoWidth: {
      type: String,
      default: "70px"
    },
    title: {
      default: ""
    }
  },
  setup(i, { emit: e }) {
    return {};
  }
}), jF = `[data-v-b1580676]:root,[data-v-b1580676]:host{--ns-primary: #28415a;--ns-primary-light-1: #3c5a7d;--ns-success: #5f785a;--ns-success-light-1: #73917d;--ns-warning: #dc8c50;--ns-warning-light-1: #f5a573;--ns-error: #aa5032;--ns-warning-light-1: #c36955;--ns-info: #b9beb4;--ns-text: #1d1d1d;--ns-border-shadow-color: #6c686e;--ns-border-color: #58545a;--ns-background-gray: #dfdfdf;--ns-size-text-normal: 14px;--ns-size-top-title: 22px;--ns-size-text-title: 18px;--ns-size-text-subtitle: 16px;--ns-weight-text: 900;--ns-border-radius: 4px;--ns-border-width: 1px;--ns-text-color-normal: var(--ns-text);--ns-text-color-primary: var(--ns-primary);--ns-text-color-success: var(--ns-success);--ns-text-color-warning: var(--ns-warning);--ns-text-color-error: var(--ns-error);--ns-text-color-info: var(--ns-info)}.ns-header-box[data-v-b1580676]{width:100%;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:space-evenly;align-items:center;position:relative;z-index:100}.ns-header-box .ns-header-item[data-v-b1580676]{width:33%;height:100%;overflow:hidden;box-sizing:border-box;padding:0 10px;display:flex;align-items:center;color:var(--ns-text-color-info)}.ns-header-box .ns-header-left[data-v-b1580676]{justify-content:flex-start}.ns-header-box .ns-header-left .ns-header-icon-box[data-v-b1580676]{width:200px;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:center;align-items:center}.ns-header-box .ns-header-left .ns-header-title-box[data-v-b1580676]{flex-grow:1;font-size:var(--ns-size-top-title);color:var(--ns-text-color-info)}.ns-header-box .ns-header-middle[data-v-b1580676]{justify-content:center}.ns-header-box .ns-header-right[data-v-b1580676]{justify-content:flex-end}
`, KF = { class: "ns-header-box" }, JF = { class: "ns-header-item ns-header-left" }, eW = ["src"], tW = { class: "ns-header-title-box" }, iW = { class: "ns-header-item ns-header-middle" }, rW = { class: "ns-header-item ns-header-right" };
function oW(i, e, t, r, o, s) {
  const n = ES("star");
  return Pe(), ht("div", KF, [
    ke("div", JF, [
      ke("div", {
        class: "ns-header-icon-box",
        style: ki(`width: ${i.logoWidth};`)
      }, [
        i.icon ? (Pe(), ht("img", {
          key: 1,
          src: i.icon
        }, null, 8, eW)) : (Pe(), Li(n, {
          key: 0,
          size: "64",
          fill: "#f0f0f0"
        }))
      ], 4),
      ke("div", tW, NT(i.title), 1)
    ]),
    ke("div", iW, [
      ui(i.$slots, "middle", {}, void 0, !0)
    ]),
    ke("div", rW, [
      ui(i.$slots, "right", {}, void 0, !0)
    ])
  ]);
}
const sW = /* @__PURE__ */ xr(qF, [["render", oW], ["styles", [jF]], ["__scopeId", "data-v-b1580676"]]);
console.log(`↓↓↓↓↓↓↓↓↓↓ 加载组件 ns-table ↓↓↓↓↓↓↓↓↓↓
`, `本组件为Tabulator的二次封装
感谢 Tabulator 为 ns-table 提供的支持`, `
↑↑↑↑↑↑↑↑↑↑ 加载组件 ns-table ↑↑↑↑↑↑↑↑↑↑`);
const ET = {
  NsAjax: Fl
}, mT = {
  "ns-sandbox": ky,
  "ns-splitpane": Wy,
  "ns-codeide": SB,
  "ns-table": PF,
  "ns-floatingbox": DF,
  "ns-framebox": $F,
  "ns-contentbox": FF,
  "ns-header": sW
};
for (let i in mT) {
  const e = mT[i], t = Cp(e);
  customElements.define(i, t);
}
Object.keys(ET).forEach((i) => {
  window[i] = ET[i];
});
